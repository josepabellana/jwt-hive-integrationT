/*! Hive Stats Pack Copyright(c) 2023 HiveStreaming AB, All rights reserved. 
* Version: html5-8.0.0
* Enabled Hive Techs: Java, WebRTC, Stats Only        [Test]
*/
/*! AtatusJs - v4.3.2 - 2020-12-10
* Copyright (c) 2020 Atatus */
!function(a){function b(a,b){return Object.prototype.hasOwnProperty.call(a,b)}function c(a){return"undefined"==typeof a}if(a){var d={},e=a.TraceKit,f=[].slice,g="?";d.noConflict=function(){return a.TraceKit=e,d},d.wrap=function(a){function b(){try{return a.apply(this,arguments)}catch(b){throw d.report(b),b}}return b},d.report=function(){function c(a){h(),m.push(a)}function e(a){for(var b=m.length-1;b>=0;--b)m[b]===a&&m.splice(b,1)}function f(a,c,e){var f=null;if(!c||d.collectWindowErrors){for(var g in m)if(b(m,g))try{m[g](a,c,e)}catch(h){f=h}if(f)throw f}}function g(a,b,c,e,g){var h=null;if(o)d.computeStackTrace.augmentStackTraceWithInitialElement(o,b,c,a),i();else if(g)h=d.computeStackTrace(g),f(h,!0,g);else{var j={url:b,line:c,column:e};j.func=d.computeStackTrace.guessFunctionName(j.url,j.line),j.context=d.computeStackTrace.gatherContext(j.url,j.line),h={mode:"onerror",message:a,stack:[j]},f(h,!0,null)}return k?k.apply(this,arguments):!1}function h(){l!==!0&&(k=a.onerror,a.onerror=g,l=!0)}function i(){var a=o,b=n;o=null,n=null,f(a,!1,b)}function j(b){if(o){if(n===b)return;i()}var c=d.computeStackTrace(b);throw o=c,n=b,a.setTimeout(function(){n===b&&i()},c.incomplete?2e3:0),b}var k,l,m=[],n=null,o=null;return j.subscribe=c,j.unsubscribe=e,j}(),d.computeStackTrace=function(){function e(a){return"string"!=typeof a?[]:""}function f(c){if("string"!=typeof c)return[];if(!b(w,c)){var d="",f="";try{f=a.document.domain}catch(g){}var h=/(.*)\:\/\/([^:\/]+)([:\d]*)\/{0,1}([\s\S]*)/.exec(c);h&&h[2]===f&&(d=e(c)),w[c]=d?d.split("\n"):[]}return w[c]}function h(a,b){var d,e=/function ([^(]*)\(([^)]*)\)/,h=/['"]?([0-9A-Za-z$_]+)['"]?\s*[:=]\s*(function|eval|new Function)/,i="",j=10,k=f(a);if(!k.length)return g;for(var l=0;j>l;++l)if(i=k[b-l]+i,!c(i)){if(d=h.exec(i))return d[1];if(d=e.exec(i))return d[1]}return g}function i(a,b){var e=f(a);if(!e.length)return null;var g=[],h=Math.floor(d.linesOfContext/2),i=h+d.linesOfContext%2,j=Math.max(0,b-h-1),k=Math.min(e.length,b+i-1);b-=1;for(var l=j;k>l;++l)c(e[l])||g.push(e[l]);return g.length>0?g:null}function j(a){return a.replace(/[\-\[\]{}()*+?.,\\\^$|#]/g,"\\$&")}function k(a){return j(a).replace("<","(?:<|&lt;)").replace(">","(?:>|&gt;)").replace("&","(?:&|&amp;)").replace('"','(?:"|&quot;)').replace(/\s+/g,"\\s+")}function l(a,b){for(var c,d,e=0,g=b.length;g>e;++e)if((c=f(b[e])).length&&(c=c.join("\n"),d=a.exec(c)))return{url:b[e],line:c.substring(0,d.index).split("\n").length,column:d.index-c.lastIndexOf("\n",d.index)-1};return null}function m(a,b,c){var d,e=f(b),g=new RegExp("\\b"+j(a)+"\\b");return c-=1,e&&e.length>c&&(d=g.exec(e[c]))?d.index:null}function n(b){if(!c(a&&a.document)){for(var d,e,f,g,h=[a.location.href],i=a.document.getElementsByTagName("script"),m=""+b,n=/^function(?:\s+([\w$]+))?\s*\(([\w\s,]*)\)\s*\{\s*(\S[\s\S]*\S)\s*\}\s*$/,o=/^function on([\w$]+)\s*\(event\)\s*\{\s*(\S[\s\S]*\S)\s*\}\s*$/,p=0;p<i.length;++p){var q=i[p];q.src&&h.push(q.src)}if(f=n.exec(m)){var r=f[1]?"\\s+"+f[1]:"",s=f[2].split(",").join("\\s*,\\s*");d=j(f[3]).replace(/;$/,";?"),e=new RegExp("function"+r+"\\s*\\(\\s*"+s+"\\s*\\)\\s*{\\s*"+d+"\\s*}")}else e=new RegExp(j(m).replace(/\s+/g,"\\s+"));if(g=l(e,h))return g;if(f=o.exec(m)){var t=f[1];if(d=k(f[2]),e=new RegExp("on"+t+"=[\\'\"]\\s*"+d+"\\s*[\\'\"]","i"),g=l(e,h[0]))return g;if(e=new RegExp(d),g=l(e,h))return g}return null}}function o(a){if(!a.stack)return null;for(var b,d,e=/^\s*at (.*?) ?\(((?:file|https?|blob|chrome-extension|native|webpack|eval).*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i,f=/^\s*(.*?)(?:\((.*?)\))?(?:^|@)((?:file|https?|blob|chrome|webpack|\[native).*?)(?::(\d+))?(?::(\d+))?\s*$/i,j=/^\s*at (?:((?:\[object object\])?.+) )?\(?((?:ms-appx|https?|webpack|blob):.*?):(\d+)(?::(\d+))?\)?\s*$/i,k=a.stack.split("\n"),l=[],n=/^(.*) is undefined$/.exec(a.message),o=0,p=k.length;p>o;++o){if(b=e.exec(k[o])){var q=b[2]&&-1!==b[2].indexOf("native");d={url:q?null:b[2],func:b[1]||g,args:q?[b[2]]:[],line:b[3]?+b[3]:null,column:b[4]?+b[4]:null}}else if(b=j.exec(k[o]))d={url:b[2],func:b[1]||g,args:[],line:+b[3],column:b[4]?+b[4]:null};else{if(!(b=f.exec(k[o])))continue;d={url:b[3],func:b[1]||g,args:b[2]?b[2].split(","):[],line:b[4]?+b[4]:null,column:b[5]?+b[5]:null}}!d.func&&d.line&&(d.func=h(d.url,d.line)),d.line&&(d.context=i(d.url,d.line)),l.push(d)}return l.length?(l[0]&&l[0].line&&!l[0].column&&n?l[0].column=m(n[1],l[0].url,l[0].line):l[0].column||c(a.columnNumber)||(l[0].column=a.columnNumber+1),{mode:"stack",name:a.name,message:a.message,stack:l}):null}function p(a){var b=a.stacktrace;if(b){for(var c,d=/ line (\d+).*script (?:in )?(\S+)(?:: in function (\S+))?$/i,e=/ line (\d+), column (\d+)\s*(?:in (?:<anonymous function: ([^>]+)>|([^\)]+))\((.*)\))? in (.*):\s*$/i,f=b.split("\n"),g=[],j=0;j<f.length;j+=2){var k=null;if((c=d.exec(f[j]))?k={url:c[2],line:+c[1],column:null,func:c[3],args:[]}:(c=e.exec(f[j]))&&(k={url:c[6],line:+c[1],column:+c[2],func:c[3]||c[4],args:c[5]?c[5].split(","):[]}),k){if(!k.func&&k.line&&(k.func=h(k.url,k.line)),k.line)try{k.context=i(k.url,k.line)}catch(l){}k.context||(k.context=[f[j+1]]),g.push(k)}}return g.length?{mode:"stacktrace",name:a.name,message:a.message,stack:g}:null}}function q(c){var d=c.message.split("\n");if(d.length<4)return null;var e,g=/^\s*Line (\d+) of linked script ((?:file|https?|blob)\S+)(?:: in function (\S+))?\s*$/i,j=/^\s*Line (\d+) of inline#(\d+) script in ((?:file|https?|blob)\S+)(?:: in function (\S+))?\s*$/i,m=/^\s*Line (\d+) of function script\s*$/i,n=[],o=a&&a.document&&a.document.getElementsByTagName("script"),p=[];for(var q in o)b(o,q)&&!o[q].src&&p.push(o[q]);for(var r=2;r<d.length;r+=2){var s=null;if(e=g.exec(d[r]))s={url:e[2],func:e[3],args:[],line:+e[1],column:null};else if(e=j.exec(d[r])){s={url:e[3],func:e[4],args:[],line:+e[1],column:null};var t=+e[1],u=p[e[2]-1];if(u){var v=f(s.url);if(v){v=v.join("\n");var w=v.indexOf(u.innerText);w>=0&&(s.line=t+v.substring(0,w).split("\n").length)}}}else if(e=m.exec(d[r])){var x=a.location.href.replace(/#.*$/,""),y=new RegExp(k(d[r+1])),z=l(y,[x]);s={url:x,func:"",args:[],line:z?z.line:e[1],column:null}}if(s){s.func||(s.func=h(s.url,s.line));var A=i(s.url,s.line),B=A?A[Math.floor(A.length/2)]:null;s.context=A&&B.replace(/^\s*/,"")===d[r+1].replace(/^\s*/,"")?A:[d[r+1]],n.push(s)}}return n.length?{mode:"multiline",name:c.name,message:d[0],stack:n}:null}function r(a,b,c,d){var e={url:b,line:c};if(e.url&&e.line){a.incomplete=!1,e.func||(e.func=h(e.url,e.line)),e.context||(e.context=i(e.url,e.line));var f=/ '([^']+)' /.exec(d);if(f&&(e.column=m(f[1],e.url,e.line)),a.stack.length>0&&a.stack[0].url===e.url){if(a.stack[0].line===e.line)return!1;if(!a.stack[0].line&&a.stack[0].func===e.func)return a.stack[0].line=e.line,a.stack[0].context=e.context,!1}return a.stack.unshift(e),a.partial=!0,!0}return a.incomplete=!0,!1}function s(a,b){for(var c,e,f,i=/function\s+([_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*)?\s*\(/i,j=[],k={},l=!1,o=s.caller;o&&!l;o=o.caller)if(o!==t&&o!==d.report){if(e={url:null,func:g,args:[],line:null,column:null},o.name?e.func=o.name:(c=i.exec(o.toString()))&&(e.func=c[1]),"undefined"==typeof e.func)try{e.func=c.input.substring(0,c.input.indexOf("{"))}catch(p){}if(f=n(o)){e.url=f.url,e.line=f.line,e.func===g&&(e.func=h(e.url,e.line));var q=/ '([^']+)' /.exec(a.message||a.description);q&&(e.column=m(q[1],f.url,f.line))}k[""+o]?l=!0:k[""+o]=!0,j.push(e)}b&&j.splice(0,b);var u={mode:"callers",name:a.name,message:a.message,stack:j};return r(u,a.sourceURL||a.fileName,a.line||a.lineNumber,a.message||a.description),u}function t(a,b){var c=null;b=null==b?0:+b;try{if(c=p(a))return c}catch(d){if(v)throw d}try{if(c=o(a))return c}catch(d){if(v)throw d}try{if(c=q(a))return c}catch(d){if(v)throw d}try{if(c=s(a,b+1))return c}catch(d){if(v)throw d}return{mode:"failed"}}function u(a){a=(null==a?0:+a)+1;try{throw new Error}catch(b){return t(b,a+1)}}var v=!1,w={};return t.augmentStackTraceWithInitialElement=r,t.guessFunctionName=h,t.gatherContext=i,t.ofCaller=u,t.getSource=f,t}(),d.extendToAsynchronousCallbacks=function(){var b=function(b){var c=a[b];a[b]=function(){var a=f.call(arguments),b=a[0];return"function"==typeof b&&(a[0]=d.wrap(b)),c.apply?c.apply(this,a):c(a[0],a[1])}};b("setTimeout"),b("setInterval")},d.remoteFetching||(d.remoteFetching=!0),d.collectWindowErrors||(d.collectWindowErrors=!0),(!d.linesOfContext||d.linesOfContext<1)&&(d.linesOfContext=11),a.TraceKit=d}}("undefined"!=typeof window?window:global),function(a,b){"use strict";if(a&&a.event&&a.event.add){var c=a.event.add;a.event.add=function(d,e,f,g,h){if("function"!=typeof f&&"function"!=typeof f.handler)return c.call(this,d,e,f,g,h);var i;return f.handler?(i=f.handler,f.handler=b.wrap(f.handler)):(i=f,f=b.wrap(f)),f.guid=i.guid?i.guid:i.guid=a.guid++,c.call(this,d,e,f,g,h)};var d=a.fn.ready;a.fn.ready=function(a){return d.call(this,b.wrap(a))};var e=a.ajax;a.ajax=function(c,d){"object"==typeof c&&(d=c,c=void 0),d=d||{};for(var f,g=["complete","error","success"];f=g.pop();)a.isFunction(d[f])&&(d[f]=b.wrap(d[f]));try{return c?e.call(this,c,d):e.call(this,d)}catch(h){throw b.report(h),h}}}}(window.jQuery,window.TraceKit),!function(a,b){b((a="undefined"!=typeof globalThis?globalThis:a||self).webVitals={})}(this,function(a){"use strict";var b,c,d=function(){return"".concat(Date.now(),"-").concat(Math.floor(8999999999999*Math.random())+1e12)},e=function(a){var b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;return{name:a,value:b,delta:0,entries:[],id:d(),isFinal:!1}},f=function(a,b){try{if(PerformanceObserver.supportedEntryTypes.includes(a)){var c=new PerformanceObserver(function(a){return a.getEntries().map(b)});return c.observe({type:a,buffered:!0}),c}}catch(a){}},g=!1,h=!1,i=function(a){g=!a.persisted},j=function(){addEventListener("pagehide",i),addEventListener("beforeunload",function(){})},k=function(a){var b=arguments.length>1&&void 0!==arguments[1]&&arguments[1];h||(j(),h=!0),addEventListener("visibilitychange",function(b){var c=b.timeStamp;"hidden"===document.visibilityState&&a({timeStamp:c,isUnloading:g})},{capture:!0,once:b})},l=function(a,b,c,d){var e;return function(){c&&b.isFinal&&c.disconnect(),b.value>=0&&(d||b.isFinal||"hidden"===document.visibilityState)&&(b.delta=b.value-(e||0),(b.delta||b.isFinal||void 0===e)&&(a(b),e=b.value))}},m=function(){return void 0===b&&(b="hidden"===document.visibilityState?0:1/0,k(function(a){var c=a.timeStamp;return b=c},!0)),{get timeStamp(){return b}}},n=function(){return c||(c=new Promise(function(a){return["scroll","keydown","pointerdown"].map(function(b){addEventListener(b,a,{once:!0,passive:!0,capture:!0})})})),c};a.getCLS=function(a){var b,c=arguments.length>1&&void 0!==arguments[1]&&arguments[1],d=e("CLS",0),g=function(a){a.hadRecentInput||(d.value+=a.value,d.entries.push(a),b())},h=f("layout-shift",g);h&&(b=l(a,d,h,c),k(function(a){var c=a.isUnloading;h.takeRecords().map(g),c&&(d.isFinal=!0),b()}))},a.getFCP=function(a){var b,c=e("FCP"),d=m(),g=f("paint",function(a){"first-contentful-paint"===a.name&&a.startTime<d.timeStamp&&(c.value=a.startTime,c.isFinal=!0,c.entries.push(a),b())});g&&(b=l(a,c,g))},a.getFID=function(a){var b=e("FID"),c=m(),d=function(a){a.startTime<c.timeStamp&&(b.value=a.processingStart-a.startTime,b.entries.push(a),b.isFinal=!0,h())},g=f("first-input",d),h=l(a,b,g);g?k(function(){g.takeRecords().map(d),g.disconnect()},!0):window.perfMetrics&&window.perfMetrics.onFirstInputDelay&&window.perfMetrics.onFirstInputDelay(function(a,d){d.timeStamp<c.timeStamp&&(b.value=a,b.isFinal=!0,b.entries=[{entryType:"first-input",name:d.type,target:d.target,cancelable:d.cancelable,startTime:d.timeStamp,processingStart:d.timeStamp+a}],h())})},a.getLCP=function(a){var b,c=arguments.length>1&&void 0!==arguments[1]&&arguments[1],d=e("LCP"),g=m(),h=function(a){var c=a.startTime;c<g.timeStamp?(d.value=c,d.entries.push(a)):d.isFinal=!0,b()},i=f("largest-contentful-paint",h);if(i){b=l(a,d,i,c);var j=function(){d.isFinal||(i.takeRecords().map(h),d.isFinal=!0,b())};n().then(j),k(j,!0)}},a.getTTFB=function(){var a,b=e("TTFB");a=function(){try{var a=performance.getEntriesByType("navigation")[0]||function(){var a=performance.timing,b={entryType:"navigation",startTime:0};for(var c in a)"navigationStart"!==c&&"toJSON"!==c&&(b[c]=Math.max(a[c]-a.navigationStart,0));return b}();b.value=b.delta=a.responseStart,b.entries=[a],b.isFinal=!0,c(b)}catch(c){}},"complete"===document.readyState?setTimeout(a,0):addEventListener("pageshow",a)},Object.defineProperty(a,"__esModule",{value:!0})}),function(a,b,c,d){function e(){try{B=null,o()&&localStorage.removeItem(ga),C=null,Ca.createCookie(ha,"",-1)}catch(a){Ca.log("Atatus Reset User",a)}}function f(a,b,c,d){if(a){B={},a&&(B.id=""+a),b&&(B.email=""+b),c&&(B.name=""+c),d&&(B.anonymous=d);try{o()&&localStorage.setItem(ga,JSON.stringify(B)),C=null,Ca.createCookie(ha,"",-1)}catch(e){Ca.log("Atatus Set User: Invalid JSON object in LocalStorage",e)}}}function g(){try{var a;if(o()&&(a=localStorage.getItem(ga)),a)B=JSON.parse(a),C=null;else{var b,c=Ca.readCookie(ha);c&&(b=Ca.readCookieElement(c,"id")),b&&"undefined"!==b?C=b:(C=Ca.uuid4(),Ca.createCookie(ha,C))}}catch(d){Ca.log("Atatus Get User: Invalid JSON object in LocalStorage",d)}}function h(a){var b=a,c=a.split("//")[1];if(c){var d=c.indexOf("?"),e=c.toString().substring(0,d),f=e.split("/").slice(0,4).join("/"),g=e.substring(0,48);b=f.length<g.length?f:g,b!==e&&(b+="..")}return b}function i(a,b,c,e){if(0!==b.status&&b.getAllResponseHeaders()){var f="AJAX Error: "+(b.statusText||"unknown")+" "+(c.type||"unknown")+" "+(h(c.url)||"unknown");Ga.send(e||a.type,{status:b.status,statusText:b.statusText,type:c.type,url:c.url,ajaxErrorMessage:f,contentType:c.contentType,requestData:c.data&&c.data.slice?c.data.slice(0,10240):d,responseData:b.responseText&&b.responseText.slice?b.responseText.slice(0,10240):d,activeTarget:a.target&&a.target.activeElement&&a.target.activeElement.outerHTML&&a.target.activeElement.outerHTML.slice?a.target.activeElement.outerHTML.slice(0,10240):d})}}function j(a){if(Ca.log("Atatus: Caught unhandled promise rejection:",a),a){var b=a.reason;Ga.notify(b&&(b instanceof Error||b.message)?b:new Error("UnhandledRejection: "+b))}}function k(){"addEventListener"in a&&a.addEventListener("unhandledrejection",j)}function l(){"removeEventListener"in a&&a.removeEventListener("unhandledrejection",j)}function m(){return z&&""!==z?!0:(Ca.log("Atatus API key has not been configured, make sure you call atatus.config(yourApiKey)"),!1)}function n(){var c=b.documentElement,d=b.getElementsByTagName("body")[0],e=a.innerWidth||c.clientWidth||d.clientWidth,f=a.innerHeight||c.clientHeight||d.clientHeight;return{width:e,height:f}}function o(){try{return"localStorage"in a&&null!==a.localStorage}catch(b){return!1}}function p(a){try{if(o()&&localStorage.length<50){var b=(new Date).toJSON(),c="atatusjs="+b+"="+Ca.getRandomInt();"undefined"==typeof localStorage[c]&&(localStorage[c]=a)}else Ca.log("Atatus: Reached local storage limit.")}catch(d){Ca.log("Atatus: LocalStorage full, cannot save exception")}}function q(){try{if(o()&&localStorage.length>0)for(var a in localStorage)if("atatusjs="===a.substring(0,9)){try{var b=JSON.parse(localStorage[a]);"apikey"in b&&t(ja,b)}catch(c){Ca.log("Atatus: Invalid JSON object in LocalStorage")}localStorage.removeItem(a)}}catch(c){Ca.log("Atatus sendSavedErrors: LocalStorage read failed!",c)}}function r(a,c){if(c=Ca.isObject(c)?c:{},!a.stack||!a.stack.length)return void Ca.log("Atatus: Canceling send due to no stacktrace.");var d=c.customData&&c.customData.ajaxErrorMessage||a.message;if(d&&0===d.indexOf("Uncaught ")&&(d=a.message.substring(9)),d=d||c.status||"Script error.",M&&M.test(d))return void Ca.log("Atatus: canceling send due to Script error or ignored errors.");d=d.substr(0,ta);var e=[];a.stack&&a.stack.length&&Ca.forEach(a.stack,function(a,b){Ca.endsWith(b.url,"/atatus.js")||Ca.endsWith(b.url,"/atatus-spa.js")||Ca.endsWith(b.url,"/atatus.min.js")||e.push({ln:b.line||0,cn:b.column||0,f:b.url||"anonymous",m:b.func||"[anonymous]"})});var f=[a.name,d,JSON.stringify(e)].join("|");if(f===N)return void Ca.log("Atatus: canceling send due to duplicate errors");N=f;var g=c.customData;try{JSON.stringify(g)}catch(h){var i="Cannot add custom data; may contain circular reference";g={error:i},Ca.log("Atatus: "+i)}var j=Fa.getAllEvents();Da.clear();var k={"class":a.name,url:b.location.href,message:d,name:d,backTraces:e,breadCrumbs:j,customData:g||null,tags:c.tags,ts:(new Date).getTime()};if("function"==typeof P&&(k.groupingKey=P(k)),"function"==typeof R){var l=R(k);l&&(delete k.name,s(k))}else delete k.name,s(k)}function s(a){return F?void Ca.log("Error Tracking is disabled."):void t(ja,{customData:A||null,errors:[a]})}function t(c,d){if(m()){if(!Ga._isAllowedUrl(location.host))return void Ca.log("Atatus: canceling send due to not an allowed domain/url.");if(!d.ts){var e=a.screen||n();d.ts=(new Date).getTime(),d.apikey=z,d.request={url:b.location.href,ua:navigator.userAgent,w:e.width,h:e.height},d.connection=Aa,d.tags=d.tags||Y,d.user=B&&B.id?B:null,d.aid=C||null,d.sid=Ga.sessionId||"",d.v=D||"",d._v=Ga.VERSION||V||""}if(Q){var f=Q(d);if(!f)return void Ca.log("Atatus: canceling send due to false from beforeSend callback.")}if(O&&O(d),Ca.log("Sending data to Atatus Receiver:",d),c===ka)w(c,d);else if(c===ma){if(!d.sid)return void Ca.log("Atatus: canceling session send due to empty session id.");if(za.session>=wa)return void Ca.log("Atatus: Canceling session send due to exceed maximum payload.");za.session+=1,y(c,d)}else if(c===na){if(za.spa>=ya)return void Ca.log("Atatus: Canceling SPA send due to exceed maximum payload.");za.spa+=1,za.ajax=0,y(c,d)}else{if(c===ja){if(za.error>=ua)return void Ca.log("Atatus: Canceling error send due to exceed maximum payload.");za.error+=1}else if(c===la){if(za.ajax>=va)return void Ca.log("Atatus: Canceling AJAX send due to exceed maximum payload.");za.ajax+=1}else if(c===oa){if(za.txn>=xa)return void Ca.log("Atatus: Canceling transaction send due to exceed maximum payload.");za.txn+=1}v(c,d)}}}function u(a){return"apikey="+a.apikey+"&v="+a._v}function v(a,b){var c=ia+a+"?data="+encodeURIComponent(JSON.stringify(b))+"&"+u(b);if(c.length>qa)return void Ca.log("Atatus: Canceling session send due to large payload size.");var d=new Image;d.crossOrigin="anonymous",d.onload=function(){q()},d.onerror=d.onabort=function(){ca&&a===ja&&p(JSON.stringify(b))},d.src=c}function w(a,c){var d=b.createElement("script"),e=ia+a+"?data="+encodeURIComponent(JSON.stringify(c))+"&callback=atatus._setFeatures&"+u(c);d.type="text/javascript",d.src=e;var f=b.getElementsByTagName("script")[0];f.parentNode.insertBefore(d,f)}function x(b,c){var d;return d=new a.XMLHttpRequest,"withCredentials"in d?d.open(b,c,!0):a.XDomainRequest&&(c=Ca.getTargetUrl(c),d=new a.XDomainRequest,d.open(b,c)),d.timeout=1e4,d}function y(b,c){var d=ia+b+"?"+u(c),e=x("POST",d);return e?("function"==typeof e.setRequestHeader&&e.setRequestHeader("Content-Type","application/json;charset=UTF-8"),"withCredentials"in e?(e.onreadystatechange=function(){4!==e.readyState},e.onload=function(){Ca.log("Sent data to Atatus. Status - "+e.status)}):a.XDomainRequest&&(e.ontimeout=function(){},e.onload=function(){Ca.log("Sent data to Atatus. Status - "+e.status)}),e.onerror=function(){Ca.log("Failed to send to Atatus. Status - "+e.status)},void e.send(JSON.stringify(c))):void Ca.log("XHR is not supported!")}var z,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V="4.3.2",W=a.TraceKit.noConflict(),X=a.atatus,Y=[],Z=!1,$=[],_=[],aa=[],ba=!1,ca=!1,da=!1,ea=!1,fa=!1,ga="atatus-user",ha="atatus-aid",ia="https://bm-rx.atatus.com",ja="/track/browser/errors",ka="/track/browser/perf/pageload",la="/track/browser/perf/ajax",ma="/track/browser/perf/session",na="/track/browser/perf/spa",oa="/track/browser/perf/txn",pa="/track/browser/perf/webvitals",qa=4e4,ra=10,sa=500,ta=1e3,ua=20,va=5,wa=10,xa=100,ya=100,za={error:0,ajax:0,session:0,txn:0,spa:0},Aa=null,Ba=["google-analytics.com","mixpanel.com","bam.nr-data.net","br-rx.atatus.com","bm-rx.atatus.com","segment.io","hotjar.io","hotjar.com","amplitude.com","fullstory.com","autopilothq.com","smartlook.com","charmerly.com","googleapis.com","logrocket.io","taboola.com","sentry.io","doubleclick.net","logentries.com","rb-collector.com"];c&&(U=c(b));var Ca={isBoolean:function(a){return"undefined"!=typeof a&&"boolean"==typeof a},isString:function(a){return"string"==typeof a},isNumber:function(a){return"number"==typeof a},isFunction:function(a){return"function"==typeof a},isArray:function(a){return"[object Array]"===Object.prototype.toString.call(a)},isObject:function(a){return"[object Object]"===Object.prototype.toString.call(a)},serialize:function(a){if(!a)return"";if(Ca.isString(a)||Ca.isNumber(a)||Ca.isBoolean(a)||Ca.isFunction(a))return""+a;if("object"==typeof a)try{return JSON.stringify(a)}catch(b){return"Unserializable Object"}return""},endsWith:function(a,b){return a&&b?-1!==a.indexOf(b,a.length-b.length):!1},joinRegExp:function(a){if(0===a.length)return null;for(var b,c=[],d=0,e=a.length;e>d;d++)b=a[d],Ca.isString(b)?c.push(b.replace(/([.*+?^=!:${}()|\[\]\/\\])/g,"\\$1")):b&&b.source&&c.push(b.source);return new RegExp(c.join("|"),"i")},getTargetUrl:function(b){return a.XDomainRequest&&ba&&(b=b.slice(6)),b},now:function(){return(new Date).getTime()},pad:function(a){return a=String(a),1===a.length&&(a="0"+a),a},merge:function(a,b){var c,d={};for(c in a)d[c]=a[c];for(c in b)d[c]=b[c];return d},mergeArray:function(a,b){return null!=b?a.concat(b):a},forEach:function(a,b){for(var c=0;c<a.length;c++)b.call(null,c,a[c])},isEmpty:function(a){for(var b in a)if(a.hasOwnProperty(b))return!1;return!0},getRandomInt:function(){return Math.floor(9007199254740992*Math.random())},log:function(b,c){Z&&a.console&&a.console.log&&(a.console.log(b),c&&a.console.log(c))},bind:function(a,b){return function(){return a.apply(b,Array.prototype.slice.call(arguments))}},canAllowInsecureSubmissions:function(){var b=a.navigator.userAgent,c=b.match(/Trident\/([\d.]+)/),d=c&&"7.0"===c[1]?11:(b=b.match(/MSIE ([\d.]+)/))?parseInt(b[1],10):!1;return d&&9>=d},uuid4:function(){return"xxxxxxxxxxxx4xxxyxxxxxxxxxxxxxxx".replace(/[xy]/g,function(a){var b=16*Math.random()|0,c="x"===a?b:3&b|8;return c.toString(16)})},addEventListener:function(b,c,d){return"undefined"!=typeof a.attachEvent?a.attachEvent("on"+b,c):a.addEventListener?a.addEventListener(b,c,d):void 0},arrayFromObject:function(a){var b=[];for(var c in a)a.hasOwnProperty(c)&&b.push(a[c]);return b},createCookie:function(a,c,d,e,f){try{var g,h;if(d){var i=new Date;i.setTime(i.getTime()+60*d*60*1e3),g="; expires="+i.toGMTString()}else g="";var j=e?"; SameSite=Lax; secure":"; SameSite=Lax",k=/[a-z0-9][a-z0-9-]+\.[a-z.]{2,6}$/i,l="";if(f){var m=b.location.hostname.match(k),n=m?m[0]:"";l=n?"; domain=."+n:""}return h=(new Date).toISOString(),b.cookie=a+"=id|"+c+"&timestamp|"+h+g+"; path=/"+l+j,h}catch(o){Ca.log("Creating cookie failed.",o)}},clearCookie:function(a){this.createCookie(a,"",-1)},readCookieElement:function(a,b){var c=a.split(/[|&]/);return"id"===b?c[1]:"timestamp"===b?c[3]:void 0},readCookie:function(a){try{for(var c=a+"=",d=b.cookie.split(";"),e=0;e<d.length;e++){for(var f=d[e];" "===f.charAt(0);)f=f.substring(1,f.length);if(0===f.indexOf(c))return f.substring(c.length,f.length)}return null}catch(g){Ca.log("Reading cookie failed.",g)}}},Da={eventObject:{},all:function(a){for(var b=this.getEventObject(a),c=[],d=0;d<b.length;d++)c.push(b[d].value);return c},clear:function(){for(var a in this.eventObject)this.eventObject.hasOwnProperty(a)&&(this.eventObject[a].length=0)},add:function(a,b){var c=this.getEventObject(a),d=Ca.uuid4();return b.m?b.m=b.m.length<=sa?b.m:b.m.substr(0,sa):b.e&&(b.e=b.e.length<=sa?b.e:b.e.substr(0,sa)),c.push({key:d,value:b}),this.truncateEventObject(a,ra),d},get:function(a,b){for(var c=this.getEventObject(a),d=0;d<c.length;d++)if(c[d].key===b)return c[d].value;return!1},getEventObject:function(a){return this.eventObject[a]||(this.eventObject[a]=[]),this.eventObject[a]},truncateEventObject:function(a,b){var c=this.getEventObject(a);c.length>b&&(this.eventObject[a]=c.slice(c.length-b))}},Ea={attach:function(b,c,d,e,f){b=b||a.console||{};for(var g=f||["log","debug","info","warn","error"],h=g.pop(),i=function(a,b,d){c&&Da.add("timeline",{ts:Ca.now(),c:"console",l:a,m:Ca.serialize(b)}),"error"===a&&e&&Ga.notify(new Error(b),d)};h;)this.wrapConsoleMethod(b,h,d,i),h=g.pop()},wrapConsoleMethod:function(a,b,c,d){var e=a[b],f=a;b in a&&(a[b]=function(){var a=[].slice.call(arguments),g=""+a.join(" "),h={level:b,logger:"console"};d&&d(b,g,h),e&&c&&Function.prototype.apply.call(e,f,a)})}},Fa={attach:function(){var a=Ca.bind(this.onDocumentClicked,this),c=Ca.bind(this.onInputChanged,this);b.addEventListener?(b.addEventListener("click",a,!0),b.addEventListener("blur",c,!0)):b.attachEvent&&(b.attachEvent("onclick",a),b.attachEvent("onfocusout",c))},writeUserEvent:function(a,b,c,d){"password"===this.getElementType(a)&&(c=void 0),Da.add("timeline",{ts:Ca.now(),a:b,e:this.getOuterHTML(a),v:this.getValueKind(c,d)})},onDocumentClicked:function(a){var b=this.getElementFromEvent(a);b&&b.tagName&&(this.isTarget(b,"a")||this.isTarget(b,"button")||this.isTarget(b,"input",["button","submit"])?this.writeUserEvent(b,"click"):this.isTarget(b,"input",["checkbox","radio"])&&this.writeUserEvent(b,"check",b.value,b.checked))},onInputChanged:function(a){var b=this.getElementFromEvent(a);b&&b.tagName&&(this.isTarget(b,"textarea")?this.writeUserEvent(b,"input",b.value):this.isTarget(b,"select")&&b.options&&b.options.length?this.onSelectInputChanged(b):this.isTarget(b,"input")&&!this.isTarget(b,"input",["button","submit","hidden","checkbox","radio"])&&this.writeUserEvent(b,"input",b.value))},onSelectInputChanged:function(a){if(a.multiple){for(var b=0;b<a.options.length;b++)if(a.options[b].selected){this.writeUserEvent(a,"select",a.options[b].value);break}}else 0<=a.selectedIndex&&a.options[a.selectedIndex]&&this.writeUserEvent(a,"select",a.options[a.selectedIndex].value)},getElementFromEvent:function(a){return a.target||b.elementFromPoint(a.clientX,a.clientY)},isTarget:function(a,b,c){if(a.tagName.toLowerCase()!==b.toLowerCase())return!1;if(!c)return!0;for(var d=this.getElementType(a),e=0;e<c.length;e++)if(c[e]===d)return!0;return!1},getElementType:function(a){return(a.getAttribute("type")||"").toLowerCase()},getOuterHTML:function(a){for(var b="<"+a.tagName.toLowerCase(),c=a.attributes,d=0,e=c.length;e>d;d++){var f=c[d].name;"value"!==f.toLowerCase()&&(b+=" "+f+'="'+c[d].value+'"')}return b+=" >"},getValueKind:function(a,b){return null==a?null:{length:a.length,checked:b,pattern:this.matchInputPattern(a)}},matchInputPattern:function(a){return""===a?"empty":/^[a-z0-9!#$%&'*+=?\^_`{|}~\-]+(?:\.[a-z0-9!#$%&'*+=?\^_`{|}~\-]+)*@(?:[a-z0-9](?:[a-z0-9\-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9\-]*[a-z0-9])?$/.test(a)?"email":/^(0?[1-9]|[12][0-9]|3[01])[\/\-](0?[1-9]|1[012])[\/\-]\d{4}$/.test(a)||/^(\d{4}[\/\-](0?[1-9]|1[012])[\/\-]0?[1-9]|[12][0-9]|3[01])$/.test(a)?"date":/^(?:(?:\+?1\s*(?:[.\-]\s*)?)?(?:\(\s*([2-9]1[02-9]|[2-9][02-8]1|[2-9][02-8][02-9])\s*\)|([2-9]1[02-9]|[2-9][02-8]1|[2-9][02-8][02-9]))\s*(?:[.\-]\s*)?)?([2-9]1[02-9]|[2-9][02-9]1|[2-9][02-9]{2})\s*(?:[.\-]\s*)?([0-9]{4})(?:\s*(?:#|x\.?|ext\.?|extension)\s*(\d+))?$/.test(a)?"phone":/^\s*$/.test(a)?"whitespace":/^\d*$/.test(a)?"numeric":"character"},getAllEvents:function(){return Da.all("timeline")}},Ga={VERSION:V,paintPerformance:{},noConflict:function(){return a.atatus=X,Ga},isConfigured:function(){return!!z},config:function(b,c){c=c||{},z=b,W.remoteFetching=!1,M=[],Ga.setCustomData(c.customData),Ga.setTags(c.tags),Z=!!c.debugMode,da=!!c.reportAjaxErrors,ea=!!c.reportUnhandledRejections,fa=!!c.allowChromeExtension,E=!!c.disableBreadcrumbs,F=!!c.disableErrorTracking,K=!!c.disableRUM,H=!!c.disableAjaxMonitoring,I=c.disableSession===d?!1:c.disableSession,J=c.disableSPA===d?!1:c.disableSPA,T=c.urlMaxLength,ba=Ca.canAllowInsecureSubmissions(),Ga.setIgnoreUrls(c.ignoreUrls),Ga.setWhitelistUrls(c.whitelistUrls),Ga.setAllowedDomains(c.allowedDomains),Ga.setVersion(c.version),Ga.enableOffline(c.enableOffline||c.offline),Ga.onBeforeSend(c.beforeSend),Ga.onBeforeErrorSend(c.beforeErrorSend),Ga.setGroupingKeyCallback(c.groupingKeyCallback),c.ignoreErrors&&Ca.isArray(c.ignoreErrors)&&(M=c.ignoreErrors),M.push(/^Script error\.?$/),M.push(/^Javascript error: Script error\.? on line 0$/),M=Ca.joinRegExp(M),q(),L={enabled:!1,timeline:!0,display:!0,error:!0,levels:null},Ca.isBoolean(c.console)&&(L.enabled=c.console),Ca.isBoolean(c.consoleTimeline)&&(L.timeline=c.consoleTimeline),Ca.isBoolean(c.consoleDisplay)&&(L.display=c.consoleDisplay),Ca.isBoolean(c.consoleErrorNotify)&&(L.error=c.consoleErrorNotify),Ca.isArray(c.consoleTimelineLevels)&&(L.levels=c.consoleTimelineLevels),L.enabled&&"console"in a&&a.console.log&&Ea.attach(a.console,L.timeline,L.display,L.error,L.levels),Ga.setHashRoutes(c.hashRoutes);var e=a.navigator.connection||a.navigator.mozConnection||a.navigator.webkitConnection;return e&&(Aa={},Aa.dlk=e.downlink,Aa.eft=e.effectiveType,Aa.rtt=e.rtt,Aa.type=e.type),Ga},install:function(){if(!m())return Ga;if(!fa&&-1!==b.location.href.indexOf("chrome-extension://"))return Ga;if(g(),E||Fa.attach(),F||(W.report.subscribe(r),W.extendToAsynchronousCallbacks(),U&&da&&U.ajaxError(i),ea&&k()),H||K||Ga.__attachAjaxHooks(),!I&&!K&&Ga.SessionTracking){var c=function(){S=new Ga.SessionTracking,S.attach()};a.addEventListener?a.addEventListener("load",c):a.attachEvent("onload",c)}return J||K||!Ga.spa||Ga.spa.init({logLevel:Z?"debug":"warn",urlMaxLength:T}),Ga},uninstall:function(){return z=null,F||(W.report.unsubscribe(r),U&&da&&U.unbind("ajaxError",i),ea&&l()),Ga},setCustomData:function(a){return a?Ca.isObject(a)?A=a:Ca.log("Custom data must be an object."):A=null,Ga},setTags:function(a){return a?Ca.isArray(a)?Y=a:Ca.log("Tags must be an array of string."):Y=[],Ga},setHashRoutes:function(a){return a?(O=function(a){if(a&&a.request&&a.request.url&&(a.request.url=a.request.url.replace("/#/","/").replace("#/","/")),a&&a.data&&a.data[0]&&a.data[0].spans)for(var b=0;b<a.data.length;b++)a.data[b].n=(a.data[b].n||"").replace("/#/","/").replace("#","");if(a&&a.slowestRoutes&&a.slowestRoutes[0])for(var c=0;c<a.slowestRoutes.length;c++)a.slowestRoutes[c].n=(a.slowestRoutes[c].n||"").replace("/#/","/").replace("#","")},Ga):(O=null,Ga)},setIgnoreUrls:function(a){return a&&Ca.isArray(a)?Array.prototype.push.apply(a,Ba):a=Ba,_=Ca.joinRegExp(a),Ga},getIgnoreUrls:function(){return _},setWhitelistUrls:function(a){return a&&Ca.isArray(a)&&(aa=Ca.joinRegExp(a)),Ga},getWhitelistUrls:function(){return aa},setAllowedDomains:function(a){return a&&Ca.isArray(a)&&($=Ca.joinRegExp(a)),Ga},getAllowedDomains:function(){return $},setUser:function(a,b,c,d){return f(a,b,c,d),Ga},resetUser:function(){return e(),Ga},setVersion:function(a){return a&&(D=""+a),Ga},enableOffline:function(a){return Ca.isBoolean(a)&&(ca=a),Ga},onBeforeSend:function(a){return Ca.isFunction(a)&&(Q=a),Ga},onBeforeErrorSend:function(a){return Ca.isFunction(a)&&(R=a),Ga},setGroupingKeyCallback:function(a){return Ca.isFunction(a)&&(P=a),Ga},setAPIEndpoint:function(a){return ia=a,Ga},getAPIEndpoint:function(){return ia},init:function(a,b,c){return c&&(b=b||{},b.customData=c),Ga.config(a,b)},withCustomData:function(a){return Ga.setCustomData(a)},withTags:function(a){return Ga.setTags(a)},attach:function(){return Ga.install()},detach:function(){return Ga.uninstall()},endSession:function(){return S&&S.endSession(),Ga},_setFeatures:function(a){Ca.isObject(a)&&(H=!!a.daj,I=!!a.dss,J=!!a.dspa,K=!!a.drum,F=!!a.derror,G=!!a.dtxn,a.error&&Ca.log("Error in sending data to Atatus",a.error))},measureRoute:function(a){return S&&a&&S.virtualPageLoaded(a),Ga},leaveBreadcrumb:function(a,b){return a?(Da.add("timeline",{ts:Ca.now(),c:"breadcrumb",l:b||"info",m:Ca.serialize(a)}),Ga):void 0},notify:function(a,b,c){return"string"==typeof a?void Ca.log("atatus.notify() was called with a string. Expected instance of Error."):Ga.send(a,b,c);

},sendPerf:function(a){return K?void Ca.log("RUM is disabled."):t(ka,a)},sendAjaxPerf:function(a){return K||H?void Ca.log("AJAX monitoring is disabled."):t(la,a)},sendSessionPerf:function(a){return K||I?void Ca.log("Session Tracking is disabled."):t(ma,a)},sendSPAPerf:function(a){return K||J?void Ca.log("SPA Tracking is disabled."):t(na,a)},sendTxnPerf:function(a){return K||G?void Ca.log("Transaction monitoring is disabled."):t(oa,a)},sendWebVitals:function(a){return K?void Ca.log("Real User Monitoring is disabled."):t(pa,a)},send:function(a,b,c){try{r(W.computeStackTrace(a),{customData:b,tags:c})}catch(d){if(a!==d)throw d}return Ga},_isAllowedUrl:function(a){return a=a||"",_&&_.test&&_.test(a)?!1:aa&&aa.test?aa.test(a)?!0:!1:$&&$.test?$.test(a)?!0:!1:!0},_helper:Ca};a.atatus=Ga,"object"==typeof exports&&"undefined"!=typeof module?(module.exports=Ga,"undefined"!=typeof global&&(global.atatus=Ga)):"function"==typeof define&&define.amd&&("object"==typeof require&&require.load?define(function(){return Ga}):define("atatus",function(){return Ga}))}(window,document,window.jQuery),function(a,b,c,d){function e(a){a.pl<=0||(a.nt=a.nt>0?a.nt:0,a.dp=a.dp>0?a.dp:0,a.pr=a.pr>0?a.pr:0,c.sendPerf(a))}function f(b,c){return"object"==typeof a.performance&&(!b||b&&typeof a.performance[b]===c)}function g(b){if(!f("getEntriesByName","function"))return b;var d=a.performance.getEntriesByName("first-paint");d.length>0&&d[0].startTime>0?b.fp=+d[0].startTime.toFixed(0):a.performance.timing&&a.performance.timing.msFirstPaint&&(b.fp=+(a.performance.timing.msFirstPaint-a.performance.timing.fetchStart).toFixed(0));var e=a.performance.getEntriesByName("first-contentful-paint");return e.length>0&&e[0].startTime>0&&(b.fcp=+e[0].startTime.toFixed(0)),c.paintPerformance={fp:b.fp,fcp:b.fcp},b}function h(){var b=a.performance||a.mozPerformance||a.msPerformance||a.webkitPerformance,c=b.timing;if(0===c.loadEventEnd)return!1;clearInterval(l),l=null;var d=c.navigationStart;0>=d&&(d=c.fetchStart);var f={};for(var h in m)f[m[h]]=-1,h in c&&(c[h]<=0||(f[m[h]]=c[h]-d));var i={nt:f.rps-f.ns,dp:f.dce-f.rps,pr:f.le-f.dce,pl:f.le-f.ns,timing:f};try{g(i)}catch(j){}e(i)}function i(){if(!k||!k.bDone)return!1;clearInterval(l),l=!1;var a=k.getMeasures();if(null!=a&&null!=a.backend&&null!=a.frontend&&null!=a["page load time"]&&null!=a["total load time"]){var b=a.backend,c=a.backend+a.frontend,d={nt:b,dp:c-b,pr:a["total load time"]-c,fe:a["total load time"]-b,pl:a["total load time"]};e(d)}}var j=(new Date).getTime(),k=k||{};k.q=k.q||[],k.version="0.3",k.targetOrigin=b.location.protocol+"//"+b.location.hostname,k.bPostMessage=!1,k.beaconUrl=k.beaconUrl||"/images/beacon.gif",k.autorun=!1,k.init=function(){if(k.bDone=!1,k.bUnloaded=!1,k.marks={},k.measures={},k.starts={},k.findStartTime(),k.addEventListener("beforeunload",k.beforeUnload,!1),k.addEventListener("pagehide",k.beforeUnload,!1),k.addEventListener("unload",k.beforeUnload,!1),k.processQ(),"complete"===b.readyState){var c=a.performance||a.mozPerformance||a.msPerformance||a.webkitPerformance;c&&"undefined"!=typeof c.timing&&"undefined"!=typeof c.timing.loadEventEnd&&(k.mark("firstbyte",c.timing.responseStart),k.mark("onload",c.timing.loadEventEnd)),k.done()}else k.addEventListener("load",k.onload,!1)},k.processQ=function(){for(var a=k.q.length,b=0;a>b;b++){var c=k.q[b],d=c[0];"mark"===d?k.mark(c[1],c[2]):"measure"===d?k.measure(c[1],c[2],c[3]):"done"===d&&k.done(c[1])}},k.mark=function(b,c){return k.dprint("RUM_EPISODES.mark: "+b+", "+c),b?(k.marks[b]=parseInt(c||(new Date).getTime()),k.bPostMessage&&a.postMessage("RUM_EPISODES:mark:"+b+":"+c,k.targetOrigin),void("firstbyte"===b?k.measure("backend","starttime","firstbyte"):"onload"===b?(k.measure("frontend","firstbyte","onload"),k.measure("page load time","starttime","onload")):"done"===b&&k.measure("total load time","starttime","done"))):void k.dprint("Error: markName is undefined in RUM_EPISODES.mark.")},k.measure=function(b,c,d){if(k.dprint("RUM_EPISODES.measure: "+b+", "+c+", "+d),!b)return void k.dprint("Error: episodeName is undefined in RUM_EPISODES.measure.");var e;if("undefined"==typeof c)e="number"==typeof k.marks[b]?k.marks[b]:(new Date).getTime();else if("number"==typeof k.marks[c])e=k.marks[c];else{if("number"!=typeof c)return void k.dprint("Error: unexpected startNameOrTime in RUM_EPISODES.measure: "+c);e=c}var f;if("undefined"==typeof d)f=(new Date).getTime();else if("number"==typeof k.marks[d])f=k.marks[d];else{if("number"!=typeof d)return void k.dprint("Error: unexpected endNameOrTime in RUM_EPISODES.measure: "+d);f=d}k.starts[b]=parseInt(e),k.measures[b]=parseInt(f-e),k.bPostMessage&&a.postMessage("RUM_EPISODES:measure:"+b+":"+e+":"+f,k.targetOrigin)},k.done=function(b){k.bDone=!0,k.mark("done"),k.bPostMessage&&a.postMessage("RUM_EPISODES:done",k.targetOrigin),"function"==typeof b&&b()},k.getMarks=function(){return k.marks},k.getMeasures=function(){return k.measures},k.getStarts=function(){return k.starts},k.findStartTime=function(){var a=k.findStartWebTiming()||k.findStartCookie();a&&k.mark("starttime",a)},k.findStartWebTiming=function(){var b,c=a.performance||a.mozPerformance||a.msPerformance||a.webkitPerformance;return c&&"undefined"!=typeof c.timing&&"undefined"!=typeof c.timing.navigationStart&&(b=c.timing.navigationStart,k.dprint("RUM_EPISODES.findStartWebTiming: startTime = "+b)),b},k.findStartCookie=function(){try{for(var c=b.cookie.split(" "),e=0;e<c.length;e++)if(0===c[e].indexOf("RUM_EPISODES=")){for(var f,g,h=c[e].substring("RUM_EPISODES=".length).split("&"),i=0;i<h.length;i++)if(0===h[i].indexOf("s="))f=h[i].substring(2);else if(0===h[i].indexOf("r=")){var j=h[i].substring(2);j=j.replace(/;$/,""),g=a.escape(b.referrer)===j}if(g&&f)return k.dprint("RUM_EPISODES.findStartCookie: startTime = "+f),f}}catch(l){}return d},k.beforeUnload=function(){try{if(k.bUnloaded)return;b.cookie="RUM_EPISODES=s="+Number(new Date)+"&r="+a.escape(b.location)+"; path=/",k.bUnloaded=!0}catch(c){}},k.onload=function(){k.mark("onload"),k.done()},k.addEventListener=function(b,c,d){return"undefined"!=typeof a.attachEvent?a.attachEvent("on"+b,c):a.addEventListener?a.addEventListener(b,c,d):void 0},k.dprint=function(){},k.init();var l=null,m={navigationStart:"ns",redirectStart:"rds",redirectEnd:"rde",unloadEventStart:"us",unloadEventEnd:"ue",fetchStart:"fs",domainLookupStart:"dls",domainLookupEnd:"dle",connectStart:"cs",secureConnectionStart:"scs",connectEnd:"ce",handshakeStart:"hs",requestStart:"rqs",responseStart:"rps",responseEnd:"rpe",domLoading:"dl",domInteractive:"di",domContentLoadedEventStart:"dcs",domContentLoadedEventEnd:"dce",domComplete:"dc",loadEventStart:"ls",loadEventEnd:"le"},n=a.performance||a.mozPerformance||a.msPerformance||a.webkitPerformance;n&&"undefined"!=typeof n.timing&&"undefined"!=typeof n.navigation?l=setInterval(h,100):(k.mark("firstbyte",j),l=setInterval(i,100))}(window,document,window.atatus),function(a,b,c){b.SessionTracking=function(){function d(a){b.sessionId=p.uuid4(),q.existingTimestamp=p.createCookie(q.cookieName,b.sessionId),a(!0)}function e(){var a;if(q.existingTimestamp){var b=new Date(new Date-s);a=q.existingTimestamp<b}a&&(q.stopSession=!0)}function f(a){return Math.min(a,3e5)}function g(a){for(var b in a)isNaN(a[b])&&"string"!=typeof a[b]?a[b]=0:a[b]<0&&(a[b]=0);return a}function h(b,c){var d;return d="object"==typeof a.performance&&"function"==typeof a.performance.now?a.performance.now():0,{du:Math.min(q.maxVirtualPageDuration,d-(b||c)),o:Math.min(q.maxVirtualPageDuration,d-c)}}function i(a){var c={du:a.loadEventEnd-a.navigationStart,s:a.fetchStart};return a.domainLookupStart&&a.domainLookupStart>0&&(c.dls=a.domainLookupStart-a.fetchStart),a.domainLookupEnd&&a.domainLookupEnd>0&&(c.dle=a.domainLookupEnd-a.fetchStart),a.connectStart&&a.connectStart>0&&(c.cs=a.connectStart-a.fetchStart),a.connectEnd&&a.connectEnd>0&&(c.ce=a.connectEnd-a.fetchStart),a.responseStart&&a.responseStart>0&&(c.rps=a.responseStart-a.fetchStart),a.responseEnd&&a.responseEnd>0&&(c.rpe=a.responseEnd-a.fetchStart),a.domLoading&&a.domLoading>0&&(c.dl=a.domLoading-a.fetchStart),a.domInteractive&&a.domInteractive>0&&(c.di=a.domInteractive-a.fetchStart),a.domContentLoadedEventEnd&&a.domContentLoadedEventEnd>0&&(c.dce=a.domContentLoadedEventEnd-a.fetchStart),a.domComplete&&a.domComplete>0&&(c.dc=f(a.domComplete-a.fetchStart)),a.loadEventStart&&a.loadEventStart>0&&(c.ls=a.loadEventStart-a.fetchStart),a.loadEventEnd&&a.loadEventEnd>0&&(c.le=a.loadEventEnd-a.fetchStart),a.secureConnectionStart&&a.secureConnectionStart>0&&(c.scs=a.secureConnectionStart-a.connectStart-a.fetchStart,c.scs=c.scs>0?c.scs:0),c=g(c),b.paintPerformance&&b.paintPerformance.fp&&(c.fp=b.paintPerformance.fp,c.fcp=b.paintPerformance.fcp),c}function j(a,b){var c={du:f(a.duration),s:b+a.fetchStart};return a.domainLookupStart&&a.domainLookupStart>0&&(c.dls=a.domainLookupStart-a.fetchStart),a.domainLookupEnd&&a.domainLookupEnd>0&&(c.dle=a.domainLookupEnd-a.fetchStart),a.connectStart&&a.connectStart>0&&(c.cs=a.connectStart-a.fetchStart),a.connectEnd&&a.connectEnd>0&&(c.ce=a.connectEnd-a.fetchStart),a.responseStart&&a.responseStart>0&&(c.rps=a.responseStart-a.fetchStart),a.responseEnd&&a.responseEnd>0&&(c.rpe=a.responseEnd-a.fetchStart),a.secureConnectionStart&&a.secureConnectionStart>0&&(c.scs=a.secureConnectionStart-a.connectStart-a.fetchStart,c.scs=c.scs>0?c.scs:0),c=g(c)}function k(){var b=a.location.pathname,c=a.location.protocol+"//"+a.location.host+b;return c.length>800&&(c=c.substring(0,800)),{u:c,t:i(a.performance.timing),g:"p"}}function l(b,c,d){var e=a.location.protocol+"//"+a.location.host+b;return e.length>800&&(e=e.substring(0,800)),{u:e,t:h(c,d),g:"r"}}function m(b,c){var d=b.name.split("?")[0];return d.length>800&&(d=d.substring(0,800)),{u:d,t:j(b,c?0:a.performance.timing.navigationStart),g:"xmlhttprequest"===b.initiatorType||"fetch"===b.initiatorType?"x":"s",z:b.decodedBodySize||b.transferSize||0}}function n(b,d){if(a.performance!==c&&a.performance.getEntriesByType)try{for(var e=a.performance.getEntriesByType("resource"),f=q.offset;f<e.length;f++){var g=e[f].name.split("?")[0];0!==g.indexOf(q.atatusHost)&&(g.indexOf("favicon.ico")>0||0!==g.indexOf("about:blank")&&("j"!==g[0]||1!==g.indexOf("avascript:"))&&0!==g.indexOf("chrome-extension://")&&0!==g.indexOf("res://")&&0!==g.indexOf("file://")&&e[f].name&&b.push(m(e[f],d)))}q.offset=e.length}catch(h){}}function o(b,d,e,f){if(a.performance===c||a.performance.timing===c||a.performance.timing.fetchStart===c||isNaN(a.performance.timing.fetchStart))return null;var g=[{rs:[]}];if(d&&(e&&(f?g[0].p=k():g[0].rs.push(k())),n(g[0].rs)),b){q.pendingVirtualPage&&(g[0].r=q.pendingVirtualPage);var h=null==q.pendingVirtualPage;if(q.pendingVirtualPage=l(b,q.previousVirtualPageLoadTimestamp,q.initalStaticPageLoadTimestamp),!h&&g.length>0)return g}return g}var p=b._helper,q=this,r={};b.sessionId=null,this.cookieName="atatus-sid",this.virtualPage=null,this.heartBeatInterval=null,this.offset=0,this.atatusHost=b.getAPIEndpoint(),this.maxVirtualPageDuration=18e5;var s=3e5;this.existingTimestamp=null,this.stopSession=!1,this.sendSessionPayload=function(a){q.stopSession||b.sendSessionPerf(a)},this.sendSPAPayload=function(){},this.attach=function(){d(function(a){setTimeout(function(){q.pageLoaded(a)},5e3)});var b=function(){var a=[{rs:[]}];if(n(a[0].rs),a[0].rs.length>0){var b={data:a};q.sendSessionPayload(b)}},c=function(){this.watchCookieTimestamp()}.bind(r),e=function(){"visible"===document.visibilityState&&this.watchCookieTimestamp()}.bind(r);a.addEventListener?(a.addEventListener("click",c),document.addEventListener("visibilitychange",e),a.addEventListener("beforeunload",b)):a.attachEvent&&document.attachEvent("onclick",c)},this.pageLoaded=function(b){q.sendPerformance(!0,!0,b),q.heartBeat(),q.initalStaticPageLoadTimestamp="object"==typeof a.performance&&"function"==typeof a.performance.now?a.performance.now():0},this.endSession=function(){q.stopSession=!0,p.createCookie(q.cookieName,b.sessionId,-1)},this.heartBeat=function(){q.heartBeatInterval=setInterval(function(){var a=[{rs:[]}];if(n(a[0].rs,q.virtualPage),a[0].rs.length>0){var b={data:a};q.sendSessionPayload(b)}},3e4)},this.virtualPageLoaded=function(b){var c=null==this.virtualPage;"string"==typeof b&&(b.length>0&&"/"!==b[0]&&(b+="/"),b.length>800&&(b=b.substring(0,800)),this.virtualPage=b),c?this.sendPerformance(!0,!1,!1):this.sendPerformance(!1,!1,!1),"string"==typeof b&&(this.previousVirtualPageLoadTimestamp="object"==typeof a.performance&&"function"==typeof a.performance.now?a.performance.now():0)},this.sendPerformance=function(a,b,c){var d=o(this.virtualPage,a,b,c);if(d){var e={data:d};d[0].r?q.sendSPAPayload(e):d[0].rs.length>0&&q.sendSessionPayload(e)}},r.watchCookieTimestamp=e}}(window,window.atatus),function(a,b,c){c.__attachAjaxHooks=function(){var d=c._helper,e={queue:[],batchSize:25,processing:!1,bUnloaded:!1,push:function(a){"string"==typeof a.url&&(a.url.indexOf(".html")>0||-1===a.url.indexOf("://")||!c._isAllowedUrl(a.url)||(this.queue.push(a),this.queue.length>=this.batchSize&&this._processQueue()))},_processQueue:function(){if(!this.processing&&this.queue.length){this.processing=!0;try{for(var a={},b={},e=0;e<this.queue.length;e++){var f,g=this.queue[e],h=g.status;if(400>h){f=g.method+g.url;var i=g.respAvailTime-g.sendTime,j=g.respProcTime-g.respAvailTime,k=g.receivedSize?+g.receivedSize:0,l=g.sendSize?+g.sendSize:0;0>i&&(i=0),0>j&&(j=0),isNaN(k)&&(k=0),isNaN(l)&&(l=0);var m=a[f];m?(m.rt.push(i),m.ct.push(j),m.rz.push(k),m.sz.push(l)):a[f]={m:g.method,u:g.url,rt:[i],ct:[j],rz:[k],sz:[l]}}else{f=g.method+h+g.url;var n=b[f];n&&n.sc?n.sc[h]?n.sc[h]++:n.sc[h]=1:(b[f]={m:g.method,u:g.url,sc:{}},b[f].sc[h]=1)}}var o={xhr:d.arrayFromObject(a),xhrError:d.arrayFromObject(b)};c.sendAjaxPerf(o)}catch(p){d.log("Error while processing queue: ",p)}finally{this.queue=[],this.processing=!1}}},beforeUnload:function(){e.bUnloaded||(e._processQueue(),e.bUnloaded=!0)}};d.addEventListener("beforeunload",e.beforeUnload,!1);var f={support:function(a){return!a||"apply"in a},around:function(a,b,c,e){return a=a||function(){},function(){var f,g=Array.prototype.slice.call(arguments);try{b&&(f=b.apply(this,g))}catch(h){d.log(e,h)}var i;try{i=a.apply(this,f||g)}finally{try{c&&c.apply(this,g)}catch(h){d.log(e,h)}}return i}},before:function(a,b){return f.around(a,b)},after:function(a,b){return f.around(a,null,b)},timeout:function(a){setTimeout(a,0)},wrapAddEventListener:function(){return function(a,b){if(("load"===a||"error"===a)&&b&&this._atrumXhrData){var c;b.__atrumInterceptor?c=b.__atrumInterceptor:f.support(b)?(c=h.wrapXHR(b,this,"XHR.invokeEventListener"),b.__atrumInterceptor=c):c=null;var d;return c&&(d=Array.prototype.slice.call(arguments),d[1]=c),d}}},wrapRemoveEventListener:function(){return function(a,b){if(this._atrumXhrData){var c=Array.prototype.slice.call(arguments);return b.__atrumInterceptor&&(c[1]=b.__atrumInterceptor),c}}},aroundWithHandleEvent:function(a,b,c,d){var e=a;return a&&"object"==typeof a&&"toString"in a&&"[xpconnect wrapped nsIDOMEventListener]"===a.toString()&&"handleEvent"in a&&(e=function(){a.handleEvent.apply(this,Array.prototype.slice.call(arguments))}),f.around(e,b,c,d)},getFullyQualifiedUrl:function(a){var c=b.createElement("a");return c.href=a,c.href}};if(a.XMLHttpRequest&&a.XMLHttpRequest.prototype){var g=a.XMLHttpRequest.prototype;if(!("open"in g&&"send"in g))return;if(!f.support(g.open)||!f.support(g.send))return;var h={};h.captureAjaxTimings=function(a){var b=a._atrumXhrData;if(b){var c=(new Date).getTime();2===a.readyState?b.firstByteTime=b.firstByteTime||c:4===a.readyState&&(b.respAvailTime=b.respAvailTime||c,b.firstByteTime=b.firstByteTime||c)}},h.sendPayload=function(a,b){b.receivedSize=0,a.responseType&&"text"!==a.responseType||"string"==typeof a.responseText&&(b.receivedSize=a.responseText.length),b.status=a.status,e.push(b)},h.wrapXHR=function(a,b,c){return f.aroundWithHandleEvent(a,function(){h.captureAjaxTimings(this)},function(){var a=b._atrumXhrData;if(a&&4===b.readyState){var c=(new Date).getTime();a.respProcTime=a.respProcTime||c,h.sendPayload(b,a),delete b._atrumXhrData}},c)},h.ajaxDone=function(a){if(a._atrumXhrData){var b=(new Date).getTime()+15e4,c=function(){h.captureAjaxTimings(a);var d=a._atrumXhrData;if(d){var e=(new Date).getTime();4===a.readyState?(d.respProcTime=d.respProcTime||e,h.sendPayload(a,d),delete a._atrumXhrData):b>e?setTimeout(c,50):delete a._atrumXhrData}};c()}},g.open=f.around(g.open,function(){var a=1<=arguments.length?String(arguments[0]):"",b=2<=arguments.length?String(arguments[1]):"";b=f.getFullyQualifiedUrl(b);var d=c._isAllowedUrl(b);d&&(b=b&&b.split("?")[0],this._atrumXhrData={method:a,url:b,sendTime:null,sendSize:null,firstByteTime:null,respAvailTime:null,respProcTime:null,receivedSize:null,parentPhase:null})},null,"XHR.open"),g.send=f.around(g.send,function(){var a=this,b=a._atrumXhrData;if(b){var c=(new Date).getTime();b.sendTime=b.sendTime||c,b.sendSize=1<=arguments.length&&arguments[0]?arguments[0].length||0:0;var d=0,e=function(){if(4===a.readyState)h.ajaxDone(a);else{var b=null;try{b=a.onreadystatechange}catch(c){return void h.ajaxDone(a)}d++,b?f.support(b)?a.onreadystatechange=h.wrapXHR(b,a,"XHR.onReadyStateChange"):h.ajaxDone(a):5>d?f.timeout(e):h.ajaxDone(a)}};e()}},null,"XHR.send"),"addEventListener"in g&&"removeEventListener"in g&&f.support(g.addEventListener)&&f.support(g.removeEventListener)&&(g.addEventListener=f.around(g.addEventListener,f.wrapAddEventListener(),null,"XHR.addEventListener"),g.removeEventListener=f.around(g.removeEventListener,f.wrapRemoveEventListener(),null,"XHR.removeEventListener"))}if("fetch"in a&&!a.fetch.polyfill){var i=a.fetch;a.fetch=function(a){return function(){for(var b=new Array(arguments.length),d=0;d<b.length;++d)b[d]=arguments[d];var f="GET",g=0;b[1]&&(b[1].method&&(f=b[1].method),"string"==typeof b[1].body&&(g=b[1].body.length));var h={url:b[0],method:f,sendSize:g,receivedSize:0,sendTime:(new Date).getTime(),respAvailTime:0,respProcTime:0};return a.apply(this,b).then(function(a){return c._isAllowedUrl(h.url)&&(h.respAvailTime=(new Date).getTime(),h.respProcTime=h.respAvailTime,h.status=a.status,a.headers&&a.headers.get&&(h.receivedSize=a.headers.get("Content-Length")),e.push(h)),a})}}(i)}}}(window,document,window.atatus),function(a,b){function c(a,c,d){if(!(0>=c)){var e={data:[{t:{n:a,s:d,t:{du:c}}}]};b.sendTxnPerf(e)}}function d(a){return i+" "+a}function e(){try{return"localStorage"in a&&null!==a.localStorage}catch(b){return!1}}function f(a){var b=j.now();try{localStorage.setItem(d(a),b)}catch(c){}}function g(a){var b=null,c=d(a);try{b=localStorage.getItem(c),localStorage.removeItem(c)}catch(e){}var f=0;return b&&(f=j.now()-b),f}function h(a){try{var b=d(a);localStorage.removeItem(b)}catch(c){}}var i="atatus.com/",j=b._helper,k=1,l=0;b.beginTransaction=function(a){e()&&f(a)},b.endTransaction=function(a){if(e()){var b=g(a);c(a,b,k)}},b.failTransaction=function(a){if(e()){var b=g(a);c(a,b,l)}},b.cancelTransaction=function(a){e()&&h(a)},b.recordTransaction=function(a,b,d){e()&&a&&b&&c(a,b,d===!1?l:k)}}(window,window.atatus),function(a,b){function c(a){a=a||{};var b=a.name&&a.name.toLowerCase();a.value&&b&&!e[b]&&(e[b]=a.value,f++),f>=5&&h()}function d(){if(a.webVitals){a.webVitals.getFID(c),a.webVitals.getFCP(c),a.webVitals.getTTFB(c),a.webVitals.getCLS(c,!1),a.webVitals.getLCP(c,!1);var b=a.performance&&a.performance.timing;!e.ttfb&&b&&(e.ttfb=b.responseStart-b.navigationStart,e.ttfb&&f++)}}var e={},f=0,g=!1,h=function(){!g&&f>0&&(g=!0,b.sendWebVitals(e))};"loading"!==document.readyState?d():document.addEventListener("DOMContentLoaded",function(){d()}),a.addEventListener("beforeunload",h)}(window,window.atatus),function(a,b){a._atatusConfig&&a._atatusConfig.apikey&&b.config(a._atatusConfig.apikey,a._atatusConfig).install()}(window,window.atatus);
!function(define){!function(e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e():"function"==typeof define&&define.amd?define([],e):("undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this).adapter=e()}(function(){return function n(i,o,a){function s(t,e){if(!o[t]){if(!i[t]){var r="function"==typeof require&&require;if(!e&&r)return r(t,!0);if(c)return c(t,!0);throw(e=new Error("Cannot find module '"+t+"'")).code="MODULE_NOT_FOUND",e}r=o[t]={exports:{}},i[t][0].call(r.exports,function(e){return s(i[t][1][e]||e)},r,r.exports,n,i,o,a)}return o[t].exports}for(var c="function"==typeof require&&require,e=0;e<a.length;e++)s(a[e]);return s}({1:[function(e,t,r){"use strict";e=(0,e("./adapter_factory.js").adapterFactory)({window:"undefined"==typeof window?void 0:window});t.exports=e},{"./adapter_factory.js":2}],2:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.adapterFactory=function(){var e=(0<arguments.length&&void 0!==arguments[0]?arguments[0]:{}).window,t=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{shimChrome:!0,shimFirefox:!0,shimSafari:!0},r=o.log,n=o.detectBrowser(e),i={browserDetails:n,commonShim:p,extractVersion:o.extractVersion,disableLog:o.disableLog,disableWarnings:o.disableWarnings,sdp:d};switch(n.browser){case"chrome":if(!a||!a.shimPeerConnection||!t.shimChrome)return r("Chrome shim is not included in this adapter release."),i;if(null===n.version)return r("Chrome shim can not determine version, not shimming."),i;r("adapter.js shimming chrome."),i.browserShim=a,p.shimAddIceCandidateNullOrEmpty(e,n),p.shimParameterlessSetLocalDescription(e,n),a.shimGetUserMedia(e,n),a.shimMediaStream(e,n),a.shimPeerConnection(e,n),a.shimOnTrack(e,n),a.shimAddTrackRemoveTrack(e,n),a.shimGetSendersWithDtmf(e,n),a.shimGetStats(e,n),a.shimSenderReceiverGetStats(e,n),a.fixNegotiationNeeded(e,n),p.shimRTCIceCandidate(e,n),p.shimRTCIceCandidateRelayProtocol(e,n),p.shimConnectionState(e,n),p.shimMaxMessageSize(e,n),p.shimSendThrowTypeError(e,n),p.removeExtmapAllowMixed(e,n);break;case"firefox":if(!s||!s.shimPeerConnection||!t.shimFirefox)return r("Firefox shim is not included in this adapter release."),i;r("adapter.js shimming firefox."),i.browserShim=s,p.shimAddIceCandidateNullOrEmpty(e,n),p.shimParameterlessSetLocalDescription(e,n),s.shimGetUserMedia(e,n),s.shimPeerConnection(e,n),s.shimOnTrack(e,n),s.shimRemoveStream(e,n),s.shimSenderGetStats(e,n),s.shimReceiverGetStats(e,n),s.shimRTCDataChannel(e,n),s.shimAddTransceiver(e,n),s.shimGetParameters(e,n),s.shimCreateOffer(e,n),s.shimCreateAnswer(e,n),p.shimRTCIceCandidate(e,n),p.shimConnectionState(e,n),p.shimMaxMessageSize(e,n),p.shimSendThrowTypeError(e,n);break;case"safari":if(!c||!t.shimSafari)return r("Safari shim is not included in this adapter release."),i;r("adapter.js shimming safari."),i.browserShim=c,p.shimAddIceCandidateNullOrEmpty(e,n),p.shimParameterlessSetLocalDescription(e,n),c.shimRTCIceServerUrls(e,n),c.shimCreateOfferLegacy(e,n),c.shimCallbacksAPI(e,n),c.shimLocalStreamsAPI(e,n),c.shimRemoteStreamsAPI(e,n),c.shimTrackEventTransceiver(e,n),c.shimGetUserMedia(e,n),c.shimAudioContext(e,n),p.shimRTCIceCandidate(e,n),p.shimRTCIceCandidateRelayProtocol(e,n),p.shimMaxMessageSize(e,n),p.shimSendThrowTypeError(e,n),p.removeExtmapAllowMixed(e,n);break;default:r("Unsupported browser!")}return i};var o=n(e("./utils")),a=n(e("./chrome/chrome_shim")),s=n(e("./firefox/firefox_shim")),c=n(e("./safari/safari_shim")),p=n(e("./common_shim")),d=n(e("sdp"));function n(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t}},{"./chrome/chrome_shim":3,"./common_shim":6,"./firefox/firefox_shim":7,"./safari/safari_shim":10,"./utils":11,sdp:12}],3:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.shimGetDisplayMedia=r.shimGetUserMedia=void 0;var s="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},n=e("./getusermedia"),i=(Object.defineProperty(r,"shimGetUserMedia",{enumerable:!0,get:function(){return n.shimGetUserMedia}}),e("./getdisplaymedia"));Object.defineProperty(r,"shimGetDisplayMedia",{enumerable:!0,get:function(){return i.shimGetDisplayMedia}}),r.shimMediaStream=function(e){e.MediaStream=e.MediaStream||e.webkitMediaStream},r.shimOnTrack=function(o){{var e;"object"!==(void 0===o?"undefined":s(o))||!o.RTCPeerConnection||"ontrack"in o.RTCPeerConnection.prototype?a.wrapPeerConnectionEvent(o,"track",function(e){return e.transceiver||Object.defineProperty(e,"transceiver",{value:{receiver:e.receiver}}),e}):(Object.defineProperty(o.RTCPeerConnection.prototype,"ontrack",{get:function(){return this._ontrack},set:function(e){this._ontrack&&this.removeEventListener("track",this._ontrack),this.addEventListener("track",this._ontrack=e)},enumerable:!0,configurable:!0}),e=o.RTCPeerConnection.prototype.setRemoteDescription,o.RTCPeerConnection.prototype.setRemoteDescription=function(){var i=this;return this._ontrackpoly||(this._ontrackpoly=function(n){n.stream.addEventListener("addtrack",function(t){var e=void 0,e=o.RTCPeerConnection.prototype.getReceivers?i.getReceivers().find(function(e){return e.track&&e.track.id===t.track.id}):{track:t.track},r=new Event("track");r.track=t.track,r.receiver=e,r.transceiver={receiver:e},r.streams=[n.stream],i.dispatchEvent(r)}),n.stream.getTracks().forEach(function(t){var e=void 0,e=o.RTCPeerConnection.prototype.getReceivers?i.getReceivers().find(function(e){return e.track&&e.track.id===t.id}):{track:t},r=new Event("track");r.track=t,r.receiver=e,r.transceiver={receiver:e},r.streams=[n.stream],i.dispatchEvent(r)})},this.addEventListener("addstream",this._ontrackpoly)),e.apply(this,arguments)})}},r.shimGetSendersWithDtmf=function(e){{var n,i,t,r,o,a;"object"===(void 0===e?"undefined":s(e))&&e.RTCPeerConnection&&!("getSenders"in e.RTCPeerConnection.prototype)&&"createDTMFSender"in e.RTCPeerConnection.prototype?(n=function(e,t){return{track:t,get dtmf(){return void 0===this._dtmf&&("audio"===t.kind?this._dtmf=e.createDTMFSender(t):this._dtmf=null),this._dtmf},_pc:e}},e.RTCPeerConnection.prototype.getSenders||(e.RTCPeerConnection.prototype.getSenders=function(){return this._senders=this._senders||[],this._senders.slice()},i=e.RTCPeerConnection.prototype.addTrack,e.RTCPeerConnection.prototype.addTrack=function(e,t){var r=i.apply(this,arguments);return r||(r=n(this,e),this._senders.push(r)),r},t=e.RTCPeerConnection.prototype.removeTrack,e.RTCPeerConnection.prototype.removeTrack=function(e){t.apply(this,arguments);e=this._senders.indexOf(e);-1!==e&&this._senders.splice(e,1)}),r=e.RTCPeerConnection.prototype.addStream,e.RTCPeerConnection.prototype.addStream=function(e){var t=this;this._senders=this._senders||[],r.apply(this,[e]),e.getTracks().forEach(function(e){t._senders.push(n(t,e))})},o=e.RTCPeerConnection.prototype.removeStream,e.RTCPeerConnection.prototype.removeStream=function(e){var r=this;this._senders=this._senders||[],o.apply(this,[e]),e.getTracks().forEach(function(t){var e=r._senders.find(function(e){return e.track===t});e&&r._senders.splice(r._senders.indexOf(e),1)})}):"object"===(void 0===e?"undefined":s(e))&&e.RTCPeerConnection&&"getSenders"in e.RTCPeerConnection.prototype&&"createDTMFSender"in e.RTCPeerConnection.prototype&&e.RTCRtpSender&&!("dtmf"in e.RTCRtpSender.prototype)&&(a=e.RTCPeerConnection.prototype.getSenders,e.RTCPeerConnection.prototype.getSenders=function(){var t=this,e=a.apply(this,[]);return e.forEach(function(e){return e._pc=t}),e},Object.defineProperty(e.RTCRtpSender.prototype,"dtmf",{get:function(){return void 0===this._dtmf&&("audio"===this.track.kind?this._dtmf=this._pc.createDTMFSender(this.track):this._dtmf=null),this._dtmf}}))}},r.shimGetStats=function(e){var a;e.RTCPeerConnection&&(a=e.RTCPeerConnection.prototype.getStats,e.RTCPeerConnection.prototype.getStats=function(){var r=this,e=Array.prototype.slice.call(arguments),t=e[0],n=e[1],e=e[2];if(0<arguments.length&&"function"==typeof t)return a.apply(this,arguments);if(0===a.length&&(0===arguments.length||"function"!=typeof t))return a.apply(this,[]);var i=function(e){var n={};return e.result().forEach(function(t){var r={id:t.id,timestamp:t.timestamp,type:{localcandidate:"local-candidate",remotecandidate:"remote-candidate"}[t.type]||t.type};t.names().forEach(function(e){r[e]=t.stat(e)}),n[r.id]=r}),n},o=function(t){return new Map(Object.keys(t).map(function(e){return[e,t[e]]}))};return 2<=arguments.length?a.apply(this,[function(e){n(o(i(e)))},t]):new Promise(function(t,e){a.apply(r,[function(e){t(o(i(e)))},e])}).then(n,e)})},r.shimSenderReceiverGetStats=function(e){var r,t,n,o;"object"===(void 0===e?"undefined":s(e))&&e.RTCPeerConnection&&e.RTCRtpSender&&e.RTCRtpReceiver&&("getStats"in e.RTCRtpSender.prototype||((r=e.RTCPeerConnection.prototype.getSenders)&&(e.RTCPeerConnection.prototype.getSenders=function(){var t=this,e=r.apply(this,[]);return e.forEach(function(e){return e._pc=t}),e}),(t=e.RTCPeerConnection.prototype.addTrack)&&(e.RTCPeerConnection.prototype.addTrack=function(){var e=t.apply(this,arguments);return e._pc=this,e}),e.RTCRtpSender.prototype.getStats=function(){var t=this;return this._pc.getStats().then(function(e){return a.filterStats(e,t.track,!0)})}),"getStats"in e.RTCRtpReceiver.prototype||((n=e.RTCPeerConnection.prototype.getReceivers)&&(e.RTCPeerConnection.prototype.getReceivers=function(){var t=this,e=n.apply(this,[]);return e.forEach(function(e){return e._pc=t}),e}),a.wrapPeerConnectionEvent(e,"track",function(e){return e.receiver._pc=e.srcElement,e}),e.RTCRtpReceiver.prototype.getStats=function(){var t=this;return this._pc.getStats().then(function(e){return a.filterStats(e,t.track,!1)})}),"getStats"in e.RTCRtpSender.prototype&&"getStats"in e.RTCRtpReceiver.prototype&&(o=e.RTCPeerConnection.prototype.getStats,e.RTCPeerConnection.prototype.getStats=function(){var t,r,n,i;return 0<arguments.length&&arguments[0]instanceof e.MediaStreamTrack?(t=arguments[0],i=n=r=void 0,this.getSenders().forEach(function(e){e.track===t&&(r?i=!0:r=e)}),this.getReceivers().forEach(function(e){return e.track===t&&(n?i=!0:n=e),e.track===t}),i||r&&n?Promise.reject(new DOMException("There are more than one sender or receiver for the track.","InvalidAccessError")):r?r.getStats():n?n.getStats():Promise.reject(new DOMException("There is no sender or receiver for the track.","InvalidAccessError"))):o.apply(this,arguments)}))},r.shimAddTrackRemoveTrackWithNative=p,r.shimAddTrackRemoveTrack=function(i,e){if(i.RTCPeerConnection){if(i.RTCPeerConnection.prototype.addTrack&&65<=e.version)return p(i);var r=i.RTCPeerConnection.prototype.getLocalStreams,n=(i.RTCPeerConnection.prototype.getLocalStreams=function(){var t=this,e=r.apply(this);return this._reverseStreams=this._reverseStreams||{},e.map(function(e){return t._reverseStreams[e.id]})},i.RTCPeerConnection.prototype.addStream),t=(i.RTCPeerConnection.prototype.addStream=function(e){var t,r=this;this._streams=this._streams||{},this._reverseStreams=this._reverseStreams||{},e.getTracks().forEach(function(t){if(r.getSenders().find(function(e){return e.track===t}))throw new DOMException("Track already exists.","InvalidAccessError")}),this._reverseStreams[e.id]||(t=new i.MediaStream(e.getTracks()),this._streams[e.id]=t,this._reverseStreams[t.id]=e,e=t),n.apply(this,[e])},i.RTCPeerConnection.prototype.removeStream),o=(i.RTCPeerConnection.prototype.removeStream=function(e){this._streams=this._streams||{},this._reverseStreams=this._reverseStreams||{},t.apply(this,[this._streams[e.id]||e]),delete this._reverseStreams[(this._streams[e.id]||e).id],delete this._streams[e.id]},i.RTCPeerConnection.prototype.addTrack=function(t,e){var r=this;if("closed"===this.signalingState)throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.","InvalidStateError");var n=[].slice.call(arguments,1);if(1!==n.length||!n[0].getTracks().find(function(e){return e===t}))throw new DOMException("The adapter.js addTrack polyfill only supports a single  stream which is associated with the specified track.","NotSupportedError");if(this.getSenders().find(function(e){return e.track===t}))throw new DOMException("Track already exists.","InvalidAccessError");this._streams=this._streams||{},this._reverseStreams=this._reverseStreams||{};var n=this._streams[e.id];return n?(n.addTrack(t),Promise.resolve().then(function(){r.dispatchEvent(new Event("negotiationneeded"))})):(n=new i.MediaStream([t]),this._streams[e.id]=n,this._reverseStreams[n.id]=e,this.addStream(n)),this.getSenders().find(function(e){return e.track===t})},["createOffer","createAnswer"].forEach(function(e){var n=i.RTCPeerConnection.prototype[e],t=c({},e,function(){var t=this,r=arguments;return arguments.length&&"function"==typeof arguments[0]?n.apply(this,[function(e){e=s(t,e);r[0].apply(null,[e])},function(e){r[1]&&r[1].apply(null,e)},arguments[2]]):n.apply(this,arguments).then(function(e){return s(t,e)})});i.RTCPeerConnection.prototype[e]=t[e]}),i.RTCPeerConnection.prototype.setLocalDescription),a=(i.RTCPeerConnection.prototype.setLocalDescription=function(){return arguments.length&&arguments[0].type&&(arguments[0]=(r=this,n=(e=arguments[0]).sdp,Object.keys(r._reverseStreams||[]).forEach(function(e){var e=r._reverseStreams[e],t=r._streams[e.id];n=n.replace(new RegExp(e.id,"g"),t.id)}),new RTCSessionDescription({type:e.type,sdp:n}))),o.apply(this,arguments);var r,e,n},Object.getOwnPropertyDescriptor(i.RTCPeerConnection.prototype,"localDescription"));Object.defineProperty(i.RTCPeerConnection.prototype,"localDescription",{get:function(){var e=a.get.apply(this);return""===e.type?e:s(this,e)}}),i.RTCPeerConnection.prototype.removeTrack=function(t){var r=this;if("closed"===this.signalingState)throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.","InvalidStateError");if(!t._pc)throw new DOMException("Argument 1 of RTCPeerConnection.removeTrack does not implement interface RTCRtpSender.","TypeError");if(!(t._pc===this))throw new DOMException("Sender was not created by this connection.","InvalidAccessError");this._streams=this._streams||{};var n=void 0;Object.keys(this._streams).forEach(function(e){r._streams[e].getTracks().find(function(e){return t.track===e})&&(n=r._streams[e])}),n&&(1===n.getTracks().length?this.removeStream(this._reverseStreams[n.id]):n.removeTrack(t.track),this.dispatchEvent(new Event("negotiationneeded")))}}function s(r,e){var n=e.sdp;return Object.keys(r._reverseStreams||[]).forEach(function(e){var e=r._reverseStreams[e],t=r._streams[e.id];n=n.replace(new RegExp(t.id,"g"),e.id)}),new RTCSessionDescription({type:e.type,sdp:n})}},r.shimPeerConnection=function(n,e){!n.RTCPeerConnection&&n.webkitRTCPeerConnection&&(n.RTCPeerConnection=n.webkitRTCPeerConnection);n.RTCPeerConnection&&e.version<53&&["setLocalDescription","setRemoteDescription","addIceCandidate"].forEach(function(e){var t=n.RTCPeerConnection.prototype[e],r=c({},e,function(){return arguments[0]=new("addIceCandidate"===e?n.RTCIceCandidate:n.RTCSessionDescription)(arguments[0]),t.apply(this,arguments)});n.RTCPeerConnection.prototype[e]=r[e]})},r.fixNegotiationNeeded=function(e,r){a.wrapPeerConnectionEvent(e,"negotiationneeded",function(e){var t=e.target;if(!(r.version<72||t.getConfiguration&&"plan-b"===t.getConfiguration().sdpSemantics)||"stable"===t.signalingState)return e})};var a=function(e){{if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t}}(e("../utils.js"));function c(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function p(e){e.RTCPeerConnection.prototype.getLocalStreams=function(){var t=this;return this._shimmedLocalStreams=this._shimmedLocalStreams||{},Object.keys(this._shimmedLocalStreams).map(function(e){return t._shimmedLocalStreams[e][0]})};var n=e.RTCPeerConnection.prototype.addTrack,i=(e.RTCPeerConnection.prototype.addTrack=function(e,t){if(!t)return n.apply(this,arguments);this._shimmedLocalStreams=this._shimmedLocalStreams||{};var r=n.apply(this,arguments);return this._shimmedLocalStreams[t.id]?-1===this._shimmedLocalStreams[t.id].indexOf(r)&&this._shimmedLocalStreams[t.id].push(r):this._shimmedLocalStreams[t.id]=[t,r],r},e.RTCPeerConnection.prototype.addStream),t=(e.RTCPeerConnection.prototype.addStream=function(e){var r=this,t=(this._shimmedLocalStreams=this._shimmedLocalStreams||{},e.getTracks().forEach(function(t){if(r.getSenders().find(function(e){return e.track===t}))throw new DOMException("Track already exists.","InvalidAccessError")}),this.getSenders()),n=(i.apply(this,arguments),this.getSenders().filter(function(e){return-1===t.indexOf(e)}));this._shimmedLocalStreams[e.id]=[e].concat(n)},e.RTCPeerConnection.prototype.removeStream),o=(e.RTCPeerConnection.prototype.removeStream=function(e){return this._shimmedLocalStreams=this._shimmedLocalStreams||{},delete this._shimmedLocalStreams[e.id],t.apply(this,arguments)},e.RTCPeerConnection.prototype.removeTrack);e.RTCPeerConnection.prototype.removeTrack=function(r){var n=this;return this._shimmedLocalStreams=this._shimmedLocalStreams||{},r&&Object.keys(this._shimmedLocalStreams).forEach(function(e){var t=n._shimmedLocalStreams[e].indexOf(r);-1!==t&&n._shimmedLocalStreams[e].splice(t,1),1===n._shimmedLocalStreams[e].length&&delete n._shimmedLocalStreams[e]}),o.apply(this,arguments)}}},{"../utils.js":11,"./getdisplaymedia":4,"./getusermedia":5}],4:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.shimGetDisplayMedia=function(o,e){o.navigator.mediaDevices&&"getDisplayMedia"in o.navigator.mediaDevices||o.navigator.mediaDevices&&("function"!=typeof e?console.error("shimGetDisplayMedia: getSourceId argument is not a function"):o.navigator.mediaDevices.getDisplayMedia=function(i){return e(i).then(function(e){var t=i.video&&i.video.width,r=i.video&&i.video.height,n=i.video&&i.video.frameRate;return i.video={mandatory:{chromeMediaSource:"desktop",chromeMediaSourceId:e,maxFrameRate:n||3}},t&&(i.video.mandatory.maxWidth=t),r&&(i.video.mandatory.maxHeight=r),o.navigator.mediaDevices.getUserMedia(i)})})}},{}],5:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0});var c="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e};r.shimGetUserMedia=function(e,t){var a,n,i,r,s=e&&e.navigator;s.mediaDevices&&(a=function(i){if("object"!==(void 0===i?"undefined":c(i))||i.mandatory||i.optional)return i;var o={};return Object.keys(i).forEach(function(t){var r,n,e;"require"!==t&&"advanced"!==t&&"mediaSource"!==t&&(void 0!==(r="object"===c(i[t])?i[t]:{ideal:i[t]}).exact&&"number"==typeof r.exact&&(r.min=r.max=r.exact),n=function(e,t){return e?e+t.charAt(0).toUpperCase()+t.slice(1):"deviceId"===t?"sourceId":t},void 0!==r.ideal&&(o.optional=o.optional||[],e={},"number"==typeof r.ideal?(e[n("min",t)]=r.ideal,o.optional.push(e),(e={})[n("max",t)]=r.ideal):e[n("",t)]=r.ideal,o.optional.push(e)),void 0!==r.exact&&"number"!=typeof r.exact?(o.mandatory=o.mandatory||{},o.mandatory[n("",t)]=r.exact):["min","max"].forEach(function(e){void 0!==r[e]&&(o.mandatory=o.mandatory||{},o.mandatory[n(e,t)]=r[e])}))}),i.advanced&&(o.optional=(o.optional||[]).concat(i.advanced)),o},n=function(r,n){if(61<=t.version)return n(r);if((r=JSON.parse(JSON.stringify(r)))&&"object"===c(r.audio)&&((e=function(e,t,r){t in e&&!(r in e)&&(e[r]=e[t],delete e[t])})((r=JSON.parse(JSON.stringify(r))).audio,"autoGainControl","googAutoGainControl"),e(r.audio,"noiseSuppression","googNoiseSuppression"),r.audio=a(r.audio)),r&&"object"===c(r.video)){var i=(i=r.video.facingMode)&&("object"===(void 0===i?"undefined":c(i))?i:{ideal:i}),e=t.version<66;if(i&&("user"===i.exact||"environment"===i.exact||"user"===i.ideal||"environment"===i.ideal)&&(!s.mediaDevices.getSupportedConstraints||!s.mediaDevices.getSupportedConstraints().facingMode||e)){delete r.video.facingMode;var o=void 0;if("environment"===i.exact||"environment"===i.ideal?o=["back","rear"]:"user"!==i.exact&&"user"!==i.ideal||(o=["front"]),o)return s.mediaDevices.enumerateDevices().then(function(e){var t=(e=e.filter(function(e){return"videoinput"===e.kind})).find(function(t){return o.some(function(e){return t.label.toLowerCase().includes(e)})});return(t=!t&&e.length&&o.includes("back")?e[e.length-1]:t)&&(r.video.deviceId=i.exact?{exact:t.deviceId}:{ideal:t.deviceId}),r.video=a(r.video),p("chrome: "+JSON.stringify(r)),n(r)})}r.video=a(r.video)}return p("chrome: "+JSON.stringify(r)),n(r)},i=function(e){return 64<=t.version?e:{name:{PermissionDeniedError:"NotAllowedError",PermissionDismissedError:"NotAllowedError",InvalidStateError:"NotAllowedError",DevicesNotFoundError:"NotFoundError",ConstraintNotSatisfiedError:"OverconstrainedError",TrackStartError:"NotReadableError",MediaDeviceFailedDueToShutdown:"NotAllowedError",MediaDeviceKillSwitchOn:"NotAllowedError",TabCaptureError:"AbortError",ScreenCaptureError:"AbortError",DeviceCaptureError:"AbortError"}[e.name]||e.name,message:e.message,constraint:e.constraint||e.constraintName,toString:function(){return this.name+(this.message&&": ")+this.message}}},s.getUserMedia=function(e,t,r){n(e,function(e){s.webkitGetUserMedia(e,t,function(e){r&&r(i(e))})})}.bind(s),s.mediaDevices.getUserMedia&&(r=s.mediaDevices.getUserMedia.bind(s.mediaDevices),s.mediaDevices.getUserMedia=function(e){return n(e,function(t){return r(t).then(function(e){if(t.audio&&!e.getAudioTracks().length||t.video&&!e.getVideoTracks().length)throw e.getTracks().forEach(function(e){e.stop()}),new DOMException("","NotFoundError");return e},function(e){return Promise.reject(i(e))})})}))};var p=function(e){{if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t}}(e("../utils.js")).log},{"../utils.js":11}],6:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0});var o="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},r=(r.shimRTCIceCandidate=function(t){var i;!t.RTCIceCandidate||t.RTCIceCandidate&&"foundation"in t.RTCIceCandidate.prototype||(i=t.RTCIceCandidate,t.RTCIceCandidate=function(e){var t,r,n;return"object"===(void 0===e?"undefined":o(e))&&e.candidate&&0===e.candidate.indexOf("a=")&&((e=JSON.parse(JSON.stringify(e))).candidate=e.candidate.substr(2)),e.candidate&&e.candidate.length?(t=new i(e),r=s.default.parseCandidate(e.candidate),(n=Object.assign(t,r)).toJSON=function(){return{candidate:n.candidate,sdpMid:n.sdpMid,sdpMLineIndex:n.sdpMLineIndex,usernameFragment:n.usernameFragment}},n):new i(e)},t.RTCIceCandidate.prototype=i.prototype,n.wrapPeerConnectionEvent(t,"icecandidate",function(e){return e.candidate&&Object.defineProperty(e,"candidate",{value:new t.RTCIceCandidate(e.candidate),writable:"false"}),e}))},r.shimRTCIceCandidateRelayProtocol=function(e){!e.RTCIceCandidate||e.RTCIceCandidate&&"relayProtocol"in e.RTCIceCandidate.prototype||n.wrapPeerConnectionEvent(e,"icecandidate",function(e){var t;return e.candidate&&"relay"===(t=s.default.parseCandidate(e.candidate.candidate)).type&&(e.candidate.relayProtocol={0:"tls",1:"tcp",2:"udp"}[t.priority>>24]),e})},r.shimMaxMessageSize=function(e,o){var a;e.RTCPeerConnection&&("sctp"in e.RTCPeerConnection.prototype||Object.defineProperty(e.RTCPeerConnection.prototype,"sctp",{get:function(){return void 0===this._sctp?null:this._sctp}}),a=e.RTCPeerConnection.prototype.setRemoteDescription,e.RTCPeerConnection.prototype.setRemoteDescription=function(){var e,t,r,n,i;return this._sctp=null,"chrome"===o.browser&&76<=o.version&&"plan-b"===this.getConfiguration().sdpSemantics&&Object.defineProperty(this,"sctp",{get:function(){return void 0===this._sctp?null:this._sctp},enumerable:!0,configurable:!0}),function(e){if(!e||!e.sdp)return!1;e=s.default.splitSections(e.sdp);return e.shift(),e.some(function(e){e=s.default.parseMLine(e);return e&&"application"===e.kind&&-1!==e.protocol.indexOf("SCTP")})}(arguments[0])&&(t=function(e){e=e.sdp.match(/mozilla...THIS_IS_SDPARTA-(\d+)/);if(null===e||e.length<2)return-1;e=parseInt(e[1],10);return e!=e?-1:e}(arguments[0]),n=t,i=65536,n=i="firefox"===o.browser?o.version<57?-1===n?16384:2147483637:o.version<60?57===o.version?65535:65536:2147483637:i,i=arguments[0],t=t,r=65536,"firefox"===o.browser&&57===o.version&&(r=65535),0<(i=s.default.matchPrefix(i.sdp,"a=max-message-size:")).length?r=parseInt(i[0].substr(19),10):"firefox"===o.browser&&-1!==t&&(r=2147483637),i=r,e=void 0,e=0===n&&0===i?Number.POSITIVE_INFINITY:0===n||0===i?Math.max(n,i):Math.min(n,i),t={},Object.defineProperty(t,"maxMessageSize",{get:function(){return e}}),this._sctp=t),a.apply(this,arguments)})},r.shimSendThrowTypeError=function(e){var t;function r(t,r){var n=t.send;t.send=function(){var e=arguments[0],e=e.length||e.size||e.byteLength;if("open"===t.readyState&&r.sctp&&e>r.sctp.maxMessageSize)throw new TypeError("Message too large (can send a maximum of "+r.sctp.maxMessageSize+" bytes)");return n.apply(t,arguments)}}e.RTCPeerConnection&&"createDataChannel"in e.RTCPeerConnection.prototype&&(t=e.RTCPeerConnection.prototype.createDataChannel,e.RTCPeerConnection.prototype.createDataChannel=function(){var e=t.apply(this,arguments);return r(e,this),e},n.wrapPeerConnectionEvent(e,"datachannel",function(e){return r(e.channel,e.target),e}))},r.shimConnectionState=function(e){var r;!e.RTCPeerConnection||"connectionState"in e.RTCPeerConnection.prototype||(r=e.RTCPeerConnection.prototype,Object.defineProperty(r,"connectionState",{get:function(){return{completed:"connected",checking:"connecting"}[this.iceConnectionState]||this.iceConnectionState},enumerable:!0,configurable:!0}),Object.defineProperty(r,"onconnectionstatechange",{get:function(){return this._onconnectionstatechange||null},set:function(e){this._onconnectionstatechange&&(this.removeEventListener("connectionstatechange",this._onconnectionstatechange),delete this._onconnectionstatechange),e&&this.addEventListener("connectionstatechange",this._onconnectionstatechange=e)},enumerable:!0,configurable:!0}),["setLocalDescription","setRemoteDescription"].forEach(function(e){var t=r[e];r[e]=function(){return this._connectionstatechangepoly||(this._connectionstatechangepoly=function(e){var t,r=e.target;return r._lastConnectionState!==r.connectionState&&(r._lastConnectionState=r.connectionState,t=new Event("connectionstatechange",e),r.dispatchEvent(t)),e},this.addEventListener("iceconnectionstatechange",this._connectionstatechangepoly)),t.apply(this,arguments)}}))},r.removeExtmapAllowMixed=function(r,e){var n;!r.RTCPeerConnection||"chrome"===e.browser&&71<=e.version||"safari"===e.browser&&605<=e.version||(n=r.RTCPeerConnection.prototype.setRemoteDescription,r.RTCPeerConnection.prototype.setRemoteDescription=function(e){var t;return e&&e.sdp&&-1!==e.sdp.indexOf("\na=extmap-allow-mixed")&&(t=e.sdp.split("\n").filter(function(e){return"a=extmap-allow-mixed"!==e.trim()}).join("\n"),r.RTCSessionDescription&&e instanceof r.RTCSessionDescription?arguments[0]=new r.RTCSessionDescription({type:e.type,sdp:t}):e.sdp=t),n.apply(this,arguments)})},r.shimAddIceCandidateNullOrEmpty=function(e,t){var r;e.RTCPeerConnection&&e.RTCPeerConnection.prototype&&((r=e.RTCPeerConnection.prototype.addIceCandidate)&&0!==r.length&&(e.RTCPeerConnection.prototype.addIceCandidate=function(){return arguments[0]?("chrome"===t.browser&&t.version<78||"firefox"===t.browser&&t.version<68||"safari"===t.browser)&&arguments[0]&&""===arguments[0].candidate?Promise.resolve():r.apply(this,arguments):(arguments[1]&&arguments[1].apply(null),Promise.resolve())}))},r.shimParameterlessSetLocalDescription=function(e,t){var r;e.RTCPeerConnection&&e.RTCPeerConnection.prototype&&((r=e.RTCPeerConnection.prototype.setLocalDescription)&&0!==r.length&&(e.RTCPeerConnection.prototype.setLocalDescription=function(){var t=this,e=arguments[0]||{};if("object"!==(void 0===e?"undefined":o(e))||e.type&&e.sdp)return r.apply(this,arguments);if(!(e={type:e.type,sdp:e.sdp}).type)switch(this.signalingState){case"stable":case"have-local-offer":case"have-remote-pranswer":e.type="offer";break;default:e.type="answer"}return e.sdp||"offer"!==e.type&&"answer"!==e.type?r.apply(this,[e]):("offer"===e.type?this.createOffer:this.createAnswer).apply(this).then(function(e){return r.apply(t,[e])})}))},e("sdp")),s=(r=r)&&r.__esModule?r:{default:r},n=function(e){{if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t}}(e("./utils"))},{"./utils":11,sdp:12}],7:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.shimGetDisplayMedia=r.shimGetUserMedia=void 0;var a="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},n=e("./getusermedia"),i=(Object.defineProperty(r,"shimGetUserMedia",{enumerable:!0,get:function(){return n.shimGetUserMedia}}),e("./getdisplaymedia"));Object.defineProperty(r,"shimGetDisplayMedia",{enumerable:!0,get:function(){return i.shimGetDisplayMedia}}),r.shimOnTrack=function(e){"object"===(void 0===e?"undefined":a(e))&&e.RTCTrackEvent&&"receiver"in e.RTCTrackEvent.prototype&&!("transceiver"in e.RTCTrackEvent.prototype)&&Object.defineProperty(e.RTCTrackEvent.prototype,"transceiver",{get:function(){return{receiver:this.receiver}}})},r.shimPeerConnection=function(n,i){var o,r;"object"===(void 0===n?"undefined":a(n))&&(n.RTCPeerConnection||n.mozRTCPeerConnection)&&(!n.RTCPeerConnection&&n.mozRTCPeerConnection&&(n.RTCPeerConnection=n.mozRTCPeerConnection),i.version<53&&["setLocalDescription","setRemoteDescription","addIceCandidate"].forEach(function(e){var t=n.RTCPeerConnection.prototype[e],r=function(e,t,r){t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r;return e}({},e,function(){return arguments[0]=new("addIceCandidate"===e?n.RTCIceCandidate:n.RTCSessionDescription)(arguments[0]),t.apply(this,arguments)});n.RTCPeerConnection.prototype[e]=r[e]}),o={inboundrtp:"inbound-rtp",outboundrtp:"outbound-rtp",candidatepair:"candidate-pair",localcandidate:"local-candidate",remotecandidate:"remote-candidate"},r=n.RTCPeerConnection.prototype.getStats,n.RTCPeerConnection.prototype.getStats=function(){var e=Array.prototype.slice.call(arguments),t=e[0],n=e[1],e=e[2];return r.apply(this,[t||null]).then(function(r){if(i.version<53&&!n)try{r.forEach(function(e){e.type=o[e.type]||e.type})}catch(e){if("TypeError"!==e.name)throw e;r.forEach(function(e,t){r.set(t,Object.assign({},e,{type:o[e.type]||e.type}))})}return r}).then(n,e)})},r.shimSenderGetStats=function(e){var r,t;"object"===(void 0===e?"undefined":a(e))&&e.RTCPeerConnection&&e.RTCRtpSender&&(e.RTCRtpSender&&"getStats"in e.RTCRtpSender.prototype||((r=e.RTCPeerConnection.prototype.getSenders)&&(e.RTCPeerConnection.prototype.getSenders=function(){var t=this,e=r.apply(this,[]);return e.forEach(function(e){return e._pc=t}),e}),(t=e.RTCPeerConnection.prototype.addTrack)&&(e.RTCPeerConnection.prototype.addTrack=function(){var e=t.apply(this,arguments);return e._pc=this,e}),e.RTCRtpSender.prototype.getStats=function(){return this.track?this._pc.getStats(this.track):Promise.resolve(new Map)}))},r.shimReceiverGetStats=function(e){var r;"object"===(void 0===e?"undefined":a(e))&&e.RTCPeerConnection&&e.RTCRtpSender&&(e.RTCRtpSender&&"getStats"in e.RTCRtpReceiver.prototype||((r=e.RTCPeerConnection.prototype.getReceivers)&&(e.RTCPeerConnection.prototype.getReceivers=function(){var t=this,e=r.apply(this,[]);return e.forEach(function(e){return e._pc=t}),e}),o.wrapPeerConnectionEvent(e,"track",function(e){return e.receiver._pc=e.srcElement,e}),e.RTCRtpReceiver.prototype.getStats=function(){return this._pc.getStats(this.track)}))},r.shimRemoveStream=function(e){!e.RTCPeerConnection||"removeStream"in e.RTCPeerConnection.prototype||(e.RTCPeerConnection.prototype.removeStream=function(t){var r=this;o.deprecated("removeStream","removeTrack"),this.getSenders().forEach(function(e){e.track&&t.getTracks().includes(e.track)&&r.removeTrack(e)})})},r.shimRTCDataChannel=function(e){e.DataChannel&&!e.RTCDataChannel&&(e.RTCDataChannel=e.DataChannel)},r.shimAddTransceiver=function(e){var i;"object"!==(void 0===e?"undefined":a(e))||!e.RTCPeerConnection||(i=e.RTCPeerConnection.prototype.addTransceiver)&&(e.RTCPeerConnection.prototype.addTransceiver=function(){this.setParametersPromises=[];var e,t=arguments[1]&&arguments[1].sendEncodings,r=0<(t=[].concat(function(e){{if(Array.isArray(e)){for(var t=0,r=Array(e.length);t<e.length;t++)r[t]=e[t];return r}return Array.from(e)}}(t=void 0===t?[]:t))).length,n=(r&&t.forEach(function(e){if("rid"in e)if(!/^[a-z0-9]{0,16}$/i.test(e.rid))throw new TypeError("Invalid RID value provided.");if("scaleResolutionDownBy"in e&&!(1<=parseFloat(e.scaleResolutionDownBy)))throw new RangeError("scale_resolution_down_by must be >= 1.0");if("maxFramerate"in e&&!(0<=parseFloat(e.maxFramerate)))throw new RangeError("max_framerate must be >= 0.0")}),i.apply(this,arguments));return!r||"encodings"in(r=(e=n.sender).getParameters())&&(1!==r.encodings.length||0!==Object.keys(r.encodings[0]).length)||(r.encodings=t,e.sendEncodings=t,this.setParametersPromises.push(e.setParameters(r).then(function(){delete e.sendEncodings}).catch(function(){delete e.sendEncodings}))),n})},r.shimGetParameters=function(e){var t;"object"!==(void 0===e?"undefined":a(e))||!e.RTCRtpSender||(t=e.RTCRtpSender.prototype.getParameters)&&(e.RTCRtpSender.prototype.getParameters=function(){var e=t.apply(this,arguments);return"encodings"in e||(e.encodings=[].concat(this.sendEncodings||[{}])),e})},r.shimCreateOffer=function(e){var r;"object"===(void 0===e?"undefined":a(e))&&e.RTCPeerConnection&&(r=e.RTCPeerConnection.prototype.createOffer,e.RTCPeerConnection.prototype.createOffer=function(){var e=this,t=arguments;return this.setParametersPromises&&this.setParametersPromises.length?Promise.all(this.setParametersPromises).then(function(){return r.apply(e,t)}).finally(function(){e.setParametersPromises=[]}):r.apply(this,arguments)})},r.shimCreateAnswer=function(e){var r;"object"===(void 0===e?"undefined":a(e))&&e.RTCPeerConnection&&(r=e.RTCPeerConnection.prototype.createAnswer,e.RTCPeerConnection.prototype.createAnswer=function(){var e=this,t=arguments;return this.setParametersPromises&&this.setParametersPromises.length?Promise.all(this.setParametersPromises).then(function(){return r.apply(e,t)}).finally(function(){e.setParametersPromises=[]}):r.apply(this,arguments)})};var o=function(e){{if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t}}(e("../utils"))},{"../utils":11,"./getdisplaymedia":8,"./getusermedia":9}],8:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.shimGetDisplayMedia=function(t,r){t.navigator.mediaDevices&&"getDisplayMedia"in t.navigator.mediaDevices||t.navigator.mediaDevices&&(t.navigator.mediaDevices.getDisplayMedia=function(e){return e&&e.video?(!0===e.video?e.video={mediaSource:r}:e.video.mediaSource=r,t.navigator.mediaDevices.getUserMedia(e)):((e=new DOMException("getDisplayMedia without video constraints is undefined")).name="NotFoundError",e.code=8,Promise.reject(e))})}},{}],9:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0});var s="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e};r.shimGetUserMedia=function(e,t){var n=e&&e.navigator,e=e&&e.MediaStreamTrack;{var r,i,o,a;n.getUserMedia=function(e,t,r){c.deprecated("navigator.getUserMedia","navigator.mediaDevices.getUserMedia"),n.mediaDevices.getUserMedia(e).then(t,r)},55<t.version&&"autoGainControl"in n.mediaDevices.getSupportedConstraints()||(r=function(e,t,r){t in e&&!(r in e)&&(e[r]=e[t],delete e[t])},i=n.mediaDevices.getUserMedia.bind(n.mediaDevices),n.mediaDevices.getUserMedia=function(e){return"object"===(void 0===e?"undefined":s(e))&&"object"===s(e.audio)&&(e=JSON.parse(JSON.stringify(e)),r(e.audio,"autoGainControl","mozAutoGainControl"),r(e.audio,"noiseSuppression","mozNoiseSuppression")),i(e)},e&&e.prototype.getSettings&&(o=e.prototype.getSettings,e.prototype.getSettings=function(){var e=o.apply(this,arguments);return r(e,"mozAutoGainControl","autoGainControl"),r(e,"mozNoiseSuppression","noiseSuppression"),e}),e&&e.prototype.applyConstraints&&(a=e.prototype.applyConstraints,e.prototype.applyConstraints=function(e){return"audio"===this.kind&&"object"===(void 0===e?"undefined":s(e))&&(e=JSON.parse(JSON.stringify(e)),r(e,"autoGainControl","mozAutoGainControl"),r(e,"noiseSuppression","mozNoiseSuppression")),a.apply(this,[e])}))}};var c=function(e){{if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t}}(e("../utils"))},{"../utils":11}],10:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0});var c="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e};r.shimLocalStreamsAPI=function(e){var o;"object"===(void 0===e?"undefined":c(e))&&e.RTCPeerConnection&&("getLocalStreams"in e.RTCPeerConnection.prototype||(e.RTCPeerConnection.prototype.getLocalStreams=function(){return this._localStreams||(this._localStreams=[]),this._localStreams}),"addStream"in e.RTCPeerConnection.prototype||(o=e.RTCPeerConnection.prototype.addTrack,e.RTCPeerConnection.prototype.addStream=function(t){var r=this;this._localStreams||(this._localStreams=[]),this._localStreams.includes(t)||this._localStreams.push(t),t.getAudioTracks().forEach(function(e){return o.call(r,e,t)}),t.getVideoTracks().forEach(function(e){return o.call(r,e,t)})},e.RTCPeerConnection.prototype.addTrack=function(e){for(var t=this,r=arguments.length,n=Array(1<r?r-1:0),i=1;i<r;i++)n[i-1]=arguments[i];return n&&n.forEach(function(e){t._localStreams?t._localStreams.includes(e)||t._localStreams.push(e):t._localStreams=[e]}),o.apply(this,arguments)}),"removeStream"in e.RTCPeerConnection.prototype||(e.RTCPeerConnection.prototype.removeStream=function(e){var t,r=this,n=(this._localStreams||(this._localStreams=[]),this._localStreams.indexOf(e));-1!==n&&(this._localStreams.splice(n,1),t=e.getTracks(),this.getSenders().forEach(function(e){t.includes(e.track)&&r.removeTrack(e)}))}))},r.shimRemoteStreamsAPI=function(e){var t;"object"===(void 0===e?"undefined":c(e))&&e.RTCPeerConnection&&("getRemoteStreams"in e.RTCPeerConnection.prototype||(e.RTCPeerConnection.prototype.getRemoteStreams=function(){return this._remoteStreams||[]}),"onaddstream"in e.RTCPeerConnection.prototype||(Object.defineProperty(e.RTCPeerConnection.prototype,"onaddstream",{get:function(){return this._onaddstream},set:function(e){var r=this;this._onaddstream&&(this.removeEventListener("addstream",this._onaddstream),this.removeEventListener("track",this._onaddstreampoly)),this.addEventListener("addstream",this._onaddstream=e),this.addEventListener("track",this._onaddstreampoly=function(e){e.streams.forEach(function(e){var t;r._remoteStreams||(r._remoteStreams=[]),r._remoteStreams.includes(e)||(r._remoteStreams.push(e),(t=new Event("addstream")).stream=e,r.dispatchEvent(t))})})}}),t=e.RTCPeerConnection.prototype.setRemoteDescription,e.RTCPeerConnection.prototype.setRemoteDescription=function(){var r=this;return this._onaddstreampoly||this.addEventListener("track",this._onaddstreampoly=function(e){e.streams.forEach(function(e){var t;r._remoteStreams||(r._remoteStreams=[]),0<=r._remoteStreams.indexOf(e)||(r._remoteStreams.push(e),(t=new Event("addstream")).stream=e,r.dispatchEvent(t))})}),t.apply(r,arguments)}))},r.shimCallbacksAPI=function(e){var n,i,o,a,s,t;"object"===(void 0===e?"undefined":c(e))&&e.RTCPeerConnection&&(e=e.RTCPeerConnection.prototype,n=e.createOffer,i=e.createAnswer,o=e.setLocalDescription,a=e.setRemoteDescription,s=e.addIceCandidate,e.createOffer=function(e,t){var r=n.apply(this,[2<=arguments.length?arguments[2]:e]);return t?(r.then(e,t),Promise.resolve()):r},e.createAnswer=function(e,t){var r=i.apply(this,[2<=arguments.length?arguments[2]:e]);return t?(r.then(e,t),Promise.resolve()):r},t=function(e,t,r){e=o.apply(this,[e]);return r?(e.then(t,r),Promise.resolve()):e},e.setLocalDescription=t,t=function(e,t,r){e=a.apply(this,[e]);return r?(e.then(t,r),Promise.resolve()):e},e.setRemoteDescription=t,t=function(e,t,r){e=s.apply(this,[e]);return r?(e.then(t,r),Promise.resolve()):e},e.addIceCandidate=t)},r.shimGetUserMedia=function(e){var n=e&&e.navigator;{var t;n.mediaDevices&&n.mediaDevices.getUserMedia&&(e=n.mediaDevices,t=e.getUserMedia.bind(e),n.mediaDevices.getUserMedia=function(e){return t(i(e))})}!n.getUserMedia&&n.mediaDevices&&n.mediaDevices.getUserMedia&&(n.getUserMedia=function(e,t,r){n.mediaDevices.getUserMedia(e).then(t,r)}.bind(n))},r.shimConstraints=i,r.shimRTCIceServerUrls=function(e){var o;e.RTCPeerConnection&&(o=e.RTCPeerConnection,e.RTCPeerConnection=function(e,t){if(e&&e.iceServers){for(var r=[],n=0;n<e.iceServers.length;n++){var i=e.iceServers[n];!i.hasOwnProperty("urls")&&i.hasOwnProperty("url")?(a.deprecated("RTCIceServer.url","RTCIceServer.urls"),(i=JSON.parse(JSON.stringify(i))).urls=i.url,delete i.url,r.push(i)):r.push(e.iceServers[n])}e.iceServers=r}return new o(e,t)},e.RTCPeerConnection.prototype=o.prototype,"generateCertificate"in o&&Object.defineProperty(e.RTCPeerConnection,"generateCertificate",{get:function(){return o.generateCertificate}}))},r.shimTrackEventTransceiver=function(e){"object"===(void 0===e?"undefined":c(e))&&e.RTCTrackEvent&&"receiver"in e.RTCTrackEvent.prototype&&!("transceiver"in e.RTCTrackEvent.prototype)&&Object.defineProperty(e.RTCTrackEvent.prototype,"transceiver",{get:function(){return{receiver:this.receiver}}})},r.shimCreateOfferLegacy=function(e){var r=e.RTCPeerConnection.prototype.createOffer;e.RTCPeerConnection.prototype.createOffer=function(e){var t;return e&&(void 0!==e.offerToReceiveAudio&&(e.offerToReceiveAudio=!!e.offerToReceiveAudio),t=this.getTransceivers().find(function(e){return"audio"===e.receiver.track.kind}),!1===e.offerToReceiveAudio&&t?"sendrecv"===t.direction?t.setDirection?t.setDirection("sendonly"):t.direction="sendonly":"recvonly"===t.direction&&(t.setDirection?t.setDirection("inactive"):t.direction="inactive"):!0!==e.offerToReceiveAudio||t||this.addTransceiver("audio",{direction:"recvonly"}),void 0!==e.offerToReceiveVideo&&(e.offerToReceiveVideo=!!e.offerToReceiveVideo),t=this.getTransceivers().find(function(e){return"video"===e.receiver.track.kind}),!1===e.offerToReceiveVideo&&t?"sendrecv"===t.direction?t.setDirection?t.setDirection("sendonly"):t.direction="sendonly":"recvonly"===t.direction&&(t.setDirection?t.setDirection("inactive"):t.direction="inactive"):!0!==e.offerToReceiveVideo||t||this.addTransceiver("video",{direction:"recvonly"})),r.apply(this,arguments)}},r.shimAudioContext=function(e){"object"!==(void 0===e?"undefined":c(e))||e.AudioContext||(e.AudioContext=e.webkitAudioContext)};var a=function(e){{if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t}}(e("../utils"));function i(e){return e&&void 0!==e.video?Object.assign({},e,{video:a.compactObject(e.video)}):e}},{"../utils":11}],11:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0});var n="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e};function a(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}r.extractVersion=s,r.wrapPeerConnectionEvent=function(e,n,i){var o,a;e.RTCPeerConnection&&(e=e.RTCPeerConnection.prototype,o=e.addEventListener,e.addEventListener=function(e,t){if(e!==n)return o.apply(this,arguments);function r(e){(e=i(e))&&(t.handleEvent?t.handleEvent(e):t(e))}return this._eventMap=this._eventMap||{},this._eventMap[n]||(this._eventMap[n]=new Map),this._eventMap[n].set(t,r),o.apply(this,[e,r])},a=e.removeEventListener,e.removeEventListener=function(e,t){if(e!==n||!this._eventMap||!this._eventMap[n])return a.apply(this,arguments);if(!this._eventMap[n].has(t))return a.apply(this,arguments);var r=this._eventMap[n].get(t);return this._eventMap[n].delete(t),0===this._eventMap[n].size&&delete this._eventMap[n],0===Object.keys(this._eventMap).length&&delete this._eventMap,a.apply(this,[e,r])},Object.defineProperty(e,"on"+n,{get:function(){return this["_on"+n]},set:function(e){this["_on"+n]&&(this.removeEventListener(n,this["_on"+n]),delete this["_on"+n]),e&&this.addEventListener(n,this["_on"+n]=e)},enumerable:!0,configurable:!0}))},r.disableLog=function(e){return"boolean"==typeof e?(i=e)?"adapter.js logging disabled":"adapter.js logging enabled":new Error("Argument type: "+(void 0===e?"undefined":n(e))+". Please use a boolean.")},r.disableWarnings=function(e){return"boolean"==typeof e?(o=!e,"adapter.js deprecation warnings "+(e?"disabled":"enabled")):new Error("Argument type: "+(void 0===e?"undefined":n(e))+". Please use a boolean.")},r.log=function(){"object"!==("undefined"==typeof window?"undefined":n(window))||i||"undefined"!=typeof console&&"function"==typeof console.log&&console.log.apply(console,arguments)},r.deprecated=function(e,t){o&&console.warn(e+" is deprecated, please use "+t+" instead.")},r.detectBrowser=function(e){var t={browser:null,version:null};if(void 0===e||!e.navigator)return t.browser="Not a browser.",t;var r=e.navigator;if(r.mozGetUserMedia)t.browser="firefox",t.version=s(r.userAgent,/Firefox\/(\d+)\./,1);else if(r.webkitGetUserMedia||!1===e.isSecureContext&&e.webkitRTCPeerConnection)t.browser="chrome",t.version=s(r.userAgent,/Chrom(e|ium)\/(\d+)\./,2);else{if(!e.RTCPeerConnection||!r.userAgent.match(/AppleWebKit\/(\d+)\./))return t.browser="Not a supported browser.",t;t.browser="safari",t.version=s(r.userAgent,/AppleWebKit\/(\d+)\./,1),t.supportsUnifiedPlan=e.RTCRtpTransceiver&&"currentDirection"in e.RTCRtpTransceiver.prototype}return t},r.compactObject=function i(o){if(!c(o))return o;return Object.keys(o).reduce(function(e,t){var r=c(o[t]),n=r?i(o[t]):o[t],r=r&&!Object.keys(n).length;return void 0===n||r?e:Object.assign(e,a({},t,n))},{})},r.walkStats=p,r.filterStats=function(r,t,e){var n=e?"outbound-rtp":"inbound-rtp",i=new Map;if(null===t)return i;var o=[];return r.forEach(function(e){"track"===e.type&&e.trackIdentifier===t.id&&o.push(e)}),o.forEach(function(t){r.forEach(function(e){e.type===n&&e.trackId===t.id&&p(r,e,i)})}),i};var i=!0,o=!0;function s(e,t,r){e=e.match(t);return e&&e.length>=r&&parseInt(e[r],10)}function c(e){return"[object Object]"===Object.prototype.toString.call(e)}function p(t,r,n){r&&!n.has(r.id)&&(n.set(r.id,r),Object.keys(r).forEach(function(e){e.endsWith("Id")?p(t,t.get(r[e]),n):e.endsWith("Ids")&&r[e].forEach(function(e){p(t,t.get(e),n)})}))}},{}],12:[function(e,t,r){"use strict";var n="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},p={generateIdentifier:function(){return Math.random().toString(36).substr(2,10)}};p.localCName=p.generateIdentifier(),p.splitLines=function(e){return e.trim().split("\n").map(function(e){return e.trim()})},p.splitSections=function(e){return e.split("\nm=").map(function(e,t){return(0<t?"m="+e:e).trim()+"\r\n"})},p.getDescription=function(e){e=p.splitSections(e);return e&&e[0]},p.getMediaSections=function(e){e=p.splitSections(e);return e.shift(),e},p.matchPrefix=function(e,t){return p.splitLines(e).filter(function(e){return 0===e.indexOf(t)})},p.parseCandidate=function(e){for(var t=void 0,r={foundation:(t=(0===e.indexOf("a=candidate:")?e.substring(12):e.substring(10)).split(" "))[0],component:{1:"rtp",2:"rtcp"}[t[1]]||t[1],protocol:t[2].toLowerCase(),priority:parseInt(t[3],10),ip:t[4],address:t[4],port:parseInt(t[5],10),type:t[7]},n=8;n<t.length;n+=2)switch(t[n]){case"raddr":r.relatedAddress=t[n+1];break;case"rport":r.relatedPort=parseInt(t[n+1],10);break;case"tcptype":r.tcpType=t[n+1];break;case"ufrag":r.ufrag=t[n+1],r.usernameFragment=t[n+1];break;default:void 0===r[t[n]]&&(r[t[n]]=t[n+1])}return r},p.writeCandidate=function(e){var t=[],r=(t.push(e.foundation),e.component),r=("rtp"===r?t.push(1):"rtcp"===r?t.push(2):t.push(r),t.push(e.protocol.toUpperCase()),t.push(e.priority),t.push(e.address||e.ip),t.push(e.port),e.type);return t.push("typ"),t.push(r),"host"!==r&&e.relatedAddress&&e.relatedPort&&(t.push("raddr"),t.push(e.relatedAddress),t.push("rport"),t.push(e.relatedPort)),e.tcpType&&"tcp"===e.protocol.toLowerCase()&&(t.push("tcptype"),t.push(e.tcpType)),(e.usernameFragment||e.ufrag)&&(t.push("ufrag"),t.push(e.usernameFragment||e.ufrag)),"candidate:"+t.join(" ")},p.parseIceOptions=function(e){return e.substr(14).split(" ")},p.parseRtpMap=function(e){var e=e.substr(9).split(" "),t={payloadType:parseInt(e.shift(),10)},e=e[0].split("/");return t.name=e[0],t.clockRate=parseInt(e[1],10),t.channels=3===e.length?parseInt(e[2],10):1,t.numChannels=t.channels,t},p.writeRtpMap=function(e){var t=e.payloadType,r=(void 0!==e.preferredPayloadType&&(t=e.preferredPayloadType),e.channels||e.numChannels||1);return"a=rtpmap:"+t+" "+e.name+"/"+e.clockRate+(1!==r?"/"+r:"")+"\r\n"},p.parseExtmap=function(e){e=e.substr(9).split(" ");return{id:parseInt(e[0],10),direction:0<e[0].indexOf("/")?e[0].split("/")[1]:"sendrecv",uri:e[1]}},p.writeExtmap=function(e){return"a=extmap:"+(e.id||e.preferredId)+(e.direction&&"sendrecv"!==e.direction?"/"+e.direction:"")+" "+e.uri+"\r\n"},p.parseFmtp=function(e){for(var t={},r=void 0,n=e.substr(e.indexOf(" ")+1).split(";"),i=0;i<n.length;i++)t[(r=n[i].trim().split("="))[0].trim()]=r[1];return t},p.writeFmtp=function(t){var r,e="",n=t.payloadType;return void 0!==t.preferredPayloadType&&(n=t.preferredPayloadType),t.parameters&&Object.keys(t.parameters).length&&(r=[],Object.keys(t.parameters).forEach(function(e){void 0!==t.parameters[e]?r.push(e+"="+t.parameters[e]):r.push(e)}),e+="a=fmtp:"+n+" "+r.join(";")+"\r\n"),e},p.parseRtcpFb=function(e){e=e.substr(e.indexOf(" ")+1).split(" ");return{type:e.shift(),parameter:e.join(" ")}},p.writeRtcpFb=function(e){var t="",r=e.payloadType;return void 0!==e.preferredPayloadType&&(r=e.preferredPayloadType),e.rtcpFeedback&&e.rtcpFeedback.length&&e.rtcpFeedback.forEach(function(e){t+="a=rtcp-fb:"+r+" "+e.type+(e.parameter&&e.parameter.length?" "+e.parameter:"")+"\r\n"}),t},p.parseSsrcMedia=function(e){var t=e.indexOf(" "),r={ssrc:parseInt(e.substr(7,t-7),10)},n=e.indexOf(":",t);return-1<n?(r.attribute=e.substr(t+1,n-t-1),r.value=e.substr(n+1)):r.attribute=e.substr(t+1),r},p.parseSsrcGroup=function(e){e=e.substr(13).split(" ");return{semantics:e.shift(),ssrcs:e.map(function(e){return parseInt(e,10)})}},p.getMid=function(e){e=p.matchPrefix(e,"a=mid:")[0];if(e)return e.substr(6)},p.parseFingerprint=function(e){e=e.substr(14).split(" ");return{algorithm:e[0].toLowerCase(),value:e[1].toUpperCase()}},p.getDtlsParameters=function(e,t){return{role:"auto",fingerprints:p.matchPrefix(e+t,"a=fingerprint:").map(p.parseFingerprint)}},p.writeDtlsParameters=function(e,t){var r="a=setup:"+t+"\r\n";return e.fingerprints.forEach(function(e){r+="a=fingerprint:"+e.algorithm+" "+e.value+"\r\n"}),r},p.parseCryptoLine=function(e){e=e.substr(9).split(" ");return{tag:parseInt(e[0],10),cryptoSuite:e[1],keyParams:e[2],sessionParams:e.slice(3)}},p.writeCryptoLine=function(e){return"a=crypto:"+e.tag+" "+e.cryptoSuite+" "+("object"===n(e.keyParams)?p.writeCryptoKeyParams(e.keyParams):e.keyParams)+(e.sessionParams?" "+e.sessionParams.join(" "):"")+"\r\n"},p.parseCryptoKeyParams=function(e){if(0!==e.indexOf("inline:"))return null;e=e.substr(7).split("|");return{keyMethod:"inline",keySalt:e[0],lifeTime:e[1],mkiValue:e[2]?e[2].split(":")[0]:void 0,mkiLength:e[2]?e[2].split(":")[1]:void 0}},p.writeCryptoKeyParams=function(e){return e.keyMethod+":"+e.keySalt+(e.lifeTime?"|"+e.lifeTime:"")+(e.mkiValue&&e.mkiLength?"|"+e.mkiValue+":"+e.mkiLength:"")},p.getCryptoParameters=function(e,t){return p.matchPrefix(e+t,"a=crypto:").map(p.parseCryptoLine)},p.getIceParameters=function(e,t){var r=p.matchPrefix(e+t,"a=ice-ufrag:")[0],e=p.matchPrefix(e+t,"a=ice-pwd:")[0];return r&&e?{usernameFragment:r.substr(12),password:e.substr(10)}:null},p.writeIceParameters=function(e){var t="a=ice-ufrag:"+e.usernameFragment+"\r\na=ice-pwd:"+e.password+"\r\n";return e.iceLite&&(t+="a=ice-lite\r\n"),t},p.parseRtpParameters=function(e){for(var t={codecs:[],headerExtensions:[],fecMechanisms:[],rtcp:[]},r=p.splitLines(e)[0].split(" "),n=3;n<r.length;n++){var i=r[n],o=p.matchPrefix(e,"a=rtpmap:"+i+" ")[0];if(o){var a=p.parseRtpMap(o),o=p.matchPrefix(e,"a=fmtp:"+i+" ");switch(a.parameters=o.length?p.parseFmtp(o[0]):{},a.rtcpFeedback=p.matchPrefix(e,"a=rtcp-fb:"+i+" ").map(p.parseRtcpFb),t.codecs.push(a),a.name.toUpperCase()){case"RED":case"ULPFEC":t.fecMechanisms.push(a.name.toUpperCase())}}}return p.matchPrefix(e,"a=extmap:").forEach(function(e){t.headerExtensions.push(p.parseExtmap(e))}),t},p.writeRtpDescription=function(e,t){var r="",n=(r=(r=(r=(r+="m="+e+" ")+(0<t.codecs.length?"9":"0")+" UDP/TLS/RTP/SAVPF ")+(t.codecs.map(function(e){return void 0!==e.preferredPayloadType?e.preferredPayloadType:e.payloadType}).join(" ")+"\r\n"))+"c=IN IP4 0.0.0.0\r\n"+"a=rtcp:9 IN IP4 0.0.0.0\r\n",t.codecs.forEach(function(e){r=(r=(r+=p.writeRtpMap(e))+p.writeFmtp(e))+p.writeRtcpFb(e)}),0);return t.codecs.forEach(function(e){e.maxptime>n&&(n=e.maxptime)}),0<n&&(r+="a=maxptime:"+n+"\r\n"),t.headerExtensions&&t.headerExtensions.forEach(function(e){r+=p.writeExtmap(e)}),r},p.parseRtpEncodingParameters=function(e){var t=[],r=p.parseRtpParameters(e),n=-1!==r.fecMechanisms.indexOf("RED"),i=-1!==r.fecMechanisms.indexOf("ULPFEC"),o=p.matchPrefix(e,"a=ssrc:").map(function(e){return p.parseSsrcMedia(e)}).filter(function(e){return"cname"===e.attribute}),a=0<o.length&&o[0].ssrc,s=void 0,o=p.matchPrefix(e,"a=ssrc-group:FID").map(function(e){return e.substr(17).split(" ").map(function(e){return parseInt(e,10)})}),c=(0<o.length&&1<o[0].length&&o[0][0]===a&&(s=o[0][1]),r.codecs.forEach(function(e){"RTX"===e.name.toUpperCase()&&e.parameters.apt&&(e={ssrc:a,codecPayloadType:parseInt(e.parameters.apt,10)},a&&s&&(e.rtx={ssrc:s}),t.push(e),n&&((e=JSON.parse(JSON.stringify(e))).fec={ssrc:a,mechanism:i?"red+ulpfec":"red"},t.push(e)))}),0===t.length&&a&&t.push({ssrc:a}),p.matchPrefix(e,"b="));return c.length&&(c=0===c[0].indexOf("b=TIAS:")?parseInt(c[0].substr(7),10):0===c[0].indexOf("b=AS:")?1e3*parseInt(c[0].substr(5),10)*.95-16e3:void 0,t.forEach(function(e){e.maxBitrate=c})),t},p.parseRtcpParameters=function(e){var t={},r=p.matchPrefix(e,"a=ssrc:").map(function(e){return p.parseSsrcMedia(e)}).filter(function(e){return"cname"===e.attribute})[0],r=(r&&(t.cname=r.value,t.ssrc=r.ssrc),p.matchPrefix(e,"a=rtcp-rsize")),r=(t.reducedSize=0<r.length,t.compound=0===r.length,p.matchPrefix(e,"a=rtcp-mux"));return t.mux=0<r.length,t},p.writeRtcpParameters=function(e){var t="";return e.reducedSize&&(t+="a=rtcp-rsize\r\n"),e.mux&&(t+="a=rtcp-mux\r\n"),void 0!==e.ssrc&&e.cname&&(t+="a=ssrc:"+e.ssrc+" cname:"+e.cname+"\r\n"),t},p.parseMsid=function(e){var t=void 0,r=p.matchPrefix(e,"a=msid:");if(1===r.length)return{stream:(t=r[0].substr(7).split(" "))[0],track:t[1]};r=p.matchPrefix(e,"a=ssrc:").map(function(e){return p.parseSsrcMedia(e)}).filter(function(e){return"msid"===e.attribute});return 0<r.length?{stream:(t=r[0].value.split(" "))[0],track:t[1]}:void 0},p.parseSctpDescription=function(e){var t=p.parseMLine(e),r=p.matchPrefix(e,"a=max-message-size:"),n=void 0,r=(0<r.length&&(n=parseInt(r[0].substr(19),10)),isNaN(n)&&(n=65536),p.matchPrefix(e,"a=sctp-port:"));if(0<r.length)return{port:parseInt(r[0].substr(12),10),protocol:t.fmt,maxMessageSize:n};r=p.matchPrefix(e,"a=sctpmap:");return 0<r.length?(t=r[0].substr(10).split(" "),{port:parseInt(t[0],10),protocol:t[1],maxMessageSize:n}):void 0},p.writeSctpDescription=function(e,t){var r=[],r="DTLS/SCTP"!==e.protocol?["m="+e.kind+" 9 "+e.protocol+" "+t.protocol+"\r\n","c=IN IP4 0.0.0.0\r\n","a=sctp-port:"+t.port+"\r\n"]:["m="+e.kind+" 9 "+e.protocol+" "+t.port+"\r\n","c=IN IP4 0.0.0.0\r\n","a=sctpmap:"+t.port+" "+t.protocol+" 65535\r\n"];return void 0!==t.maxMessageSize&&r.push("a=max-message-size:"+t.maxMessageSize+"\r\n"),r.join("")},p.generateSessionId=function(){return Math.random().toString().substr(2,21)},p.writeSessionBoilerplate=function(e,t,r){t=void 0!==t?t:2;return"v=0\r\no="+(r||"thisisadapterortc")+" "+(e||p.generateSessionId())+" "+t+" IN IP4 127.0.0.1\r\ns=-\r\nt=0 0\r\n"},p.getDirection=function(e,t){for(var r=p.splitLines(e),n=0;n<r.length;n++)switch(r[n]){case"a=sendrecv":case"a=sendonly":case"a=recvonly":case"a=inactive":return r[n].substr(2)}return t?p.getDirection(t):"sendrecv"},p.getKind=function(e){return p.splitLines(e)[0].split(" ")[0].substr(2)},p.isRejected=function(e){return"0"===e.split(" ",2)[1]},p.parseMLine=function(e){e=p.splitLines(e)[0].substr(2).split(" ");return{kind:e[0],port:parseInt(e[1],10),protocol:e[2],fmt:e.slice(3).join(" ")}},p.parseOLine=function(e){e=p.matchPrefix(e,"o=")[0].substr(2).split(" ");return{username:e[0],sessionId:e[1],sessionVersion:parseInt(e[2],10),netType:e[3],addressType:e[4],address:e[5]}},p.isValidSDP=function(e){if("string"!=typeof e||0===e.length)return!1;for(var t=p.splitLines(e),r=0;r<t.length;r++)if(t[r].length<2||"="!==t[r].charAt(1))return!1;return!0},"object"===(void 0===t?"undefined":n(t))&&(t.exports=p)},{}]},{},[1])(1)});}(undefined);
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else {
		var a = factory();
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./build/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../../../core/build/core/src/common/HiveEventsBinder.js":
/*!********************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/common/HiveEventsBinder.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.HiveEventsBinder = void 0;
var HashMap = __webpack_require__(/*! @hivestreaming/collections/map */ "../../../node_modules/@hivestreaming/collections/map.js");
var HiveEventsBinder = /** @class */ (function () {
    function HiveEventsBinder(plugin, target, addMethod, removeMethod) {
        this.registeredEvents = new HashMap();
        this.plugin = plugin;
        if (target) {
            this.addTarget(target, addMethod, removeMethod);
        }
    }
    /**
     * Adds a target to this event binder.
     * @param {any} target The event emmiter object to attach handlers to.
     * @param {string} addMethod The name of the target method to add event handlers ['addEventListener', 'on', 'once', ...].
     * @param {string} removeMethod The name of the target method to remove event handlers ['removeEventListener', 'off', ...].
     *
     * @throws {Error} Couldn't find the addMethod or removeMethod on the target.
     */
    HiveEventsBinder.prototype.addTarget = function (target, addMethod, removeMethod) {
        if (!this.registeredEvents.has(target)) {
            this.validateTarget(target, addMethod, removeMethod);
            this.registeredEvents.set(target, {
                targetId: HiveEventsBinder.nextTargetId++,
                addMethod: addMethod,
                removeMethod: removeMethod,
                events: {}
            });
        }
        return this;
    };
    HiveEventsBinder.prototype.validateTarget = function (target, addMethod, removeMethod) {
        if (!target[addMethod]) {
            throw new Error(HiveEventsBinder.loggerId + "- method " + addMethod + " is undefined in event target.");
        }
        else if (!target[removeMethod]) {
            throw new Error(HiveEventsBinder.loggerId + "- method " + removeMethod + " is undefined in event target.");
        }
    };
    HiveEventsBinder.prototype.registerEvents = function (target, events) {
        if (!events) {
            var keys = this.registeredEvents.keys();
            var numTargets = keys.length;
            if (numTargets !== 1) {
                throw new Error(HiveEventsBinder.loggerId + "Incorrect use of non-targeted registerEvents; " + numTargets + " registered");
            }
            events = target;
            target = keys[0];
        }
        var existing = this.registeredEvents.get(target);
        if (!existing) {
            throw new Error(HiveEventsBinder.loggerId + "- target not registered");
        }
        var addMethod = existing.addMethod, targetId = existing.targetId;
        var newRegistered = [];
        for (var _i = 0, _a = Object.keys(events); _i < _a.length; _i++) {
            var name_1 = _a[_i];
            var hiveHandler = events[name_1];
            var handler = void 0;
            if (typeof hiveHandler === 'function') {
                handler = hiveHandler = hiveHandler.bind(this.plugin);
            }
            else {
                handler = hiveHandler.handler = hiveHandler.handler.bind(this.plugin);
            }
            if (!existing.events[name_1]) {
                try {
                    var registeredHandler = this.registerEvent(target, addMethod, name_1, handler, hiveHandler);
                    existing.events[name_1] = registeredHandler;
                    newRegistered.push(name_1);
                }
                catch (bindError) {
                    this.plugin.logger().warn(HiveEventsBinder.loggerId + " error binding event '" + name_1 + "' on target #" + targetId + ": " + bindError.toString());
                }
            }
        }
        if (this.plugin) {
            this.plugin.logger().debug(HiveEventsBinder.loggerId + "Registering events [" + newRegistered.join(', ') + "] on target #" + targetId);
        }
        return newRegistered.length > 0;
    };
    /**
     * Adds a single listener to the target.
     * @param {any} target The event emmiter object to register the event.
     * @param {string} addMethod The name of the add method.
     * @param {string} name The name of event.
     * @param {handler} Function The handler function.
     * @param {HiveHandler} hiveHandler The original HiveHandler. Useful for modifications when extending this class.
     *
     * @returns {HiveHandler} The HiveHandler, which could be the original or a modified object.
     *
     * @throws {Error} If an error happens while adding the listener it will be thrown.
     */
    HiveEventsBinder.prototype.registerEvent = function (target, addMethod, name, handler, hiveHandler) {
        target[addMethod](name, handler);
        return hiveHandler;
    };
    /**
     * Unregisters the HiveEvents (name, handler) for all targets
     *
     * @param {boolean} isPluginDestroy Specifies if it's called in sequence of the plugin destroy to unregister all events.
     * If 'false', it only unregisters events which value of persistUntilDestroy is 'false'.
     */
    HiveEventsBinder.prototype.unregisterEvents = function (isPluginDestroy) {
        var _this = this;
        if (isPluginDestroy === void 0) { isPluginDestroy = false; }
        this.registeredEvents.forEach(function (_a, target) {
            var removeMethod = _a.removeMethod, events = _a.events, targetId = _a.targetId;
            var removedEvents = [];
            for (var _i = 0, _b = Object.keys(events); _i < _b.length; _i++) {
                var name_2 = _b[_i];
                var hiveHandler = events[name_2];
                var handler = void 0, persistUntilDestroy = void 0;
                if (typeof hiveHandler === 'function') {
                    handler = hiveHandler;
                }
                else {
                    handler = hiveHandler.handler;
                    persistUntilDestroy = hiveHandler.persistUntilDestroy;
                }
                if (isPluginDestroy || !persistUntilDestroy) {
                    try {
                        _this.unregisterEvent(target, removeMethod, name_2, handler);
                        delete events[name_2];
                        removedEvents.push(name_2);
                    }
                    catch (unbindError) {
                        _this.plugin.logger().warn(HiveEventsBinder.loggerId + " error unbinding event '" + name_2 + "' on target #" + targetId + ": " + unbindError.toString());
                    }
                }
            }
            if (isPluginDestroy) {
                _this.registeredEvents.delete(target);
            }
            if (_this.plugin) {
                _this.plugin.logger().debug(HiveEventsBinder.loggerId + "Unregistering events [" + removedEvents.join(', ') + "] on target #" + targetId + " [destroy: " + isPluginDestroy + "]");
            }
        });
    };
    /**
     * Removes a single listener from the target.
     * @param {any} target The event emmiter object to register the event.
     * @param {string} removeMethod The name of the remove method.
     * @param {string} name The name of event.
     * @param {handler} Function The handler function.
     *
     * @throws {Error} If an error happens while removing the listener it will be thrown.
     */
    HiveEventsBinder.prototype.unregisterEvent = function (target, removeMethod, name, handler) {
        target[removeMethod](name, handler);
    };
    /**
     * Clears the registered events object without unregistering from target.
     */
    HiveEventsBinder.prototype.reset = function () {
        var _this = this;
        this.registeredEvents.forEach(function (_a, target) {
            var targetId = _a.targetId;
            _this.registeredEvents.delete(target);
            if (_this.plugin) {
                _this.plugin.logger().debug(HiveEventsBinder.loggerId + "Reset on target #" + targetId);
            }
        });
    };
    HiveEventsBinder.loggerId = '[HiveEventsBinder] ';
    HiveEventsBinder.nextTargetId = 0;
    return HiveEventsBinder;
}());
exports.HiveEventsBinder = HiveEventsBinder;
//# sourceMappingURL=HiveEventsBinder.js.map

/***/ }),

/***/ "../../../core/build/core/src/common/InitStepTimers.js":
/*!******************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/common/InitStepTimers.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.InitStepTimers = void 0;
var Track_1 = __webpack_require__(/*! ../stats/Track */ "../../../core/build/core/src/stats/Track.js");
var InitStepTimers = /** @class */ (function () {
    /**
     * Create an InitStepTimers context.
     * @param {any} logger The logger
     */
    function InitStepTimers(logger, initStepCallback) {
        this.timers = {};
        this.events = new Array();
        this.persistentEvents = new Array();
        this.logger = logger;
        this.initStepCallback = initStepCallback;
    }
    /**
     * Start new timers for the provided steps.
     * Stores the start timestamp used to calculate the steps duration, overwriting started for the step.
     *
     * @param {InitStep} initSteps Init steps to account
     */
    InitStepTimers.prototype.start = function (initSteps) {
        var _this = this;
        var startTime = Date.now();
        if (Array.isArray(initSteps)) {
            initSteps.forEach(function (iniStep) { return _this.timers[iniStep] = startTime; });
        }
        else {
            this.timers[initSteps] = Date.now();
        }
    };
    /**
     * Stop an existing timer, if it has started, and creates a InitStepEndEvent holding the data to report.
     * The 'persistReset'parameter is used for events that only happen once.
     * If a 'failedStep' is provided, it will report the step as this InitStep failed.
     *
     * @param {InitStep} initStep Init step to account
     * @param {boolean} persistReset Init step event persists to reset(false) calls.
     * @param {InitStep} failedStep Matches the started step with correspondent failed step, so it reports correctly cases of failure.
     */
    InitStepTimers.prototype.stop = function (initStep, persistReset, failedStep) {
        if (persistReset === void 0) { persistReset = false; }
        var ts = Date.now();
        var startTime = this.timers[initStep];
        if (!startTime) {
            // If attempting to stop InitStep that hasn't started
            return false;
        }
        delete this.timers[initStep];
        var stepDuration = ts - startTime;
        // Changing to corresponding failure code
        if (failedStep) {
            initStep = failedStep;
        }
        var initStepEvent = new Track_1.InitStepEvent(initStep, ts, stepDuration);
        if (persistReset) {
            this.persistentEvents.push(initStepEvent);
        }
        else {
            this.events.push(initStepEvent);
        }
        this.logger.debug(InitStepTimers.loggerId, Track_1.InitStep[initStep], 'in', stepDuration, 'ms');
        if (this.initStepCallback)
            try {
                this.initStepCallback(initStepEvent);
            }
            catch (error) {
                this.logger.debug(InitStepTimers.loggerId + " failing to run callback", error);
            }
        return true;
    };
    /**
     * Flushes the events created
     */
    InitStepTimers.prototype.flushEvents = function () {
        var events = this.events;
        var persistentEvents = this.persistentEvents;
        this.reset(true);
        return events.concat(persistentEvents);
    };
    /**
     * Reset the events.
     *
     * @param {boolean} complete Removes all the ended events
     */
    InitStepTimers.prototype.reset = function (complete) {
        if (complete === void 0) { complete = false; }
        this.events = new Array();
        if (complete) {
            this.timers = {};
            this.persistentEvents = new Array();
        }
    };
    InitStepTimers.loggerId = '[Timing]';
    return InitStepTimers;
}());
exports.InitStepTimers = InitStepTimers;
//# sourceMappingURL=InitStepTimers.js.map

/***/ }),

/***/ "../../../core/build/core/src/common/JWTAuthErrorCodes.js":
/*!*********************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/common/JWTAuthErrorCodes.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.JWTAuthErrorCodes = void 0;
var build_defaults_1 = __webpack_require__(/*! ./build.defaults */ "../../../core/build/core/src/common/build.defaults.js");
/**
*   This class is a representation of the error that should be used when triggering a failure during the initialization
*   to the partner platform
*/
var JWTAuthErrorCodes = /** @class */ (function () {
    function JWTAuthErrorCodes(code, errorMessage) {
        this.setErrorCode(code);
        this.errStr = errorMessage;
    }
    JWTAuthErrorCodes.prototype.parseAuthError = function (code, description) {
        this.setErrorCode("" + code);
        this.errStr = description;
    };
    JWTAuthErrorCodes.prototype.isJWTError = function (errorCode) {
        if (errorCode) {
            var numberVal = Number(errorCode);
            return (numberVal >= 1075 && numberVal <= 1099) || (numberVal >= 1000 && numberVal <= 1049);
        }
        return false;
    };
    JWTAuthErrorCodes.prototype.isJWKError = function (errorCode) {
        if (errorCode) {
            var numberVal = Number(errorCode);
            return numberVal >= 1050 && numberVal <= 1074;
        }
        return false;
    };
    JWTAuthErrorCodes.prototype.setErrorCode = function (errorCode) {
        this.errCode = errorCode;
        if (errorCode && isNaN(Number(errorCode)))
            this.errCode = errorCode;
        else if (errorCode && JWTAuthErrorCodes.backEndErrorCodeMaps.hasOwnProperty(errorCode))
            this.errCode = JWTAuthErrorCodes.backEndErrorCodeMaps[errorCode];
        else if (errorCode && this.isJWKError(errorCode.toString()))
            this.errCode = JWTAuthErrorCodes.JWT_PUBLIC_KEY;
        else if (errorCode && this.isJWTError(errorCode.toString()))
            this.errCode = JWTAuthErrorCodes.JWT_INVALID;
        // Remove the `C_` prefix for non-stream plugins
        if (build_defaults_1.BuildParameters.PLUGIN_NAME !== 'stream' && typeof this.errCode === 'string' && this.errCode.match(/^C_/)) {
            this.errCode = this.errCode.slice(2);
        }
    };
    JWTAuthErrorCodes.createError = function (code, description) {
        var errorObj = new JWTAuthErrorCodes();
        if (typeof description !== 'undefined') {
            errorObj.parseAuthError(code, description);
        }
        else if (typeof code === 'string') {
            try {
                var error = JSON.parse(code);
                errorObj.parseAuthError(error.code, error.description);
            }
            catch (_a) {
                errorObj.errCode = JWTAuthErrorCodes.NETWORK;
                errorObj.errStr = 'Network Error';
            }
        }
        return __assign({}, errorObj);
    };
    // Backend related Error codes
    JWTAuthErrorCodes.JWT_PUBLIC_KEY = 'JWT_PUBLIC_KEY'; // not used for now
    JWTAuthErrorCodes.JWT_INVALID = 'JWT_INVALID';
    JWTAuthErrorCodes.INVALID_LIC = 'INVALID_LIC';
    JWTAuthErrorCodes.SDN_API_FAIL = 'SDN_API_FAIL';
    JWTAuthErrorCodes.C_MULTIPLE_CUSTOMERS_FOUND = 'C_MULTIPLE_CUSTOMERS_FOUND';
    JWTAuthErrorCodes.C_MULTIPLE_PARTNERS_FOUND = 'C_MULTIPLE_PARTNERS_FOUND';
    JWTAuthErrorCodes.C_TECH_UNSUPPORTED = 'C_TECH_UNSUPPORTED';
    JWTAuthErrorCodes.C_NO_STREAM_PROVIDED = 'C_NO_STREAM_PROVIDED';
    JWTAuthErrorCodes.C_INVALID_PARTNER = 'C_INVALID_PARTNER';
    JWTAuthErrorCodes.C_INVALID_CUSTOMER = 'C_INVALID_CUSTOMER';
    // Plugin related Error codes
    JWTAuthErrorCodes.CONFIG_STRING = 'CONFIG_STRING'; // Not used. wrong config is translated in a initialization with a default setup
    JWTAuthErrorCodes.MANIFEST_FETCH = 'MANIFEST_FETCH'; // Not used for now
    JWTAuthErrorCodes.MANIFEST_PARSE = 'MANIFEST_PARSE'; // Not used for now
    JWTAuthErrorCodes.TIME_OUT = 'TIME_OUT';
    JWTAuthErrorCodes.NETWORK = 'NETWORK';
    JWTAuthErrorCodes.LOCAL_HOST = 'LOCAL_HOST'; // Not used for now
    // ErrorCode mapping between the number based one received from the Backend Service
    // and the string based one that the plugin will give back to the platform
    JWTAuthErrorCodes.backEndErrorCodeMaps = {
        1003: JWTAuthErrorCodes.C_MULTIPLE_PARTNERS_FOUND,
        1004: JWTAuthErrorCodes.C_MULTIPLE_CUSTOMERS_FOUND,
        1005: JWTAuthErrorCodes.C_INVALID_PARTNER,
        1006: JWTAuthErrorCodes.C_INVALID_CUSTOMER,
        1007: JWTAuthErrorCodes.C_TECH_UNSUPPORTED,
        1008: JWTAuthErrorCodes.INVALID_LIC,
        1009: JWTAuthErrorCodes.C_NO_STREAM_PROVIDED,
        1010: JWTAuthErrorCodes.SDN_API_FAIL
    };
    return JWTAuthErrorCodes;
}());
exports.JWTAuthErrorCodes = JWTAuthErrorCodes;
//# sourceMappingURL=JWTAuthErrorCodes.js.map

/***/ }),

/***/ "../../../core/build/core/src/common/basicutils.hive.js":
/*!*******************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/common/basicutils.hive.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.toHiveTextTrackList = exports.isValidResponseType = exports.getStreamProtocol = exports.getVolume = exports.isSourceAllowed = exports.getCleanBufferLen = exports.copyBuffer = exports.assignPolyfill = exports.ajaxPostPromise = exports.ajaxGenericPromise = exports.ajaxGetPromise = exports.promiseWhile = exports.parseParameterOptions = exports.updateOptions = exports.stringFormat = exports.nullifyNaNs = exports.reportNaNs = exports.toHumanReadable = void 0;
var Q = __webpack_require__(/*! @hivestreaming/q */ "../../../node_modules/@hivestreaming/q/q.js");
var URI = __webpack_require__(/*! urijs */ "../../../node_modules/urijs/src/URI.js");
var Dash_1 = __webpack_require__(/*! ../core/metadata/dash/Dash */ "../../../core/build/core/src/core/metadata/dash/Dash.js");
var Hls_1 = __webpack_require__(/*! ../core/metadata/hls/Hls */ "../../../core/build/core/src/core/metadata/hls/Hls.js");
var Utils_1 = __webpack_require__(/*! ../core/Utils */ "../../../core/build/core/src/core/Utils.js");
function toHumanReadable(bytes, toFixed) {
    if (toFixed === void 0) { toFixed = 2; }
    if (bytes > 1000000)
        return (bytes / 1000000).toFixed(toFixed) + 'MB';
    if (bytes > 1000)
        return (bytes / 1000).toFixed(toFixed) + 'KB';
    return bytes + 'B';
}
exports.toHumanReadable = toHumanReadable;
function reportNaNs(obj, parentKey, keysWithNaN) {
    if (parentKey === void 0) { parentKey = ''; }
    if (keysWithNaN === void 0) { keysWithNaN = []; }
    return nullifyNaNs(obj, parentKey, keysWithNaN, true);
}
exports.reportNaNs = reportNaNs;
function nullifyNaNs(obj, parentKey, keysWithNaN, reportOnly) {
    if (parentKey === void 0) { parentKey = ''; }
    if (keysWithNaN === void 0) { keysWithNaN = []; }
    if (reportOnly === void 0) { reportOnly = false; }
    var _loop_1 = function (key) {
        if (obj.hasOwnProperty(key)) {
            var val = obj[key];
            if (Array.isArray(val)) {
                val.forEach(function (arrayVal, index) {
                    // This should _always_ be the case, as Thrift snapshots are always objects
                    if (typeof arrayVal === 'object')
                        nullifyNaNs(arrayVal, parentKey + "." + key + "[" + index + "]", keysWithNaN, reportOnly);
                });
            }
            else if (typeof val === 'object') {
                nullifyNaNs(val, parentKey + "." + key, keysWithNaN, reportOnly);
            }
            else if (typeof val === 'number' && isNaN(val)) {
                keysWithNaN.push(parentKey + "." + key);
                if (!reportOnly)
                    obj[key] = null;
            }
        }
    };
    for (var key in obj) {
        _loop_1(key);
    }
    return keysWithNaN;
}
exports.nullifyNaNs = nullifyNaNs;
function stringFormat() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    // The string containing the format items (e.g. "{0}")
    // will and always has to be the first argument.
    var theString = args[0];
    // start with the second argument (i = 1)
    for (var i = 1; i < args.length; i++) {
        // "gm" = RegEx options for Global search (more than one instance)
        // and for Multiline search
        var regEx = new RegExp('\\{' + (i - 1) + '\\}', 'gm');
        theString = theString.replace(regEx, args[i]);
    }
    return theString;
}
exports.stringFormat = stringFormat;
/**
 * update the default options with new values
 *
 * @param newOptions
 * @param options
 */
function updateOptions(newOptions, options) {
    for (var attrName in newOptions) {
        if (newOptions.hasOwnProperty(attrName) && options.hasOwnProperty(attrName)) {
            /**
             * In order to support cross-frame callbacks, the plugin allows
             * passing strings for expected-function options. The string
             * represents a function name in this-or-any-parent window.
             */
            if (typeof options[attrName] === 'function' && typeof newOptions[attrName] === 'string') {
                /** try/catch just in case of cross-frame access errors */
                try {
                    /** Traverse the windows */
                    var win = window;
                    do {
                        var funcName = newOptions[attrName];
                        if (typeof win[funcName] === 'function') {
                            options[attrName] = win[funcName];
                            break;
                        }
                    } while (win != win.top && (win = win.parent));
                }
                catch (e) { /* ignore error */ }
            }
            else {
                options[attrName] = newOptions[attrName];
            }
        }
    }
}
exports.updateOptions = updateOptions;
/**
 * given a URL, a configuration object and a optionMapping object
 * this function parses all the query parameter and checks if any of them
 * matches an optionMapping and sets the matching configuration with the
 * parameter value parsed into the right type.
 *
 * @param url
 * @param optionMapping
 * @param options
 */
function parseParameterOptions(url, optionMapping, options) {
    // get all query parameters
    var query = new URI(url).query(true);
    for (var k in query) {
        try {
            // for every element matching an element in the mapping
            if (query.hasOwnProperty(k) && optionMapping.hasOwnProperty(k) && options.hasOwnProperty(optionMapping[k])) {
                // try to apply the value with the specified type
                var mapping = optionMapping[k];
                var v = query[k];
                options[mapping] = matchValueType(v, options[mapping]);
            }
        }
        catch (e) {
        }
    }
}
exports.parseParameterOptions = parseParameterOptions;
function matchValueType(v, objectToMatchType) {
    var value;
    switch (typeof objectToMatchType) {
        case 'number':
            value = parseInt(v);
            break;
        case 'boolean':
            value = v === 'true';
            break;
        default:
            value = v;
            break;
    }
    return value;
}
function promiseWhile(condition, body) {
    var done = Q.defer();
    function loop() {
        // When the result of calling `condition` is no longer true, we are
        // done.
        if (!condition())
            return done.resolve(true);
        // Use `when`, in case `body` does not return a promise.
        // When it completes loop again otherwise, if it fails, reject the
        // done promise
        Q.when(body(), loop, done.reject);
    }
    // Start running the loop in the next tick so that this function is
    // completely async. It would be unexpected if `body` was called
    // synchronously the first time.
    Q.nextTick(loop);
    // The promise
    return done.promise;
}
exports.promiseWhile = promiseWhile;
function ajaxGetPromise(url, contentType, async, customHeaders) {
    if (async === void 0) { async = true; }
    if (customHeaders === void 0) { customHeaders = {}; }
    return ajaxGenericPromise('GET', url, contentType, async, customHeaders);
}
exports.ajaxGetPromise = ajaxGetPromise;
function ajaxGenericPromise(method, url, contentType, async, customHeaders, body) {
    if (async === void 0) { async = true; }
    if (customHeaders === void 0) { customHeaders = {}; }
    var deferred = Q.defer();
    try {
        var xhr_1 = new XMLHttpRequest();
        xhr_1.open(method, url, async);
        if (contentType != undefined && contentType != null)
            xhr_1.setRequestHeader('Content-Type', contentType);
        if (customHeaders)
            for (var key in customHeaders)
                if (customHeaders.hasOwnProperty(key) && customHeaders[key] !== null)
                    xhr_1.setRequestHeader(key, customHeaders[key]);
        xhr_1.onload = function () {
            if (xhr_1.status == 200) {
                deferred.resolve(xhr_1.response);
            }
            else {
                deferred.reject({ status: xhr_1.status, reason: xhr_1.statusText, body: xhr_1.responseText });
            }
        };
        xhr_1.onerror = function (err) {
            deferred.reject({ status: -1, reason: 'Network Error' });
        };
        body ? xhr_1.send(body) : xhr_1.send();
    }
    catch (e) {
        deferred.reject({ status: -1, reason: e });
    }
    return deferred.promise;
}
exports.ajaxGenericPromise = ajaxGenericPromise;
function ajaxPostPromise(url, body, contentType, customHeaders, async) {
    if (async === void 0) { async = true; }
    var deferred = Q.defer();
    try {
        var xhr_2 = new XMLHttpRequest();
        xhr_2.open('POST', url, async);
        if (contentType != undefined && contentType != null)
            xhr_2.setRequestHeader('Content-Type', contentType);
        if (customHeaders != undefined && customHeaders != null) {
            for (var key in customHeaders) {
                if (customHeaders.hasOwnProperty(key) && customHeaders[key] !== null) {
                    xhr_2.setRequestHeader(key, customHeaders[key]);
                }
            }
        }
        xhr_2.onload = function () {
            if (xhr_2.status == 200) {
                deferred.resolve(xhr_2.response);
            }
            else {
                deferred.reject({ status: xhr_2.status, reason: xhr_2.response });
            }
        };
        xhr_2.onerror = function (err) {
            deferred.reject({ status: -1, reason: 'Network Error' });
        };
        xhr_2.send(body);
    }
    catch (e) {
        deferred.reject({ status: -1, reason: e });
    }
    return deferred.promise;
}
exports.ajaxPostPromise = ajaxPostPromise;
function assignPolyfill() {
    if (typeof Object.assign != 'function') {
        Object.assign = function (target, varArgs) {
            'use strict';
            if (target == null) { // TypeError if undefined or null
                throw new TypeError('Cannot convert undefined or null to object');
            }
            var to = Object(target);
            for (var index = 1; index < arguments.length; index++) {
                var nextSource = arguments[index];
                if (nextSource != null) { // Skip over if undefined or null
                    for (var nextKey in nextSource) {
                        // Avoid bugs when hasOwnProperty is shadowed
                        if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
                            to[nextKey] = nextSource[nextKey];
                        }
                    }
                }
            }
            return to;
        };
    }
}
exports.assignPolyfill = assignPolyfill;
function copyBuffer(buffer1) {
    var tmp = new Uint8Array(buffer1.byteLength);
    tmp.set(new Uint8Array(buffer1), 0);
    return tmp.buffer;
}
exports.copyBuffer = copyBuffer;
function getCleanBufferLen(pos, timeRanges) {
    var bufferLen = 0;
    var timeRangeIndex = 0;
    var buffLenFound = false;
    if (timeRanges)
        while (timeRangeIndex < timeRanges.length && !buffLenFound) {
            if (pos >= timeRanges.start(timeRangeIndex) && pos < timeRanges.end(timeRangeIndex)) {
                // play position is inside this buffer TimeRange, retrieve end of buffer position and buffer length
                bufferLen = timeRanges.end(timeRangeIndex) - pos;
                buffLenFound = true;
            }
            timeRangeIndex++;
        }
    return bufferLen;
}
exports.getCleanBufferLen = getCleanBufferLen;
/**
 * Method that checks if the source requested by the plater is eligible for the Hive Session
 *
 * @param requestSource {string} - URL extracted by the player rrequest
 * @param sessionSource {string} - URL valid for the session
 * @param manifestDomainMatcher {RegExp} - partner defined regex for matching request sourece with session soource
 * @param isWamsStrict {string} - if the URL matches needs to be strict (considering the WAMS format and params) or not
 * @returns {isAllowed, needsOverride} {boolean, boolean} - It returns if the source is allowed and if the session source
 *  needs to be overridden by the request one in order to complete the activation
 */
function isSourceAllowed(requestSource, sessionSource, manifestDomainMatcher, isWamsStrict) {
    if (isWamsStrict === void 0) { isWamsStrict = false; }
    var lowerReqSource = Utils_1.removeQueryParams(requestSource.toLowerCase());
    var lowerSessionSource = Utils_1.removeQueryParams(sessionSource.toLowerCase());
    var manifestRootIdx = lowerSessionSource.indexOf('.ism/manifest');
    var isWams = manifestRootIdx > -1 && (isWamsStrict ? lowerReqSource === lowerSessionSource : true);
    var needsOverride = false;
    var isAllowed = false;
    var reqURI = new URI(lowerReqSource);
    var sessionURI = new URI(lowerSessionSource);
    var domain = reqURI.hostname();
    if (lowerReqSource === lowerSessionSource) {
        isAllowed = true;
        // lowercase logic removes WAMS format parameters as well. so the override is needed if the manifest is WAMS
        needsOverride = isWams;
    }
    else if (isWams) {
        var manifestRoot = lowerReqSource.substring(0, manifestRootIdx);
        isAllowed = lowerReqSource.indexOf(manifestRoot) > -1;
        needsOverride = true;
    }
    else if (manifestDomainMatcher && manifestDomainMatcher.test(domain) && sessionURI.path() === reqURI.path()) {
        isAllowed = true;
        needsOverride = true;
    }
    return { isAllowed: isAllowed, needsOverride: needsOverride, isWams: isWams };
}
exports.isSourceAllowed = isSourceAllowed;
function getVolume(videoOrMuted, volume) {
    if (videoOrMuted !== undefined) {
        if (volume !== undefined) {
            // Case the volume parameter is defined then consider the first param is the muted
            var muted = videoOrMuted;
            return muted ? 0 : Math.round(volume * 100);
        }
        // Case the volume parameter is undefined then consider the first param is the HTMLVideoElement
        var video = videoOrMuted;
        return video.muted ? 0 : Math.round(video.volume * 100);
    }
    return undefined;
}
exports.getVolume = getVolume;
function getStreamProtocol(src) {
    if (src != null) {
        if (Hls_1.Hls.isManifest(src))
            return StreamProtocol.HLS;
        if (Dash_1.Dash.isManifest(src))
            return StreamProtocol.DASH;
    }
    return null;
}
exports.getStreamProtocol = getStreamProtocol;
function isValidResponseType(responseType) {
    return ['', 'arraybuffer', 'blob', 'document', 'json', 'text'].indexOf(responseType) > -1;
}
exports.isValidResponseType = isValidResponseType;
function toHiveTextTrackList(textTrackList) {
    return Array.from(textTrackList).filter(function (tt) { return tt.kind === 'subtitles' || tt.kind === 'captions'; }).map(function (tt) { return new hive.snapshots.TextTrack(tt); });
}
exports.toHiveTextTrackList = toHiveTextTrackList;
//# sourceMappingURL=basicutils.hive.js.map

/***/ }),

/***/ "../../../core/build/core/src/common/build.defaults.js":
/*!******************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/common/build.defaults.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.BuildParameters = void 0;
var BuildParameters = /** @class */ (function () {
    function BuildParameters() {
    }
    BuildParameters.COMM_JS = ( true) ? true : undefined;
    BuildParameters.COMM_JAVA = ( true) ? true : undefined;
    BuildParameters.WEBRTC_VERSION = ( true) ? "5.1.0" : undefined;
    BuildParameters.CORE_VERSION = ( true) ? "7.2.0" : undefined;
    BuildParameters.PLUGIN_NAME = ( true) ? "html5" : undefined;
    BuildParameters.PLUGIN_TIMEOUT = (typeof HIVE_PLUGIN_TIMEOUT !== 'undefined') ? HIVE_PLUGIN_TIMEOUT : 30000;
    BuildParameters.PLUGIN_VERSION = ( true) ? "8.0.0" : undefined;
    BuildParameters.PLAYER_NAME = ( true) ? "HTML5" : undefined;
    BuildParameters.DEFAULT_HLS_TRIMMING = (typeof HIVE_DEFAULT_HLS_TRIMMING !== 'undefined') ? HIVE_DEFAULT_HLS_TRIMMING : 16;
    BuildParameters.DEFAULT_DASH_TRIMMING = (typeof HIVE_DEFAULT_DASH_TRIMMING !== 'undefined') ? HIVE_DEFAULT_DASH_TRIMMING : 10;
    BuildParameters.SERVICE_ENDPOINT_TEST = ( true) ? true : undefined;
    BuildParameters.SERVICE_ENDPOINT_CUSTOM = (typeof HIVE_SERVICE_ENDPOINT_CUSTOM !== 'undefined') ? HIVE_SERVICE_ENDPOINT_CUSTOM : false;
    BuildParameters.CUSTOM_TICKET_REGEXP = (typeof HIVE_CUSTOM_TICKET_REGEXP !== 'undefined') ? HIVE_CUSTOM_TICKET_REGEXP : undefined;
    BuildParameters.CUSTOM_BACKEND_ENDPOINT = (typeof HIVE_CUSTOM_BACKEND_ENDPOINT !== 'undefined') ? HIVE_CUSTOM_BACKEND_ENDPOINT : undefined;
    BuildParameters.USE_PERSISTENT_IDENTITY = ( true) ? true : undefined;
    BuildParameters.SCORE_EQUALITY = (typeof LEADER_SCORE_EQUALITY !== 'undefined') ? LEADER_SCORE_EQUALITY : false;
    BuildParameters.RESTRICTED_CONN_INFO = (typeof HIVE_RESTRICTED_CONNINFO !== 'undefined') ? HIVE_RESTRICTED_CONNINFO : false;
    BuildParameters.DISCOVERY = (typeof HIVE_DISCOVERY !== 'undefined') ? HIVE_DISCOVERY : 'ws://127.0.0.1:8000/hive';
    BuildParameters.P2PDispatcherLog = (typeof P2PDispatcherDetailedLog !== 'undefined') ? P2PDispatcherDetailedLog : false;
    BuildParameters.NetworkManagerLog = (typeof NetworkManagerDetailedLog !== 'undefined') ? NetworkManagerDetailedLog : false;
    BuildParameters.ATATUS_key = (typeof ATATUS_KEY !== 'undefined') ? ATATUS_KEY : '0b83dd6a94664cc9a09c478a7d77384e';
    BuildParameters.ATATUS_version = (typeof ATATUS_VERSION !== 'undefined') ? ATATUS_VERSION : '4.2.1';
    BuildParameters.ATATUS_DEFAULT = (typeof ATATUS_DEFAULT_ENABLED !== 'undefined') ? ATATUS_DEFAULT_ENABLED : true;
    BuildParameters.ATATUS_EXCLUDE_ROWS = ( true) ? 9 : undefined;
    BuildParameters.DETECT_PRIVATEIP = (typeof HIVE_DETECT_PRIVATEIP !== 'undefined') ? HIVE_DETECT_PRIVATEIP : true;
    BuildParameters.USE_STORE_IP_DB = ( true) ? true : undefined;
    BuildParameters.TICKETLESS_PLUGIN = ( true) ? false : undefined;
    BuildParameters.LOG_MANIFEST_PARSING = ( true) ? true : undefined;
    BuildParameters.IP_SPOOFING_ENABLED = (typeof HIVE_IP_SPOOFING_ENABLED !== 'undefined') ? HIVE_IP_SPOOFING_ENABLED : true;
    BuildParameters.STATS_MANIFEST_INTERCEPTION_ENABLED = (typeof STATS_MANIFEST_INTERCEPTION_ENABLED !== 'undefined') ? STATS_MANIFEST_INTERCEPTION_ENABLED : true;
    BuildParameters.REPORTING_THRESHOLD = (typeof HIVE_REPORTING_THRESHOLD !== 'undefined') ? HIVE_REPORTING_THRESHOLD : 0;
    return BuildParameters;
}());
exports.BuildParameters = BuildParameters;
//# sourceMappingURL=build.defaults.js.map

/***/ }),

/***/ "../../../core/build/core/src/common/comm.hive.js":
/*!*************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/common/comm.hive.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.JWTAuthErrorCodes = exports.StreamLiveChecker = exports.PlayerTech = exports.HiveEventsBinder = exports.SessionRegistry = exports.PlayerEvents = exports.UrlConfigurableOptions = exports.Ticket = exports.TechName = exports.StatsJS = exports.Options = exports.MainStatusCode = exports.BuildParameters = exports.HiveXhrLoaderV1 = exports.HiveXhrLoader = exports.HiveSessionInternal = exports.HiveSessionErrorCode = exports.HiveSessionError = exports.HiveSession = exports.HiveRequestFactory = exports.HivePluginReference = exports.BasicUtils = exports.logError = exports.PluginErrorCodes = exports.Plugin = void 0;
var uuid = __webpack_require__(/*! uuid */ "../../../node_modules/uuid/index.js");
var Q = __webpack_require__(/*! @hivestreaming/q */ "../../../node_modules/@hivestreaming/q/q.js");
var HashMap = __webpack_require__(/*! @hivestreaming/collections/map */ "../../../node_modules/@hivestreaming/collections/map.js");
var HiveXhrLoaderV0_1 = __webpack_require__(/*! ./loaders/HiveXhrLoaderV0 */ "../../../core/build/core/src/common/loaders/HiveXhrLoaderV0.js");
Object.defineProperty(exports, "HiveXhrLoader", { enumerable: true, get: function () { return HiveXhrLoaderV0_1.HiveXhrLoader; } });
var HiveXhrLoaderV1_1 = __webpack_require__(/*! ./loaders/HiveXhrLoaderV1 */ "../../../core/build/core/src/common/loaders/HiveXhrLoaderV1.js");
Object.defineProperty(exports, "HiveXhrLoaderV1", { enumerable: true, get: function () { return HiveXhrLoaderV1_1.HiveXhrLoader; } });
var Framework_1 = __webpack_require__(/*! ../core/Framework */ "../../../core/build/core/src/core/Framework.js");
var options_hive_1 = __webpack_require__(/*! ./options.hive */ "../../../core/build/core/src/common/options.hive.js");
Object.defineProperty(exports, "Options", { enumerable: true, get: function () { return options_hive_1.Options; } });
Object.defineProperty(exports, "UrlConfigurableOptions", { enumerable: true, get: function () { return options_hive_1.UrlConfigurableOptions; } });
var techs_hive_1 = __webpack_require__(/*! ./techs/techs.hive */ "../../../core/build/core/src/common/techs/techs.hive.js");
Object.defineProperty(exports, "TechName", { enumerable: true, get: function () { return techs_hive_1.TechName; } });
var common_hive_1 = __webpack_require__(/*! ./common.hive */ "../../../core/build/core/src/common/common.hive.js");
Object.defineProperty(exports, "HiveSession", { enumerable: true, get: function () { return common_hive_1.HiveSession; } });
Object.defineProperty(exports, "HivePluginReference", { enumerable: true, get: function () { return common_hive_1.HivePluginReference; } });
Object.defineProperty(exports, "HiveSessionError", { enumerable: true, get: function () { return common_hive_1.HiveSessionError; } });
Object.defineProperty(exports, "HiveSessionErrorCode", { enumerable: true, get: function () { return common_hive_1.HiveSessionErrorCode; } });
Object.defineProperty(exports, "MainStatusCode", { enumerable: true, get: function () { return common_hive_1.MainStatusCode; } });
var HiveConfig_1 = __webpack_require__(/*! ../core/HiveConfig */ "../../../core/build/core/src/core/HiveConfig.js");
var HiveRequestFactory_1 = __webpack_require__(/*! ./utils/HiveRequestFactory */ "../../../core/build/core/src/common/utils/HiveRequestFactory.js");
Object.defineProperty(exports, "HiveRequestFactory", { enumerable: true, get: function () { return HiveRequestFactory_1.HiveRequestFactory; } });
var HivePlayerStats_1 = __webpack_require__(/*! ./utils/HivePlayerStats */ "../../../core/build/core/src/common/utils/HivePlayerStats.js");
var HiveTech_1 = __webpack_require__(/*! ./utils/HiveTech */ "../../../core/build/core/src/common/utils/HiveTech.js");
var SessionStorageUtil_1 = __webpack_require__(/*! ./utils/SessionStorageUtil */ "../../../core/build/core/src/common/utils/SessionStorageUtil.js");
var StatsChecker_1 = __webpack_require__(/*! ./utils/StatsChecker */ "../../../core/build/core/src/common/utils/StatsChecker.js");
var StreamLiveChecker_1 = __webpack_require__(/*! ./utils/StreamLiveChecker */ "../../../core/build/core/src/common/utils/StreamLiveChecker.js");
Object.defineProperty(exports, "StreamLiveChecker", { enumerable: true, get: function () { return StreamLiveChecker_1.StreamLiveChecker; } });
var VisibilityChangeListener_1 = __webpack_require__(/*! ./utils/VisibilityChangeListener */ "../../../core/build/core/src/common/utils/VisibilityChangeListener.js");
var HiveSessionInternal_1 = __webpack_require__(/*! ./utils/HiveSessionInternal */ "../../../core/build/core/src/common/utils/HiveSessionInternal.js");
Object.defineProperty(exports, "HiveSessionInternal", { enumerable: true, get: function () { return HiveSessionInternal_1.HiveSessionInternal; } });
var BasicUtils = __webpack_require__(/*! ./basicutils.hive */ "../../../core/build/core/src/common/basicutils.hive.js");
exports.BasicUtils = BasicUtils;
var basicutils_hive_1 = __webpack_require__(/*! ./basicutils.hive */ "../../../core/build/core/src/common/basicutils.hive.js");
var silent_hive_1 = __webpack_require__(/*! ./silent.hive */ "../../../core/build/core/src/common/silent.hive.js");
var Track_1 = __webpack_require__(/*! ../stats/Track */ "../../../core/build/core/src/stats/Track.js");
Object.defineProperty(exports, "PlayerEvents", { enumerable: true, get: function () { return Track_1.PlayerEvents; } });
var RealTimeBindings_1 = __webpack_require__(/*! ../core/RealTimeBindings */ "../../../core/build/core/src/core/RealTimeBindings.js");
var Bindings_1 = __webpack_require__(/*! ../stats/Bindings */ "../../../core/build/core/src/stats/Bindings.js");
var stats_hive_1 = __webpack_require__(/*! ./techs/statsjs/stats.hive */ "../../../core/build/core/src/common/techs/statsjs/stats.hive.js");
Object.defineProperty(exports, "StatsJS", { enumerable: true, get: function () { return stats_hive_1.StatsJS; } });
var stats_1 = __webpack_require__(/*! ../stats */ "../../../core/build/core/src/stats/index.js");
var logger_hive_1 = __webpack_require__(/*! ./logger.hive */ "../../../core/build/core/src/common/logger.hive.js");
var ErrorCodes = __webpack_require__(/*! ./error.hive */ "../../../core/build/core/src/common/error.hive.js");
var JWTAuthErrorCodes_1 = __webpack_require__(/*! ./JWTAuthErrorCodes */ "../../../core/build/core/src/common/JWTAuthErrorCodes.js");
Object.defineProperty(exports, "JWTAuthErrorCodes", { enumerable: true, get: function () { return JWTAuthErrorCodes_1.JWTAuthErrorCodes; } });
var Ticket_1 = __webpack_require__(/*! ../core/ticket/Ticket */ "../../../core/build/core/src/core/ticket/Ticket.js");
Object.defineProperty(exports, "Ticket", { enumerable: true, get: function () { return Ticket_1.Ticket; } });
var constants_hive_1 = __webpack_require__(/*! ./constants.hive */ "../../../core/build/core/src/common/constants.hive.js");
var Constants_1 = __webpack_require__(/*! ../core/Constants */ "../../../core/build/core/src/core/Constants.js");
var SessionRegistry_1 = __webpack_require__(/*! ./session/SessionRegistry */ "../../../core/build/core/src/common/session/SessionRegistry.js");
Object.defineProperty(exports, "SessionRegistry", { enumerable: true, get: function () { return SessionRegistry_1.SessionRegistry; } });
var build_defaults_1 = __webpack_require__(/*! ./build.defaults */ "../../../core/build/core/src/common/build.defaults.js");
Object.defineProperty(exports, "BuildParameters", { enumerable: true, get: function () { return build_defaults_1.BuildParameters; } });
var HiveEventsBinder_1 = __webpack_require__(/*! ./HiveEventsBinder */ "../../../core/build/core/src/common/HiveEventsBinder.js");
Object.defineProperty(exports, "HiveEventsBinder", { enumerable: true, get: function () { return HiveEventsBinder_1.HiveEventsBinder; } });
var Utils_1 = __webpack_require__(/*! ../core/Utils */ "../../../core/build/core/src/core/Utils.js");
var InitStepTimers_1 = __webpack_require__(/*! ../common/InitStepTimers */ "../../../core/build/core/src/common/InitStepTimers.js");
var hivejs_hive_1 = __webpack_require__(/*! ./techs/hivejs/hivejs.hive */ "../../../core/build/core/src/common/techs/hivejs/hivejs.hive.js");
var hivejava_hive_1 = __webpack_require__(/*! ./techs/hivejava/hivejava.hive */ "../../../core/build/core/src/common/techs/hivejava/hivejava.hive.js");
var CORE_VERSION = build_defaults_1.BuildParameters.CORE_VERSION, WEBRTC_VERSION = build_defaults_1.BuildParameters.WEBRTC_VERSION, PLUGIN_VERSION = build_defaults_1.BuildParameters.PLUGIN_VERSION, COMM_JAVA = build_defaults_1.BuildParameters.COMM_JAVA, COMM_JS = build_defaults_1.BuildParameters.COMM_JS, PLAYER_NAME = build_defaults_1.BuildParameters.PLAYER_NAME;
// if hivejs is included in the build, register the Client Configurations on the global window
if (COMM_JS) {
    __webpack_require__(/*! ../webrtc/ClientConfigs */ "../../../core/build/core/src/webrtc/ClientConfigs.js").HiveConfig;
}
var PlayerTech;
(function (PlayerTech) {
    PlayerTech["HTML5"] = "html5";
    PlayerTech["NATIVE"] = "native_hls";
    PlayerTech["FLASH"] = "flash";
})(PlayerTech || (PlayerTech = {}));
exports.PlayerTech = PlayerTech;
var Plugin = /** @class */ (function () {
    /**
     * initialize the Hive Plugin with the options
     * @param newOptions
     */
    function Plugin(newOptions) {
        var _this = this;
        this.eventName = null;
        // Hive techs
        this.defaultHiveTechOrder = [techs_hive_1.Techs[techs_hive_1.Techs.HiveJava], techs_hive_1.Techs[techs_hive_1.Techs.HiveJS], techs_hive_1.Techs[techs_hive_1.Techs.StatsJS]];
        this.hiveTechs = new HashMap();
        // Hive Techs events
        this.techEvents = new Array();
        // Hive Sessions
        this.initializedSessions = new Array();
        this.activeSession = null;
        // Hive QoE data
        this.totalBufferingTime = 0;
        this.lastBufferingStart = 0;
        // logger tag
        this.loggerId = '[HiveComm] ';
        this.statusCode = 0x0000000;
        this.playingStateCounter = new Utils_1.StateDurationCounter();
        this.eventBinder = new HiveEventsBinder_1.HiveEventsBinder(this);
        this.pluginId = uuid.v4();
        Framework_1.Framework.startFramework('peer0', new RealTimeBindings_1.RealTimeBindings(), new Bindings_1.StatsBindings());
        /*
         * load the plugin id from the current viewing session or generate it if missing.
         * The sessionStorage objects will be saved even if the tab is refreshed.
         * Opening a page in a new tab or window will cause a new session to be initiated.
         */
        this.pluginId4Java = SessionStorageUtil_1.SessionStorageUtil.getItem('hivePluginId');
        if (!this.pluginId4Java) {
            this.pluginId4Java = Math.abs(Math.floor(Math.random() * 0x1000000000)).toString(16);
            SessionStorageUtil_1.SessionStorageUtil.setItem('hivePluginId', this.pluginId4Java);
        }
        // load instance of ErrorMonitor
        var errorMonitorInstance = logger_hive_1.ErrorMonitor.getInstance(PLUGIN_VERSION);
        this.options_ = new options_hive_1.Options();
        this.validateHiveTechs(newOptions);
        basicutils_hive_1.updateOptions(newOptions, this.options_);
        basicutils_hive_1.parseParameterOptions(window.location.href, new options_hive_1.UrlConfigurableOptions(), this.options_);
        options_hive_1.OptionsConfigurator.applySpecialDevConfig(this.options_);
        this.logger_ = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.LOGGER);
        HiveConfig_1.HiveConfig.Framework.LoggerTimestamp = this.options().loggerTimestamp;
        if (this.options().isSDNDebug)
            this.options().debugLevel = 'debug';
        this.logger_.setLevel(this.options().debugLevel);
        errorMonitorInstance.setLogger(this.logger_.log());
        // setting the onerror callback to give to the partner a filtered info we send to atatus
        if (this.options().onError)
            errorMonitorInstance.setOnErrorCallback(this.options().onError);
        var identityProvider = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.IDENTITY_PROVIDER);
        var connInfoProvider = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.CONNECTIVITY_INFO_PROVIDER);
        identityProvider.getIdentity().then(function (identity) {
            if (_this.options().reportingId)
                identity.setReportingId(_this.options().reportingId);
            errorMonitorInstance.setUser(identity.getPeerId());
            errorMonitorInstance.setGlobalCustomData({ reportingGuid: identity.getReportingId() });
            errorMonitorInstance.setGlobalCustomData({ p2pId: identity.getPeerId() });
        });
        var privateIp = {};
        // We have this initialization before the first getConnectivityInfo, since when using a silent test for statsJS the default or preset
        // option of the IP address detection will be overridden and set always to true
        new silent_hive_1.HiveSilentTest(this);
        connInfoProvider.setCandidateTopicName(this.options().candidateTopicName);
        connInfoProvider.getConnectivityInfo().then(function (connInfo) {
            privateIp = {
                pIPAddr: connInfo.getNetworkInfo().getPrivateIp()
            };
            errorMonitorInstance.setGlobalCustomData({ privateIp: privateIp['pIPAddr'] });
        }).catch(function (error) {
            _this.logger().debug(_this.loggerId + " Not Able to initialize ErrorMonitor with the private IP address ", error);
        });
        // register a shared Hive Logger instance on the browser global
        // for other hive services like hive-services
        window['HiveLoggerInstance'] = this.logger_.log();
        this.registerCloseSession();
        this.pluginReference = new common_hive_1.HivePluginReference(this);
        // initialize the statsChecker with the correct idleTimePeriod
        var idleTimePeriod = ((this.options().idleTimePeriod > this.options().feedbackPeriod) ? this.options().idleTimePeriod : constants_hive_1.Constants.DEFAULT_IDLE_TIME_PERIOD);
        this.statsChecker = new StatsChecker_1.StatsChecker(idleTimePeriod);
        // we register the generic events (Visibility events...)
        this.registerGenericEvents();
        this.initStepTimers = new InitStepTimers_1.InitStepTimers(this.logger(), this.options().onInitStep);
        this.logger().notice(this.loggerId + 'registered plugin [id: ' + this.getPluginId() + '][version: ' + this.getPluginVersion() + ']');
    }
    Plugin.prototype.options = function () {
        return this.options_;
    };
    Plugin.prototype.logger = function () {
        if (this.activeSession) {
            return this.logger_.log(this.activeSession.id);
        }
        return this.logger_.log();
    };
    Plugin.prototype.getManifestUrl = function () {
        return this.manifestUrl;
    };
    Plugin.prototype.setManifestUrl = function (manifestUrl) {
        this.manifestUrl = manifestUrl;
    };
    /**
     * Called to set or get the log level used by the plugin
     * The log levels are (ordered by min to max verbosity):
     * off | error | warn | notice | info | debug | trace
     */
    Plugin.prototype.loggerLevel = function (level) {
        if (typeof level === 'string') {
            this.logger_.setLevel(level);
        }
        if (this.logger) {
            return this.logger_.level;
        }
    };
    Plugin.prototype.getPluginId = function () {
        return this.pluginId;
    };
    Plugin.prototype.getPluginId4Java = function () {
        return this.pluginId4Java;
    };
    Plugin.prototype.getCoreVersion = function () {
        return CORE_VERSION;
    };
    Plugin.prototype.getWebRTCVersion = function () {
        if (COMM_JS) {
            return WEBRTC_VERSION;
        }
    };
    Plugin.prototype.updateCommsForInitSessions = function () {
        for (var _i = 0, _a = this.initializedSessions; _i < _a.length; _i++) {
            var session = _a[_i];
            session.tech.setPlugin(this);
            if (session.tech.getName() === 'HiveJS' && session.tech['statsJS']) {
                session.tech['statsJS'].setPlugin(this);
            }
        }
    };
    Plugin.prototype.validateHiveTechs = function (newOptions) {
        var statsJSTech = new stats_hive_1.StatsJS(this, newOptions);
        this.hiveTechs.set(stats_hive_1.StatsJS.techName, statsJSTech);
        if (COMM_JS) {
            var HiveJS_1 = __webpack_require__(/*! ./techs/hivejs/hivejs.hive */ "../../../core/build/core/src/common/techs/hivejs/hivejs.hive.js").HiveJS;
            this.hiveTechs.set(HiveJS_1.techName, new HiveJS_1(this, newOptions, statsJSTech));
        }
        if (COMM_JAVA) {
            var HiveJava_1 = __webpack_require__(/*! ./techs/hivejava/hivejava.hive */ "../../../core/build/core/src/common/techs/hivejava/hivejava.hive.js").HiveJava;
            this.hiveTechs.set(HiveJava_1.techName, new HiveJava_1(this, newOptions));
        }
        // validate the hiveTechOrder
        var techOrderOptions = newOptions['hiveTechOrder'];
        if (techOrderOptions && !(techOrderOptions instanceof Array)) {
            console.warn(this.loggerId + 'hiveTechOrder value not accepted. It must be an array of strings');
            techOrderOptions = this.defaultHiveTechOrder;
        }
        else if (techOrderOptions && techOrderOptions.length > 0) {
            var i = techOrderOptions.length;
            while (i--) {
                var elem = techOrderOptions[i];
                if (typeof elem !== 'string' || this.defaultHiveTechOrder.indexOf(elem) == -1) {
                    console.warn(this.loggerId + 'The "' + elem + '" Hive tech is undefined');
                    techOrderOptions.splice(i, 1);
                }
                else if ((typeof elem !== 'string' || !this.hiveTechs.has(elem))) {
                    console.warn(this.loggerId + 'The "' + elem + '" Hive tech is not enabled on this plugin');
                }
            }
            this.newOptionsTechOrder = techOrderOptions;
        }
        else {
            techOrderOptions = this.defaultHiveTechOrder;
        }
        newOptions.hiveTechOrder = techOrderOptions;
    };
    Plugin.prototype.newSession = function (ticketOrToken) {
        var _this = this;
        if (typeof ticketOrToken === 'string') {
            return this.resolveTicketPromise(ticketOrToken).timeout(this.options().pluginTimeout).catch(function (error) {
                logError('Error resolving ticket promise', _this.loggerId, exports.PluginErrorCodes.UNABLE_RESOLVE_TICKET, error);
                throw error;
            });
        }
        else {
            return this.resolveJWTPromise(ticketOrToken).timeout(this.options().pluginTimeout).catch(function (error) {
                logError('Error resolving JWT promise', _this.loggerId, exports.PluginErrorCodes.UNABLE_RESOLVE_JWT, error);
                throw error;
            });
        }
    };
    Plugin.prototype.resolveJWTPromise = function (token) {
        var manifest = token.manifest, jwt = token.jwt, videoId = token.videoId, endpoint = token.endpoint;
        return this.authenticate([{ manifests: [manifest], jwt: jwt, videoId: videoId, endpoint: endpoint }]).then(function (sessionInternals) {
            return sessionInternals[0];
        });
    };
    /**
     * Attempt to resolve a ticket through any of the available techs
     *
     * In a loop through all the tech, one at the time:
     *
     * - First checks if the tech is available
     * - Then checks if the tech needs a Reporting Instance (verified ticket)
     * - Then tries to initialize a session with that tech
     * - If successful, resolve the promise with the initialized HiveSession
     *
     *
     * In case no tech can resolve the Session, an the Promise will fail with a
     * HiveTechError
     *
     * @param ticketUrl
     * @returns {Q.Promise<HiveSessionInternal>}
     */
    Plugin.prototype.resolveTicketPromise = function (ticketUrl) {
        var _this = this;
        this.initStepTimers.start([Track_1.InitStep.TIME_TO_OVERALL_AUTH, Track_1.InitStep.TIME_TO_PLAYER_INIT]);
        this.logger().notice(this.loggerId + 'resolving ' + ticketUrl);
        // the deferred object
        // TODO: remove antipattern
        var deferred = Q.defer();
        // Truthy-check ("", null, undefined, 0)
        if (!ticketUrl) {
            deferred.reject(common_hive_1.HiveSessionError.getHiveSessionError('', common_hive_1.HiveSessionErrorCode.TICKET_ERROR, 'No ticket provided.'));
            return deferred.promise;
        }
        // fill the error monitor tags
        this.extractErrorMonitorTags(ticketUrl);
        // get the list of tech in the right order
        var techArray = this.getOrderedTechs().values();
        // check that we have any tech available
        if (techArray.length == 0) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error initializing all Techs', this.loggerId, ErrorCodes.HIVE_COMM_PLUGIN.UNABLE_INIT_TECHS);
            deferred.reject(common_hive_1.HiveSessionError.getHiveSessionError(ticketUrl, common_hive_1.HiveSessionErrorCode.NO_TECH_AVAILABLE));
        }
        // use the promiseWhile loop to execute the resolve of
        // each tech one at the time in async way
        var foundTech = false;
        var exitedOnError = false;
        var ticketError;
        var techIndex = 0;
        var session = null;
        var reportingInstance;
        // asynchronous loop while
        basicutils_hive_1.promiseWhile(function () {
            // condition to keep staying in the loop
            return !foundTech && !exitedOnError && techIndex < techArray.length && !ticketError;
        }, function () {
            // the loop body should return a promise
            // currently, only collects the 'plugin-init-times' for the session that successfully activates
            _this.initStepTimers.reset();
            // we pick the next tech and check if it's ready
            var tech = techArray[techIndex++];
            tech.resetTech();
            /*
             * we need a promise in case we need to verify the ticket from javascript.
             * In case we already verified it, or this tech doesn't need it, we immediately
             * resolve the promise
             */
            var riPromise;
            if (tech.needsReportingInstance() && !reportingInstance) {
                _this.initStepTimers.start(Track_1.InitStep.TIME_TO_RI_INIT_SUCCESS);
                riPromise = _this.verifyTicket(ticketUrl, _this.options().testId);
            }
            else {
                // we either already verified the ticket or we don't need to
                riPromise = Q.resolve(null);
            }
            // first step: wait for the reporting instance
            return riPromise.then(function (ri) {
                _this.initStepTimers.stop(Track_1.InitStep.TIME_TO_RI_INIT_SUCCESS);
                // if we got a real reporting instance, we store it for later
                if (ri != null) {
                    reportingInstance = ri;
                    reportingInstance.setThreshold(_this.options().reportingThreshold);
                }
                // attempt to initialize a session with the current tech
                var initSessionTimeout = tech.getInitSessionTimeout();
                _this.initStepTimers.start(Track_1.InitStep.TIME_TO_TECH_INIT_SUCCESS);
                return tech.initSession(ticketUrl, _this.agentPicker, reportingInstance)
                    .timeout(initSessionTimeout, "[" + tech.getName() + "] Error: initialization timed out after " + initSessionTimeout + "ms")
                    .then(function (s) {
                    _this.initStepTimers.stop(Track_1.InitStep.TIME_TO_TECH_INIT_SUCCESS);
                    session = s;
                    _this.onInitializeSession(session, tech);
                    foundTech = true;
                    // in case we initialized a session with HiveJava, but we already initialized
                    // a Reporting instance, reset it
                    if (!tech.needsReportingInstance() && reportingInstance) {
                        reportingInstance.trackManager.reset();
                    }
                    logger_hive_1.ErrorMonitor.getInstance().setGlobalCustomData({ sessionId: session.id });
                    s.notifyStateChange(HiveSessionInternal_1.SessionState.INITIALIZED);
                    _this.logger().notice(_this.loggerId + 'initializing Session:[' + session.id + '] Ticket:' + session.ticket.toString() + ' HiveTech:[' + session.tech.getName() + ']');
                    return true;
                }).catch(function (error) {
                    error = _this.handleTechError(error, tech);
                    error.ticketUrl = ticketUrl;
                    // in case of tech error, we check if the tech has a specific
                    // onError callback which instructs if to continue with other techs, or exit the loop
                    exitedOnError = !tech.onError(error);
                    _this.logger().debug(_this.loggerId + 'tech ' + tech.getName() + ': ' + error.message);
                    return true;
                });
            }).catch(function (error) {
                ticketError = error;
                return true;
            });
        }).then(function () {
            // this block statement is reached when the promiseLoop is exited so we check the state
            if (ticketError) {
                deferred.reject(common_hive_1.HiveSessionError.getHiveSessionError(ticketUrl, common_hive_1.HiveSessionErrorCode.TICKET_ERROR, ticketError));
            }
            else if (exitedOnError) {
                deferred.reject(common_hive_1.HiveSessionError.getHiveSessionError(ticketUrl, common_hive_1.HiveSessionErrorCode.TECH_ERROR));
            }
            else if (foundTech) {
                _this.initStepTimers.stop(Track_1.InitStep.TIME_TO_OVERALL_AUTH);
                deferred.resolve(session);
            }
            else {
                logger_hive_1.ErrorMonitor.getInstance().logError('Error initializing all Techs', _this.loggerId, ErrorCodes.HIVE_COMM_PLUGIN.UNABLE_INIT_TECHS);
                deferred.reject(common_hive_1.HiveSessionError.getHiveSessionError(ticketUrl, common_hive_1.HiveSessionErrorCode.NO_TECH_AVAILABLE));
            }
        }).catch(function (err) {
            var _a;
            var errorMessage = "" + ((_a = err.message) !== null && _a !== void 0 ? _a : (typeof err === 'string' ? err : 'no details'));
            logger_hive_1.ErrorMonitor.getInstance().logError("Error resolving ticket promise: " + errorMessage, _this.loggerId, ErrorCodes.HIVE_COMM_PLUGIN.UNABLE_RESOLVE_TICKET, err);
            deferred.reject(common_hive_1.HiveSessionError.getHiveSessionError(ticketUrl, common_hive_1.HiveSessionErrorCode.GENERIC_ERROR, err.toString()));
        }).done();
        return deferred.promise;
    };
    /**
     * this method authenticate the stream to our backend giving us back the info of the event and
     * the specific plugin to use with the techs enabled for the customer
     * The response should look like:
     * {
     *   "endpoint": "{Unique WebSocket Connection URL}",
     *   "techs": "[{Tech(s) enabled}]",
     *   "partnerID": "{partnerID}",
     *   "customerID": "{customerID}",
     *   "videoID": "{videoID}",
     *   "manifests": [{manifests base URL(s)}]
     * }
     * @param  {Array<{Token}>} tokens
     * @returns {Q.Promise<boolean> | Q.Promise<any>} returns a promise fulfilled with true or a promise rejected
     */
    Plugin.prototype.authenticate = function (tokens) {
        var _this = this;
        var _a, _b;
        this.initStepTimers.start([Track_1.InitStep.TIME_TO_OVERALL_AUTH, Track_1.InitStep.TIME_TO_PLAYER_INIT]);
        if (!this.validateTokens(tokens))
            return Q.reject(JWTAuthErrorCodes_1.JWTAuthErrorCodes.createError('C_INVALID_DATA', 'There are missing data in among the videoId, JWT or manifest lists'));
        var authServiceEndpoint;
        if (build_defaults_1.BuildParameters.PLUGIN_NAME === 'stream') {
            authServiceEndpoint = build_defaults_1.BuildParameters.SERVICE_ENDPOINT_TEST ?
                Constants_1.Constants.TEST_STREAM_AUTH_SERVICE_ENDPOINT : Constants_1.Constants.PROD_STREAM_AUTH_SERVICE_ENDPOINT;
        }
        else {
            try {
                var endpoint = (_b = (_a = tokens[0].endpoint) === null || _a === void 0 ? void 0 : _a.toLowerCase()) !== null && _b !== void 0 ? _b : (build_defaults_1.BuildParameters.SERVICE_ENDPOINT_TEST ? 'test' : 'prod');
                if ((endpoint === 'dev' || endpoint == 'test') && !build_defaults_1.BuildParameters.SERVICE_ENDPOINT_TEST) {
                    throw new Error("Error trying to resolve " + endpoint + " JWT against production services");
                }
                switch (endpoint) {
                    case 'dev':
                        authServiceEndpoint = Constants_1.Constants.DEV_JWT_AUTH_SERVICE_ENDPOINT;
                        break;
                    case 'test':
                        authServiceEndpoint = Constants_1.Constants.TEST_JWT_AUTH_SERVICE_ENDPOINT;
                        break;
                    case 'prod':
                        authServiceEndpoint = Constants_1.Constants.PROD_JWT_AUTH_SERVICE_ENDPOINT;
                        break;
                    default: throw new Error("Invalid endpoint: " + endpoint);
                }
            }
            catch (ex) {
                this.logger().warn("" + this.loggerId + ex.message);
                return Q.reject(JWTAuthErrorCodes_1.JWTAuthErrorCodes.createError('C_INVALID_DATA', ex.message));
            }
        }
        var requestTs = new Date().getTime();
        this.initStepTimers.start(Track_1.InitStep.TIME_TO_AUTH_TOKEN_ENDPOINT);
        // The backend only accepts known properties, which does not include the `endpoint` property.
        var postData = JSON.stringify(tokens.map(function (_a) {
            var jwt = _a.jwt, manifests = _a.manifests, videoId = _a.videoId;
            return ({ jwt: jwt, manifests: manifests, videoId: videoId });
        }));
        var ajaxPostPromise = __webpack_require__(/*! ./basicutils.hive */ "../../../core/build/core/src/common/basicutils.hive.js").ajaxPostPromise;
        return ajaxPostPromise(authServiceEndpoint, postData).then(function (response) {
            _this.initStepTimers.stop(Track_1.InitStep.TIME_TO_AUTH_TOKEN_ENDPOINT, true);
            var respObj = JSON.parse(response);
            _this.logger().debug('Response: ', respObj);
            if (respObj.validated.length === 0 && respObj.failed.length > 0) {
                var _a = respObj.failed[0], code = _a.code, description = _a.description;
                return Q.reject(JWTAuthErrorCodes_1.JWTAuthErrorCodes.createError(code, description));
            }
            if (respObj.techs) {
                if (_this.newOptionsTechOrder) {
                    _this.logger().warn("JWT validation has provided license of [" + respObj.techs.join(', ') + "], ignoring plugin tech order of [" + _this.newOptionsTechOrder.join(', ') + "]");
                }
                _this.options().hiveTechOrder = respObj.techs;
            }
            else {
                _this.logger().info("JWT validation did not provide license, using plugin tech order of [" + _this.options().hiveTechOrder.join(', ') + "]");
            }
            _this.eventName = respObj.eventName;
            var deferred = Q.defer();
            var techArray = _this.getOrderedTechs().values();
            var foundTech = false;
            var techIndex = 0;
            var sessions = [];
            basicutils_hive_1.promiseWhile(function () {
                if (sessions.length > 0) {
                    _this.initStepTimers.stop(Track_1.InitStep.TIME_TO_OVERALL_AUTH);
                    deferred.resolve(sessions);
                    return false;
                }
                else if (!foundTech && techIndex < techArray.length) {
                    // currently, only collects the 'plugin-init-times' for the session that successfully activates
                    _this.initStepTimers.reset();
                    return true;
                }
                else {
                    logger_hive_1.ErrorMonitor.getInstance().logError('Error initializing all Techs', _this.loggerId, ErrorCodes.HIVE_COMM_PLUGIN.UNABLE_INIT_TECHS);
                    deferred.reject(JWTAuthErrorCodes_1.JWTAuthErrorCodes.createError("C_" + common_hive_1.HiveSessionErrorCode[common_hive_1.HiveSessionErrorCode.NO_TECH_AVAILABLE], 'No Tech successfully initialized'));
                    return false;
                }
            }, function () {
                var tech = techArray[techIndex++];
                tech.resetTech();
                // for each validate stream we create a session
                return Q.allSettled(respObj.validated.map(function (videoStream) {
                    var videoId = videoStream.videoId;
                    // get all manifests of the valid videoID from the parsed tokens
                    // The assumption here is that we have always one token per videoId
                    var videoIdTokens = tokens.filter(function (token) { return token.videoId === videoId; });
                    if (videoIdTokens.length === 0) {
                        logger_hive_1.ErrorMonitor.getInstance().logError('No Token found for the specific videoId', _this.loggerId, ErrorCodes.HIVE_COMM_PLUGIN.NO_TOKEN_FOUND, { videoId: videoId });
                        return Q.reject(false);
                    }
                    var manifests = videoStream.manifests;
                    _this.logger().debug('Manifests: ', manifests);
                    // for each actual manifest we generate a specific session
                    // so we are still compliant with one session for one manifest
                    return Q.allSettled(manifests.map(function (manifest) {
                        var riPromise;
                        var initSessionTimeout = tech.getInitSessionTimeout();
                        if (tech.needsReportingInstance()) {
                            _this.initStepTimers.start(Track_1.InitStep.TIME_TO_RI_INIT_SUCCESS);
                            var ticket = Ticket_1.Ticket.fromTuple(respObj.partnerId, respObj.customerId, respObj.validated[0].videoId);
                            ticket.setManifestUrl(manifest.uri);
                            ticket.requestTs = requestTs;
                            ticket.responseTs = new Date().getTime();
                            riPromise = stats_1.default.getInstance().initSession(_this.pluginId, ticket, false, { serviceEndpoint: respObj.connectionEndpoint });
                        }
                        else {
                            // we either already verified the ticket or we don't need to
                            riPromise = Q.resolve(null);
                        }
                        _this.initStepTimers.start(Track_1.InitStep.TIME_TO_TECH_INIT_SUCCESS);
                        return riPromise.then(function (ri) {
                            _this.initStepTimers.stop(Track_1.InitStep.TIME_TO_RI_INIT_SUCCESS);
                            // update the player info in the Reporting Instance
                            if (ri) {
                                _this.updateIntegrationInfo(ri);
                                ri.setThreshold(_this.options().reportingThreshold);
                            }
                            return tech.initSession(respObj.ticketEndpoint + "/" + manifest.jwt, _this.agentPicker, ri)
                                .timeout(initSessionTimeout)
                                .then(function (session) {
                                _this.onInitializeSession(session, tech);
                                foundTech = true;
                                // update ticket info
                                if (tech.getName() === 'HiveJava')
                                    session.ticket.updateFromTuple(respObj.partnerId, respObj.customerId, videoId);
                                // in case we initialized a session with HiveJava, but we already initialized
                                // a Reporting instance, reset it
                                if (!tech.needsReportingInstance() && ri) {
                                    ri.trackManager.reset();
                                }
                                logger_hive_1.ErrorMonitor.getInstance().setGlobalCustomData({ sessionId: session.id });
                                _this.logger().notice(_this.loggerId + 'initializing Session:[' + session.id + '] Ticket:' + session.ticket.toString() + ' HiveTech:[' + session.tech.getName() + ']');
                                // we keep the info of the original manifest for easily replace it in the original sourcelist if the session is HiveJava
                                session.ticket.originalManifest = manifest.uri;
                                _this.initStepTimers.stop(Track_1.InitStep.TIME_TO_TECH_INIT_SUCCESS);
                                return session;
                            });
                        }).fail(function (error) {
                            error = _this.handleTechError(error, tech);
                            return Q.reject(error);
                        });
                    })).then(function (results) {
                        return _this.extractResolved(results, false);
                    });
                })).then(function (results) {
                    var extractedSession = _this.extractResolved(results, [], false);
                    if (extractedSession instanceof Array)
                        sessions = extractedSession;
                });
            }).done();
            return deferred.promise;
        }).fail(function (error) {
            try {
                var errorObj = typeof error.reason === 'string' ? JWTAuthErrorCodes_1.JWTAuthErrorCodes.createError(error.reason) : error;
                _this.logger().debug('Authentication Failed', errorObj);
                return Q.reject(errorObj);
            }
            catch (e) {
                _this.logger().warn('Error parsing JWT Auth Error exception', e);
            }
            return Q.reject(error);
        });
    };
    Plugin.prototype.handleTechError = function (error, tech) {
        this.logger().debug(this.loggerId + " init Session failed:", error.message);
        if (error instanceof Error) {
            // In case of timeout Q will reject with a generic Error
            error = new common_hive_1.HiveTechError(common_hive_1.HiveTechErrorCode.TIMEOUT_ERROR, error.message);
            tech.onTechTimeout(error);
        }
        this.logger().debug(this.loggerId + 'tech ' + tech.getName() + ': ' + error.message);
        this.initStepTimers.stop(Track_1.InitStep.TIME_TO_TECH_INIT_SUCCESS, false, Track_1.InitStep.TIME_TO_TECH_INIT_FAIL);
        return error;
    };
    /**
     * This method validates that there are no missing data among the one collected in the source list of the player.
     * @param {Array<{Token}>} tokens
     * @returns {boolean}
     */
    Plugin.prototype.validateTokens = function (tokens) {
        if (tokens.length === 0)
            return false;
        return tokens.every(function (token, index, tokensArray) {
            return token.jwt && token.videoId && token.manifests.length > 0;
        });
    };
    /**
     * This method is general to extract all fulfilled results from the allSettled
     * the push variable allows to decide if to push the fulfilled values in the main array,
     * or to flatten everything
     * If no fulfilled result, it will reject the promise with the rejectObj as reason
     * @param results
     * @param rejectObj
     * @param {boolean} push
     * @returns {any}
     */
    Plugin.prototype.extractResolved = function (results, rejectObj, push) {
        if (push === void 0) { push = true; }
        var fulfilledResults = [];
        for (var _i = 0, results_1 = results; _i < results_1.length; _i++) {
            var result = results_1[_i];
            if (result.status === 'fulfilled')
                if (push)
                    fulfilledResults.push(result.value);
                else
                    fulfilledResults = fulfilledResults.concat(result.value);
        }
        if (fulfilledResults.length > 0)
            return fulfilledResults;
        return Q.reject(rejectObj);
    };
    /**
     * attempt to initialize a ReportingInstance session creating a ws connection to the service,
     * resolving and verifying the ticket, and initializing the stats store for Stats/Hivejs
     *
     * @param ticketUrl
     * @returns {Q.Promise<Reporting.ReportingInstance>}
     */
    Plugin.prototype.verifyTicket = function (ticketUrl, testId) {
        var _this = this;
        // verify the ticket and initialize a Reporting Instance Session
        this.initStepTimers.start(Track_1.InitStep.TIME_TO_AUTH_HIVE_ENDPOINT);
        return stats_1.default.getInstance().initSession(this.pluginId, ticketUrl, false, { testId: testId, reportingId: this.options().reportingId }).then(function (ri) {
            // here the reporting instance is ready and the ticket is verified
            _this.initStepTimers.stop(Track_1.InitStep.TIME_TO_AUTH_HIVE_ENDPOINT);
            _this.logger().debug(_this.loggerId + 'verified ticket ' + ticketUrl);
            // update the player info in the Reporting Instance
            _this.updateIntegrationInfo(ri);
            return ri;
        }).catch(function (error) {
            var _a;
            return Q.reject("Ticket not verified, error: " + ((_a = error.message) !== null && _a !== void 0 ? _a : (typeof error === 'string' ? error : 'no details')));
        });
    };
    /**
     * returns the allowed techs in the specified order
     *
     * @returns {Map<HiveTech>}
     */
    Plugin.prototype.getOrderedTechs = function () {
        var clonedOrder = JSON.parse(JSON.stringify(this.options().hiveTechOrder));
        var ticketTechs = new HashMap();
        for (var _i = 0, clonedOrder_1 = clonedOrder; _i < clonedOrder_1.length; _i++) {
            var tech = clonedOrder_1[_i];
            if (this.hiveTechs.has(tech)) {
                ticketTechs.set(tech, this.hiveTechs.get(tech));
            }
        }
        this.agentPicker = HiveTech_1.AgentPicker.javaAgent;
        /**
         * If we don't have HiveJs AND HiveJava in the tech order then we have either
         * only HiveJs in which case we want to go to HiveJs OR only HiveJava
         * in which case we don't want to fallback to HiveJs + Booster.
         * So no need to check for other cases
         */
        if (ticketTechs.has(hivejs_hive_1.HiveJS.techName) && ticketTechs.has(hivejava_hive_1.HiveJava.techName) && hivejs_hive_1.HiveJS.isBrowserSupported(navigator.userAgent))
            this.agentPicker = HiveTech_1.AgentPicker.boosterIfPossible;
        return ticketTechs;
    };
    /**
     * attempts to extract the eventId from the ticket and use the triplet as
     * tags for the error monitor
     * @param ticketUrl
     */
    Plugin.prototype.extractErrorMonitorTags = function (ticketUrl) {
        var errorMonitor = logger_hive_1.ErrorMonitor.getInstance();
        try {
            var ticket = Ticket_1.Ticket.fromUrl(ticketUrl);
            if (ticket.getPartnerId() && ticket.getCustomerId() && ticket.getContentId()) {
                errorMonitor.setTags([ticket.getPartnerId(), ticket.getCustomerId(), ticket.getContentId()]);
            }
            else {
                errorMonitor.logError('Ticket not valid, we could not resolve the triple partnerId/CustomerId/ContentId', this.loggerId, ErrorCodes.HIVE_COMM_PLUGIN.NO_VALID_TICKET, {
                    partnerId: ticket.getPartnerId(),
                    customerId: ticket.getCustomerId(),
                    contentId: ticket.getContentId()
                });
            }
        }
        catch (e) {
            this.logger().warn(this.loggerId + " " + e.message, e);
            errorMonitor.notify(e);
        }
    };
    Plugin.prototype.updateIntegrationInfo = function (ri) {
        // Updates the integration info sent in the track snapshot
        ri.trackManager.updateIntegrationInfo(this.getIntegrationInfo());
    };
    Plugin.prototype.getIntegrationInfo = function () {
        return {
            playerName: this.getPlayerName(),
            playerVersion: this.getPlayerVersion(),
            playerTech: this.getPlayerTech(),
            pluginName: this.getPluginName(),
            pluginVersion: this.getPluginVersion(),
            coreVersion: this.getCoreVersion(),
            webRTCVersion: this.getWebRTCVersion(),
            consumptionApp: this.getConsumptionApp(),
            telemetryId: this.getTelemetryId(),
            eventName: this.getEventName()
        };
    };
    /**
     * appends a tech event record
     * @param event
     */
    Plugin.prototype.addTechEvent = function (event) {
        if (this.activeSession && this.activeSession.tech) {
            event.sessionId = this.activeSession.id;
            this.activeSession.tech.handleTechEvent(this.activeSession, event);
        }
        else {
            this.techEvents.push(event);
        }
    };
    /**
     * reset and returns all the tech event records collected so far
     * @returns {Array<TechEventRecord>}
     */
    Plugin.prototype.flushTechEvents = function () {
        var events = this.techEvents;
        this.techEvents = new Array();
        return events;
    };
    // ----------- SESSION HANDLING -------------
    /**
     * Intermediate method needed to add and remove the listener to the window
    */
    Plugin.prototype.beforeUnloadClose = function () {
        this.destroyHivePlugin();
    };
    /**
     * add the event listener for closing an active session
     * on page close/refresh
     */
    Plugin.prototype.registerCloseSession = function () {
        var wnd = window;
        this.beforeUnloadClose = this.beforeUnloadClose.bind(this);
        if (wnd.addEventListener) {
            wnd.addEventListener('beforeunload', this.beforeUnloadClose, false); // W3C
        }
        else {
            wnd.attachEvent('onbeforeunload', this.beforeUnloadClose); // IE
        }
    };
    Plugin.prototype.unRegisterCloseSession = function () {
        var wnd = window;
        if (wnd.removeEventListener) {
            wnd.removeEventListener('beforeunload', this.beforeUnloadClose, false); // W3C
        }
        else {
            wnd.detachEvent('onbeforeunload', this.beforeUnloadClose); // IE
        }
    };
    /**
     * Close the current session. This is a public API call for the plugin utilized by partners when
     * the Hive session must be explicitly stopped. This will stop periodic feedback and capturing player events.
     * This method is made available on the player object via the integration plugin.
     * @param reason {string} Reason for manual close
     * @param async {boolean} Flush the last track snapshot asynchronously. Defaults to true.
     */
    Plugin.prototype.closeHiveSession = function (reason) {
        this.logger().debug("Manually Closing Session" + (reason ? " because: " + reason : ''));
        this.eventBinder.unregisterEvents();
        HiveRequestFactory_1.HiveRequestFactory.clearPluginState(this.pluginId);
        this.resetSession(true);
    };
    /**
     * This method destroy the plugin and removes all its references. After the destroy, a new instance
     * needs to be initialized in order to create a new viewing session
     * Steps:
     * - Unregister close session handlers
     * - Close Hive Session
     * - Unregister visibility listeners
     * - Purge the Framework
     * @param async {boolean} Flush the last track snapshot asynchronously. Defaults to true.
     *
     * @returns {number} The number of remaining plugins _after_ destroying `this`.
     */
    Plugin.prototype.destroyHivePlugin = function () {
        this.unRegisterCloseSession();
        this.eventBinder.unregisterEvents(true);
        this.closeHiveSession('Invoked Plugin Destroy');
        this.logger_.flush();
        VisibilityChangeListener_1.VisibilityChangeListener.getInstance(this.logger()).cleanListeners();
        Framework_1.Framework.purge();
        this.options_.onLoadingCompleted = null;
        this.options_.onSourceSetCompleted = null;
        this.options_.onActiveSession = null;
        this.options_.onError = null;
        logger_hive_1.ErrorMonitor.getInstance().resetOnErrorCallback();
        return Framework_1.Framework.pluginCounter;
    };
    /**
     * close the current active/initialized session,
     * reset the active and initialized session values and
     * reset the timers and stop the periodic stats
     * @param completeClose true if we want to close completely the session
     * @param async {boolean} Flush the last track snapshot asynchronously. Defaults to true.
     */
    Plugin.prototype.resetSession = function (completeClose) {
        var _this = this;
        this.onCloseSession(completeClose);
        if (completeClose === false) {
            if (this.activeSession && this.initializedSessions.every(function (session) { return session.id !== _this.activeSession.id; })) {
                this.initializedSessions.unshift(this.activeSession);
            }
        }
        else {
            this.initializedSessions.length = 0;
        }
        this.stopPeriodicFeedback();
        this.activeSession = null;
        this.lastEvent = null;
        this.lastEventData = null;
        this.totalBufferingTime = 0;
        this.lastBufferingStart = 0;
        this.initStepTimers.reset(true);
        this.eventName = null;
    };
    Plugin.prototype.onInitializeSession = function (session, tech) {
        session.tech = tech;
        this.initializedSessions.push(session);
    };
    /** *
     * Called after the initial metadata have been received from the player in order to activate the initialized
     * Session
     * @param explicitPlayerSource
     * @param isWamsStrict - tells if the WAMS manifest needs to be strictly equal (used in MS Stream) or just compare it with the base manifest (used in MS Teams)
     * @returns {boolean}
     */
    Plugin.prototype.onActivateSession = function (explicitPlayerSource, isWamsStrict) {
        var _this = this;
        if (isWamsStrict === void 0) { isWamsStrict = false; }
        if (this.activeSession == null) {
            this.initStepTimers.stop(Track_1.InitStep.TIME_TO_PLAYER_INIT);
            this.initStepTimers.start(Track_1.InitStep.TIME_TO_SESSION_ACTIVATED);
            // the source is either passed as argument or retrieved from the player
            var playerSource = explicitPlayerSource ? explicitPlayerSource : this.getPlayerSource();
            if (playerSource === undefined) {
                logger_hive_1.ErrorMonitor.getInstance().logError('No player source found', this.loggerId, ErrorCodes.HIVE_COMM_PLUGIN.NO_PLAYER_SOURCE, {
                    initializedSessions: this.initializedSessions.map(function (initializedSession) { return initializedSession.manifest; })
                });
                this.resetSession(true);
                return false;
            }
            for (var i = 0; i < this.initializedSessions.length; i++) {
                var session = this.initializedSessions[i];
                // we check if the hiveTech recognize this source as active and supports the protocol
                if (session.isActive(playerSource, isWamsStrict)) {
                    // set the current session as active, remove it from the initialized
                    // and reset the initialized ones
                    this.activeSession = session;
                    if (this.activeSession.reportingInstance) {
                        this.activeSession.reportingInstance.serviceClient.activate(this.activeSession.ticket);
                    }
                    else {
                        this.resetInitializedSessions();
                    }
                    // activate the session on the tech
                    this.activeSession.tech.onActiveSession(this.activeSession);
                    this.activeSession.notifyStateChange(HiveSessionInternal_1.SessionState.ACTIVE);
                    this.logger().notice(this.loggerId + 'activating Session:[' + this.activeSession.id + '] Ticket:' + this.activeSession.ticket.toString() +
                        ' HiveTech:[' + this.activeSession.tech.getName() + ']');
                    if (this.options().onActiveSession) {
                        try {
                            this.options().onActiveSession(session.toHiveSession());
                        }
                        catch (e) {
                            logger_hive_1.ErrorMonitor.getInstance().logError('Exception in user-defined Generic onActiveSession callback', this.loggerId, ErrorCodes.HIVE_COMM_PLUGIN.ON_ACTIVE_SESSION_CB_ERROR, { error: e });
                        }
                    }
                    this.initStepTimers.stop(Track_1.InitStep.TIME_TO_SESSION_ACTIVATED);
                    break;
                }
            }
            // if we found an active session we can 'deactivate' the other initialized ones
            // and then clear them up. This will clear track events scheduled to be sent.
            if (this.activeSession) {
                this.initializedSessions.forEach(function (s) {
                    if (s != _this.activeSession)
                        s.getReportingInstance().then(function (ri) { return ri.deactivate(); });
                });
                this.initializedSessions.length = 0;
                return true;
            }
            // the requested manifest doesn't match any of the initialized one
            // so we log it and reset the hive session
            logger_hive_1.ErrorMonitor.getInstance().logError('No matching session found', this.loggerId, ErrorCodes.HIVE_COMM_PLUGIN.NO_MATCHING_SESSION, {
                playerSource: playerSource,
                initializedSessions: this.initializedSessions.map(function (initializedSession) { return initializedSession.manifest; })
            });
            this.resetSession(true);
        }
        return false;
    };
    Plugin.prototype.getActiveSession = function () {
        if (this.activeSession) {
            return this.activeSession.toHiveSession();
        }
    };
    /**
     * Call only when the HiveJava is activated!!
     * Close all the connections for HiveJs/Stats initialized sessions
     */
    Plugin.prototype.resetInitializedSessions = function () {
        this.initializedSessions.forEach(function (s) {
            if (s.reportingInstance) {
                s.close(true);
            }
        });
    };
    /**
     * true if the current watched manifest corresponds to the
     * active HiveSession
     * @returns {boolean}
     */
    Plugin.prototype.isSessionActive = function () {
        if (this.activeSession != null) {
            if (this.activeSession.isActive(this.getPlayerSource())) {
                return true;
            }
            else {
                var reason = 'Session src mismatch: ' + this.getPlayerSource() + ' != ' + this.activeSession.manifest;
                this.logger().warn(this.loggerId + reason);
                this.closeHiveSession(reason);
            }
        }
        return false;
    };
    /**
     * close the active session or the first initialized one.
     * @param completeClose true if we want to close completely the session
     * @param async {boolean} Flush the last track snapshot asynchronously. Defaults to true.
     */
    Plugin.prototype.onCloseSession = function (completeClose) {
        var _this = this;
        if (completeClose === void 0) { completeClose = false; }
        if (this.activeSession != null) {
            this.logger().notice(this.loggerId + 'Stopping session [' + this.activeSession.id + ']');
            this.activeSession.close(completeClose);
        }
        else if (this.initializedSessions.length > 0) {
            /*
             * fix to make sure that initialized sessions not yet activated (manifest problems or player errors)
             * are correctly reset on the Hive Java client on page refresh
             */
            this.initializedSessions.forEach(function (session) {
                _this.logger().notice(_this.loggerId + 'Attempt to stopping session [' + session.id + ']');
                session.close(completeClose);
            });
        }
        else {
            // Called when the plugin is stil in initializing phase
            stats_1.default.getInstance().close();
        }
    };
    // ------- STATS HANDLING -----------
    Plugin.prototype.startPeriodicFeedback = function () {
        var _this = this;
        if (this.periodicFeedbackEvent == null) {
            this.periodicFeedbackEvent = setInterval(function () {
                _this.sendStatsFeedback(true);
            }, this.options().feedbackPeriod);
            this.sendStatsFeedback();
        }
    };
    Plugin.prototype.stopPeriodicFeedback = function () {
        clearInterval(this.periodicFeedbackEvent);
        this.periodicFeedbackEvent = null;
    };
    Plugin.prototype.getPlayingTime = function (fromPeriodicInterval) {
        if (fromPeriodicInterval === void 0) { fromPeriodicInterval = false; }
        return this.playingStateCounter.getAndReset(undefined, fromPeriodicInterval ? this.options().feedbackPeriod : undefined);
    };
    Plugin.prototype.sendStatsFeedback = function (fromPeriodicInterval) {
        var _this = this;
        if (fromPeriodicInterval === void 0) { fromPeriodicInterval = false; }
        if (this.isSessionActive()) {
            // periodically check if the player is still active or disposed
            if (!this.isActive()) {
                this.resetSession(true);
                return;
            }
            var windowSize = this.getWindowSize();
            var stats = new HivePlayerStats_1.HivePlayerStats(this.getCurrentTime(), this.getBufferLen(), this.totalBufferingTime, windowSize.width, windowSize.height, this.isFullscreen(), this.getPlayingTime(fromPeriodicInterval), this.getPlayerVolume(), this.getCaptionLanguage());
            // we check each new player stats against the previous one.
            // if it has not changed for too long, we assume that the player is idle
            if (this.lastBufferingStart === 0) {
                this.activeSession.updateIdleState(this.statsChecker.check(stats));
            }
            // we always send stats, each tech knows how to handle them according to the
            // client state
            this.activeSession.tech.handleStats(this.activeSession, stats).fail(function (err) {
                _this.logger().warn(_this.loggerId + 'stats handling failed', err);
                _this.stopPeriodicFeedback();
            });
        }
    };
    /* -----------EVENTS--------- */
    Plugin.prototype.registerGenericEvents = function () {
        var _this = this;
        try {
            VisibilityChangeListener_1.VisibilityChangeListener.getInstance(this.logger()).setVisibilityChangeListener(function (visible) {
                // only notify visibility event if the session is not idle or they will trigger track events
                var session = _this.getPotentialSession();
                if (session && !session.isIdle()) {
                    _this.onEventFeedback(visible ? Track_1.PlayerEvents.VISIBLE : Track_1.PlayerEvents.HIDDEN);
                    _this.logger().debug(visible ? 'visible' : 'hidden');
                }
            });
        }
        catch (e) {
            logger_hive_1.ErrorMonitor.getInstance().logError('error setting up the visibilityChange listener', this.loggerId, ErrorCodes.HIVE_COMM_PLUGIN.NO_VISIBILITY_LISTENER, { error: e });
        }
    };
    /**
     * Handle a buffering started event.
     * @param sendEvent If falsey, will not count the event as a player track
     * event. Used when counting initial buffering,
     * @param [skipActiveCheck=false] If `true`, do not do an is-session-active check.
     * This is used when activating the session from WebRTC prior to the player
     * providing an API to retrieve current player source.
     */
    Plugin.prototype.onStartBuffering = function (sendEvent, skipActiveCheck) {
        if (skipActiveCheck === void 0) { skipActiveCheck = false; }
        if (skipActiveCheck || this.isSessionActive()) {
            if (this.lastBufferingStart <= 0) {
                this.lastBufferingStart = (Date.now());
                if (sendEvent == undefined || sendEvent) {
                    this.onEventFeedback(Track_1.PlayerEvents.BUFFERING);
                }
            }
        }
    };
    Plugin.prototype.onEndBuffering = function () {
        var initial = this.totalBufferingTime == 0;
        if (this.lastBufferingStart > 0) {
            var lastBufferingDuration = (Date.now()) - this.lastBufferingStart;
            this.totalBufferingTime += lastBufferingDuration;
            this.logger().debug(this.loggerId + 'reporting new buffering event of ' + lastBufferingDuration + ' ms');
            this.lastBufferingStart = 0;
            // if it is the end of the initial buffering, flush immediately the stats
            // feedback to Stats to correctly measure the initial playTS
            if (initial) {
                this.sendStatsFeedback();
            }
            return true;
        }
        return false;
    };
    Plugin.prototype.onError = function (errorCode, errorString, closeSession) {
        if (closeSession === void 0) { closeSession = true; }
        // We handle errors synchronously if we want to close the session
        this.onEventFeedback(Track_1.PlayerEvents.ERROR, { 'code': -1, 'player-code': errorCode }, !closeSession);
        if (closeSession) {
            this.closeHiveSession(errorString);
        }
    };
    Plugin.prototype.onEventFeedback = function (event, objEvent, async) {
        var _this = this;
        if (async === void 0) { async = true; }
        var session = this.getPotentialSession();
        if (session != null && (session == this.activeSession || session.tech.getName() !== techs_hive_1.Techs[techs_hive_1.Techs.HiveJava])) {
            switch (event) {
                case Track_1.PlayerEvents.PLAYING:
                    this.playingStateCounter.start();
                    break;
                case Track_1.PlayerEvents.PAUSED:
                case Track_1.PlayerEvents.SKIP:
                case Track_1.PlayerEvents.BUFFERING:
                case Track_1.PlayerEvents.STOPPED:
                    this.playingStateCounter.stop();
                    break;
            }
            session.tech.handleEvent(session, event, objEvent, async).fail(function (err) {
                _this.logger().warn(_this.loggerId + 'error in forwarding player event to tech', err);
            });
        }
    };
    Plugin.prototype.getInitStepTimers = function () {
        return this.initStepTimers;
    };
    Plugin.prototype.isDifferentEvent = function (event, eventData) {
        if (event !== this.lastEvent)
            return true;
        var eventDataKeys = eventData ? Object.keys(eventData) : [];
        if (eventDataKeys.length > 0) {
            for (var _i = 0, eventDataKeys_1 = eventDataKeys; _i < eventDataKeys_1.length; _i++) {
                var key = eventDataKeys_1[_i];
                if (eventData[key] !== this.lastEventData[key])
                    return true;
            }
        }
        return false;
    };
    /**
     * Default behaviour to filter events: filtered if equal to the last event.
     */
    Plugin.prototype.filterEvent = function (event, eventData) {
        if (this.isDifferentEvent(event, eventData)) {
            this.onEventFeedback(event, eventData);
        }
        this.lastEvent = event;
        this.lastEventData = eventData;
    };
    /**
     * return what could be the potential activate session. To use for handling events even when
     * a session has not been activated yet
     * @returns {HiveSessionInternal}
     */
    Plugin.prototype.getPotentialSession = function () {
        if (this.activeSession) {
            return this.activeSession;
        }
        if (this.initializedSessions && this.initializedSessions.length > 0) {
            return this.initializedSessions[0];
        }
    };
    /* ------------ Methods used for the Generation/Retrieval of the Plugin Status Code ----------- */
    /**
     * initialize the status code of teh plugin to 0x00000000
     */
    Plugin.prototype.initStatusCode = function () {
        this.statusCode = 0x00000000;
    };
    /**
     * set the status code according to the {@link MainStatusCode} and the tech used
     * the hexadecimal code is structured like this:
     *  0x 0 0 0 0 0 0 0 0
     *     7 6 5 4 3 2 1 0
     * The 7th position defines the overall status, specified by {@link MainStatusCode}
     * The positions from the 6th to the 0th define which Tech is active.
     * The {@link Techs} enumeration is used in order to calculate which position refers to which tech.
     * @param mainStatusCode
     * @param tech (optional, used only when the MainStatusCode is OK)
     */
    Plugin.prototype.setStatusCode = function (mainStatusCode, tech) {
        // for now we reset always the status code before setting it because we will return just the last error
        this.initStatusCode();
        // for the calculation of the status code we are using the bit shift to set the right value at
        // the right position.
        var mainStatusCodePosition = 7;
        var firstTechPosition = 6;
        this.statusCode += (mainStatusCode << (4 * mainStatusCodePosition));
        if (tech && mainStatusCode === 0) {
            this.statusCode += (0x1 << (4 * (firstTechPosition - techs_hive_1.Techs[tech.getName()])));
        }
        if (mainStatusCode > 0) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Status Code Error', this.loggerId, ErrorCodes.HIVE_COMM_PLUGIN.STATUS_CODE, { code: common_hive_1.mainStatusCodeToString(mainStatusCode) }, ['Plugin Error Code', common_hive_1.mainStatusCodeToString(mainStatusCode)]);
        }
    };
    /**
     * returns the current status code of the plugin
     * @returns {number}
     */
    Plugin.prototype.getStatusCode = function () {
        return this.statusCode;
    };
    /**
     * returns the configured telemetryId passed
     * in the Hive Plugin initialization options
     * @returns {string}
     */
    Plugin.prototype.getTelemetryId = function () {
        var telemetryId = this.options().telemetryId;
        var type = typeof telemetryId;
        if (type === 'number' || type === 'string') {
            return String(telemetryId);
        }
        else if (telemetryId != null) {
            this.logger().warn(this.loggerId + " telemetryId is accepted with type 'number' or 'string'. Provided '" + type + "' is invalid.");
        }
    };
    Plugin.prototype.getPluginName = function () {
        return build_defaults_1.BuildParameters.PLUGIN_NAME;
    };
    Plugin.prototype.getPluginVersion = function () {
        return build_defaults_1.BuildParameters.PLUGIN_VERSION;
    };
    Plugin.prototype.getPlayerName = function () {
        return PLAYER_NAME;
    };
    /* --------- METHODS TO BE IMPLEMENTED BY THE PLAYER MODULE -------- */
    Plugin.prototype.getEventName = function () {
        var _a;
        return (_a = this.eventName) !== null && _a !== void 0 ? _a : this.options_.eventName;
    };
    Plugin.prototype.getConsumptionApp = function () {
        return window.location.hostname;
    };
    // Currently only implemented in amp / stream. See PENG-617
    Plugin.prototype.getPlayerVolume = function () {
        return undefined;
    };
    // Currently only implemented in html5. See PENG-1849
    Plugin.prototype.getCaptionLanguage = function () {
        return undefined;
    };
    Plugin.prototype.getTextTracks = function () {
        return undefined;
    };
    return Plugin;
}());
exports.Plugin = Plugin;
// We keep HiveRequestFactory on the window because certain scenarios require this globally (eg. hive xhr interceptor)
if (typeof window != 'undefined') {
    window['HiveRequestFactory'] = HiveRequestFactory_1.HiveRequestFactory;
}
exports.PluginErrorCodes = ErrorCodes.HIVE_COMM_PLUGIN;
function logError(message, loggerIdOrData, detailedErrorCode, customData, tags) {
    var instance = logger_hive_1.ErrorMonitor.getInstance();
    instance.logError.apply(instance, arguments);
}
exports.logError = logError;
//# sourceMappingURL=comm.hive.js.map

/***/ }),

/***/ "../../../core/build/core/src/common/common.hive.js":
/*!***************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/common/common.hive.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.HivePluginReference = exports.mainStatusCodeToString = exports.MainStatusCode = exports.HiveTechErrorCode = exports.HiveTechError = exports.HiveSessionError = exports.HiveSessionErrorCode = exports.HiveSession = exports.HivePartnerStats = exports.HiveClientStats = void 0;
/**
 * Container of local client statistics. These statistics are passed to the HiveJS option's
 * {@link HiveRenderStatsCallback} via {@link HiveJSOptions.renderStatsCallback}
 */
var HiveClientStats = /** @class */ (function () {
    function HiveClientStats() {
        /**
         * Percent savings, defined as `p2pResponseBytes / (cdnResponseBytes + p2pResponseBytes)`
         */
        this.savings = 0;
        /**
         * Number of requests made to CDN.
         */
        this.cdnRequests = 0;
        /**
         * Number of successful responses received from CDN.
        */
        this.cdnResponses = 0;
        /**
         * Number of error responses (4xx, etc) received from CDN.
         */
        this.cdnResponseErrors = 0;
        /**
         * Number of received bytes from CDN.
         */
        this.cdnResponseBytes = 0;
        /**
         * Number of requests to P2P network.
         */
        this.p2pRequests = 0;
        /**
         * Number of responses from P2P network.
         */
        this.p2pResponses = 0;
        /**
         * Number of error responses (timeouts, etc) received from P2P network.
         */
        this.p2pResponseErrors = 0;
        /**
         * Number of received bytes from P2P network.
         */
        this.p2pResponseBytes = 0;
        /**
         * Number of bytes sent to other viewers
         */
        this.p2pPartnerTotalSentBytes = 0;
        /**
         * An object containing information about the current session's involvement
         * with the P2P network. Each key represents a unique peering partner.
         */
        this.partners = {};
    }
    return HiveClientStats;
}());
exports.HiveClientStats = HiveClientStats;
/**
 * Container for local client partners statistics.
 */
var HivePartnerStats = /** @class */ (function () {
    function HivePartnerStats() {
        /**
         * UUID of peering partner.
         */
        this.uuid = '';
        /**
         * Number of bytes sent to this peer.
         */
        this.sentBytes = 0;
        /**
         * Number of bytes received from this peer.
         */
        this.receivedBytes = 0;
        /**
         * Number of successful requests from this peer.
         */
        this.successTransfers = 0;
        /**
         * Number of failed requests from this peer.
         */
        this.failedTransfers = 0;
        /**
         * received rate from this peer in Bps
         */
        this.rateReceived = 0;
        /**
         * time we last updated info from this peer
         */
        this.lastUpdated = 0;
    }
    return HivePartnerStats;
}());
exports.HivePartnerStats = HivePartnerStats;
/**
 * Object containing information about the initialized Hive Session
 */
var HiveSession = /** @class */ (function () {
    function HiveSession() {
    }
    return HiveSession;
}());
exports.HiveSession = HiveSession;
/**
 * Error codes for failure in initializing Hive Sessions
 */
var HiveSessionErrorCode;
(function (HiveSessionErrorCode) {
    /**
     * Generic Undefined Error
     */
    HiveSessionErrorCode[HiveSessionErrorCode["GENERIC_ERROR"] = 0] = "GENERIC_ERROR";
    /**
     * No Tech available to resolve the ticket
     */
    HiveSessionErrorCode[HiveSessionErrorCode["NO_TECH_AVAILABLE"] = 1] = "NO_TECH_AVAILABLE";
    /**
     * No available Tech could resolved the ticket
     */
    HiveSessionErrorCode[HiveSessionErrorCode["NO_TECH_RESOLVED"] = 2] = "NO_TECH_RESOLVED";
    /**
     * Stopped resolving session on last tech onError
     */
    HiveSessionErrorCode[HiveSessionErrorCode["TECH_ERROR"] = 3] = "TECH_ERROR";
    /**
     * The ticket could not be resolved
     */
    HiveSessionErrorCode[HiveSessionErrorCode["TICKET_ERROR"] = 4] = "TICKET_ERROR";
})(HiveSessionErrorCode = exports.HiveSessionErrorCode || (exports.HiveSessionErrorCode = {}));
/**
 * Error messages corresponding to the HiveSessionErrorCode
 */
var HiveSessionErrorString;
(function (HiveSessionErrorString) {
    HiveSessionErrorString[HiveSessionErrorString["Generic Undefined Error"] = 0] = "Generic Undefined Error";
    HiveSessionErrorString[HiveSessionErrorString["No Tech available to resolve the ticket"] = 1] = "No Tech available to resolve the ticket";
    HiveSessionErrorString[HiveSessionErrorString["No available Tech could resolved the ticket"] = 2] = "No available Tech could resolved the ticket";
    HiveSessionErrorString[HiveSessionErrorString["Stopped resolving session on last tech onError"] = 3] = "Stopped resolving session on last tech onError";
    HiveSessionErrorString[HiveSessionErrorString["The ticket could not be resolved"] = 4] = "The ticket could not be resolved";
})(HiveSessionErrorString || (HiveSessionErrorString = {}));
/**
 * Object containing information for failure in initializing Hive Session
 */
var HiveSessionError = /** @class */ (function () {
    function HiveSessionError() {
    }
    /**
     * get the Hive Session Error Message corresponding to a certain error code
     * @param code
     * @returns {string}
     */
    HiveSessionError.getHiveSessionErrorMessage = function (code) {
        return HiveSessionErrorString[code];
    };
    HiveSessionError.getHiveSessionError = function (ticketUrl, code, detailedMessage) {
        var err = new HiveSessionError();
        err.ticketUrl = ticketUrl;
        err.code = code;
        err.message = HiveSessionError.getHiveSessionErrorMessage(code);
        err.detailedMessage = detailedMessage;
        return err;
    };
    HiveSessionError.HiveSessionErrorCode = HiveSessionErrorCode;
    return HiveSessionError;
}());
exports.HiveSessionError = HiveSessionError;
/**
 * Object containing information about the Hive Tech Error that prevented
 * the initialization of a Hive Session
 */
var HiveTechError = /** @class */ (function () {
    function HiveTechError(errCode, errMsg) {
        this.code = errCode;
        this.message = errMsg;
    }
    return HiveTechError;
}());
exports.HiveTechError = HiveTechError;
/**
 * Internal code of the Hive Tech Error
 */
var HiveTechErrorCode;
(function (HiveTechErrorCode) {
    /**
     * the tech is not ready to resolve the ticket or initialize a HiveSession
     */
    HiveTechErrorCode[HiveTechErrorCode["NOT_READY"] = 0] = "NOT_READY";
    /**
     * generic unspecified plugin error
     */
    HiveTechErrorCode[HiveTechErrorCode["PLUGIN_ERROR"] = 1] = "PLUGIN_ERROR";
    /**
     * an error happened while initializing the HiveSession
     */
    HiveTechErrorCode[HiveTechErrorCode["SESSION_ERROR"] = 2] = "SESSION_ERROR";
    /**
     * an error happened while resolving/verifying the ticket
     */
    HiveTechErrorCode[HiveTechErrorCode["TICKET_ERROR"] = 3] = "TICKET_ERROR";
    /**
     * the tech doesn't satisfy the minimum version requirement
     */
    HiveTechErrorCode[HiveTechErrorCode["VERSION_ERROR"] = 4] = "VERSION_ERROR";
    /**
     * the tech didn't initialized the ticket before the timeout
     */
    HiveTechErrorCode[HiveTechErrorCode["TIMEOUT_ERROR"] = 5] = "TIMEOUT_ERROR";
    /**
     * the Booster is present and active, therefore falling back to HiveJs + Booster
     */
    HiveTechErrorCode[HiveTechErrorCode["BOOSTER_PRESENT"] = 6] = "BOOSTER_PRESENT";
})(HiveTechErrorCode = exports.HiveTechErrorCode || (exports.HiveTechErrorCode = {}));
/**
 * This is the main status code, which will be used to generate the first 4 bits of the plugin status code
 */
var MainStatusCode;
(function (MainStatusCode) {
    /**
     * The plugin initialization completed without errors
     */
    MainStatusCode[MainStatusCode["OK"] = 0] = "OK";
    /**
     * The plugin is not allowed as SDN (only for AMP)
     */
    MainStatusCode[MainStatusCode["HIVE_NOT_ALLOWED"] = 1] = "HIVE_NOT_ALLOWED";
    /**
     * It was not possible to resolve the ticket with the specified techs
     */
    MainStatusCode[MainStatusCode["TICKET_NOT_RESOLVED"] = 2] = "TICKET_NOT_RESOLVED";
    /**
     * The plugin initialization and ticket resolving process timed out
     */
    MainStatusCode[MainStatusCode["TIMEOUT_RESOLVING_TICKET"] = 3] = "TIMEOUT_RESOLVING_TICKET";
})(MainStatusCode = exports.MainStatusCode || (exports.MainStatusCode = {}));
/** This function was created in order to make the above {@link MainStatusCode} enum constant */
function mainStatusCodeToString(code) {
    switch (code) {
        case MainStatusCode.OK: return 'OK';
        case MainStatusCode.HIVE_NOT_ALLOWED: return 'HIVE_NOT_ALLOWED';
        case MainStatusCode.TICKET_NOT_RESOLVED: return 'TICKET_NOT_RESOLVED';
        case MainStatusCode.TIMEOUT_RESOLVING_TICKET: return 'TIMEOUT_RESOLVING_TICKET';
        default: return undefined;
    }
}
exports.mainStatusCodeToString = mainStatusCodeToString;
/**
 * Reference to the Hive Plugin
 */
var HivePluginReference = /** @class */ (function () {
    function HivePluginReference(hivePlugin) {
        this.hivePlugin = hivePlugin;
    }
    /**
     * return the plugin status code generated by the Plugin Status Code Generator
     * @returns {number}
     */
    HivePluginReference.prototype.getPluginStatusCode = function () {
        return this.hivePlugin.getStatusCode();
    };
    return HivePluginReference;
}());
exports.HivePluginReference = HivePluginReference;
//# sourceMappingURL=common.hive.js.map

/***/ }),

/***/ "../../../core/build/core/src/common/constants.hive.js":
/*!******************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/common/constants.hive.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Constants = void 0;
/**
 * generic constants and defaults
 */
var Constants = /** @class */ (function () {
    function Constants() {
    }
    Constants.IS_HTTPS = typeof location !== 'undefined' ? location.protocol === 'https:' : false;
    Constants.DEFAULT_SESSION_CHECK = true;
    Constants.SILENT_FEEDBACK_PERIOD = 10000;
    Constants.DEFAULT_IDLE_TIME_PERIOD = 60000;
    Constants.SILENT_TEST_ID_HEADER_KEY = 'X-Hive-TestId';
    return Constants;
}());
exports.Constants = Constants;
//# sourceMappingURL=constants.hive.js.map

/***/ }),

/***/ "../../../core/build/core/src/common/error.hive.js":
/*!**************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/common/error.hive.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var _a, _b;
Object.defineProperty(exports, "__esModule", { value: true });
exports.SeverityMap = exports.ErrorMessages = exports.GENERIC_ERROR = exports.LOCALITY_SERVICE_CODES = exports.HIVE_STREAM_CHECKER_CODES = exports.LOCALITY_CODES = exports.HIVE_COMM_PLUGIN = exports.HIVE_SERVICES_CODES = exports.PEER_CODES = exports.OBJECT_INDEX_CODES = exports.HIVE_CACHE_CODES = exports.FALLBACK_REQUESTER_CODES = exports.PREFETCHER_CODES = exports.PARTNER_CODES = exports.IP_SPOOFING_CODES = exports.P2P_RESPONDER_CODES = exports.P2P_REQUESTER_CODES = exports.FRAGMENT_SENDER_CODES = exports.FRAGMENT_REQUESTER_CODES = exports.PICKER_EXT_CODES = exports.PICKER_SINGLE_CODES = exports.TRACKER_CLIENT_MANAGER_CODES = exports.TRACKER_CLIENT_CODES = exports.VIDEO_CONTEXT_BASE_CODES = exports.TIMER_HANDLE_CODES = exports.HLS_METADATA_CODES = exports.HLS_CONTEXT_CODES = exports.DASH_METADATA_CODES = exports.DASH_CONTEXT_CODES = exports.DASH_AES_MANAGER_CODES = exports.CHUNK_HANDLER_CODES = exports.THROUGHPUT_PARTNER_SELECTION_CODES = exports.DELTA_PARTNER_SELECTION_CODES = exports.SCORE_PARTNER_SELECTION_CODES = exports.RANDOM_PARTNER_SELECTION_CODES = exports.BASE_PARTNER_SELECTION_CODES = exports.PARTNERSHIP_CODES = exports.BASE_PARTNERSHIP_CODES = exports.MEMBERSHIP_CODES = exports.VOD_CACHE_CODES = exports.LIVE_CACHE_CODES = exports.CACHE_CODES = exports.DISPATCHER_MANAGER_CODES = exports.P2P_TRASNSPORT_CODES = exports.P2P_DISPATCHER_CODES = exports.CHANNEL_MANAGER_CODES = exports.CHANNEL_CODES = exports.NETWORK_MANAGER_CODES = exports.HiveSeverity = void 0;
var HiveSeverity;
(function (HiveSeverity) {
    HiveSeverity[HiveSeverity["NORMAL"] = 0] = "NORMAL";
    HiveSeverity[HiveSeverity["HIGH"] = 1] = "HIGH";
    HiveSeverity[HiveSeverity["CRITICAL"] = 2] = "CRITICAL";
})(HiveSeverity = exports.HiveSeverity || (exports.HiveSeverity = {}));
var NETWORK_MANAGER_CODES;
(function (NETWORK_MANAGER_CODES) {
    NETWORK_MANAGER_CODES[NETWORK_MANAGER_CODES["BASE_CODE"] = 268435456] = "BASE_CODE";
    NETWORK_MANAGER_CODES[NETWORK_MANAGER_CODES["FIRE_SERVER_CONNECTED_WITH_SWARM"] = 268435457] = "FIRE_SERVER_CONNECTED_WITH_SWARM";
    NETWORK_MANAGER_CODES[NETWORK_MANAGER_CODES["FIRE_SERVER_CONNECTED_WITHOUT_SWARM"] = 268435458] = "FIRE_SERVER_CONNECTED_WITHOUT_SWARM";
    NETWORK_MANAGER_CODES[NETWORK_MANAGER_CODES["CONNECTION_NOT_ESTABLISHED"] = 268435459] = "CONNECTION_NOT_ESTABLISHED";
    NETWORK_MANAGER_CODES[NETWORK_MANAGER_CODES["SEND_MESSAGE_TO_NON_EXISTING_CHANNEL"] = 268435460] = "SEND_MESSAGE_TO_NON_EXISTING_CHANNEL";
    NETWORK_MANAGER_CODES[NETWORK_MANAGER_CODES["RECEIVED_MESSAGE_FROM_NON_EXISTING_CONNECTION"] = 268435461] = "RECEIVED_MESSAGE_FROM_NON_EXISTING_CONNECTION";
})(NETWORK_MANAGER_CODES = exports.NETWORK_MANAGER_CODES || (exports.NETWORK_MANAGER_CODES = {}));
var CHANNEL_CODES;
(function (CHANNEL_CODES) {
    CHANNEL_CODES[CHANNEL_CODES["BASE_CODE"] = 536870912] = "BASE_CODE";
    CHANNEL_CODES[CHANNEL_CODES["CREATE_OFFER"] = 536870913] = "CREATE_OFFER";
    CHANNEL_CODES[CHANNEL_CODES["CREATE_ANSWER"] = 536870914] = "CREATE_ANSWER";
    CHANNEL_CODES[CHANNEL_CODES["SIGNALING_STATE_CLOSED"] = 536870915] = "SIGNALING_STATE_CLOSED";
    CHANNEL_CODES[CHANNEL_CODES["SET_LOCAL_DESCRIPTION_FAILED"] = 536870916] = "SET_LOCAL_DESCRIPTION_FAILED";
    CHANNEL_CODES[CHANNEL_CODES["NEGOTIATION_FAILURE"] = 536870917] = "NEGOTIATION_FAILURE";
    CHANNEL_CODES[CHANNEL_CODES["SETUP_CHANNEL_ERROR"] = 536870918] = "SETUP_CHANNEL_ERROR";
    CHANNEL_CODES[CHANNEL_CODES["ICE_CONNECTION_FAILED"] = 536870919] = "ICE_CONNECTION_FAILED";
    CHANNEL_CODES[CHANNEL_CODES["SET_REMOTE_DESCRIPTION"] = 536870920] = "SET_REMOTE_DESCRIPTION";
    CHANNEL_CODES[CHANNEL_CODES["UPDATE_ICE_CANDIDATES"] = 536870921] = "UPDATE_ICE_CANDIDATES";
    CHANNEL_CODES[CHANNEL_CODES["ANSWER_RECEIVED"] = 536870922] = "ANSWER_RECEIVED";
    CHANNEL_CODES[CHANNEL_CODES["OFFER_RECEIVED"] = 536870923] = "OFFER_RECEIVED";
    CHANNEL_CODES[CHANNEL_CODES["SEND_CANDIDATES"] = 536870924] = "SEND_CANDIDATES";
    CHANNEL_CODES[CHANNEL_CODES["CLOSE_CONNECTION"] = 536870925] = "CLOSE_CONNECTION";
    CHANNEL_CODES[CHANNEL_CODES["SEND_DATA"] = 536870926] = "SEND_DATA";
})(CHANNEL_CODES = exports.CHANNEL_CODES || (exports.CHANNEL_CODES = {}));
var CHANNEL_MANAGER_CODES;
(function (CHANNEL_MANAGER_CODES) {
    CHANNEL_MANAGER_CODES[CHANNEL_MANAGER_CODES["BASE_CODE"] = 805306368] = "BASE_CODE";
    CHANNEL_MANAGER_CODES[CHANNEL_MANAGER_CODES["SEND_MSG_WITHOUT_CHANNEL"] = 805306369] = "SEND_MSG_WITHOUT_CHANNEL";
    CHANNEL_MANAGER_CODES[CHANNEL_MANAGER_CODES["MSG_TRIGGER_ERROR"] = 805306370] = "MSG_TRIGGER_ERROR";
    CHANNEL_MANAGER_CODES[CHANNEL_MANAGER_CODES["CONNECTION_TIMEOUT"] = 805306371] = "CONNECTION_TIMEOUT";
})(CHANNEL_MANAGER_CODES = exports.CHANNEL_MANAGER_CODES || (exports.CHANNEL_MANAGER_CODES = {}));
var P2P_DISPATCHER_CODES;
(function (P2P_DISPATCHER_CODES) {
    P2P_DISPATCHER_CODES[P2P_DISPATCHER_CODES["BASE_CODE"] = 1073741824] = "BASE_CODE";
    P2P_DISPATCHER_CODES[P2P_DISPATCHER_CODES["CLOSE_CONNECTION"] = 1073741825] = "CLOSE_CONNECTION";
    P2P_DISPATCHER_CODES[P2P_DISPATCHER_CODES["P2P_DISPATCHER_ERROR"] = 1073741826] = "P2P_DISPATCHER_ERROR";
})(P2P_DISPATCHER_CODES = exports.P2P_DISPATCHER_CODES || (exports.P2P_DISPATCHER_CODES = {}));
var P2P_TRASNSPORT_CODES;
(function (P2P_TRASNSPORT_CODES) {
    P2P_TRASNSPORT_CODES[P2P_TRASNSPORT_CODES["BASE_CODE"] = 1342177280] = "BASE_CODE";
    P2P_TRASNSPORT_CODES[P2P_TRASNSPORT_CODES["CONSTRUCT_MESSAGE"] = 1342177281] = "CONSTRUCT_MESSAGE";
    P2P_TRASNSPORT_CODES[P2P_TRASNSPORT_CODES["DROPPED_MESSAGE"] = 1342177282] = "DROPPED_MESSAGE";
    P2P_TRASNSPORT_CODES[P2P_TRASNSPORT_CODES["SEND_MESSAGE"] = 1342177283] = "SEND_MESSAGE";
    P2P_TRASNSPORT_CODES[P2P_TRASNSPORT_CODES["RECEIVE_MESSAGE"] = 1342177284] = "RECEIVE_MESSAGE";
})(P2P_TRASNSPORT_CODES = exports.P2P_TRASNSPORT_CODES || (exports.P2P_TRASNSPORT_CODES = {}));
var DISPATCHER_MANAGER_CODES;
(function (DISPATCHER_MANAGER_CODES) {
    DISPATCHER_MANAGER_CODES[DISPATCHER_MANAGER_CODES["BASE_CODE"] = 1610612736] = "BASE_CODE";
    DISPATCHER_MANAGER_CODES[DISPATCHER_MANAGER_CODES["NEW_DISPATCHER"] = 1610612737] = "NEW_DISPATCHER";
})(DISPATCHER_MANAGER_CODES = exports.DISPATCHER_MANAGER_CODES || (exports.DISPATCHER_MANAGER_CODES = {}));
var CACHE_CODES;
(function (CACHE_CODES) {
    CACHE_CODES[CACHE_CODES["BASE_CODE"] = 1879048192] = "BASE_CODE";
    CACHE_CODES[CACHE_CODES["INIT_CACHE"] = 1879048193] = "INIT_CACHE";
    CACHE_CODES[CACHE_CODES["PUT_OPERATION"] = 1879048194] = "PUT_OPERATION";
    CACHE_CODES[CACHE_CODES["GET_OPERATION"] = 1879048195] = "GET_OPERATION";
    CACHE_CODES[CACHE_CODES["CONTAINS_OPERATION"] = 1879048196] = "CONTAINS_OPERATION";
    CACHE_CODES[CACHE_CODES["GET_KEYS_OPERATION"] = 1879048197] = "GET_KEYS_OPERATION";
    CACHE_CODES[CACHE_CODES["GET_ELEMENTS_OPERATION"] = 1879048198] = "GET_ELEMENTS_OPERATION";
})(CACHE_CODES = exports.CACHE_CODES || (exports.CACHE_CODES = {}));
var LIVE_CACHE_CODES;
(function (LIVE_CACHE_CODES) {
    LIVE_CACHE_CODES[LIVE_CACHE_CODES["BASE_CODE"] = 2147483648] = "BASE_CODE";
    LIVE_CACHE_CODES[LIVE_CACHE_CODES["PUT_OPERATION"] = 2147483649] = "PUT_OPERATION";
    LIVE_CACHE_CODES[LIVE_CACHE_CODES["GET_OPERATION"] = 2147483650] = "GET_OPERATION";
    LIVE_CACHE_CODES[LIVE_CACHE_CODES["CONTAINS_OPERATION"] = 2147483651] = "CONTAINS_OPERATION";
    LIVE_CACHE_CODES[LIVE_CACHE_CODES["GET_KEYS_OPERATION"] = 2147483652] = "GET_KEYS_OPERATION";
    LIVE_CACHE_CODES[LIVE_CACHE_CODES["GET_ELEMENTS_OPERATION"] = 2147483653] = "GET_ELEMENTS_OPERATION";
    LIVE_CACHE_CODES[LIVE_CACHE_CODES["PURGE_CACHE_OPERATION"] = 2147483654] = "PURGE_CACHE_OPERATION";
})(LIVE_CACHE_CODES = exports.LIVE_CACHE_CODES || (exports.LIVE_CACHE_CODES = {}));
var VOD_CACHE_CODES;
(function (VOD_CACHE_CODES) {
    VOD_CACHE_CODES[VOD_CACHE_CODES["BASE_CODE"] = 2415919104] = "BASE_CODE";
})(VOD_CACHE_CODES = exports.VOD_CACHE_CODES || (exports.VOD_CACHE_CODES = {}));
var MEMBERSHIP_CODES;
(function (MEMBERSHIP_CODES) {
    MEMBERSHIP_CODES[MEMBERSHIP_CODES["BASE_CODE"] = 2684354560] = "BASE_CODE";
    MEMBERSHIP_CODES[MEMBERSHIP_CODES["DISCOVERED_PEERS"] = 2684354561] = "DISCOVERED_PEERS";
    MEMBERSHIP_CODES[MEMBERSHIP_CODES["LEADER_ELECTION"] = 2684354562] = "LEADER_ELECTION";
    MEMBERSHIP_CODES[MEMBERSHIP_CODES["GC_MEMBERS"] = 2684354563] = "GC_MEMBERS";
    MEMBERSHIP_CODES[MEMBERSHIP_CODES["ADD_LAN_MEMBER"] = 2684354564] = "ADD_LAN_MEMBER";
    MEMBERSHIP_CODES[MEMBERSHIP_CODES["ADD_RANDOM_MEMBER"] = 2684354565] = "ADD_RANDOM_MEMBER";
    MEMBERSHIP_CODES[MEMBERSHIP_CODES["SAMPLE_MEMBERSHIP"] = 2684354566] = "SAMPLE_MEMBERSHIP";
})(MEMBERSHIP_CODES = exports.MEMBERSHIP_CODES || (exports.MEMBERSHIP_CODES = {}));
var BASE_PARTNERSHIP_CODES;
(function (BASE_PARTNERSHIP_CODES) {
    BASE_PARTNERSHIP_CODES[BASE_PARTNERSHIP_CODES["BASE_CODE"] = 2952790016] = "BASE_CODE";
    BASE_PARTNERSHIP_CODES[BASE_PARTNERSHIP_CODES["SEND_ALL_HAVES"] = 2952790017] = "SEND_ALL_HAVES";
    BASE_PARTNERSHIP_CODES[BASE_PARTNERSHIP_CODES["SEND_HAVE"] = 2952790018] = "SEND_HAVE";
    BASE_PARTNERSHIP_CODES[BASE_PARTNERSHIP_CODES["UNKNOWN_HAVE"] = 2952790019] = "UNKNOWN_HAVE";
    BASE_PARTNERSHIP_CODES[BASE_PARTNERSHIP_CODES["UNKNOWN_HAVES"] = 2952790020] = "UNKNOWN_HAVES";
    BASE_PARTNERSHIP_CODES[BASE_PARTNERSHIP_CODES["RECEIVED_HAVE"] = 2952790021] = "RECEIVED_HAVE";
    BASE_PARTNERSHIP_CODES[BASE_PARTNERSHIP_CODES["RECEIVED_HAVES"] = 2952790022] = "RECEIVED_HAVES";
    BASE_PARTNERSHIP_CODES[BASE_PARTNERSHIP_CODES["NO_OUT_PARTNER"] = 2952790023] = "NO_OUT_PARTNER";
    BASE_PARTNERSHIP_CODES[BASE_PARTNERSHIP_CODES["CREATE_RANDOM_BUFFER"] = 2952790024] = "CREATE_RANDOM_BUFFER";
    BASE_PARTNERSHIP_CODES[BASE_PARTNERSHIP_CODES["REQUEST_PING"] = 2952790025] = "REQUEST_PING";
    BASE_PARTNERSHIP_CODES[BASE_PARTNERSHIP_CODES["RECEIVED_PING"] = 2952790026] = "RECEIVED_PING";
    BASE_PARTNERSHIP_CODES[BASE_PARTNERSHIP_CODES["UNKNOWN_PING"] = 2952790027] = "UNKNOWN_PING";
    BASE_PARTNERSHIP_CODES[BASE_PARTNERSHIP_CODES["SEND_PONG"] = 2952790028] = "SEND_PONG";
    BASE_PARTNERSHIP_CODES[BASE_PARTNERSHIP_CODES["UNKOWN_PONG"] = 2952790029] = "UNKOWN_PONG";
    BASE_PARTNERSHIP_CODES[BASE_PARTNERSHIP_CODES["WRONG_PONG_SIZE"] = 2952790030] = "WRONG_PONG_SIZE";
    BASE_PARTNERSHIP_CODES[BASE_PARTNERSHIP_CODES["WRONG_TIMESTAMP"] = 2952790031] = "WRONG_TIMESTAMP";
    BASE_PARTNERSHIP_CODES[BASE_PARTNERSHIP_CODES["RECEIVED_PONG"] = 2952790032] = "RECEIVED_PONG";
    BASE_PARTNERSHIP_CODES[BASE_PARTNERSHIP_CODES["COLLECT_PARTNER_SNAPSHOTS"] = 2952790033] = "COLLECT_PARTNER_SNAPSHOTS";
})(BASE_PARTNERSHIP_CODES = exports.BASE_PARTNERSHIP_CODES || (exports.BASE_PARTNERSHIP_CODES = {}));
var PARTNERSHIP_CODES;
(function (PARTNERSHIP_CODES) {
    PARTNERSHIP_CODES[PARTNERSHIP_CODES["BASE_CODE"] = 3221225472] = "BASE_CODE";
    PARTNERSHIP_CODES[PARTNERSHIP_CODES["START_PARTNERSHIP"] = 3221225473] = "START_PARTNERSHIP";
    PARTNERSHIP_CODES[PARTNERSHIP_CODES["NEW_LAN_MEMBER"] = 3221225474] = "NEW_LAN_MEMBER";
    PARTNERSHIP_CODES[PARTNERSHIP_CODES["IN_PARTNER_CHOICE"] = 3221225475] = "IN_PARTNER_CHOICE";
    PARTNERSHIP_CODES[PARTNERSHIP_CODES["IN_PARTNER_ADD_PROCESS"] = 3221225476] = "IN_PARTNER_ADD_PROCESS";
    PARTNERSHIP_CODES[PARTNERSHIP_CODES["IN_PARTNER_CONNECT"] = 3221225477] = "IN_PARTNER_CONNECT";
    PARTNERSHIP_CODES[PARTNERSHIP_CODES["IN_PARTNERSHIP_REQUEST"] = 3221225478] = "IN_PARTNERSHIP_REQUEST";
    PARTNERSHIP_CODES[PARTNERSHIP_CODES["OUT_PARNTERSHIP_REQUEST_PROCESS"] = 3221225479] = "OUT_PARNTERSHIP_REQUEST_PROCESS";
    PARTNERSHIP_CODES[PARTNERSHIP_CODES["CONSTRUCT_DISCOVER_PEER_INFO"] = 3221225480] = "CONSTRUCT_DISCOVER_PEER_INFO";
    PARTNERSHIP_CODES[PARTNERSHIP_CODES["SEND_PARTN_RESP"] = 3221225481] = "SEND_PARTN_RESP";
    PARTNERSHIP_CODES[PARTNERSHIP_CODES["NEW_IN_PARTNER_TO_LIST"] = 3221225482] = "NEW_IN_PARTNER_TO_LIST";
    PARTNERSHIP_CODES[PARTNERSHIP_CODES["REMOVE_DISCONNECTED_PEER"] = 3221225483] = "REMOVE_DISCONNECTED_PEER";
    PARTNERSHIP_CODES[PARTNERSHIP_CODES["REMOVE_IN_PARTNER"] = 3221225484] = "REMOVE_IN_PARTNER";
    PARTNERSHIP_CODES[PARTNERSHIP_CODES["CLOSE_RECEIVED"] = 3221225485] = "CLOSE_RECEIVED";
    PARTNERSHIP_CODES[PARTNERSHIP_CODES["SEND_PART_REQUEST"] = 3221225486] = "SEND_PART_REQUEST";
    PARTNERSHIP_CODES[PARTNERSHIP_CODES["PART_REQUEST_EXPIRED"] = 3221225487] = "PART_REQUEST_EXPIRED";
    PARTNERSHIP_CODES[PARTNERSHIP_CODES["UNKNOWN_PARTNERSHIP_REQUEST_EXPIRED"] = 3221225488] = "UNKNOWN_PARTNERSHIP_REQUEST_EXPIRED";
    PARTNERSHIP_CODES[PARTNERSHIP_CODES["UNKNOWN_OUT_PART_RESP"] = 3221225489] = "UNKNOWN_OUT_PART_RESP";
    PARTNERSHIP_CODES[PARTNERSHIP_CODES["CLOSE_PARTNERSHIP"] = 3221225490] = "CLOSE_PARTNERSHIP";
    PARTNERSHIP_CODES[PARTNERSHIP_CODES["ANNOUNCE_QUALITY_LEVEL"] = 3221225491] = "ANNOUNCE_QUALITY_LEVEL";
    PARTNERSHIP_CODES[PARTNERSHIP_CODES["CONSTRUCT_ANNOUNCE_QUALITY_LEVEL_MSG"] = 3221225492] = "CONSTRUCT_ANNOUNCE_QUALITY_LEVEL_MSG";
    PARTNERSHIP_CODES[PARTNERSHIP_CODES["RECEIVE_QUALITY_LEVEL_INFO"] = 3221225493] = "RECEIVE_QUALITY_LEVEL_INFO";
    PARTNERSHIP_CODES[PARTNERSHIP_CODES["PEER_INFO_RECEIVED"] = 3221225494] = "PEER_INFO_RECEIVED";
    PARTNERSHIP_CODES[PARTNERSHIP_CODES["PEER_INFO_ANNOUNCED"] = 3221225495] = "PEER_INFO_ANNOUNCED";
    PARTNERSHIP_CODES[PARTNERSHIP_CODES["COLLECT_ALL_PARTNERS"] = 3221225496] = "COLLECT_ALL_PARTNERS";
})(PARTNERSHIP_CODES = exports.PARTNERSHIP_CODES || (exports.PARTNERSHIP_CODES = {}));
var BASE_PARTNER_SELECTION_CODES;
(function (BASE_PARTNER_SELECTION_CODES) {
    BASE_PARTNER_SELECTION_CODES[BASE_PARTNER_SELECTION_CODES["BASE_CODE"] = 3489660928] = "BASE_CODE";
    BASE_PARTNER_SELECTION_CODES[BASE_PARTNER_SELECTION_CODES["UPDATE_IN_PARTNERS"] = 3489660929] = "UPDATE_IN_PARTNERS";
})(BASE_PARTNER_SELECTION_CODES = exports.BASE_PARTNER_SELECTION_CODES || (exports.BASE_PARTNER_SELECTION_CODES = {}));
var RANDOM_PARTNER_SELECTION_CODES;
(function (RANDOM_PARTNER_SELECTION_CODES) {
    RANDOM_PARTNER_SELECTION_CODES[RANDOM_PARTNER_SELECTION_CODES["BASE_CODE"] = 3758096384] = "BASE_CODE";
    RANDOM_PARTNER_SELECTION_CODES[RANDOM_PARTNER_SELECTION_CODES["SELECT_PARTNERS_TO_REMOVE"] = 3758096385] = "SELECT_PARTNERS_TO_REMOVE";
    RANDOM_PARTNER_SELECTION_CODES[RANDOM_PARTNER_SELECTION_CODES["SELECT_PARTNERS_TO_ADD"] = 3758096386] = "SELECT_PARTNERS_TO_ADD";
    RANDOM_PARTNER_SELECTION_CODES[RANDOM_PARTNER_SELECTION_CODES["SELECT_UPDATE_OUT"] = 3758096387] = "SELECT_UPDATE_OUT";
})(RANDOM_PARTNER_SELECTION_CODES = exports.RANDOM_PARTNER_SELECTION_CODES || (exports.RANDOM_PARTNER_SELECTION_CODES = {}));
var SCORE_PARTNER_SELECTION_CODES;
(function (SCORE_PARTNER_SELECTION_CODES) {
    SCORE_PARTNER_SELECTION_CODES[SCORE_PARTNER_SELECTION_CODES["BASE_CODE"] = 4026531840] = "BASE_CODE";
    SCORE_PARTNER_SELECTION_CODES[SCORE_PARTNER_SELECTION_CODES["SELECT_PARTNERS_TO_REMOVE"] = 4026531841] = "SELECT_PARTNERS_TO_REMOVE";
    SCORE_PARTNER_SELECTION_CODES[SCORE_PARTNER_SELECTION_CODES["SELECT_PARTNERS_TO_ADD"] = 4026531842] = "SELECT_PARTNERS_TO_ADD";
    SCORE_PARTNER_SELECTION_CODES[SCORE_PARTNER_SELECTION_CODES["SELECT_UPDATE_OUT"] = 4026531843] = "SELECT_UPDATE_OUT";
})(SCORE_PARTNER_SELECTION_CODES = exports.SCORE_PARTNER_SELECTION_CODES || (exports.SCORE_PARTNER_SELECTION_CODES = {}));
var DELTA_PARTNER_SELECTION_CODES;
(function (DELTA_PARTNER_SELECTION_CODES) {
    DELTA_PARTNER_SELECTION_CODES[DELTA_PARTNER_SELECTION_CODES["BASE_CODE"] = 4294967296] = "BASE_CODE";
    DELTA_PARTNER_SELECTION_CODES[DELTA_PARTNER_SELECTION_CODES["UPDATE_IN_PARTNERS"] = 4294967297] = "UPDATE_IN_PARTNERS";
    DELTA_PARTNER_SELECTION_CODES[DELTA_PARTNER_SELECTION_CODES["SELECT_PARTNERS_TO_REMOVE"] = 4294967298] = "SELECT_PARTNERS_TO_REMOVE";
    DELTA_PARTNER_SELECTION_CODES[DELTA_PARTNER_SELECTION_CODES["SELECT_PARTNERS_TO_ADD"] = 4294967299] = "SELECT_PARTNERS_TO_ADD";
    DELTA_PARTNER_SELECTION_CODES[DELTA_PARTNER_SELECTION_CODES["SELECT_UPDATE_OUT"] = 4294967300] = "SELECT_UPDATE_OUT";
    DELTA_PARTNER_SELECTION_CODES[DELTA_PARTNER_SELECTION_CODES["GROUP_PARTNERS"] = 4294967301] = "GROUP_PARTNERS";
    DELTA_PARTNER_SELECTION_CODES[DELTA_PARTNER_SELECTION_CODES["IDENTIFY_MEMBER_AS_LEADER_OR_SAME_SITE"] = 4294967302] = "IDENTIFY_MEMBER_AS_LEADER_OR_SAME_SITE";
    DELTA_PARTNER_SELECTION_CODES[DELTA_PARTNER_SELECTION_CODES["AHEAD_BUT_BEHIND_DELTA"] = 4294967303] = "AHEAD_BUT_BEHIND_DELTA";
    DELTA_PARTNER_SELECTION_CODES[DELTA_PARTNER_SELECTION_CODES["BEHIND_OR_NOT_RETRIEVING_QUALITY_LEVEL"] = 4294967304] = "BEHIND_OR_NOT_RETRIEVING_QUALITY_LEVEL";
    DELTA_PARTNER_SELECTION_CODES[DELTA_PARTNER_SELECTION_CODES["GET_DELTA_FOR_QUALITY_LEVEL"] = 4294967305] = "GET_DELTA_FOR_QUALITY_LEVEL";
})(DELTA_PARTNER_SELECTION_CODES = exports.DELTA_PARTNER_SELECTION_CODES || (exports.DELTA_PARTNER_SELECTION_CODES = {}));
var THROUGHPUT_PARTNER_SELECTION_CODES;
(function (THROUGHPUT_PARTNER_SELECTION_CODES) {
    THROUGHPUT_PARTNER_SELECTION_CODES[THROUGHPUT_PARTNER_SELECTION_CODES["BASE_CODE"] = 4563402752] = "BASE_CODE";
    THROUGHPUT_PARTNER_SELECTION_CODES[THROUGHPUT_PARTNER_SELECTION_CODES["UPDATE_OUT_PARTNERS"] = 4563402753] = "UPDATE_OUT_PARTNERS";
})(THROUGHPUT_PARTNER_SELECTION_CODES = exports.THROUGHPUT_PARTNER_SELECTION_CODES || (exports.THROUGHPUT_PARTNER_SELECTION_CODES = {}));
var CHUNK_HANDLER_CODES;
(function (CHUNK_HANDLER_CODES) {
    CHUNK_HANDLER_CODES[CHUNK_HANDLER_CODES["BASE_CODE"] = 4831838208] = "BASE_CODE";
    CHUNK_HANDLER_CODES[CHUNK_HANDLER_CODES["ADD_FRAGMENT_TO_MAP"] = 4831838209] = "ADD_FRAGMENT_TO_MAP";
    CHUNK_HANDLER_CODES[CHUNK_HANDLER_CODES["WRAP_CHUNK"] = 4831838210] = "WRAP_CHUNK";
    CHUNK_HANDLER_CODES[CHUNK_HANDLER_CODES["GENERATE_HASHMAPS"] = 4831838211] = "GENERATE_HASHMAPS";
})(CHUNK_HANDLER_CODES = exports.CHUNK_HANDLER_CODES || (exports.CHUNK_HANDLER_CODES = {}));
var DASH_AES_MANAGER_CODES;
(function (DASH_AES_MANAGER_CODES) {
    DASH_AES_MANAGER_CODES[DASH_AES_MANAGER_CODES["BASE_CODE"] = 5100273664] = "BASE_CODE";
    DASH_AES_MANAGER_CODES[DASH_AES_MANAGER_CODES["INIT_AES_MANAGER"] = 5100273665] = "INIT_AES_MANAGER";
    DASH_AES_MANAGER_CODES[DASH_AES_MANAGER_CODES["INIT_KEY"] = 5100273666] = "INIT_KEY";
    DASH_AES_MANAGER_CODES[DASH_AES_MANAGER_CODES["INIT_IV"] = 5100273667] = "INIT_IV";
    DASH_AES_MANAGER_CODES[DASH_AES_MANAGER_CODES["DECRYPT_BUFFER"] = 5100273668] = "DECRYPT_BUFFER";
    DASH_AES_MANAGER_CODES[DASH_AES_MANAGER_CODES["DOWNLOAD_KEY_ONLOAD"] = 5100273669] = "DOWNLOAD_KEY_ONLOAD";
    DASH_AES_MANAGER_CODES[DASH_AES_MANAGER_CODES["DOWNLOAD_KEY"] = 5100273670] = "DOWNLOAD_KEY";
})(DASH_AES_MANAGER_CODES = exports.DASH_AES_MANAGER_CODES || (exports.DASH_AES_MANAGER_CODES = {}));
var DASH_CONTEXT_CODES;
(function (DASH_CONTEXT_CODES) {
    DASH_CONTEXT_CODES[DASH_CONTEXT_CODES["BASE_CODE"] = 5368709120] = "BASE_CODE";
    DASH_CONTEXT_CODES[DASH_CONTEXT_CODES["GET_ENTITY_TYPE"] = 5368709121] = "GET_ENTITY_TYPE";
    DASH_CONTEXT_CODES[DASH_CONTEXT_CODES["GET_ENTITY_CHARACTERISTICS"] = 5368709122] = "GET_ENTITY_CHARACTERISTICS";
    DASH_CONTEXT_CODES[DASH_CONTEXT_CODES["GET_NEXT_ENTITY"] = 5368709123] = "GET_NEXT_ENTITY";
    DASH_CONTEXT_CODES[DASH_CONTEXT_CODES["IS_CURRENT_CONTEXT"] = 5368709124] = "IS_CURRENT_CONTEXT";
    DASH_CONTEXT_CODES[DASH_CONTEXT_CODES["PARSED_METADATA"] = 5368709125] = "PARSED_METADATA";
    DASH_CONTEXT_CODES[DASH_CONTEXT_CODES["PREFETCH_METADATA_RECEIVED"] = 5368709126] = "PREFETCH_METADATA_RECEIVED";
    DASH_CONTEXT_CODES[DASH_CONTEXT_CODES["FRAGMENT_RECEIVED"] = 5368709127] = "FRAGMENT_RECEIVED";
    DASH_CONTEXT_CODES[DASH_CONTEXT_CODES["EVALUATE_PROTECTION"] = 5368709128] = "EVALUATE_PROTECTION";
    DASH_CONTEXT_CODES[DASH_CONTEXT_CODES["GET_DISTANCE_DURATION"] = 5368709129] = "GET_DISTANCE_DURATION";
})(DASH_CONTEXT_CODES = exports.DASH_CONTEXT_CODES || (exports.DASH_CONTEXT_CODES = {}));
var DASH_METADATA_CODES;
(function (DASH_METADATA_CODES) {
    DASH_METADATA_CODES[DASH_METADATA_CODES["BASE_CODE"] = 5637144576] = "BASE_CODE";
    DASH_METADATA_CODES[DASH_METADATA_CODES["PARSE_METADATA"] = 5637144577] = "PARSE_METADATA";
    DASH_METADATA_CODES[DASH_METADATA_CODES["EXTRACT_SEGMENT_MAPS"] = 5637144578] = "EXTRACT_SEGMENT_MAPS";
    DASH_METADATA_CODES[DASH_METADATA_CODES["INIT_PROTECTION"] = 5637144579] = "INIT_PROTECTION";
    DASH_METADATA_CODES[DASH_METADATA_CODES["GET_SEGMENT_INFO"] = 5637144580] = "GET_SEGMENT_INFO";
    DASH_METADATA_CODES[DASH_METADATA_CODES["GET_SEGMENT_DISTANCE"] = 5637144581] = "GET_SEGMENT_DISTANCE";
    DASH_METADATA_CODES[DASH_METADATA_CODES["EXTRACT_DURATION"] = 5637144582] = "EXTRACT_DURATION";
    DASH_METADATA_CODES[DASH_METADATA_CODES["EXTRACT_DURATION_OR_DECRYPT"] = 5637144583] = "EXTRACT_DURATION_OR_DECRYPT";
    DASH_METADATA_CODES[DASH_METADATA_CODES["EXTRACT_DURATION_CANNOT_DECRYPT"] = 5637144584] = "EXTRACT_DURATION_CANNOT_DECRYPT";
    DASH_METADATA_CODES[DASH_METADATA_CODES["EXTRACT_DURATION_NON_ENCRYPTED"] = 5637144585] = "EXTRACT_DURATION_NON_ENCRYPTED";
    DASH_METADATA_CODES[DASH_METADATA_CODES["GENERATE_MISSING_SEGMENTS"] = 5637144586] = "GENERATE_MISSING_SEGMENTS";
    DASH_METADATA_CODES[DASH_METADATA_CODES["REGENERATE_MANIFEST"] = 5637144587] = "REGENERATE_MANIFEST";
    DASH_METADATA_CODES[DASH_METADATA_CODES["TRIM_MANIFEST"] = 5637144588] = "TRIM_MANIFEST";
    DASH_METADATA_CODES[DASH_METADATA_CODES["PARSE_BITRATES_TO_FILTER"] = 5637144589] = "PARSE_BITRATES_TO_FILTER";
    DASH_METADATA_CODES[DASH_METADATA_CODES["FILTER_BITRATES"] = 5637144590] = "FILTER_BITRATES";
    DASH_METADATA_CODES[DASH_METADATA_CODES["GET_DISTANCE_DURATION_BETWEEN_SEGMENTS"] = 5637144591] = "GET_DISTANCE_DURATION_BETWEEN_SEGMENTS";
    DASH_METADATA_CODES[DASH_METADATA_CODES["GET_SEGMENT"] = 5637144592] = "GET_SEGMENT";
})(DASH_METADATA_CODES = exports.DASH_METADATA_CODES || (exports.DASH_METADATA_CODES = {}));
var HLS_CONTEXT_CODES;
(function (HLS_CONTEXT_CODES) {
    HLS_CONTEXT_CODES[HLS_CONTEXT_CODES["BASE_CODE"] = 5905580032] = "BASE_CODE";
    HLS_CONTEXT_CODES[HLS_CONTEXT_CODES["IS_CURRENT_CONTEXT"] = 5905580033] = "IS_CURRENT_CONTEXT";
    HLS_CONTEXT_CODES[HLS_CONTEXT_CODES["GET_ENTITY_TYPE"] = 5905580034] = "GET_ENTITY_TYPE";
    HLS_CONTEXT_CODES[HLS_CONTEXT_CODES["GET_ENTITY_CHARACTERISTICS"] = 5905580035] = "GET_ENTITY_CHARACTERISTICS";
    HLS_CONTEXT_CODES[HLS_CONTEXT_CODES["METADATA_RECEIVED"] = 5905580036] = "METADATA_RECEIVED";
    HLS_CONTEXT_CODES[HLS_CONTEXT_CODES["SCHEDULE_METADATA_PREFETCH"] = 5905580037] = "SCHEDULE_METADATA_PREFETCH";
    HLS_CONTEXT_CODES[HLS_CONTEXT_CODES["GET_NEXT_ENTITY"] = 5905580038] = "GET_NEXT_ENTITY";
    HLS_CONTEXT_CODES[HLS_CONTEXT_CODES["GET_DISTANCE_DURATION"] = 5905580039] = "GET_DISTANCE_DURATION";
})(HLS_CONTEXT_CODES = exports.HLS_CONTEXT_CODES || (exports.HLS_CONTEXT_CODES = {}));
var HLS_METADATA_CODES;
(function (HLS_METADATA_CODES) {
    HLS_METADATA_CODES[HLS_METADATA_CODES["BASE_CODE"] = 6174015488] = "BASE_CODE";
    HLS_METADATA_CODES[HLS_METADATA_CODES["PLAYLIST_MISMATCH"] = 6174015489] = "PLAYLIST_MISMATCH";
    HLS_METADATA_CODES[HLS_METADATA_CODES["FLOAT_BITRATE"] = 6174015490] = "FLOAT_BITRATE";
    HLS_METADATA_CODES[HLS_METADATA_CODES["PARSE_METADATA"] = 6174015491] = "PARSE_METADATA";
    HLS_METADATA_CODES[HLS_METADATA_CODES["GET_SEGMENT_INFO"] = 6174015492] = "GET_SEGMENT_INFO";
    HLS_METADATA_CODES[HLS_METADATA_CODES["UPDATE_PLAYLIST"] = 6174015493] = "UPDATE_PLAYLIST";
    HLS_METADATA_CODES[HLS_METADATA_CODES["TRIM_PLAYLIST"] = 6174015494] = "TRIM_PLAYLIST";
})(HLS_METADATA_CODES = exports.HLS_METADATA_CODES || (exports.HLS_METADATA_CODES = {}));
var TIMER_HANDLE_CODES;
(function (TIMER_HANDLE_CODES) {
    TIMER_HANDLE_CODES[TIMER_HANDLE_CODES["BASE_CODE"] = 6442450944] = "BASE_CODE";
    TIMER_HANDLE_CODES[TIMER_HANDLE_CODES["GET_P2P_TIMEOUT"] = 6442450945] = "GET_P2P_TIMEOUT";
    TIMER_HANDLE_CODES[TIMER_HANDLE_CODES["DELIVER_DELAY"] = 6442450946] = "DELIVER_DELAY";
})(TIMER_HANDLE_CODES = exports.TIMER_HANDLE_CODES || (exports.TIMER_HANDLE_CODES = {}));
var VIDEO_CONTEXT_BASE_CODES;
(function (VIDEO_CONTEXT_BASE_CODES) {
    VIDEO_CONTEXT_BASE_CODES[VIDEO_CONTEXT_BASE_CODES["BASE_CODE"] = 6710886400] = "BASE_CODE";
    VIDEO_CONTEXT_BASE_CODES[VIDEO_CONTEXT_BASE_CODES["IS_PLAYER_BUFFERING_BASE"] = 6710886401] = "IS_PLAYER_BUFFERING_BASE";
    VIDEO_CONTEXT_BASE_CODES[VIDEO_CONTEXT_BASE_CODES["CONFIGURE_REQUEST_DIRECTIVE"] = 6710886402] = "CONFIGURE_REQUEST_DIRECTIVE";
    VIDEO_CONTEXT_BASE_CODES[VIDEO_CONTEXT_BASE_CODES["ATTEMPT_TO_UPGRADE_PREFETCH"] = 6710886403] = "ATTEMPT_TO_UPGRADE_PREFETCH";
    VIDEO_CONTEXT_BASE_CODES[VIDEO_CONTEXT_BASE_CODES["GET_NEXT_ENTITY"] = 6710886404] = "GET_NEXT_ENTITY";
})(VIDEO_CONTEXT_BASE_CODES = exports.VIDEO_CONTEXT_BASE_CODES || (exports.VIDEO_CONTEXT_BASE_CODES = {}));
var TRACKER_CLIENT_CODES;
(function (TRACKER_CLIENT_CODES) {
    TRACKER_CLIENT_CODES[TRACKER_CLIENT_CODES["BASE_CODE"] = 6979321856] = "BASE_CODE";
    TRACKER_CLIENT_CODES[TRACKER_CLIENT_CODES["PREPARE_REQUEST"] = 6979321857] = "PREPARE_REQUEST";
    TRACKER_CLIENT_CODES[TRACKER_CLIENT_CODES["GET_CONNECTIVITY_INFO"] = 6979321858] = "GET_CONNECTIVITY_INFO";
    TRACKER_CLIENT_CODES[TRACKER_CLIENT_CODES["COLLECT_TRACKER_REQUEST_INFO"] = 6979321859] = "COLLECT_TRACKER_REQUEST_INFO";
    TRACKER_CLIENT_CODES[TRACKER_CLIENT_CODES["PREPARE_QUERY"] = 6979321860] = "PREPARE_QUERY";
    TRACKER_CLIENT_CODES[TRACKER_CLIENT_CODES["PREPARE_QUALITY_LEVEL_QUERY"] = 6979321861] = "PREPARE_QUALITY_LEVEL_QUERY";
    TRACKER_CLIENT_CODES[TRACKER_CLIENT_CODES["PREPARE_TRACKER_INFO"] = 6979321862] = "PREPARE_TRACKER_INFO";
    TRACKER_CLIENT_CODES[TRACKER_CLIENT_CODES["SEND_REQUEST"] = 6979321863] = "SEND_REQUEST";
    TRACKER_CLIENT_CODES[TRACKER_CLIENT_CODES["HANDLE_RESPONSE"] = 6979321864] = "HANDLE_RESPONSE";
})(TRACKER_CLIENT_CODES = exports.TRACKER_CLIENT_CODES || (exports.TRACKER_CLIENT_CODES = {}));
var TRACKER_CLIENT_MANAGER_CODES;
(function (TRACKER_CLIENT_MANAGER_CODES) {
    TRACKER_CLIENT_MANAGER_CODES[TRACKER_CLIENT_MANAGER_CODES["BASE_CODE"] = 7247757312] = "BASE_CODE";
    TRACKER_CLIENT_MANAGER_CODES[TRACKER_CLIENT_MANAGER_CODES["NEW_TRACKER_CLIENT"] = 7247757313] = "NEW_TRACKER_CLIENT";
    TRACKER_CLIENT_MANAGER_CODES[TRACKER_CLIENT_MANAGER_CODES["SERIALIZE_REQUEST"] = 7247757314] = "SERIALIZE_REQUEST";
    TRACKER_CLIENT_MANAGER_CODES[TRACKER_CLIENT_MANAGER_CODES["DESERIALIZE_RESPONSE"] = 7247757315] = "DESERIALIZE_RESPONSE";
    TRACKER_CLIENT_MANAGER_CODES[TRACKER_CLIENT_MANAGER_CODES["SERVICE_CONNECTION_DOWN"] = 7247757316] = "SERVICE_CONNECTION_DOWN";
    TRACKER_CLIENT_MANAGER_CODES[TRACKER_CLIENT_MANAGER_CODES["SEND_REQUEST"] = 7247757317] = "SEND_REQUEST";
    TRACKER_CLIENT_MANAGER_CODES[TRACKER_CLIENT_MANAGER_CODES["TRACKER_MANAGER_INIT"] = 7247757318] = "TRACKER_MANAGER_INIT";
})(TRACKER_CLIENT_MANAGER_CODES = exports.TRACKER_CLIENT_MANAGER_CODES || (exports.TRACKER_CLIENT_MANAGER_CODES = {}));
var PICKER_SINGLE_CODES;
(function (PICKER_SINGLE_CODES) {
    PICKER_SINGLE_CODES[PICKER_SINGLE_CODES["BASE_CODE"] = 7516192768] = "BASE_CODE";
    PICKER_SINGLE_CODES[PICKER_SINGLE_CODES["SORT_PARTNERS"] = 7516192769] = "SORT_PARTNERS";
})(PICKER_SINGLE_CODES = exports.PICKER_SINGLE_CODES || (exports.PICKER_SINGLE_CODES = {}));
var PICKER_EXT_CODES;
(function (PICKER_EXT_CODES) {
    PICKER_EXT_CODES[PICKER_EXT_CODES["BASE_CODE"] = 7784628224] = "BASE_CODE";
    PICKER_EXT_CODES[PICKER_EXT_CODES["CHOOSE_PARTNER"] = 7784628225] = "CHOOSE_PARTNER";
})(PICKER_EXT_CODES = exports.PICKER_EXT_CODES || (exports.PICKER_EXT_CODES = {}));
var FRAGMENT_REQUESTER_CODES;
(function (FRAGMENT_REQUESTER_CODES) {
    FRAGMENT_REQUESTER_CODES[FRAGMENT_REQUESTER_CODES["BASE_CODE"] = 8053063680] = "BASE_CODE";
    FRAGMENT_REQUESTER_CODES[FRAGMENT_REQUESTER_CODES["CONSTRUCT_FRAGMENT_REQUEST_MESSAGE"] = 8053063681] = "CONSTRUCT_FRAGMENT_REQUEST_MESSAGE";
    FRAGMENT_REQUESTER_CODES[FRAGMENT_REQUESTER_CODES["SEND_FRAGMENT_REQUEST"] = 8053063682] = "SEND_FRAGMENT_REQUEST";
    FRAGMENT_REQUESTER_CODES[FRAGMENT_REQUESTER_CODES["RECEIVE_CHUNK"] = 8053063683] = "RECEIVE_CHUNK";
    FRAGMENT_REQUESTER_CODES[FRAGMENT_REQUESTER_CODES["SEND_ACK"] = 8053063684] = "SEND_ACK";
    FRAGMENT_REQUESTER_CODES[FRAGMENT_REQUESTER_CODES["CLEAN_UP_NOT_PENDING"] = 8053063685] = "CLEAN_UP_NOT_PENDING";
    FRAGMENT_REQUESTER_CODES[FRAGMENT_REQUESTER_CODES["STOP_TRANSFER"] = 8053063686] = "STOP_TRANSFER";
    FRAGMENT_REQUESTER_CODES[FRAGMENT_REQUESTER_CODES["RECEIVE_EXPIRED_CHUNK"] = 8053063687] = "RECEIVE_EXPIRED_CHUNK";
})(FRAGMENT_REQUESTER_CODES = exports.FRAGMENT_REQUESTER_CODES || (exports.FRAGMENT_REQUESTER_CODES = {}));
var FRAGMENT_SENDER_CODES;
(function (FRAGMENT_SENDER_CODES) {
    FRAGMENT_SENDER_CODES[FRAGMENT_SENDER_CODES["BASE_CODE"] = 8321499136] = "BASE_CODE";
    FRAGMENT_SENDER_CODES[FRAGMENT_SENDER_CODES["CONSTRUCT_CHUNK_RESPONSE"] = 8321499137] = "CONSTRUCT_CHUNK_RESPONSE";
    FRAGMENT_SENDER_CODES[FRAGMENT_SENDER_CODES["START_SENDING_CHUNK"] = 8321499138] = "START_SENDING_CHUNK";
    FRAGMENT_SENDER_CODES[FRAGMENT_SENDER_CODES["SEND_CHUNK"] = 8321499139] = "SEND_CHUNK";
    FRAGMENT_SENDER_CODES[FRAGMENT_SENDER_CODES["UNKNOWN_ACK"] = 8321499140] = "UNKNOWN_ACK";
})(FRAGMENT_SENDER_CODES = exports.FRAGMENT_SENDER_CODES || (exports.FRAGMENT_SENDER_CODES = {}));
var P2P_REQUESTER_CODES;
(function (P2P_REQUESTER_CODES) {
    P2P_REQUESTER_CODES[P2P_REQUESTER_CODES["BASE_CODE"] = 8589934592] = "BASE_CODE";
    P2P_REQUESTER_CODES[P2P_REQUESTER_CODES["NO_PARTNER_FOUND"] = 8589934593] = "NO_PARTNER_FOUND";
    P2P_REQUESTER_CODES[P2P_REQUESTER_CODES["FILTER_IN_PARTNERS"] = 8589934594] = "FILTER_IN_PARTNERS";
    P2P_REQUESTER_CODES[P2P_REQUESTER_CODES["SET_REQUEST_TIMEOUT"] = 8589934595] = "SET_REQUEST_TIMEOUT";
    P2P_REQUESTER_CODES[P2P_REQUESTER_CODES["REMOVE_REQUEST"] = 8589934596] = "REMOVE_REQUEST";
    P2P_REQUESTER_CODES[P2P_REQUESTER_CODES["CANCEL_ON_NON_EXISTING_SESSION"] = 8589934597] = "CANCEL_ON_NON_EXISTING_SESSION";
    P2P_REQUESTER_CODES[P2P_REQUESTER_CODES["DO_NOT_HAVE"] = 8589934598] = "DO_NOT_HAVE";
    P2P_REQUESTER_CODES[P2P_REQUESTER_CODES["REQUESTED_TO_NON_PARTNER"] = 8589934599] = "REQUESTED_TO_NON_PARTNER";
})(P2P_REQUESTER_CODES = exports.P2P_REQUESTER_CODES || (exports.P2P_REQUESTER_CODES = {}));
var P2P_RESPONDER_CODES;
(function (P2P_RESPONDER_CODES) {
    P2P_RESPONDER_CODES[P2P_RESPONDER_CODES["BASE_CODE"] = 8858370048] = "BASE_CODE";
    P2P_RESPONDER_CODES[P2P_RESPONDER_CODES["RESPOND_TO_PEER"] = 8858370049] = "RESPOND_TO_PEER";
    P2P_RESPONDER_CODES[P2P_RESPONDER_CODES["REQUEST_SATISFIED"] = 8858370050] = "REQUEST_SATISFIED";
    P2P_RESPONDER_CODES[P2P_RESPONDER_CODES["REQUEST_PARTIALLY_SATISFIED"] = 8858370051] = "REQUEST_PARTIALLY_SATISFIED";
    P2P_RESPONDER_CODES[P2P_RESPONDER_CODES["REQUEST_NOT_SATISFIED"] = 8858370052] = "REQUEST_NOT_SATISFIED";
    P2P_RESPONDER_CODES[P2P_RESPONDER_CODES["SEND_DO_NOT_HAVE"] = 8858370053] = "SEND_DO_NOT_HAVE";
    P2P_RESPONDER_CODES[P2P_RESPONDER_CODES["SEND_NO_PARTNERS"] = 8858370054] = "SEND_NO_PARTNERS";
})(P2P_RESPONDER_CODES = exports.P2P_RESPONDER_CODES || (exports.P2P_RESPONDER_CODES = {}));
var IP_SPOOFING_CODES;
(function (IP_SPOOFING_CODES) {
    IP_SPOOFING_CODES[IP_SPOOFING_CODES["BASE_CODE"] = 9126805504] = "BASE_CODE";
    IP_SPOOFING_CODES[IP_SPOOFING_CODES["VIOLATE_SPOOFING_HANDLER"] = 9126805505] = "VIOLATE_SPOOFING_HANDLER";
    IP_SPOOFING_CODES[IP_SPOOFING_CODES["VIOLATE_SPOOFING_RULES"] = 9126805506] = "VIOLATE_SPOOFING_RULES";
    IP_SPOOFING_CODES[IP_SPOOFING_CODES["ADD_OR_UPDATE_SPOOFING_MAPS"] = 9126805507] = "ADD_OR_UPDATE_SPOOFING_MAPS";
    IP_SPOOFING_CODES[IP_SPOOFING_CODES["PERIODIC_CHECK_IP_SPOOFING"] = 9126805508] = "PERIODIC_CHECK_IP_SPOOFING";
})(IP_SPOOFING_CODES = exports.IP_SPOOFING_CODES || (exports.IP_SPOOFING_CODES = {}));
var PARTNER_CODES;
(function (PARTNER_CODES) {
    PARTNER_CODES[PARTNER_CODES["BASE_CODE"] = 9395240960] = "BASE_CODE";
    PARTNER_CODES[PARTNER_CODES["REQUEST_COMPLETED"] = 9395240961] = "REQUEST_COMPLETED";
    PARTNER_CODES[PARTNER_CODES["REQUEST_NOT_EXISTING_COMPLETED"] = 9395240962] = "REQUEST_NOT_EXISTING_COMPLETED";
    PARTNER_CODES[PARTNER_CODES["REQUEST_PARTIALLY_FAILED"] = 9395240963] = "REQUEST_PARTIALLY_FAILED";
    PARTNER_CODES[PARTNER_CODES["REQUEST_NOT_EXISTING_PARTIALLY_FAILED"] = 9395240964] = "REQUEST_NOT_EXISTING_PARTIALLY_FAILED";
    PARTNER_CODES[PARTNER_CODES["REQUEST_FAILED"] = 9395240965] = "REQUEST_FAILED";
    PARTNER_CODES[PARTNER_CODES["REQUEST_NOT_EXISTING_FAILED"] = 9395240966] = "REQUEST_NOT_EXISTING_FAILED";
})(PARTNER_CODES = exports.PARTNER_CODES || (exports.PARTNER_CODES = {}));
var PREFETCHER_CODES;
(function (PREFETCHER_CODES) {
    PREFETCHER_CODES[PREFETCHER_CODES["BASE_CODE"] = 9663676416] = "BASE_CODE";
    PREFETCHER_CODES[PREFETCHER_CODES["UPDATE_WANTED_SESSIONS"] = 9663676417] = "UPDATE_WANTED_SESSIONS";
    PREFETCHER_CODES[PREFETCHER_CODES["CONFIGURE_PREFETCHING"] = 9663676418] = "CONFIGURE_PREFETCHING";
    PREFETCHER_CODES[PREFETCHER_CODES["START_PREFETCHING"] = 9663676419] = "START_PREFETCHING";
    PREFETCHER_CODES[PREFETCHER_CODES["FRAGMENT_RETRIEVED_SESSION_NOT_EXISTING"] = 9663676420] = "FRAGMENT_RETRIEVED_SESSION_NOT_EXISTING";
    PREFETCHER_CODES[PREFETCHER_CODES["ATTEMPT_PREFETCH_BEFORE_PLAYER_REQUEST"] = 9663676421] = "ATTEMPT_PREFETCH_BEFORE_PLAYER_REQUEST";
    PREFETCHER_CODES[PREFETCHER_CODES["FORWARD_IF_NECESSARY"] = 9663676422] = "FORWARD_IF_NECESSARY";
    PREFETCHER_CODES[PREFETCHER_CODES["IS_ALLOWED_TO_PREFETCH"] = 9663676423] = "IS_ALLOWED_TO_PREFETCH";
    PREFETCHER_CODES[PREFETCHER_CODES["PREFETCH_PROCESS"] = 9663676424] = "PREFETCH_PROCESS";
    PREFETCHER_CODES[PREFETCHER_CODES["CHECK_PLAYER_DISTANCE"] = 9663676425] = "CHECK_PLAYER_DISTANCE";
    PREFETCHER_CODES[PREFETCHER_CODES["OFFLOAD_LEADER"] = 9663676426] = "OFFLOAD_LEADER";
    PREFETCHER_CODES[PREFETCHER_CODES["UPGRADE_PREFETCH"] = 9663676427] = "UPGRADE_PREFETCH";
})(PREFETCHER_CODES = exports.PREFETCHER_CODES || (exports.PREFETCHER_CODES = {}));
var FALLBACK_REQUESTER_CODES;
(function (FALLBACK_REQUESTER_CODES) {
    FALLBACK_REQUESTER_CODES[FALLBACK_REQUESTER_CODES["BASE_CODE"] = 9932111872] = "BASE_CODE";
    FALLBACK_REQUESTER_CODES[FALLBACK_REQUESTER_CODES["REQUEST_TIMEOUT"] = 9932111873] = "REQUEST_TIMEOUT";
})(FALLBACK_REQUESTER_CODES = exports.FALLBACK_REQUESTER_CODES || (exports.FALLBACK_REQUESTER_CODES = {}));
var HIVE_CACHE_CODES;
(function (HIVE_CACHE_CODES) {
    HIVE_CACHE_CODES[HIVE_CACHE_CODES["BASE_CODE"] = 10200547328] = "BASE_CODE";
    HIVE_CACHE_CODES[HIVE_CACHE_CODES["PLAYER_REQUEST_ERROR"] = 10200547329] = "PLAYER_REQUEST_ERROR";
    HIVE_CACHE_CODES[HIVE_CACHE_CODES["PLAYER_ABORT_ERROR"] = 10200547330] = "PLAYER_ABORT_ERROR";
})(HIVE_CACHE_CODES = exports.HIVE_CACHE_CODES || (exports.HIVE_CACHE_CODES = {}));
var OBJECT_INDEX_CODES;
(function (OBJECT_INDEX_CODES) {
    OBJECT_INDEX_CODES[OBJECT_INDEX_CODES["BASE_CODE"] = 10468982784] = "BASE_CODE";
    OBJECT_INDEX_CODES[OBJECT_INDEX_CODES["ADD_HAVE"] = 10468982785] = "ADD_HAVE";
    OBJECT_INDEX_CODES[OBJECT_INDEX_CODES["REMOVE_PEER"] = 10468982786] = "REMOVE_PEER";
})(OBJECT_INDEX_CODES = exports.OBJECT_INDEX_CODES || (exports.OBJECT_INDEX_CODES = {}));
var PEER_CODES;
(function (PEER_CODES) {
    PEER_CODES[PEER_CODES["BASE_CODE"] = 10737418240] = "BASE_CODE";
    PEER_CODES[PEER_CODES["CONSTRUCT_SWARM"] = 10737418241] = "CONSTRUCT_SWARM";
    PEER_CODES[PEER_CODES["INIT_SWARM"] = 10737418242] = "INIT_SWARM";
    PEER_CODES[PEER_CODES["SWITCH_STATE"] = 10737418243] = "SWITCH_STATE";
    PEER_CODES[PEER_CODES["REQUEST_TIMEOUT"] = 10737418244] = "REQUEST_TIMEOUT";
})(PEER_CODES = exports.PEER_CODES || (exports.PEER_CODES = {}));
var HIVE_SERVICES_CODES;
(function (HIVE_SERVICES_CODES) {
    HIVE_SERVICES_CODES[HIVE_SERVICES_CODES["BASE_CODE"] = 11005853696] = "BASE_CODE";
    HIVE_SERVICES_CODES[HIVE_SERVICES_CODES["SERIALIZE_MESSAGE"] = 11005853697] = "SERIALIZE_MESSAGE";
    HIVE_SERVICES_CODES[HIVE_SERVICES_CODES["EXTRACT_MESSAGE"] = 11005853698] = "EXTRACT_MESSAGE";
})(HIVE_SERVICES_CODES = exports.HIVE_SERVICES_CODES || (exports.HIVE_SERVICES_CODES = {}));
var HIVE_COMM_PLUGIN;
(function (HIVE_COMM_PLUGIN) {
    HIVE_COMM_PLUGIN[HIVE_COMM_PLUGIN["BASE_CODE"] = 11274289152] = "BASE_CODE";
    HIVE_COMM_PLUGIN[HIVE_COMM_PLUGIN["NO_MATCHING_SESSION"] = 11274289153] = "NO_MATCHING_SESSION";
    HIVE_COMM_PLUGIN[HIVE_COMM_PLUGIN["UNABLE_RESOLVE_TICKET"] = 11274289154] = "UNABLE_RESOLVE_TICKET";
    HIVE_COMM_PLUGIN[HIVE_COMM_PLUGIN["UNABLE_INIT_TECHS"] = 11274289155] = "UNABLE_INIT_TECHS";
    HIVE_COMM_PLUGIN[HIVE_COMM_PLUGIN["NO_TOKEN_FOUND"] = 11274289156] = "NO_TOKEN_FOUND";
    HIVE_COMM_PLUGIN[HIVE_COMM_PLUGIN["NO_VALID_TICKET"] = 11274289157] = "NO_VALID_TICKET";
    HIVE_COMM_PLUGIN[HIVE_COMM_PLUGIN["ON_ACTIVE_SESSION_CB_ERROR"] = 11274289158] = "ON_ACTIVE_SESSION_CB_ERROR";
    HIVE_COMM_PLUGIN[HIVE_COMM_PLUGIN["NO_VISIBILITY_LISTENER"] = 11274289159] = "NO_VISIBILITY_LISTENER";
    HIVE_COMM_PLUGIN[HIVE_COMM_PLUGIN["STATUS_CODE"] = 11274289160] = "STATUS_CODE";
    HIVE_COMM_PLUGIN[HIVE_COMM_PLUGIN["ON_SESSION_STATE_CHANGE_CB_ERROR"] = 11274289161] = "ON_SESSION_STATE_CHANGE_CB_ERROR";
    HIVE_COMM_PLUGIN[HIVE_COMM_PLUGIN["NO_REQUIRED_PARAMETERS"] = 11274289162] = "NO_REQUIRED_PARAMETERS";
    HIVE_COMM_PLUGIN[HIVE_COMM_PLUGIN["NO_REPORTING_INSTANCE"] = 11274289163] = "NO_REPORTING_INSTANCE";
    HIVE_COMM_PLUGIN[HIVE_COMM_PLUGIN["UNABLE_RESOLVE_JWT"] = 11274289164] = "UNABLE_RESOLVE_JWT";
    HIVE_COMM_PLUGIN[HIVE_COMM_PLUGIN["NO_PLAYER_SOURCE"] = 11274289165] = "NO_PLAYER_SOURCE";
    HIVE_COMM_PLUGIN[HIVE_COMM_PLUGIN["GET_CONNECTIVITY_INFO"] = 11274289166] = "GET_CONNECTIVITY_INFO";
    HIVE_COMM_PLUGIN[HIVE_COMM_PLUGIN["PARSE_EXTERNAL_CANDIDATES"] = 11274289167] = "PARSE_EXTERNAL_CANDIDATES";
})(HIVE_COMM_PLUGIN = exports.HIVE_COMM_PLUGIN || (exports.HIVE_COMM_PLUGIN = {}));
var LOCALITY_CODES;
(function (LOCALITY_CODES) {
    LOCALITY_CODES[LOCALITY_CODES["BASE_CODE"] = 11542724608] = "BASE_CODE";
    LOCALITY_CODES[LOCALITY_CODES["CALCULATE_BATCH_LOCALITY"] = 11542724609] = "CALCULATE_BATCH_LOCALITY";
})(LOCALITY_CODES = exports.LOCALITY_CODES || (exports.LOCALITY_CODES = {}));
var HIVE_STREAM_CHECKER_CODES;
(function (HIVE_STREAM_CHECKER_CODES) {
    HIVE_STREAM_CHECKER_CODES[HIVE_STREAM_CHECKER_CODES["BASE_CODE"] = 11811160064] = "BASE_CODE";
    HIVE_STREAM_CHECKER_CODES[HIVE_STREAM_CHECKER_CODES["BITRATE_TOO_HIGH"] = 11811160065] = "BITRATE_TOO_HIGH";
    HIVE_STREAM_CHECKER_CODES[HIVE_STREAM_CHECKER_CODES["NUM_BITRATES_NONE"] = 11811160066] = "NUM_BITRATES_NONE";
    HIVE_STREAM_CHECKER_CODES[HIVE_STREAM_CHECKER_CODES["NUM_BITRATES_OK"] = 11811160067] = "NUM_BITRATES_OK";
    HIVE_STREAM_CHECKER_CODES[HIVE_STREAM_CHECKER_CODES["NUM_BITRATES_WARNING"] = 11811160068] = "NUM_BITRATES_WARNING";
    HIVE_STREAM_CHECKER_CODES[HIVE_STREAM_CHECKER_CODES["NUM_BITRATES_ERROR"] = 11811160069] = "NUM_BITRATES_ERROR";
    /**
     * Used to differentiate different atatus error messages, as they do NOT
     * have string formatting (to properly group errors)
     */
    HIVE_STREAM_CHECKER_CODES[HIVE_STREAM_CHECKER_CODES["NUM_BITRATES_ATATUS_ERROR_NONE"] = 11811160070] = "NUM_BITRATES_ATATUS_ERROR_NONE";
    HIVE_STREAM_CHECKER_CODES[HIVE_STREAM_CHECKER_CODES["NUM_BITRATES_ATATUS_ERROR_HIGH"] = 11811160071] = "NUM_BITRATES_ATATUS_ERROR_HIGH";
})(HIVE_STREAM_CHECKER_CODES = exports.HIVE_STREAM_CHECKER_CODES || (exports.HIVE_STREAM_CHECKER_CODES = {}));
var LOCALITY_SERVICE_CODES;
(function (LOCALITY_SERVICE_CODES) {
    LOCALITY_SERVICE_CODES[LOCALITY_SERVICE_CODES["BASE_CODE"] = 12079595520] = "BASE_CODE";
    LOCALITY_SERVICE_CODES[LOCALITY_SERVICE_CODES["SERIALIZE_MESSAGE"] = 12079595521] = "SERIALIZE_MESSAGE";
    LOCALITY_SERVICE_CODES[LOCALITY_SERVICE_CODES["SEND_REQUEST"] = 12079595522] = "SEND_REQUEST";
    LOCALITY_SERVICE_CODES[LOCALITY_SERVICE_CODES["SERVICE_CONNECTION_DOWN"] = 12079595523] = "SERVICE_CONNECTION_DOWN";
    LOCALITY_SERVICE_CODES[LOCALITY_SERVICE_CODES["GET_CONNECTIVITY_INFO"] = 12079595524] = "GET_CONNECTIVITY_INFO";
})(LOCALITY_SERVICE_CODES = exports.LOCALITY_SERVICE_CODES || (exports.LOCALITY_SERVICE_CODES = {}));
exports.GENERIC_ERROR = 0x000000001;
exports.ErrorMessages = (_a = {},
    _a[HIVE_STREAM_CHECKER_CODES.BITRATE_TOO_HIGH] = 'The detected bitrate ({0}) is higher than the maximum certified bitrate ({1}). You may encounter issues watching the stream.',
    // All messages must have format: {0} = Live/VOD, {1} = number of bitrates, {2} = list of bitrates
    _a[HIVE_STREAM_CHECKER_CODES.NUM_BITRATES_NONE] = '{0} stream detected with missing video bitrate metadata. This is likely caused by an incorrect manifest served by the video platform application.',
    _a[HIVE_STREAM_CHECKER_CODES.NUM_BITRATES_OK] = '{0} stream detected {1} video bitrates: {2}',
    _a[HIVE_STREAM_CHECKER_CODES.NUM_BITRATES_WARNING] = '{0} stream detected with {1} video bitrates: {2}. Hive Streaming recommends four or fewer video bitrates to insure optimal networking savings.',
    _a[HIVE_STREAM_CHECKER_CODES.NUM_BITRATES_ERROR] = '{0} stream detected with {1} video bitrates: {2}. This is likely caused by an incorrect configuration in the video encoder, video streaming origin or transcoding service.',
    _a[HIVE_STREAM_CHECKER_CODES.NUM_BITRATES_ATATUS_ERROR_NONE] = 'Stream has zero available bitrates.',
    _a[HIVE_STREAM_CHECKER_CODES.NUM_BITRATES_ATATUS_ERROR_HIGH] = 'Stream has too many available bitrates.',
    _a);
// SeverityMap contains the information described in https://hivestreaming.atlassian.net/wiki/spaces/CT/pages/420937914/Hive+Web+Client+Integration+Error+Codes
// It will allow us to identify (and report) which codes are HIGH or CRITICAL
// N.B. all the error codes not listed here are considered as NORMAL severity
exports.SeverityMap = (_b = {},
    // NETWORK MANAGER
    _b[NETWORK_MANAGER_CODES.FIRE_SERVER_CONNECTED_WITH_SWARM] = HiveSeverity.HIGH,
    _b[NETWORK_MANAGER_CODES.FIRE_SERVER_CONNECTED_WITHOUT_SWARM] = HiveSeverity.HIGH,
    // PARTNERSHIP
    _b[PARTNERSHIP_CODES.START_PARTNERSHIP] = HiveSeverity.HIGH,
    // DASH CONTEXT
    _b[DASH_CONTEXT_CODES.IS_CURRENT_CONTEXT] = HiveSeverity.HIGH,
    // DASH METADATA
    _b[DASH_METADATA_CODES.REGENERATE_MANIFEST] = HiveSeverity.HIGH,
    // HLS CONTEXT
    _b[HLS_CONTEXT_CODES.IS_CURRENT_CONTEXT] = HiveSeverity.HIGH,
    // HLS METADATA
    _b[HLS_METADATA_CODES.PLAYLIST_MISMATCH] = HiveSeverity.HIGH,
    // PEER / SWARM
    _b[PEER_CODES.CONSTRUCT_SWARM] = HiveSeverity.HIGH,
    // Core / Plugin
    _b[HIVE_COMM_PLUGIN.NO_MATCHING_SESSION] = HiveSeverity.HIGH,
    _b[HIVE_COMM_PLUGIN.UNABLE_RESOLVE_TICKET] = HiveSeverity.HIGH,
    _b[HIVE_COMM_PLUGIN.UNABLE_INIT_TECHS] = HiveSeverity.HIGH,
    _b[HIVE_COMM_PLUGIN.NO_TOKEN_FOUND] = HiveSeverity.HIGH,
    _b[HIVE_COMM_PLUGIN.NO_VALID_TICKET] = HiveSeverity.HIGH,
    _b[HIVE_COMM_PLUGIN.NO_REQUIRED_PARAMETERS] = HiveSeverity.CRITICAL,
    _b[HIVE_COMM_PLUGIN.NO_PLAYER_SOURCE] = HiveSeverity.CRITICAL,
    _b);
//# sourceMappingURL=error.hive.js.map

/***/ }),

/***/ "../../../core/build/core/src/common/key.hive.js":
/*!************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/common/key.hive.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.KeyHandlerHiveComm = void 0;
var KeyHandlerHiveComm = /** @class */ (function () {
    /**
     * don't use the constructor, use KeyHandlerHiveComm.getInstance() instead
     */
    function KeyHandlerHiveComm() {
        var _this = this;
        this.combinations = [];
        this.callbacks = [];
        if (KeyHandlerHiveComm.instance) {
            throw new Error('Error: Instantiation failed: Use KeyHandlerHiveComm.getInstance() instead of new.');
        }
        var keyMap = {};
        document.addEventListener('keydown', function (e) {
            keyMap[e.keyCode] = true;
            _this.checkCombinations(keyMap);
        }, true);
        document.addEventListener('keyup', function (e) {
            keyMap = {};
        }, true);
    }
    /**
     * get instance of KeyHandler to register key combinations
     * @returns {KeyHandlerHiveComm}
     */
    KeyHandlerHiveComm.getInstance = function () {
        if (this.instance === undefined)
            this.instance = new KeyHandlerHiveComm();
        return this.instance;
    };
    /**
     * register a callback whenever a key combination is pressed
     * @param combination
     * @param callback
     */
    KeyHandlerHiveComm.prototype.registerKeyCombination = function (combination, callback) {
        this.combinations.push(combination);
        this.callbacks.push(callback);
    };
    KeyHandlerHiveComm.prototype.checkCombinations = function (keyMap) {
        var _loop_1 = function (i) {
            var match = true;
            this_1.combinations[i].forEach(function (n) {
                if (keyMap[n] == undefined || !keyMap[n])
                    match = false;
            });
            if (match)
                this_1.callbacks[i]();
        };
        var this_1 = this;
        for (var i = 0; i < this.combinations.length; i++) {
            _loop_1(i);
        }
    };
    return KeyHandlerHiveComm;
}());
exports.KeyHandlerHiveComm = KeyHandlerHiveComm;
//# sourceMappingURL=key.hive.js.map

/***/ }),

/***/ "../../../core/build/core/src/common/loaders/HiveXhrLoaderV0.js":
/*!***************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/common/loaders/HiveXhrLoaderV0.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.HiveXhrLoader = void 0;
var Framework_1 = __webpack_require__(/*! ../../core/Framework */ "../../../core/build/core/src/core/Framework.js");
var basicutils_hive_1 = __webpack_require__(/*! ../basicutils.hive */ "../../../core/build/core/src/common/basicutils.hive.js");
var HiveXhrLoader = /** @class */ (function () {
    function HiveXhrLoader(config) {
        this.loggerId = '[HiveXhrLoader] ';
        this.generalConf = config;
        if (config && config.xhrSetup) {
            this.xhrSetup = config.xhrSetup;
        }
    }
    HiveXhrLoader.prototype.destroy = function () {
        this.abort();
        this.loader = null;
        this.xhr = null;
    };
    HiveXhrLoader.prototype.abort = function () {
        var loader = this.loader || this.xhr;
        if (loader && loader.readyState !== 4) {
            this.stats.aborted = true;
            loader.abort();
        }
        window.clearTimeout(this.requestTimeout);
        this.requestTimeout = null;
        window.clearTimeout(this.retryTimeout);
        this.retryTimeout = null;
    };
    HiveXhrLoader.prototype.load = function (context, config, callbacks) {
        this.context = context;
        this.config = config;
        this.callbacks = callbacks;
        this.stats = { trequest: performance.now(), retry: 0 };
        this.retryDelay = config.retryDelay;
        this.loadInternal();
    };
    /**
     * Hive xhr loader lets the xhrSetup recreate the xhr with
     * HiveGenericRequest with the correct sessionId
     */
    HiveXhrLoader.prototype.loadInternal = function () {
        // to be compliant with the hls.js loader, xhr should be a XHR, not null
        // reference: https://github.com/video-dev/hls.js/blob/master/src/utils/xhr-loader.js#L45
        this.xhr = this.loader = new XMLHttpRequest();
        var context = this.context;
        var stats = this.stats;
        stats.tfirst = 0;
        stats.loaded = 0;
        if (this.xhrSetup) {
            // TODO: refactor HiveXHRLoader to pass the context directly as third argument
            // adding compliance to xhrSetup used by hlsjs that doesn't return back the new instance of the xhr created
            this.xhr = this.xhrSetup(this.xhr, context) || this.xhr;
        }
        else {
            // Since partners can extend HiveXhrLoader, it is possible they could use the loader on a non-Hive
            // enabled stream. If that is the case, we will return a default XMLHttpRequest in order to have
            // successful playback. However, display a warning: there is no need to use a Hive-based XhrLoader
            // if not using a Hive plugin on the player.
            // No reference to a Plugin object, so using console.log
            console.warn(this.loggerId + "Hive XHR setup missing. To disable this warning, do not use a Hive-based XhrLoader without a Hive plugin on the player.");
            if (Framework_1.Framework.getPeerContext())
                this.xhr = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.HTTP_REQUEST);
            if (!this.xhr)
                this.xhr = new XMLHttpRequest();
            this.xhr.open('GET', context.url, true);
            if (context.rangeEnd) {
                this.xhr.setRequestHeader('Range', 'bytes=' + context.rangeStart + '-' + (context.rangeEnd - 1));
            }
        }
        // same logic as the original xhrLoader
        if (!this.xhr.readyState)
            this.xhr.open('GET', context.url, true);
        if (context.rangeEnd)
            this.xhr.setRequestHeader('Range', 'bytes=' + context.rangeStart + '-' + (context.rangeEnd - 1));
        this.xhr.onreadystatechange = this.readystatechange.bind(this);
        this.xhr.onprogress = this.loadprogress.bind(this);
        var responseType = this.context.responseType;
        this.xhr.responseType = basicutils_hive_1.isValidResponseType(responseType) ? responseType : '';
        // setup timeout before we perform request
        if (this.config.timeout) {
            this.xhr.timeout = this.config.timeout;
            this.requestTimeout = window.setTimeout(this.loadtimeout.bind(this), this.config.timeout);
        }
        this.xhr.send();
    };
    HiveXhrLoader.prototype.readystatechange = function (event) {
        var xhr = event.currentTarget, readyState = xhr.readyState, stats = this.stats, context = this.context, config = this.config;
        // don't proceed if xhr has been aborted
        if (stats.aborted) {
            return;
        }
        // >= HEADERS_RECEIVED
        if (readyState >= 2) {
            // clear xhr timeout and rearm it if readyState less than 4
            window.clearTimeout(this.requestTimeout);
            if (stats.tfirst === 0) {
                stats.tfirst = Math.max(performance.now(), stats.trequest);
            }
            if (readyState === 4) {
                var status_1 = xhr.status;
                var headerStr = xhr.getAllResponseHeaders() || '';
                var responseURL = xhr.responseURL || xhr['url'], statusText = xhr.statusText || (status_1 === 200 ? 'OK' : '');
                // Create a map of header names to values.
                // See https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/getAllResponseHeaders
                var arr = headerStr.trim().split(/[\r\n]+/);
                var headerMap_1 = {};
                if (headerStr) {
                    arr.forEach(function (line) {
                        var parts = line.split(': ');
                        var header = parts.shift();
                        var value = parts.join(': ');
                        headerMap_1[header] = value;
                    });
                }
                // http status between 200 to 299 are all successful
                if (status_1 >= 200 && status_1 < 300) {
                    stats.tload = Math.max(stats.tfirst, performance.now());
                    var data = void 0;
                    var len = void 0;
                    if (context.responseType === 'arraybuffer') {
                        data = xhr.response;
                        len = data.byteLength;
                    }
                    else {
                        data = xhr.responseText;
                        len = data.length;
                    }
                    stats.loaded = stats.total = len;
                    var response = {
                        url: responseURL,
                        code: status_1,
                        text: statusText,
                        responseHeaders: headerStr,
                        headerMap: headerMap_1,
                        data: data
                    };
                    this.callbacks.onSuccess(response, stats, context);
                }
                else {
                    // if max nb of retries reached or if http status between 400 and 499 (such error cannot be recovered, retrying is useless), return error
                    if ((typeof config.retryDelay === 'undefined' || typeof config.maxRetryDelay === 'undefined') ||
                        (stats.retry >= config.maxRetry || (status_1 >= 400 && status_1 < 499))) {
                        console.warn(status_1 + " while loading " + context.url);
                        var response = {
                            url: responseURL,
                            code: status_1,
                            text: statusText,
                            responseHeaders: headerStr,
                            headerMap: headerMap_1,
                            data: context.responseType === 'arraybuffer' ? xhr.response : xhr.responseText
                        };
                        this.callbacks.onError(response, context);
                    }
                    else {
                        // retry
                        console.warn(status_1 + " while loading " + context.url + ", retrying in " + this.retryDelay + "...");
                        // aborts and resets internal state
                        this.destroy();
                        // schedule retry
                        this.retryTimeout = window.setTimeout(this.loadInternal.bind(this), this.retryDelay);
                        // set exponential backoff
                        this.retryDelay = Math.min(2 * this.retryDelay, config.maxRetryDelay);
                        stats.retry++;
                    }
                }
            }
            else {
                // readyState >= 2 AND readyState !==4 (readyState = HEADERS_RECEIVED || LOADING) rearm timeout as xhr not finished yet
                if (config.timeout)
                    this.requestTimeout = window.setTimeout(this.loadtimeout.bind(this), config.timeout);
            }
        }
    };
    HiveXhrLoader.prototype.loadtimeout = function () {
        console.warn("timeout while loading " + this.context.url);
        this.callbacks.onTimeout(this.stats, this.context);
    };
    HiveXhrLoader.prototype.loadprogress = function (event) {
        var stats = this.stats;
        stats.loaded = event.loaded;
        if (event.lengthComputable) {
            stats.total = event.total;
        }
        var onProgress = this.callbacks.onProgress;
        if (onProgress) {
            // last args is to provide on progress data
            onProgress(stats, this.context, null);
        }
    };
    return HiveXhrLoader;
}());
exports.HiveXhrLoader = HiveXhrLoader;
//# sourceMappingURL=HiveXhrLoaderV0.js.map

/***/ }),

/***/ "../../../core/build/core/src/common/loaders/HiveXhrLoaderV1.js":
/*!***************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/common/loaders/HiveXhrLoaderV1.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.HiveXhrLoader = exports.LoadStats = void 0;
var Framework_1 = __webpack_require__(/*! ../../core/Framework */ "../../../core/build/core/src/core/Framework.js");
var basicutils_hive_1 = __webpack_require__(/*! ../basicutils.hive */ "../../../core/build/core/src/common/basicutils.hive.js");
// This is a copy because Hlsjs does not export this?
var LoadStats = /** @class */ (function () {
    function LoadStats() {
        this.aborted = false;
        this.loaded = 0;
        this.retry = 0;
        this.total = 0;
        this.chunkCount = 0;
        this.bwEstimate = 0;
        this.loading = { start: 0, first: 0, end: 0 };
        this.parsing = { start: 0, end: 0 };
        this.buffering = { start: 0, first: 0, end: 0 };
    }
    return LoadStats;
}());
exports.LoadStats = LoadStats;
var AGE_HEADER_LINE_REGEX = /^age:\s*[\d.]+\s*$/m;
var HiveXhrLoader = /** @class */ (function () {
    function HiveXhrLoader(config) {
        this.config = null;
        this.callbacks = null;
        this.loader = null;
        this.xhrSetup = config ? config.xhrSetup : null;
        this.stats = new LoadStats();
        this.retryDelay = 0;
        this.logger = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.LOGGER).log();
    }
    HiveXhrLoader.prototype.destroy = function () {
        this.callbacks = null;
        this.abortInternal();
        this.loader = null;
        this.config = null;
    };
    HiveXhrLoader.prototype.abortInternal = function () {
        var loader = this.loader;
        self.clearTimeout(this.requestTimeout);
        self.clearTimeout(this.retryTimeout);
        if (loader) {
            loader.onreadystatechange = null;
            loader.onprogress = null;
            if (loader.readyState !== 4) {
                this.stats.aborted = true;
                loader.abort();
            }
        }
    };
    HiveXhrLoader.prototype.abort = function () {
        var _a;
        this.abortInternal();
        if ((_a = this.callbacks) === null || _a === void 0 ? void 0 : _a.onAbort) {
            this.callbacks.onAbort(this.stats, this.context, this.loader);
        }
    };
    HiveXhrLoader.prototype.load = function (context, config, callbacks) {
        if (this.stats.loading.start) {
            throw new Error('Loader can only be used once.');
        }
        this.stats.loading.start = self.performance.now();
        this.context = context;
        this.config = config;
        this.callbacks = callbacks;
        this.retryDelay = config.retryDelay;
        this.loadInternal();
    };
    HiveXhrLoader.prototype.loadInternal = function () {
        var _a, _b, _c;
        var _d = this, config = _d.config, context = _d.context;
        if (!config) {
            return;
        }
        var xhr = (this.loader = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.HTTP_REQUEST));
        var stats = this.stats;
        stats.loading.first = 0;
        stats.loaded = 0;
        var xhrSetup = this.xhrSetup;
        try {
            if (xhrSetup) {
                try {
                    xhr = this.loader = (_a = xhrSetup(xhr, context)) !== null && _a !== void 0 ? _a : xhr;
                }
                catch (e) {
                    // fix xhrSetup: (xhr, url) => {xhr.setRequestHeader("Content-Language", "test");}
                    // not working, as xhr.setRequestHeader expects xhr.readyState === OPEN
                    this.logger.warn("Integration-provided xhrSetup failed: " + e);
                }
            }
            if (!xhr.readyState) {
                xhr.open('GET', context.url, true);
            }
        }
        catch (e) {
            // IE11 throws an exception on xhr.open if attempting to access an HTTP resource over HTTPS
            (_c = (_b = this.callbacks) === null || _b === void 0 ? void 0 : _b.onError) === null || _c === void 0 ? void 0 : _c.call(_b, { code: xhr.status, text: e.message }, context, xhr);
            return;
        }
        if (context.rangeEnd) {
            xhr.setRequestHeader('Range', 'bytes=' + context.rangeStart + '-' + (context.rangeEnd - 1));
        }
        xhr.onreadystatechange = this.readystatechange.bind(this);
        xhr.onprogress = this.loadprogress.bind(this);
        var responseType = this.context.responseType;
        xhr.responseType = basicutils_hive_1.isValidResponseType(responseType) ? responseType : '';
        // setup timeout before we perform request
        xhr.timeout = config.timeout;
        self.clearTimeout(this.requestTimeout);
        this.requestTimeout = self.setTimeout(this.loadtimeout.bind(this), config.timeout);
        xhr.send();
    };
    HiveXhrLoader.prototype.readystatechange = function (event) {
        var _a, _b;
        var _c = this, context = _c.context, stats = _c.stats;
        var xhr = event.currentTarget, readyState = xhr.readyState;
        if (!context || !xhr) {
            return;
        }
        var config = this.config;
        // don't proceed if xhr has been aborted
        if (stats.aborted) {
            return;
        }
        // >= HEADERS_RECEIVED
        if (readyState >= 2) {
            // clear xhr timeout and rearm it if readyState less than 4
            self.clearTimeout(this.requestTimeout);
            if (stats.loading.first === 0) {
                stats.loading.first = Math.max(self.performance.now(), stats.loading.start);
            }
            if (readyState === 4) {
                xhr.onreadystatechange = null;
                xhr.onprogress = null;
                var status_1 = xhr.status;
                // http status between 200 to 299 are all successful
                if (status_1 >= 200 && status_1 < 300) {
                    stats.loading.end = Math.max(self.performance.now(), stats.loading.first);
                    var data = void 0;
                    var len = void 0;
                    if (context.responseType === 'arraybuffer') {
                        data = xhr.response;
                        len = data.byteLength;
                    }
                    else {
                        data = xhr.responseText;
                        len = data.length;
                    }
                    stats.loaded = stats.total = len;
                    if (!this.callbacks) {
                        return;
                    }
                    var onProgress = this.callbacks.onProgress;
                    if (onProgress) {
                        onProgress(stats, context, data, xhr);
                    }
                    if (!this.callbacks) {
                        return;
                    }
                    var response = {
                        url: xhr.responseURL,
                        data: data
                    };
                    this.callbacks.onSuccess(response, stats, context, xhr);
                }
                else {
                    // if max nb of retries reached or if http status between 400 and 499 (such error cannot be recovered, retrying is useless), return error
                    if (stats.retry >= config.maxRetry ||
                        (status_1 >= 400 && status_1 < 499)) {
                        this.logger.error(status_1 + " while loading " + context.url);
                        (_b = (_a = this.callbacks) === null || _a === void 0 ? void 0 : _a.onError) === null || _b === void 0 ? void 0 : _b.call(_a, { code: status_1, text: xhr.statusText }, context, xhr);
                    }
                    else {
                        // retry
                        this.logger.warn(status_1 + " while loading " + context.url + ", retrying in " + this.retryDelay + "...");
                        // abort and reset internal state
                        this.abortInternal();
                        this.loader = null;
                        // schedule retry
                        self.clearTimeout(this.retryTimeout);
                        this.retryTimeout = self.setTimeout(this.loadInternal.bind(this), this.retryDelay);
                        // set exponential backoff
                        this.retryDelay = Math.min(2 * this.retryDelay, config.maxRetryDelay);
                        stats.retry++;
                    }
                }
            }
            else {
                // readyState >= 2 AND readyState !==4 (readyState = HEADERS_RECEIVED || LOADING) rearm timeout as xhr not finished yet
                self.clearTimeout(this.requestTimeout);
                this.requestTimeout = self.setTimeout(this.loadtimeout.bind(this), config.timeout);
            }
        }
    };
    HiveXhrLoader.prototype.loadtimeout = function () {
        this.logger.warn("timeout while loading " + this.context.url);
        var callbacks = this.callbacks;
        if (callbacks) {
            this.abortInternal();
            callbacks.onTimeout(this.stats, this.context, this.loader);
        }
    };
    HiveXhrLoader.prototype.loadprogress = function (event) {
        var stats = this.stats;
        stats.loaded = event.loaded;
        if (event.lengthComputable) {
            stats.total = event.total;
        }
    };
    HiveXhrLoader.prototype.getCacheAge = function () {
        var result = null;
        if (this.loader &&
            AGE_HEADER_LINE_REGEX.test(this.loader.getAllResponseHeaders())) {
            var ageHeader = this.loader.getResponseHeader('age');
            result = ageHeader ? parseFloat(ageHeader) : null;
        }
        return result;
    };
    return HiveXhrLoader;
}());
exports.HiveXhrLoader = HiveXhrLoader;
//# sourceMappingURL=HiveXhrLoaderV1.js.map

/***/ }),

/***/ "../../../core/build/core/src/common/logger.hive.js":
/*!***************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/common/logger.hive.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ErrorMonitor = void 0;
var key_hive_1 = __webpack_require__(/*! ./key.hive */ "../../../core/build/core/src/common/key.hive.js");
var options_hive_1 = __webpack_require__(/*! ./options.hive */ "../../../core/build/core/src/common/options.hive.js");
var build_defaults_1 = __webpack_require__(/*! ./build.defaults */ "../../../core/build/core/src/common/build.defaults.js");
var ErrorCodes = __webpack_require__(/*! ./error.hive */ "../../../core/build/core/src/common/error.hive.js");
var error_hive_1 = __webpack_require__(/*! ./error.hive */ "../../../core/build/core/src/common/error.hive.js");
var Framework_1 = __webpack_require__(/*! ../core/Framework */ "../../../core/build/core/src/core/Framework.js");
// the global values configurable by webpack
var ATATUS_key = build_defaults_1.BuildParameters.ATATUS_key;
var ATATUS_version = build_defaults_1.BuildParameters.ATATUS_version;
var ATATUS_DEFAULT = build_defaults_1.BuildParameters.ATATUS_DEFAULT;
var ATATUS_EXCLUDE_ROWS = build_defaults_1.BuildParameters.ATATUS_EXCLUDE_ROWS;
/**
 * Singleton class with on the first instantiation will attempt to install
 * the ErrorMonitor, a wrapper for Atatus (https://www.atatus.com)
 * The default setting, which can be overriden manually by ErrorMonitorOptions
 *
 * When the ErrorMonitor is installed every console error will be directly notified to the atatus service
 */
var ErrorMonitor = /** @class */ (function () {
    function ErrorMonitor(version) {
        var _this = this;
        // Error Monitor installed check
        this.isActive = false;
        this.atatusPresent = typeof atatus !== 'undefined' && atatus != null;
        this.globalCustomData = {};
        if (ErrorMonitor.instance) {
            throw new Error('Error: Instantiation failed: Use AtatusLogger.getInstance() instead of new.');
        }
        // key and version can be specified or use defaults (configurable by gulp)
        var key = options_hive_1.ErrorMonitorOptions.key != undefined ? options_hive_1.ErrorMonitorOptions.key : ATATUS_key;
        var enableRUM = options_hive_1.ErrorMonitorOptions.enabledRUM == true;
        var keyHandlerEnabled = options_hive_1.ErrorMonitorOptions.enableKeyCombination == true;
        // if error filter is enabled, try to generate a extract this script url
        var errorFilter;
        var enableErrorFilter = options_hive_1.ErrorMonitorOptions.enabledErrorFilter == true;
        if (enableErrorFilter)
            errorFilter = this.extractScriptFilter();
        this.version = version;
        /*
         * enable Atatus only if it has not been explicitly disabled and
         * it's enabled by default (configurable by webpack)
         */
        if (this.atatusPresent &&
            // enabled not specified, check the default setting
            ((options_hive_1.ErrorMonitorOptions.enabled == undefined && ATATUS_DEFAULT) ||
                // enabled specified and true
                (options_hive_1.ErrorMonitorOptions.enabled != undefined && options_hive_1.ErrorMonitorOptions.enabled == true))) {
            // install atatus
            atatus.config(key, {
                enableSourcemap: true,
                // disable Real User Monitor
                disableRUM: !enableRUM,
                // Enable or Disable all console activity.
                // When we set this true, whenever we have a this.logger.error(....) ErrorMonitor catches it and sends a message to atatus
                console: false,
                version: version,
                beforeErrorSend: function (payload) {
                    // check if the error must ignore the filter looking for "forceSend" in the
                    // customData, and remove it before forwarding the error
                    var forceSend = false;
                    payload.customData = payload.customData || {};
                    if (typeof payload.customData.forceSend !== 'undefined') {
                        forceSend = payload.customData.forceSend;
                        delete payload.customData.forceSend;
                        if (Object.keys(payload.customData).length === 0)
                            payload.customData = null;
                    }
                    for (var key_1 in _this.globalCustomData) {
                        if (_this.globalCustomData.hasOwnProperty(key_1)) {
                            payload.customData[key_1] = _this.globalCustomData[key_1];
                        }
                    }
                    // if filter not enabled or is forced, send it
                    if (!enableErrorFilter || forceSend)
                        return true;
                    // if we could not extract the errorFilter don't send them
                    if (!errorFilter)
                        return false;
                    try {
                        var forward = false;
                        if (payload.backTraces) {
                            // basically we want to check if any trace file is not our script or atatus
                            // (first ATATUS_ROWS_TO_EXCLUDE lines of our script)
                            for (var _i = 0, _a = payload.backTraces; _i < _a.length; _i++) {
                                var trace = _a[_i];
                                // if it's our file, the line must be > ATATUS_ROWS_TO_EXCLUDE
                                var isHiveScript = trace.f.indexOf(errorFilter) > -1;
                                if (isHiveScript && trace.ln > ATATUS_EXCLUDE_ROWS) {
                                    forward = true;
                                    break;
                                }
                            }
                            if (forward) {
                                // cleanup and remove our timestamp
                                payload.name = payload.name.replace(/%s \[[0-9]{2}:[0-9]{2}:[0-9]{2}:[0-9]+] /, '');
                                // When we send a Status Code Error, we want to tag it with its error name
                                // described in MainStatusCode (e.g.: Ticket Not Allowed), so it is easier
                                // to track
                                if (payload.name.indexOf('Status Code Error:') >= 0)
                                    payload.tags = ['Plugin Error Code', (payload.name.split(':')[1]).trim()];
                            }
                        }
                        return forward;
                    }
                    catch (e) {
                        return false;
                    }
                }
            }).install();
            if (keyHandlerEnabled)
                this.registerKeyHandler();
            // the error monitor is correctly activated
            this.isActive = true;
            if (window.console)
                console.log('[HiveComm] Error Monitor installed [RUM:' + enableRUM + ', KeyHandler:' + keyHandlerEnabled + ']');
            if (enableErrorFilter && !errorFilter)
                this.logError('Could not extract error filter');
        }
    }
    ErrorMonitor.getInstance = function (version) {
        if (version === void 0) { version = '3.0.0'; }
        if (this.instance === undefined)
            this.instance = new ErrorMonitor(version);
        return this.instance;
    };
    /**
     * install key combination handler to uplad console logs
     */
    ErrorMonitor.prototype.registerKeyHandler = function () {
        // register CTRL + SHIFT + X to Upload logs to atatus
        key_hive_1.KeyHandlerHiveComm.getInstance().registerKeyCombination([16, 17, 88], function () {
            try {
                throw new Error('Upload console logs');
            }
            catch (e) {
                atatus.notify(e);
                if (window.console)
                    console.log('[HiveComm] console log uploaded for debugging');
            }
        });
    };
    /**
     * extract this script url
     * @returns {string}
     */
    ErrorMonitor.prototype.extractScriptFilter = function () {
        try {
            throw new Error('test');
        }
        catch (err) {
            var match = err.stack.match(/(\/\/.*\.js)/i);
            if (match && match.length > 0)
                return match[0];
        }
    };
    // ---------------------------------------- PUBLIC METHODS -------------------------------
    ErrorMonitor.prototype.setUser = function (userId) {
        if (this.atatusPresent && this.isActive)
            atatus.setUser(userId);
    };
    ErrorMonitor.prototype.setLogger = function (logger) {
        this.logger = logger;
    };
    ErrorMonitor.prototype.setCustomData = function (customData) {
        if (this.atatusPresent && this.isActive)
            atatus.setCustomData(customData);
    };
    ErrorMonitor.prototype.setGlobalCustomData = function (customData) {
        for (var key in customData) {
            if (customData.hasOwnProperty(key)) {
                this.globalCustomData[key] = customData[key];
            }
        }
    };
    /**
     * Add the onerror callback function specified in the plugin options to notify
     * the partner of all the error/warning usually sent to atatus
     * @param onErrorCallback {onErrorCallbackFunction}
     */
    ErrorMonitor.prototype.setOnErrorCallback = function (onErrorCallback) {
        this.onErrorCallback = onErrorCallback;
    };
    ErrorMonitor.prototype.resetOnErrorCallback = function () {
        this.onErrorCallback = null;
    };
    ErrorMonitor.prototype.logError = function (message, loggerIdOrData, detailedErrorCode, customData, tags) {
        var loggerId = '';
        var severity = (detailedErrorCode && error_hive_1.SeverityMap[detailedErrorCode]) ? error_hive_1.SeverityMap[detailedErrorCode] : error_hive_1.HiveSeverity.NORMAL;
        // If second parameter is a string, treat it as loggerId.
        if (typeof loggerIdOrData === 'string') {
            loggerId = loggerIdOrData.trim();
        }
        // If second parameter is not a string, treat it as customData.
        else if (typeof loggerIdOrData !== 'undefined') {
            customData = loggerIdOrData;
        }
        if (customData instanceof Error || (customData && typeof customData !== 'object')) {
            customData = { error: customData.toString() };
        }
        if (!customData) {
            customData = {};
        }
        customData['errorCode'] = (detailedErrorCode) ? detailedErrorCode : ErrorCodes.GENERIC_ERROR;
        if (this.logger) {
            if (Object.keys(customData).length > 0) {
                this.logger.warn(loggerId + " " + message, customData);
            }
            else {
                this.logger.warn(loggerId + " " + message);
            }
        }
        if (Framework_1.Framework.isSimulated()) {
            this.logger = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.LOGGER).log();
        }
        // Set the loggerId inside customData only if it's not already set.
        if (loggerId) {
            tags = tags ? tags.concat([loggerId]) : [loggerId];
        }
        customData.forceSend = true;
        if (this.atatusPresent && this.isActive) {
            try {
                throw new Error(message);
            }
            catch (e) {
                atatus.notify(e, customData, tags);
            }
        }
        if (this.onErrorCallback) {
            try {
                this.onErrorCallback({
                    pluginVersion: this.version,
                    reportingId: (this.globalCustomData) ? this.globalCustomData['reportingGuid'] : '',
                    p2pId: (this.globalCustomData) ? this.globalCustomData['p2pId'] : '',
                    message: message,
                    severity: severity,
                    code: customData['errorCode']
                });
            }
            catch (error) {
                this.logger.warn('Error in the onErrorCallback', error);
            }
        }
    };
    ErrorMonitor.prototype.setTags = function (tags) {
        if (this.atatusPresent && this.isActive)
            atatus.setTags(tags);
    };
    /**
     * This methods sends a notification on atatus in oder to create an event out of a specific Error
     * @param error {Error}
     * @param customData {Hash} [optional]
     * The custom data are sent to atatus and can be seen in the context tab of the error
     */
    ErrorMonitor.prototype.notify = function (error, customData) {
        if (this.atatusPresent && this.isActive) {
            if (!customData)
                customData = {};
            customData.forceSend = true;
            atatus.notify(error, customData);
        }
    };
    return ErrorMonitor;
}());
exports.ErrorMonitor = ErrorMonitor;
//# sourceMappingURL=logger.hive.js.map

/***/ }),

/***/ "../../../core/build/core/src/common/options.hive.js":
/*!****************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/common/options.hive.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.OptionsConfigurator = exports.ErrorMonitorOptions = exports.UrlConfigurableOptions = exports.HiveTechOptions = exports.Options = void 0;
var HiveConfig_1 = __webpack_require__(/*! ../core/HiveConfig */ "../../../core/build/core/src/core/HiveConfig.js");
var constants_hive_1 = __webpack_require__(/*! ./constants.hive */ "../../../core/build/core/src/common/constants.hive.js");
var constants_hivejava_hive_1 = __webpack_require__(/*! ./techs/hivejava/constants.hivejava.hive */ "../../../core/build/core/src/common/techs/hivejava/constants.hivejava.hive.js");
var build_defaults_1 = __webpack_require__(/*! ./build.defaults */ "../../../core/build/core/src/common/build.defaults.js");
/**
 * General configurable options
 */
var Options = /** @class */ (function () {
    function Options() {
        /**
         * Ice Candidates Topic name for external gathering
         * @type {string}
         * @default undefined
         */
        this.candidateTopicName = undefined;
        /**
         * Hive Java monitor port
         * @type {number}
         * @default 8899 for http, 8898 for https
         */
        this.monitorPort = !constants_hive_1.Constants.IS_HTTPS ? constants_hivejava_hive_1.HiveJavaConstants.DEFAULT_MONITOR_HTTP_PORT : constants_hivejava_hive_1.HiveJavaConstants.DEFAULT_MONITOR_HTTPS_PORT;
        /**
         * Hive Java player port
         * @type {number}
         * @default 8999 for http, 8998 for https
         */
        this.playerPort = !constants_hive_1.Constants.IS_HTTPS ? constants_hivejava_hive_1.HiveJavaConstants.DEFAULT_PLAYER_HTTP_PORT : constants_hivejava_hive_1.HiveJavaConstants.DEFAULT_PLAYER_HTTPS_PORT;
        /**
         * the feedback interval of statistic forwarding in millisecond.
         * @type {number}
         * @default 2000
         */
        this.feedbackPeriod = 2000;
        /**
         * time interval in which if the statistics forwarded are always identical, we assume the player is idle
         * and the session over
         * @type {number}
         * @default 60000
         */
        this.idleTimePeriod = 60000;
        /**
         * enable or disable the check for other active sessions on Hive Java. Default off;
         * @type {boolean}
         */
        this.useSessionCheck = constants_hive_1.Constants.DEFAULT_SESSION_CHECK;
        /**
         * configure the debug level for the Hive Player Plugin.
         * The allowed levels are: </br>
         * <i><ul>
         * <li>error</li>
         * <li>warn</li>
         * <li>notice</li>
         * <li>info</li>
         * <li>debug</ul>
         * </ul></i>
         * </br>
         * @default 'notice' if production plugin, otherwise 'debug'
         */
        this.debugLevel = build_defaults_1.BuildParameters.SERVICE_ENDPOINT_TEST ? 'debug' : 'notice';
        /**
         * if true, set hive debug level to 'debug'
         */
        this.isSDNDebug = false;
        /**
         * order in which the hive techs [[TechNameType]] will try to resolve a ticket
         * Usually the default tech order depends on the plugin license:
         * - <i>[player].stats.hive.min.js</i> default tech order is: ['StatsJS']
         * - <i>[player].hive.min.js</i> default tech order is: ['HiveJava', 'StatsJS']
         * - <i>[player].hivejs.hive.min.js</i> default tech order is: ['HiveJS', 'StatsJS']
         *
         * it is possible to override the default tech order for example to disable HiveJava proxy and use directly
         * only the StatsJS telemetry pack
         */
        this.hiveTechOrder = [];
        /**
         * Customer-defined userId.
         * This information will be added to the Insights Peer Report.
         */
        this.telemetryId = null;
        /**
         * if true activate the Hive-Tester Driver feedback to monitor the player status
         * @type {boolean}
         * @default false
         */
        this.silent = false;
        /**
         * if true dinamically appends a timestamp to the console logs
         * @type {boolean}
         * @default true
         */
        this.loggerTimestamp = HiveConfig_1.HiveConfig.Framework.LoggerTimestamp;
        /**
         * Test ID used for generating silent test related metric snapshots
         * (for now working just for the JAVA tech)
         * @type {string}
         * @default null
         */
        this.testId = null;
        /**
         * this defines the max time (in millisecond) allowed to the plugin to initialize and start the session
         * Right now not all plugins supports it. The default can be set from the build.
         * @type {number}
         * @default BuildParameters.PLUGIN_TIMEOUT
         */
        this.pluginTimeout = build_defaults_1.BuildParameters.PLUGIN_TIMEOUT;
        /**
         * For WebRTC and Stats Only-based playback, do not send reporting snapshots
         * if the player viewing time is less than this threshold (milliseconds)
         * @type {number}
         * @default BuildParameters.PLUGIN_TIMEOUT
         */
        this.reportingThreshold = build_defaults_1.BuildParameters.REPORTING_THRESHOLD;
        /**
         * Timeout used for reducing the time to fail when checking if the Hive Agent is ready
         * @type {number}
         * @default 0ms - Infinite
         */
        this.readyCheckTimeout = 0;
        /**
         * Mac Java clients are slower when responding to /version.json. If this value is different than -1 we will
         * use this value for mac clients instead
         */
        this.macReadyCheckTimeout = -1;
        /**
         * define a callback to be called when the hive setup completes. This will give the status code generated
         * by the Plugin Status Code Generator. If given a string, the option represents a named function in the
         * this-or-ancestor window.
         * See: comm.hive.ts
         *
         * <p><h4>Status Codes Table</h2></p>
         * <table>
         * <thead>
         * <tr>
         * <th>Status Description</th>
         * <th>Status Code (Hexadecimal)</th>
         * <th>Status Code (Decimal)</th>
         * </tr>
         * </thead>
         * <tbody>
         * <tr>
         * <td>Success - Plugin Started with StatsJs Tech</td>
         * <td>0x00010000</td>
         * <td>65536</td>
         * </tr>
         * <tr>
         * <td>Success - Plugin Started with Hive Java Tech</td>
         * <td>0x00100000</td>
         * <td>1048576</td>
         * </tr>
         * <tr>
         * <td>Success - Plugin Started with HiveJS Tech</td>
         * <td>0x01000000</td>
         * <td>16777216</td>
         * </tr>
         * <tr>
         * <td>Error - Hive Plugin not Allowed (amp only)</td>
         * <td>0x10000000</td>
         * <td>268435456</td>
         * </tr>
         * <tr>
         * <td>Error - Ticket Not Resolved</td>
         * <td>0x20000000</td>
         * <td>536870912</td>
         * </tr>
         * <tr>
         * <td>Error - Plugin Initialization Timeout</td>
         * <td>0x30000000</td>
         * <td>805306368</td>
         * </tr>
         * </tbody>
         * </table>
         *
         * @param statusCode
         */
        this.onSourceSetCompleted = function (statusCode) {
            // noop
        };
        /**
         * define a callback that will be called when the hive setup completes.
         * The argument will be a special reference to the HivePlugin with special
         * APIs. If given a string, the option represents a named function in the
         * this-or-ancestor window.
         * See: HivePluginReference
         * @param plugin
         */
        this.onLoadingCompleted = function (plugin) {
            // noop
        };
        /**
        * detectPrivateIP accepts a boolean value to disable private IP detection, useful
        * for HiveJava silent tests on partner-controlled HTML pages. Defaults to the plugin's
        * build parameters.
        * @type {boolean}
        */
        this.detectPrivateIP = build_defaults_1.BuildParameters.DETECT_PRIVATEIP;
        this.authTokenEnabled = true;
        this.dashRemoveBitrateSize = false;
        this.dashFilterBitrates = null;
        /**
         * @hidden
         */
        this.staticPartnerId = null;
        /**
         * @hidden
         */
        this.staticCustomerId = null;
        /**
         * @hidden
         */
        this.audioMetrics = true;
        this.logJsonSnapshots = undefined;
        /**
         * define a callback to be called when the hive setup completes. This will give the generated session
         * with ticket, manifest and tech info. If given a string, the option represents a named function in the
         * this-or-ancestor window.
         * See: comm.hive.ts
         *
         * @param session: {@link HiveSession}
         */
        this.onActiveSession = function (session) {
            // noop
        };
        /**
         * define a callback called by the plugin when any warning or error happens during the execution of both
         * integration and webRTC sections
         *
         * Message Structure:
         *
         *  { <br>
         *      pluginVersion: {string}, <br>
         *      reportingId: {string}, <br>
         *      severity: {HiveSeverity}, <br>
         *      message: {string}, <br>
         *      code: {number}, <br>
         *      p2pId: {string}, <br>
         *  }
         * If given a string, the option represents a named function in the
         * this-or-ancestor window.
         * @param message: {@link HiveErrorMessage}
         */
        this.onError = function (message) { };
        /**
         * Define a callback to be notified when the state of the hive session changes.
         *
         * Message Structure:
         *
         *  { <br>
         *      id: {string} the identifier of the session, <br>
         *      state: {string} the new state of the session <br>
         *  }
         * If given a string, the option represents a named function in the
         * this-or-ancestor window.
         * @param message: {@link SessionStateChangeMessage}
         */
        this.onSessionStateChange = function (message) { };
        /**
         * Callback that sends back the duration of each step of the initialization of the plugin <br>
         *  init Event Structure:
         *
         *  { <br>
         *      initStep: {@link InitStep}, <br>
                ts: number, <br>
                duration: number, <br>
         *  }
         * <br>
         * <br>
         * InitStep Structure: <br>
         * {<br>
         *      TIME_TO_AUTH_TOKEN_ENDPOINT,  // 0 <br>
         *      TIME_TO_AUTH_HIVE_ENDPOINT,   // 1 <br>
         *      TIME_TO_RI_INIT_SUCCESS,      // 2 <br>
         *      TIME_TO_TECH_INIT_SUCCESS,    // 3 <br>
         *      TIME_TO_TECH_INIT_FAIL,       // 4 <br>
         *      TIME_TO_CLIENT_NOT_READY,     // 5 <br>
         *      TIME_TO_CLIENT_NOT_FOUND,     // 6 <br>
         *      TIME_TO_OVERALL_AUTH,         // 7 <br>
         *      TIME_TO_PLAYER_INIT,          // 8 <br>
         *      TIME_TO_SESSION_ACTIVATED     // 9 <br>
         * }<br>
         *
         * @param initStepEvent {@link InitStepEvent}
         */
        this.onInitStep = function (initStepEvent) { };
        /**
         *  It is possible to use a single ticket for multiple player sources on
         * different domains. For example, if the ticket's manifest is
         * https://example.com/manifest.m3u8, setting this option to the regular
         * expression `/example2.com/` will allow the player to load a source from
         * https://example2.com/manifest.m3u8. The manifest paths **MUST** match:
         * only the domain may be different.
         *
         * This setting only affects WebRTC and Stats Only.
         */
        this.manifestDomainMatcher = undefined;
        /**
         * Do not use Hive for VOD assets. This setting only affects certain
         * plugins.
         */
        this.disableHiveForVod = false;
        /**
         * Event name. This name is used in lieu of the Event/Video ID on the Hive
         * Portal (Video Listing, Video Monitor, Insights) if no name is passed in
         * the ticket creation metadata. Since JWT Authorization does not use a
         * ticket, this value *SHOULD* be provided by the Partner.
         */
        this.eventName = null;
        /**
         * Partner-provided reportingId
         * @type {string}
         * @default undefined
         */
        this.reportingId = undefined;
    }
    return Options;
}());
exports.Options = Options;
/**
 * Options specific for each tech</br>
 * Usage:
 * <pre><code>
 *  options: {
 *       StatsJS: {
 *           onError:function (error) {
 *               console.log(error)
 *               // return whether you want the plugin to try to
 *               // initialize the session through another tech
 *               return true
 *           },
 *           onActiveSession:function (session) {
 *               console.log("active hive session ", session)
 *           }
 *       }
 *  }</code></pre>
 */
var HiveTechOptions = /** @class */ (function () {
    function HiveTechOptions() {
        /**
         * The tech will fail if will not initiate a session before the timeout (in millisecond)
         * @type {number}
         * @default 30000
         */
        this.initTimeout = 30000;
        /**
         * Partner-specific overrides for detecting the protocol (DASH, HLS) from
         * the manifest's URL. Provide regular expressions in either the `hls` or
         * `dash` properties in this key. If present, the regular expression will be
         * used to determine if a given manifest is an HLS or DASH manifest,
         * respectively.
         * @type {@link HiveContextMatcher}
         */
        this.contextMatcher = undefined;
        /**
         * Define a callback in case a specific tech could NOT initialize a session. If
         * given a string, the option represents a named function in the
         * this-or-ancestor window.
         * @param error
         * @returns {boolean} whether you want the plugin to try to
         *          initialize the session through the next techs
         */
        this.onError = function (error) {
            return true;
        };
        /**
         * Define a callback in case a specific tech could initialize a session. If
         * given a string, the option represents a named function in the
         * this-or-ancestor window.
         * @param session
         */
        this.onActiveSession = function (session) {
        };
    }
    return HiveTechOptions;
}());
exports.HiveTechOptions = HiveTechOptions;
/**
 * List of parameter names that can be passed to the page URL to setup
 * correspondent plugin options.
 */
var UrlConfigurableOptions = /** @class */ (function () {
    function UrlConfigurableOptions() {
        /**
         * hivePlayerPort url parameter accepts a numeric value for the
         * player port binded by Hive Java client
         * @type{number}
         */
        this.hivePlayerPort = 'playerPort';
        /**
         * hiveMonitorPort url parameter accepts a numeric value for the
         * monitor port binded by Hive Java client
         * @type{number}
         */
        this.hiveMonitorPort = 'monitorPort';
        /**
         * hiveSilent url parameter accepts a boolean value to initialize a session
         * as a silent test one. If true, HiveComm will start a periodic ping back
         * to the local Hive Tester instance
         * @type{boolean}
         */
        this.hiveSilent = 'silent';
        /**
         * hiveDebugLevel accepts a string value to initialize the debug console level.
         * The valid values are the same as "debugLevel"
         * @type {string}
         */
        this.hiveDebugLevel = 'debugLevel';
        /**
        * isSDNDebug is a shortcut used by MS Stream to set the debug log level to 'debug'
        * @type {boolean}
        * @default false
        */
        this.isSDNDebug = 'isSDNDebug';
        /**
         * hiveLoggerTimestamp accepts a boolean value to activate or deactivate appending
         * a timestamp in our console logs
         * @type {boolean}
         */
        this.hiveDebugTimestamp = 'loggerTimestamp';
        /**
         * configure the timeout in millisecond for the plugin ticket initSession
         * @type {number}
         */
        this.hiveSetupTimeout = 'setupTimeout';
        /**
         * configure the timeout in millisecond for the java tech to resolve
         * the ticket
         * @type {number}
         */
        this.hiveJavaTimeout = 'initTimeout';
        /**
         * configure the timeout in milliseconds for the java tech to resolve the session request
         * @type {number}
         */
        this.hiveWarnJavaTimeout = 'warnSlowRespTimeout';
        /**
         * configure the testId value in the metrics snapshots (Used when running a silent test)
         */
        this.hiveTestId = 'testId';
        /**
         * detectPrivateIP accepts a boolean value to disable private IP detection, useful
         * for HiveJava silent tests on partner-controlled HTML pages
         * @type {boolean}
         */
        this.hiveDetectPrivateIP = 'detectPrivateIP';
        this.hiveAuthTokenEnabled = 'authTokenEnabled';
        this.hiveDashRemoveBitrateSize = 'dashRemoveBitrateSize';
        this.hiveDashFilterBitrates = 'dashFilterBitrates';
        /**
         * force to debug log the jsonized version of
         * - metric snapshots
         * - track snapshots
         * - tracker request/response
         * @type {string}
         */
        this.hiveLogJsonSnapshots = 'logJsonSnapshots';
        /**
         * force the track snapshot and the tracker to have the above partner id
         * @hidden
         */
        this.hiveStaticPartnerId = 'staticPartnerId';
        /**
         * force the track snapshot and the tracker to have the above customer id
         * @hidden
         */
        this.hiveStaticCustomerId = 'staticCustomerId';
        /**
         * force the metric snapshots to include/exclude the audio metrics
         * @hidden
         */
        this.hiveAudioMetrics = 'audioMetrics';
    }
    return UrlConfigurableOptions;
}());
exports.UrlConfigurableOptions = UrlConfigurableOptions;
/**
 * Overriding configurations for the Error Monitoring component.
 * The ErrorMonitoring component provides RUM (Real User Monitor) and error tracking.
 * This configurations are global per page.
 */
var ErrorMonitorOptions = /** @class */ (function () {
    function ErrorMonitorOptions() {
    }
    /**
     * Real User Monitor enabled. If true the component
     * will monitor and send performance data of page and AJAX
     * @type {boolean}
     * @default false
     */
    ErrorMonitorOptions.enabledRUM = false;
    /**
     * Upload Log Key Combination enabled.
     * If true, pressing the combination CTRL + SHIFT + X will upload the last 10 logs
     * @default true
     */
    ErrorMonitorOptions.enableKeyCombination = true;
    /**
     * enable a filter for JS errors. If true it will track only errors generated
     * by the Hive plugin only.
     * @type {boolean}
     * @default false
     */
    ErrorMonitorOptions.enabledErrorFilter = true;
    return ErrorMonitorOptions;
}());
exports.ErrorMonitorOptions = ErrorMonitorOptions;
/**
 * @hidden
 *
 * Static class with special logic for applying HiveConfig based
 * on url parameters, useful for silent tests with page not controlled
 * by us, like SMB
 */
var OptionsConfigurator = /** @class */ (function () {
    function OptionsConfigurator() {
    }
    OptionsConfigurator.applySpecialDevConfig = function (options) {
        if ('dashRemoveBitrateSize' in options && options.dashRemoveBitrateSize) {
            if (window['HiveConfig'] && window['HiveConfig']['Dash']) {
                window['HiveConfig']['Dash']['DashRemoveBitrateSize'] = options.dashRemoveBitrateSize;
            }
        }
        if ('dashFilterBitrates' in options && options.dashFilterBitrates) {
            if (window['HiveConfig'] && window['HiveConfig']['Dash']) {
                window['HiveConfig']['Dash']['DashFilterBitrates'] = options.dashFilterBitrates;
            }
        }
        if ('staticCustomerId' in options && options.staticCustomerId) {
            if (window['HiveConfig'] && window['HiveConfig']['ClientInfo']) {
                window['HiveConfig']['ClientInfo']['CustomerId'] = options.staticCustomerId;
            }
        }
        if ('staticPartnerId' in options && options.staticPartnerId) {
            if (window['HiveConfig'] && window['HiveConfig']['ClientInfo']) {
                window['HiveConfig']['ClientInfo']['PartnerId'] = options.staticPartnerId;
            }
        }
        if ('audioMetrics' in options && !options.audioMetrics) {
            if (window['HiveConfig'] && window['HiveConfig']['Stats']) {
                window['HiveConfig']['Stats']['AudioAccounting'] = options.audioMetrics;
            }
        }
        if ('detectPrivateIP' in options && typeof options.detectPrivateIP === 'boolean') {
            if (window['HiveConfig'] && window['HiveConfig']['ConnInfo']) {
                window['HiveConfig']['ConnInfo']['detectPrivateIP'] = options.detectPrivateIP;
            }
        }
        if ('logJsonSnapshots' in options && options.logJsonSnapshots) {
            if (window['HiveConfig'] && window['HiveConfig']['DebugLogs']) {
                window['HiveConfig']['DebugLogs']['MetricSnapshotLogs'] = 1;
                window['HiveConfig']['DebugLogs']['TrackSnapshotLogs'] = 1;
                window['HiveConfig']['DebugLogs']['TrackerLogs'] = 1;
            }
        }
    };
    return OptionsConfigurator;
}());
exports.OptionsConfigurator = OptionsConfigurator;
// set HiveConfig.AtatusConfig accessible from window global
if (typeof window != 'undefined') {
    if (typeof window['HiveConfig'] == 'undefined')
        window['HiveConfig'] = {};
    window['HiveConfig']['ErrorMonitor'] = ErrorMonitorOptions;
}
//# sourceMappingURL=options.hive.js.map

/***/ }),

/***/ "../../../core/build/core/src/common/session/SessionActivator.js":
/*!****************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/common/session/SessionActivator.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.SessionActivator = void 0;
var SessionRegistry_1 = __webpack_require__(/*! ./SessionRegistry */ "../../../core/build/core/src/common/session/SessionRegistry.js");
var logger_hive_1 = __webpack_require__(/*! ../logger.hive */ "../../../core/build/core/src/common/logger.hive.js");
var URI = __webpack_require__(/*! urijs */ "../../../node_modules/urijs/src/URI.js");
var SessionActivator = /** @class */ (function () {
    function SessionActivator() {
        this.loggerId = '[SessionActivator] ';
    }
    SessionActivator.getInstance = function () {
        if (!this.instance) {
            this.instance = new SessionActivator();
        }
        return this.instance;
    };
    SessionActivator.prototype.activate = function (pluginId, url, onActivateSession) {
        var plugin = SessionRegistry_1.SessionRegistry.getInstance().getPlugin(pluginId);
        var sessions = SessionRegistry_1.SessionRegistry.getInstance().getSessions(pluginId);
        if (!plugin) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Tech or Plugin are not defined', this.loggerId);
            return false;
        }
        var args = { plugin: plugin, url: url, onActivateSession: onActivateSession };
        return this.tryActivate(sessions, true, args) || this.tryActivate(sessions, false, args);
    };
    SessionActivator.prototype.tryActivate = function (sessions, strict, args) {
        var plugin = args.plugin, url = args.url, onActivateSession = args.onActivateSession;
        var initialized = false;
        for (var _i = 0, sessions_1 = sessions; _i < sessions_1.length; _i++) {
            var session = sessions_1[_i];
            var criterion = false;
            var expectedUrl = void 0;
            if (strict) {
                expectedUrl = session.ticket.getManifestUrlWithQuery();
                criterion = expectedUrl === url;
            }
            else {
                expectedUrl = session.ticket.getManifestUrl();
                criterion = url.indexOf(session.ticket.getManifestUrl()) !== -1;
            }
            if (!criterion) {
                var manifestDomainMatcher = plugin.options().manifestDomainMatcher;
                if (manifestDomainMatcher) {
                    var reqURI = new URI(url);
                    var expectedURI = new URI(expectedUrl);
                    var domain = reqURI.hostname();
                    criterion = manifestDomainMatcher.test(domain) && expectedURI.path() === reqURI.path();
                }
            }
            if (criterion) {
                plugin.logger().debug(this.loggerId + 'Intercepted Manifest Request ' + url);
                plugin.setManifestUrl(session.ticket.getManifestUrlWithQuery());
                onActivateSession && onActivateSession(session);
                plugin.onActivateSession(url, strict);
                initialized = true;
            }
            else if (!strict) {
                // last activation trial (not strict) determines activation success
                logger_hive_1.ErrorMonitor.getInstance().logError('Manifest url mismatches manifest url in ticket. Expected: ' + expectedUrl + ', Actual: ' + url, this.loggerId);
            }
        }
        return initialized;
    };
    return SessionActivator;
}());
exports.SessionActivator = SessionActivator;
//# sourceMappingURL=SessionActivator.js.map

/***/ }),

/***/ "../../../core/build/core/src/common/session/SessionRegistry.js":
/*!***************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/common/session/SessionRegistry.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.SessionRegistry = void 0;
var SessionRegistry = /** @class */ (function () {
    function SessionRegistry() {
        this.loggerId = '[SessionRegistry] ';
        this.store = {};
    }
    SessionRegistry.getInstance = function () {
        if (!this.instance) {
            this.instance = new SessionRegistry();
        }
        return this.instance;
    };
    SessionRegistry.prototype.register = function (plugin, session, pluginId) {
        pluginId = pluginId || plugin.getPluginId();
        var store = this.getStore(pluginId);
        store.plugin = plugin;
        if (session) {
            store.sessions.push(session);
        }
    };
    SessionRegistry.prototype.unregister = function (plugin, session) {
        var pluginId = plugin.getPluginId();
        var store = this.getStore(pluginId);
        var sessionCount = store.sessions.length;
        if (!store.plugin) {
            // No plugin, using console log
            console.log(this.loggerId + " Attempt to unregister session with no comm (pluginId = " + pluginId + ", sessionId = " + session.id + ")");
            return;
        }
        if (!sessionCount) {
            // The plugin has no registered sessions. Display a warning.
            plugin.logger().warn(this.loggerId + " Attempt to unregister a session for plugin with no sessions (pluginId = " + pluginId + ", sessionId = " + session.id + ")");
            return;
        }
        store.sessions = store.sessions.filter(function (_session) { return _session.id !== session.id; });
        // If length didn't change, nothing was removed. Display a warning.
        if (sessionCount === store.sessions.length) {
            plugin.logger().warn(this.loggerId + " Attempt to unregister a not found session (pluginId = " + pluginId + ", sessionId = " + session.id + ")");
        }
        else {
            plugin.logger().debug(this.loggerId + " Unregistered session (pluginId = " + pluginId + ", sessionId = " + session.id + ")");
        }
    };
    SessionRegistry.prototype.clear = function () {
        this.store = {};
    };
    SessionRegistry.prototype.getStore = function (pluginId) {
        var store = this.store[pluginId];
        if (!store) {
            store = { plugin: null, sessions: [] };
            this.store[pluginId] = store;
        }
        return store;
    };
    SessionRegistry.prototype.getDefaultPluginId = function () {
        var keys = Object.keys(this.store);
        if (!keys.length)
            return null;
        var plugin = this.store[keys[0]].plugin;
        if (!plugin)
            return null;
        return plugin.getPluginId();
    };
    SessionRegistry.prototype.getPlugin = function (pluginId) {
        return this.getStore(pluginId).plugin;
    };
    SessionRegistry.prototype.getSessions = function (pluginId) {
        return this.getStore(pluginId).sessions;
    };
    return SessionRegistry;
}());
exports.SessionRegistry = SessionRegistry;
//# sourceMappingURL=SessionRegistry.js.map

/***/ }),

/***/ "../../../core/build/core/src/common/silent.hive.js":
/*!***************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/common/silent.hive.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.HiveSilentTest = void 0;
var constants_hivejava_hive_1 = __webpack_require__(/*! ./techs/hivejava/constants.hivejava.hive */ "../../../core/build/core/src/common/techs/hivejava/constants.hivejava.hive.js");
var constants_hive_1 = __webpack_require__(/*! ./constants.hive */ "../../../core/build/core/src/common/constants.hive.js");
var basicutils_hive_1 = __webpack_require__(/*! ./basicutils.hive */ "../../../core/build/core/src/common/basicutils.hive.js");
var logger_hive_1 = __webpack_require__(/*! ./logger.hive */ "../../../core/build/core/src/common/logger.hive.js");
var HiveSilentTest = /** @class */ (function () {
    function HiveSilentTest(plugin) {
        this.feedbackPort = !constants_hive_1.Constants.IS_HTTPS ? 9988 : 9989;
        this.previousTime = -1;
        this.plugin = plugin;
        this.initSilentTestFeedback();
    }
    HiveSilentTest.prototype.initSilentTestFeedback = function () {
        var _this = this;
        // TODO: Why do we check the silent option here instead of doing it before initializing HiveSilentTest??
        if (this.plugin.options().silent) {
            // when using Stats or HiveBrowser we need to detect the private IP address everytime!
            if (HiveConfig)
                HiveConfig.ConnInfo.detectPrivateIP = true;
            if (this.periodicSilentFeedback === undefined) {
                this.url = '//' + constants_hivejava_hive_1.HiveJavaConstants.HIVE_PROXY_HOST + ':' + this.feedbackPort + '/feedback';
                this.plugin.logger().info('starting periodic alive ping to hive tester [' + this.url + ']');
                this.periodicSilentFeedback = setInterval(function () {
                    _this.silentFeedback();
                }, constants_hive_1.Constants.SILENT_FEEDBACK_PERIOD);
            }
        }
    };
    HiveSilentTest.prototype.silentFeedback = function () {
        var _this = this;
        var activeSession = this.plugin.getActiveSession();
        var loggerId = undefined;
        if (activeSession)
            loggerId = "S[" + activeSession.id + "]";
        var currentTime = this.plugin.getCurrentTime();
        if (currentTime > this.previousTime) {
            this.plugin.logger().info('sending hive tester ping [' + currentTime + ' > ' + this.previousTime + ']');
            basicutils_hive_1.ajaxGetPromise(this.url).then(function (response) {
            }).catch(function (e) {
                logger_hive_1.ErrorMonitor.getInstance().logError('error sending hive tester ping', loggerId, { error: e });
                clearInterval(_this.periodicSilentFeedback);
            });
        }
        else {
            this.plugin.logger().warn('not sending hive tester ping [' + currentTime + ' <= ' + this.previousTime + ']');
        }
        this.previousTime = currentTime;
    };
    return HiveSilentTest;
}());
exports.HiveSilentTest = HiveSilentTest;
//# sourceMappingURL=silent.hive.js.map

/***/ }),

/***/ "../../../core/build/core/src/common/techs/hivejava/constants.hivejava.hive.js":
/*!******************************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/common/techs/hivejava/constants.hivejava.hive.js ***!
  \******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.HiveJavaConstants = void 0;
/**
 * constants for Hive Java Plugin
 */
var HiveJavaConstants = /** @class */ (function () {
    function HiveJavaConstants() {
    }
    HiveJavaConstants.HIVE_PROXY_HOST = '127.0.0.1';
    HiveJavaConstants.DEFAULT_PLAYER_HTTP_PORT = 8999;
    HiveJavaConstants.DEFAULT_PLAYER_HTTPS_PORT = 8998;
    HiveJavaConstants.DEFAULT_MONITOR_HTTP_PORT = 8899;
    HiveJavaConstants.DEFAULT_MONITOR_HTTPS_PORT = 8898;
    HiveJavaConstants.HIVE_TICKET_RESOLVE_QUERY = '//{0}:{1}/?callback={2}{3}hivePluginId={4}';
    HiveJavaConstants.HIVE_TICKET_RESOLVE_QUERY_LEGACY = '//{0}:{1}/?callback={2}';
    HiveJavaConstants.DEFAULT_SESSION_CHECK = true;
    HiveJavaConstants.SESSION_PROXY_REGEX = /((http|https):\/\/(.*):([0-9]*)\/([0-9a-z-]*).ism\/)(.*)/;
    HiveJavaConstants.DEFAULT_HIVE_JAVA_VERSION = '2013.1.1';
    HiveJavaConstants.MIN_HIVE_JAVA_VERSION_TEST_ID_SUPP = '2018.1';
    return HiveJavaConstants;
}());
exports.HiveJavaConstants = HiveJavaConstants;
//# sourceMappingURL=constants.hivejava.hive.js.map

/***/ }),

/***/ "../../../core/build/core/src/common/techs/hivejava/hivejava.hive.js":
/*!********************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/common/techs/hivejava/hivejava.hive.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.HiveJava = exports.navigator2 = void 0;
var Q = __webpack_require__(/*! @hivestreaming/q */ "../../../node_modules/@hivestreaming/q/q.js");
var ua_parser_js_1 = __webpack_require__(/*! ua-parser-js */ "../../../node_modules/ua-parser-js/src/ua-parser.js");
var URLToolkit = __webpack_require__(/*! url-toolkit */ "../../../node_modules/url-toolkit/src/url-toolkit.js");
var Framework_1 = __webpack_require__(/*! ../../../core/Framework */ "../../../core/build/core/src/core/Framework.js");
var Ticket_1 = __webpack_require__(/*! ../../../core/ticket/Ticket */ "../../../core/build/core/src/core/ticket/Ticket.js");
var Reporting_1 = __webpack_require__(/*! ../../../stats/Reporting */ "../../../core/build/core/src/stats/Reporting.js");
var Track_1 = __webpack_require__(/*! ../../../stats/Track */ "../../../core/build/core/src/stats/Track.js");
var basicutils_hive_1 = __webpack_require__(/*! ../../basicutils.hive */ "../../../core/build/core/src/common/basicutils.hive.js");
var comm_hive_1 = __webpack_require__(/*! ../../comm.hive */ "../../../core/build/core/src/common/comm.hive.js");
var common_hive_1 = __webpack_require__(/*! ../../common.hive */ "../../../core/build/core/src/common/common.hive.js");
var constants_hive_1 = __webpack_require__(/*! ../../constants.hive */ "../../../core/build/core/src/common/constants.hive.js");
var logger_hive_1 = __webpack_require__(/*! ../../logger.hive */ "../../../core/build/core/src/common/logger.hive.js");
var options_hive_1 = __webpack_require__(/*! ../../options.hive */ "../../../core/build/core/src/common/options.hive.js");
var HiveRequestFactory_1 = __webpack_require__(/*! ../../utils/HiveRequestFactory */ "../../../core/build/core/src/common/utils/HiveRequestFactory.js");
var HiveSessionInternal_1 = __webpack_require__(/*! ../../utils/HiveSessionInternal */ "../../../core/build/core/src/common/utils/HiveSessionInternal.js");
var HiveTech_1 = __webpack_require__(/*! ../../utils/HiveTech */ "../../../core/build/core/src/common/utils/HiveTech.js");
var SessionStorageUtil_1 = __webpack_require__(/*! ../../utils/SessionStorageUtil */ "../../../core/build/core/src/common/utils/SessionStorageUtil.js");
var TimeoutResolver_1 = __webpack_require__(/*! ../../utils/TimeoutResolver */ "../../../core/build/core/src/common/utils/TimeoutResolver.js");
var constants_hivejava_hive_1 = __webpack_require__(/*! ./constants.hivejava.hive */ "../../../core/build/core/src/common/techs/hivejava/constants.hivejava.hive.js");
var options_hivejava_hive_1 = __webpack_require__(/*! ./options.hivejava.hive */ "../../../core/build/core/src/common/techs/hivejava/options.hivejava.hive.js");
exports.navigator2 = navigator;
var HiveJavaSession = /** @class */ (function (_super) {
    __extends(HiveJavaSession, _super);
    function HiveJavaSession() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return HiveJavaSession;
}(HiveSessionInternal_1.HiveSessionInternal));
var HiveJava = /** @class */ (function () {
    function HiveJava(plugin, newOptions) {
        this.hiveCheckedTime = 0;
        this.plugin = plugin;
        this.options_ = new options_hivejava_hive_1.HiveJavaOptions();
        this.timeoutResolver = new TimeoutResolver_1.TimeoutResolver();
        this.applyOptions(newOptions);
        basicutils_hive_1.parseParameterOptions(window.location.href, new options_hive_1.UrlConfigurableOptions(), this.options_);
    }
    HiveJava.prototype.getName = function () {
        return HiveJava.techName;
    };
    HiveJava.prototype.getVersion = function () {
        return this.version;
    };
    HiveJava.prototype.needsReportingInstance = function () {
        return false;
    };
    /**
     * called only to check the hive client version
     * @returns {Q.Promise<string | HiveTechError>}
     */
    HiveJava.prototype.isReady = function () {
        var _this = this;
        this.plugin.getInitStepTimers().start([Track_1.InitStep.TIME_TO_CLIENT_NOT_READY, Track_1.InitStep.TIME_TO_CLIENT_NOT_FOUND]);
        if (this.isReadyPromise == null || (Date.now() - this.hiveCheckedTime > 10000)) {
            // / the javascript ticket resolve is supported only in IE >= 10
            var parser = new ua_parser_js_1.UAParser();
            parser.setUA(navigator.userAgent);
            var browser = parser.getBrowser();
            if (browser.name === 'IE' && browser.version && parseInt(browser.version) < 10)
                return Q.reject(new common_hive_1.HiveTechError(common_hive_1.HiveTechErrorCode.NOT_READY, 'Internet Explorer < v.10 not supported'));
            else {
                this.isReadyTimeBegin = Date.now();
                this.isReadyTimeEnd = 0;
                var versionJsUrl = '//' + constants_hivejava_hive_1.HiveJavaConstants.HIVE_PROXY_HOST + ':' + this.plugin.options().monitorPort + '/version.json';
                this.logger().debug(this.id() + 'verifying Hive Client version');
                this.isReadyPromise = basicutils_hive_1.ajaxGetPromise(versionJsUrl).then(function (response) {
                    var _a, _b, _c, _d;
                    var responseJson = JSON.parse(response);
                    _this.state = responseJson.state;
                    _this.version = responseJson.version;
                    // Fallback to HiveJs + Booster if possible
                    if (((_b = (_a = responseJson.services) === null || _a === void 0 ? void 0 : _a.booster) === null || _b === void 0 ? void 0 : _b.port) && _this.agentPicker === HiveTech_1.AgentPicker.boosterIfPossible) {
                        _this.logger().info('Booster port is present. Falling back to HiveJS + Booster');
                        return Q.reject(new common_hive_1.HiveTechError(common_hive_1.HiveTechErrorCode.BOOSTER_PRESENT, 'Booster is present. Falling back to HiveJs + Booster'));
                    }
                    else if (!((_d = (_c = responseJson.services) === null || _c === void 0 ? void 0 : _c.booster) === null || _d === void 0 ? void 0 : _d.port) && _this.agentPicker === HiveTech_1.AgentPicker.boosterIfPossible) {
                        _this.logger().info('Booster is not present. Trying to connect to Java Agent.');
                    }
                    if (_this.state === 'ready') {
                        if (_this.version === 'developer' || _this.version >= _this.options_.minVersion) {
                            _this.isReadyTimeEnd = Date.now();
                            _this.logger().debug(_this.id() + "Hive Client ready - version " + _this.version + " [" + (_this.isReadyTimeEnd - _this.isReadyTimeBegin) + "]");
                            return 'ready';
                        }
                        else {
                            logger_hive_1.ErrorMonitor.getInstance().logError('Client version requirement not satisfied', _this.id(), { version: _this.version, minVersion: _this.options_.minVersion });
                            _this.plugin.addTechEvent(new Track_1.TechEventRecord(null, 2 /* JAVA_WRONG_VERSION */));
                            return Q.reject(new common_hive_1.HiveTechError(common_hive_1.HiveTechErrorCode.VERSION_ERROR, 'version ' + _this.version));
                        }
                    }
                    else {
                        _this.plugin.getInitStepTimers().stop(Track_1.InitStep.TIME_TO_CLIENT_NOT_READY, true);
                        logger_hive_1.ErrorMonitor.getInstance().logError('Cannot check version: client state not ready', _this.id(), { state: _this.state });
                        _this.plugin.addTechEvent(new Track_1.TechEventRecord(null, 1 /* JAVA_NOT_READY */));
                        _this.isReadyTimeEnd = Date.now();
                        _this.logger().debug('[Timing] Hive Client not ready', _this.isReadyTimeEnd - _this.isReadyTimeBegin);
                        return Q.reject(new common_hive_1.HiveTechError(common_hive_1.HiveTechErrorCode.NOT_READY, 'state ' + _this.state));
                    }
                }, function (error) {
                    var errorMsg = 'Client not reachable';
                    if (error != undefined && error.status != undefined && error.status != -1)
                        errorMsg = 'Client check returned error';
                    if (error.status === 500) {
                        _this.plugin.getInitStepTimers().stop(Track_1.InitStep.TIME_TO_CLIENT_NOT_READY, true);
                        logger_hive_1.ErrorMonitor.getInstance().logError(errorMsg, _this.id(), { error: error });
                        _this.plugin.addTechEvent(new Track_1.TechEventRecord(null, 1 /* JAVA_NOT_READY */));
                        return Q.reject(new common_hive_1.HiveTechError(common_hive_1.HiveTechErrorCode.PLUGIN_ERROR, errorMsg));
                    }
                    else {
                        _this.plugin.getInitStepTimers().stop(Track_1.InitStep.TIME_TO_CLIENT_NOT_FOUND, true);
                        logger_hive_1.ErrorMonitor.getInstance().logError(errorMsg, _this.id(), error != undefined && error.status != undefined && error.status != -1 ? { status: error.status } : undefined);
                        _this.plugin.addTechEvent(new Track_1.TechEventRecord(null, 0 /* JAVA_NOT_REACHABLE */));
                        return Q.reject(new common_hive_1.HiveTechError(common_hive_1.HiveTechErrorCode.NOT_READY, errorMsg));
                    }
                }).catch(function (error) {
                    // if the error was already handled, we just forward it
                    if (error instanceof common_hive_1.HiveTechError)
                        return Q.reject(error);
                    var errorMsg = 'Error fetching Hive Client version';
                    logger_hive_1.ErrorMonitor.getInstance().logError(errorMsg, _this.id(), error);
                    return Q.reject(new common_hive_1.HiveTechError(common_hive_1.HiveTechErrorCode.NOT_READY, errorMsg));
                });
            }
            this.hiveCheckedTime = Date.now();
        }
        return this.isReadyPromise;
    };
    /**
     * attempts to initialize a session through Hive Java given a ticket url
     *
     * if there is need to verify the java version, first tries to retrieve the version.json,
     * otherwise it directly tries to initialize a new session and resolve the ticket
     *
     * @param ticketUrl
     * @param ri (ignored by HiveJava tech)
     * @returns {Q.Promise<HiveSessionInternal>}
     */
    HiveJava.prototype.initSession = function (ticketUrl, agentPicker, _ri) {
        var _this = this;
        this.agentPicker = agentPicker;
        var _a = this.plugin.options(), readyCheckTimeout = _a.readyCheckTimeout, macReadyCheckTimeout = _a.macReadyCheckTimeout;
        var timeout = this.timeoutResolver.getTimeout(readyCheckTimeout, macReadyCheckTimeout, this.logger());
        var readyCheckPromise = ((timeout && timeout > 0) ? this.isReady().timeout(timeout, "Client Ready check timed out after " + timeout + "ms") : this.isReady());
        return readyCheckPromise.then(function () {
            return _this.checkSessionAndResolveTicket(ticketUrl)
                .then(function (session) {
                _this.logger().debug(_this.id() + " Session " + session.id + " registered");
                comm_hive_1.SessionRegistry.getInstance().register(_this.plugin, session);
                return session;
            })
                .catch(function (e) {
                _this.logger().warn(_this.id() + " Session registered error", e);
                return Q.reject(e);
            });
        }).catch(function (error) {
            if (error instanceof Error)
                error = new common_hive_1.HiveTechError(common_hive_1.HiveTechErrorCode.TIMEOUT_ERROR, error.message);
            return Q.reject(error);
        });
    };
    HiveJava.prototype.getInitSessionTimeout = function () {
        return this.options_.initTimeout;
    };
    HiveJava.prototype.isActive = function (source, session) {
        return (source === null || source === void 0 ? void 0 : source.indexOf(session.proxyUrl)) > -1;
    };
    /**
     * tell the HiveJava client to stop the active session
     * @param session
     * @param completeClose
     */
    HiveJava.prototype.closeSession = function (session, completeClose) {
        var _this = this;
        this.logger().debug(this.id() + 'Stopping session ' + session.id + ' [complete close:' + completeClose + ']');
        var hiveProxySessionQuery = '//' + constants_hivejava_hive_1.HiveJavaConstants.HIVE_PROXY_HOST + ':' + this.plugin.options().playerPort + '/session?action=stop';
        hiveProxySessionQuery += '&currentSession=' + session.id;
        if (completeClose)
            hiveProxySessionQuery += '&completeStop=true';
        /**
         * if it's a normal close session, just use async xhr
         * if it's onUnload, try using the sendBeacon (Chrome && FF)
         * otherwise use sync xhr
         */
        if (!completeClose || !exports.navigator2.sendBeacon) {
            basicutils_hive_1.ajaxGetPromise(hiveProxySessionQuery, null, !completeClose).then(function () {
                _this.logger().debug(_this.id() + 'session stopped [' + session.id + ']' + (completeClose ? '[sync]' : ''));
            }).catch(function (error) {
                _this.logger().warn(_this.id() + 'session close error [' + session.id + ']' + (completeClose ? '[sync]' : ''), error);
            });
        }
        else {
            exports.navigator2.sendBeacon(hiveProxySessionQuery);
            this.logger().debug(this.id() + 'session stopped [' + session.id + '][beacon]');
        }
    };
    HiveJava.prototype.onStateChange = function (session, isIdle) {
        this.clientState = isIdle ? Reporting_1.ClientState.IDLE : Reporting_1.ClientState.PLAY;
        this.logger().notice('[HiveComm] client state: ' + Reporting_1.ClientState[this.clientState]);
        // no operation needed, java will automatically expire the session and go in paused mode
    };
    HiveJava.prototype.handleStats = function (session, stats) {
        if (this.clientState == Reporting_1.ClientState.IDLE)
            return Q.resolve(true);
        var statsStr = 'playing-point=' + stats.playingPoint;
        statsStr += '&buffer-length=' + stats.bufferLength;
        statsStr += '&total-buffering=' + stats.totalBuffering;
        statsStr += '&width=' + stats.width;
        statsStr += '&height=' + stats.height;
        statsStr += '&fullscreen=' + stats.fullscreen;
        // create the stats feedback url using the current proxy session
        var feedbackProxyUrl = session.proxyUrl + 'stats?' + statsStr;
        this.logger().trace(feedbackProxyUrl);
        // execute an async get with the feedback stats url
        return basicutils_hive_1.ajaxGetPromise(feedbackProxyUrl);
    };
    // All events are handled asynchronously in Java, so no `async` parameter here.
    HiveJava.prototype.handleEvent = function (session, event, eventObj) {
        var _this = this;
        // 2016 releases don't support page visibility event so it will return 400 and bunch of warnings
        if ((event === Track_1.PlayerEvents.VISIBLE || event === Track_1.PlayerEvents.HIDDEN) &&
            !(this.version && (this.version === 'developer' || this.version >= '2017')))
            return Q.resolve(true);
        var feedbackEventProxyUrl = session.proxyUrl + 'player-event?type=' + Track_1.PlayerEvents[event];
        if (eventObj != undefined)
            for (var key in eventObj) {
                if (eventObj.hasOwnProperty(key)) {
                    feedbackEventProxyUrl += '&' + key + '=' + eventObj[key];
                }
            }
        this.logger().debug(this.id() + 'event ' + Track_1.PlayerEvents[event], eventObj != undefined ? eventObj : '');
        return basicutils_hive_1.ajaxGetPromise(feedbackEventProxyUrl).fail(function (err) {
            _this.logger().warn(_this.id() + 'error sending feedback event to Hive Client', err);
            return Q.reject(err);
        });
    };
    HiveJava.prototype.handleTechEvent = function (session, event) {
        // for now we don't have a protocol to pass tech events to the java :(
        return Q.resolve(true);
    };
    HiveJava.prototype.updateIntegrationInfo = function (session) {
        // legacy clients don't support player-info
        if (this.isLegacyClient()) {
            this.logger().warn('Player info not supported in this Java client version');
            return Q.resolve(true);
        }
        if (this.getVersion() === 'developer' || this.getVersion() > '2020.1') {
            return this.updateIntegrationInfoPost(session);
        }
        else {
            return this.updateIntegrationInfoGet(session);
        }
    };
    HiveJava.prototype.updateIntegrationInfoPost = function (session) {
        var _this = this;
        // create the player-info feedback url using the current proxy session
        var feedbackProxyUrl = session.proxyUrl + 'player-info';
        var playerInfo = this.plugin.getIntegrationInfo();
        // execute an async post with the feedback url
        return basicutils_hive_1.ajaxPostPromise(feedbackProxyUrl, JSON.stringify(playerInfo)).fail(function (err) {
            _this.logger().debug(_this.id() + 'error sending player Info to Hive Client', err);
            return Q.reject(err);
        });
    };
    HiveJava.prototype.updateIntegrationInfoGet = function (session) {
        var _this = this;
        var playerInfoStr = 'comm-version=' + this.plugin.getCoreVersion();
        playerInfoStr += '&plugin-name=' + this.plugin.getPluginName();
        playerInfoStr += '&plugin-version=' + this.plugin.getPluginVersion();
        playerInfoStr += '&player-tech=' + this.plugin.getPlayerTech();
        playerInfoStr += '&player-version=' + this.plugin.getPlayerVersion();
        var telemetryId = this.plugin.getTelemetryId();
        if (telemetryId)
            playerInfoStr += '&telemetry-id=' + this.plugin.getTelemetryId();
        // create the player-info feedback url using the current proxy session
        var feedbackProxyUrl = session.proxyUrl + 'player-info?' + playerInfoStr;
        // execute an async get with the feedback url
        return basicutils_hive_1.ajaxGetPromise(feedbackProxyUrl).fail(function (err) {
            _this.logger().debug(_this.id() + 'error sending player Info to Hive Client', err);
            return Q.reject(err);
        });
    };
    HiveJava.prototype.onError = function (error) {
        var proceedOnError = true;
        if (this.options_.onError != undefined) {
            try {
                // Continue tech fallback unless provided 'onError' explicitly returns 'false'
                if (this.options_.onError(error) === false) {
                    proceedOnError = false;
                }
            }
            catch (e) {
                logger_hive_1.ErrorMonitor.getInstance().logError('Exception in user-defined onError callback', this.id(), e);
            }
        }
        return proceedOnError;
    };
    /**
     * on java tech timeout means that the java took too long to
     * resolve the ticket. In this case we gather the timestamps
     * for start and completion of the 3 steps:
     * - isReady
     *      - isReadyIn
     *      - isReadyOut
     * - requestLease
     *      - reqLeaseIn
     *      - reqLeaseOut
     * - resolveTicket
     *      - resolveIn
     *      - resolveOut
     *
     * We forward them both to atatus and as Track Tech Event
     */
    HiveJava.prototype.onTechTimeout = function (error, session, totalInitTime) {
        var techEventInfo = {
            isReadyIn: this.isReadyTimeBegin,
            isReadyOut: this.isReadyTimeEnd,
            leaseIn: this.requestLeaseTimeBegin,
            leaseOut: this.requestLeaseTimeEnd,
            resolveIn: this.resolveTicketTimeBegin,
            resolveOut: this.resolveTicketTimeEnd
        };
        if (typeof session != 'undefined' && session != null)
            techEventInfo['sessionId'] = session.id;
        if (typeof totalInitTime != 'undefined')
            techEventInfo['total'] = totalInitTime;
        var errorInfo = JSON.parse(JSON.stringify(techEventInfo));
        // log the error on the errorMonitor
        logger_hive_1.ErrorMonitor.getInstance().logError(error.message, this.id(), errorInfo);
        // append the event to track snapshot
        this.plugin.addTechEvent(new Track_1.TechEventRecord(null, 5 /* JAVA_TICKET_TIMEOUT */, techEventInfo));
        // reset the Timers
        this.resetTimers();
    };
    HiveJava.prototype.onActiveSession = function (session) {
        this.updateIntegrationInfo(session);
        SessionStorageUtil_1.SessionStorageUtil.setItem('hiveActiveSessionId', session.id);
        if (this.options_.onActiveSession != undefined) {
            try {
                this.options_.onActiveSession(session.toHiveSession());
            }
            catch (e) {
                logger_hive_1.ErrorMonitor.getInstance().logError('Exception in user-defined onActiveSession callback', this.id(), e);
            }
        }
    };
    HiveJava.prototype.setPlugin = function (plugin) {
        this.plugin = plugin;
    };
    HiveJava.prototype.id = function () {
        return '[' + HiveJava.techName + '] ';
    };
    HiveJava.prototype.applyOptions = function (newOptions) {
        if (newOptions[HiveJava.techName] != undefined) {
            basicutils_hive_1.updateOptions(newOptions[HiveJava.techName], this.options_);
        }
    };
    /**
     * attempts to request a lease for a session and resolve the ticket.
     * @param ticketUrl
     * @param def
     * @returns {Promise<U>}
     */
    HiveJava.prototype.checkSessionAndResolveTicket = function (ticketUrl) {
        var _this = this;
        var sessionResolveStartTime = new Date().getTime();
        return this.requestLeaseDirect(ticketUrl).then(function (manifest) {
            if (manifest) {
                // if the request lease already resolved a manifest, generate the internal session
                return _this.resolveSession(ticketUrl, manifest, sessionResolveStartTime);
            }
            else
                // the request lease only authorized a new session, we need to resolve the ticket
                return _this.resolveTicketPromise(ticketUrl).then(function (manifest) {
                    return _this.resolveSession(ticketUrl, manifest, sessionResolveStartTime);
                });
        });
    };
    /**
     * Advanced request lease. If the session check is active, it requests a new session AND passes the ticket url.
     *
     * If the session is allowed Hive Client versions before 2017.Q1, will simply return 200 OK, and the promise is resolved (false)
     * Newer clients instead will directly try to resolve the ticket:
     *
     * - If the client resolves the manifest, it will return 200 and the manifest will be in the body. The promised is resolved with the absolute manifest url
     * - If the client returns 400 - Bad request, the ticket could not be resolved by Java and the body will contain the status of the internal resolve attempt request (promise rejected)
     * - If the client returns 401 - Unauthorized, the ticket verification failed (promise rejected)
     * - If the client returns 403 - Forbidden, the client has already an active session. The body will contain a json with the current active sessionId (promise rejected)
     * - If the client returns 404 - Not Found, the client is old and does not support session checks, promised is resolved (false)
     * - any other error means that the client is not reachable (promised rejected)
     *
     * @param ticketUrl
     * @returns {Promise<T>}
     */
    HiveJava.prototype.requestLeaseDirect = function (ticketUrl) {
        var _this = this;
        this.requestLeaseTimeBegin = Date.now();
        if (this.plugin.options().useSessionCheck) {
            var hiveProxySessionQuery_1 = '//' + constants_hivejava_hive_1.HiveJavaConstants.HIVE_PROXY_HOST + ':' + this.plugin.options().playerPort + '/session?&action=check';
            hiveProxySessionQuery_1 += '&hivePluginId=' + this.plugin.getPluginId();
            hiveProxySessionQuery_1 += '&callback=' + encodeURIComponent(ticketUrl);
            // previousSessionId is saved if it was refreshed
            var previousSessionId = SessionStorageUtil_1.SessionStorageUtil.getItem('hiveActiveSessionId');
            SessionStorageUtil_1.SessionStorageUtil.removeItem('hiveActiveSessionId');
            if (previousSessionId) {
                hiveProxySessionQuery_1 += '&currentSession=' + previousSessionId;
            }
            /*
             * if we get a 403 Forbidden, then Hive is busy with another session
             * otherwise for both a 200 or a 404 is fine to go ahead
             */
            this.resetWarnTimer();
            return this.sessionRequest(hiveProxySessionQuery_1).then(function (response) {
                _this.requestLeaseTimeEnd = Date.now();
                if (response) {
                    return _this.onManifestResolved(response, hiveProxySessionQuery_1, ticketUrl, _this.requestLeaseTimeBegin);
                }
                _this.logger().debug(_this.id() + 'session allowed [' + (_this.requestLeaseTimeEnd - _this.requestLeaseTimeBegin) + ']');
                return false;
            }, function (error) {
                if (error.status == 400) { // bad request
                    return _this.handleJavaError('bad request', 'error resolving ticket', error);
                }
                else if (error.status == 401) { // unauthorized
                    return _this.handleJavaError('unauthorized', 'error verifying the ticket', error);
                }
                else if (error.status == 403) { // forbidden
                    // check in the body if the java client sent the current active session
                    var session = HiveJava.extractBodyError(error, undefined, 'session');
                    var blockingSessionObject = (session ? { session: session } : undefined);
                    logger_hive_1.ErrorMonitor.getInstance().logError('reports another active session', _this.id(), blockingSessionObject);
                    _this.plugin.addTechEvent(new Track_1.TechEventRecord(null, 3 /* JAVA_SESSION_BUSY */, blockingSessionObject));
                    return Q.reject(new common_hive_1.HiveTechError(common_hive_1.HiveTechErrorCode.SESSION_ERROR, 'another active session' +
                        (blockingSessionObject ? ' [' + blockingSessionObject.session + ']' : '')));
                }
                else if (error.status == 404) { // not found
                    _this.logger().debug(_this.id() + 'installed version does not support active session check');
                    _this.requestLeaseTimeEnd = Date.now();
                    return false;
                }
                else { // some other unhandled error
                    logger_hive_1.ErrorMonitor.getInstance().logError('unhandled error from Java', _this.id(), { error: error.status });
                    _this.plugin.addTechEvent(new Track_1.TechEventRecord(null, 4 /* JAVA_SESSION_ERROR */));
                    return Q.reject(new common_hive_1.HiveTechError(common_hive_1.HiveTechErrorCode.PLUGIN_ERROR, error));
                }
            }).catch(function (e) {
                // if the error was already handled, we just forward it
                if (e instanceof common_hive_1.HiveTechError)
                    return Q.reject(e);
                logger_hive_1.ErrorMonitor.getInstance().logError('unhandled error on requestLeaseDirect', _this.id(), { error: e });
                _this.plugin.addTechEvent(new Track_1.TechEventRecord(null, 4 /* JAVA_SESSION_ERROR */));
                _this.requestLeaseTimeEnd = Date.now();
                _this.plugin.logger().warn('[Timing] unhandeled session request ', _this.requestLeaseTimeEnd - _this.requestLeaseTimeBegin);
                return Q.reject(new common_hive_1.HiveTechError(common_hive_1.HiveTechErrorCode.PLUGIN_ERROR, e));
            }).finally(function () {
                // reset the timer for monitoring slow java responses
                clearTimeout(_this.warnSlowResp);
            });
        }
        else {
            this.logger().debug(this.id() + 'Hive session check disabled - will directly resolve ticket (other active sessions may fail)');
            return Q.resolve(false);
        }
    };
    /**
     * This is the actual session request adding the testID as custom header req (if provided)
     * @param  {} hiveProxySessionQuery
     * @returns Q.Promise
     */
    HiveJava.prototype.sessionRequest = function (hiveProxySessionQuery) {
        var _a;
        if (this.plugin.options().testId) {
            if (this.version !== 'developer' || this.version < constants_hivejava_hive_1.HiveJavaConstants.MIN_HIVE_JAVA_VERSION_TEST_ID_SUPP)
                this.logger().warn(this.id() + "The Hive Client Version installed does not support the test id in its generated metrics");
            else
                return basicutils_hive_1.ajaxGetPromise(hiveProxySessionQuery, undefined, true, (_a = {}, _a[constants_hive_1.Constants.SILENT_TEST_ID_HEADER_KEY] = this.plugin.options().testId, _a));
        }
        return basicutils_hive_1.ajaxGetPromise(hiveProxySessionQuery);
    };
    /**
     * handle the new error report system from the java
     * @param defaultStatus
     * @param logError
     * @param error
     * @returns {Promise<T>}
     */
    HiveJava.prototype.handleJavaError = function (defaultStatus, logError, error) {
        var realStatus = HiveJava.extractBodyError(error, defaultStatus);
        logger_hive_1.ErrorMonitor.getInstance().logError(logError, this.id());
        this.resolveTicketTimeEnd = Date.now();
        return Q.reject(new common_hive_1.HiveTechError(common_hive_1.HiveTechErrorCode.TICKET_ERROR, realStatus));
    };
    /**
     * parse the java error body for extracting extended info reported
     * like the internal request status or internal active sessions
     * @param error
     * @param defaultStatus
     * @param jsonKey @default 'status'
     * @returns {string}
     */
    HiveJava.extractBodyError = function (error, defaultStatus, jsonKey) {
        if (jsonKey === void 0) { jsonKey = 'status'; }
        var status = defaultStatus;
        // check what's the actual status returned to the java client
        if (error.body) {
            try {
                var jsonError = JSON.parse(error.body);
                status = jsonError[jsonKey];
            }
            catch (e) {
            }
        }
        return status;
    };
    /**
     * used by 2016.Q1/Q2 client to directly resolve a ticket once a lease has been granted
     *
     * @param ticketUrl
     * @returns {Promise<T>}
     */
    HiveJava.prototype.resolveTicketPromise = function (ticketUrl) {
        var _this = this;
        this.resolveTicketTimeBegin = Date.now();
        this.logger().debug(this.id() + 'resolving ticket: ' + ticketUrl);
        var hiveProxyTicketUrl = this.generateProxyUrl(ticketUrl);
        return basicutils_hive_1.ajaxGetPromise(hiveProxyTicketUrl, 'application/json').then(function (response) {
            return _this.onManifestResolved(response, hiveProxyTicketUrl, ticketUrl, _this.resolveTicketTimeBegin);
        }, function (error) {
            return _this.resolveTicketError(error, ticketUrl);
        }).catch(function (e) {
            logger_hive_1.ErrorMonitor.getInstance().logError('error parsing ticket response', _this.id(), e);
            return Q.reject(new common_hive_1.HiveTechError(common_hive_1.HiveTechErrorCode.PLUGIN_ERROR, e));
        });
    };
    HiveJava.prototype.resolveTicketError = function (error, ticketUrl) {
        logger_hive_1.ErrorMonitor.getInstance().logError('error resolving ticket', this.id(), { ticket: ticketUrl, detailedError: error });
        return Q.reject(new common_hive_1.HiveTechError(common_hive_1.HiveTechErrorCode.TICKET_ERROR, error));
    };
    HiveJava.prototype.onManifestResolved = function (response, hiveProxyTicketUrl, ticketUrl, startTime) {
        var responseJson = JSON.parse(response);
        // URLToolkit does not add the protocol. We'll inherit the location's protocol if one is not set.
        var protocol = location.protocol.indexOf('about:') === 0 ? 'https:' : location.protocol;
        var hiveUrl = URLToolkit.buildAbsoluteURL((hiveProxyTicketUrl.indexOf('//') === 0 ? protocol : '') + hiveProxyTicketUrl, responseJson.location);
        // starting from 2017.1 we pass the client version through ticket response
        // since by default we skip the version.json
        if (responseJson.version && !this.version)
            this.version = responseJson.version;
        this.resolveTicketTimeEnd = Date.now();
        this.logger().debug(this.id() + 'resolved ticket ' + ticketUrl + ' -> ' + hiveUrl + ' [' + (this.resolveTicketTimeEnd - startTime) + ']');
        return hiveUrl;
    };
    HiveJava.prototype.resolveSession = function (ticketUrl, manifest, sessionResolveStartTime) {
        var s = this.generateSession(ticketUrl, manifest);
        if (s != null) {
            var sessionResolveEndTime = new Date().getTime();
            var techInitTime = sessionResolveEndTime - sessionResolveStartTime;
            if (techInitTime >= this.options_.warnSlowRespTimeout)
                this.onTechTimeout(new common_hive_1.HiveTechError(common_hive_1.HiveTechErrorCode.TIMEOUT_ERROR, this.id() + " The tech initialization took more than " + this.options_.warnSlowRespTimeout + " milliseconds"), s, techInitTime);
            // make sure that the player uses normal http requests to Java proxy
            HiveRequestFactory_1.HiveRequestFactory.register(this);
            return s;
        }
        else
            throw new common_hive_1.HiveTechError(common_hive_1.HiveTechErrorCode.TICKET_ERROR, 'error generating session');
    };
    HiveJava.prototype.generateSession = function (ticketUrl, manifest) {
        var ticket = Ticket_1.Ticket.fromUrl(ticketUrl);
        var session = new HiveJavaSession(ticketUrl, ticket, manifest, null, this.plugin.options().onSessionStateChange);
        session.SDN = true;
        var regex = constants_hivejava_hive_1.HiveJavaConstants.SESSION_PROXY_REGEX;
        var matches = regex.exec(session.manifest);
        if (matches != null) {
            session.proxyUrl = matches[1];
            session.id = matches[5];
            return session;
        }
        return null;
    };
    HiveJava.prototype.generateProxyUrl = function (ticketUrl) {
        var paramAppend = ticketUrl.indexOf('?') == -1 ? '?' : '&';
        // old 2015 versions don't like the pluginId appended to the callback
        if (this.isLegacyClient())
            return basicutils_hive_1.stringFormat(constants_hivejava_hive_1.HiveJavaConstants.HIVE_TICKET_RESOLVE_QUERY_LEGACY, constants_hivejava_hive_1.HiveJavaConstants.HIVE_PROXY_HOST, this.plugin.options().playerPort, ticketUrl);
        else
            return basicutils_hive_1.stringFormat(constants_hivejava_hive_1.HiveJavaConstants.HIVE_TICKET_RESOLVE_QUERY, constants_hivejava_hive_1.HiveJavaConstants.HIVE_PROXY_HOST, this.plugin.options().playerPort, ticketUrl, paramAppend, this.plugin.getPluginId4Java());
    };
    HiveJava.prototype.resetWarnTimer = function () {
        var _this = this;
        if (this.warnSlowResp)
            clearTimeout(this.warnSlowResp);
        this.warnSlowResp = setTimeout(function () {
            logger_hive_1.ErrorMonitor.getInstance().logError("The Lease Request is taking more than " + _this.options_.warnSlowRespTimeout + " secs", _this.id());
        }, this.options_.warnSlowRespTimeout);
    };
    /**
     * resetting the internal timers for lease and resolve
     * no need to reset the isReady since it might have been called previously
     */
    HiveJava.prototype.resetTimers = function () {
        this.requestLeaseTimeBegin = 0;
        this.requestLeaseTimeEnd = 0;
        this.resolveTicketTimeBegin = 0;
        this.resolveTicketTimeEnd = 0;
    };
    HiveJava.prototype.logger = function () {
        return this.plugin.logger();
    };
    HiveJava.prototype.resetTech = function () {
        this.resetTimers();
    };
    HiveJava.prototype.isLegacyClient = function () {
        return this.options_.supportLegacyClient && (!this.version || this.version.substr(0, 4) < '2016');
    };
    HiveJava.prototype.getPluginId = function () {
        return this.plugin.getPluginId();
    };
    HiveJava.prototype.createManifestRequest = function (pluginId) {
        var _this = this;
        this.logger().debug(this.id() + " Creating manifest URL");
        var xhr = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.HTTP_REQUEST);
        if (!pluginId) {
            pluginId = comm_hive_1.SessionRegistry.getInstance().getDefaultPluginId();
        }
        var _open = xhr.open;
        xhr.open = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var _ = args[0], url = args[1];
            var sessions = comm_hive_1.SessionRegistry.getInstance().getSessions(pluginId);
            var plugin = comm_hive_1.SessionRegistry.getInstance().getPlugin(pluginId);
            for (var _a = 0, sessions_1 = sessions; _a < sessions_1.length; _a++) {
                var session = sessions_1[_a];
                if (session.manifest === url) {
                    _this.logger().debug(_this.id() + " Setting manifest URL: " + url);
                    plugin.setManifestUrl(url);
                }
            }
            // Call the original open() implementation
            _open.apply(xhr, args);
        };
        return xhr;
    };
    HiveJava.prototype.createRequest = function (pluginId) {
        return new XMLHttpRequest();
    };
    HiveJava.prototype.supportsXhrInterception = function () {
        return false;
    };
    HiveJava.techName = 'HiveJava';
    return HiveJava;
}());
exports.HiveJava = HiveJava;
//# sourceMappingURL=hivejava.hive.js.map

/***/ }),

/***/ "../../../core/build/core/src/common/techs/hivejava/options.hivejava.hive.js":
/*!****************************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/common/techs/hivejava/options.hivejava.hive.js ***!
  \****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.HiveJavaOptions = void 0;
var options_hive_1 = __webpack_require__(/*! ../../options.hive */ "../../../core/build/core/src/common/options.hive.js");
var constants_hivejava_hive_1 = __webpack_require__(/*! ./constants.hivejava.hive */ "../../../core/build/core/src/common/techs/hivejava/constants.hivejava.hive.js");
/**
 * Configurable Options valid only for the HiveJava Tech
 * Usage: </br>
 * <pre><code>
 *  options: {
 *      HiveJava: {
 *          minVersion: "2015.1.100"
 *      }
 *  }
 *  </code></pre>
 */
var HiveJavaOptions = /** @class */ (function (_super) {
    __extends(HiveJavaOptions, _super);
    function HiveJavaOptions() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * minimum version of Hive Java allowed to run
         * @type {string}
         * @default {2013.1.1}
         */
        _this.minVersion = constants_hivejava_hive_1.HiveJavaConstants.DEFAULT_HIVE_JAVA_VERSION;
        /**
         * The Hive Java tech will fail if will not initiate a session before the timeout (in millisecond)
         * @type {number}
         * @default 60000
         */
        _this.initTimeout = 60000;
        /**
         * send a warning to atatus if the session request takes more than the specified time
         * @type {number}
         */
        _this.warnSlowRespTimeout = 5000;
        /**
         * enable this if the plugin should support also the old pre-2016 callback resolve
         * without the pluginId and no player-info
         * @type {boolean}
         */
        _this.supportLegacyClient = false;
        return _this;
    }
    return HiveJavaOptions;
}(options_hive_1.HiveTechOptions));
exports.HiveJavaOptions = HiveJavaOptions;
//# sourceMappingURL=options.hivejava.hive.js.map

/***/ }),

/***/ "../../../core/build/core/src/common/techs/hivejs/constants.hivejs.hive.js":
/*!**************************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/common/techs/hivejs/constants.hivejs.hive.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.HiveJsConstants = void 0;
var HiveJsConstants = /** @class */ (function () {
    function HiveJsConstants() {
    }
    HiveJsConstants.BOOSTER_DOMAIN = '127.0.0.1';
    HiveJsConstants.AGENT_MONITOR_PORT = 8898;
    return HiveJsConstants;
}());
exports.HiveJsConstants = HiveJsConstants;
//# sourceMappingURL=constants.hivejs.hive.js.map

/***/ }),

/***/ "../../../core/build/core/src/common/techs/hivejs/hivejs.hive.js":
/*!****************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/common/techs/hivejs/hivejs.hive.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.HiveJS = void 0;
var Q = __webpack_require__(/*! @hivestreaming/q */ "../../../node_modules/@hivestreaming/q/q.js");
var ua_parser_js_1 = __webpack_require__(/*! ua-parser-js */ "../../../node_modules/ua-parser-js/src/ua-parser.js");
var Framework_1 = __webpack_require__(/*! ../../../core/Framework */ "../../../core/build/core/src/core/Framework.js");
var Bindings_1 = __webpack_require__(/*! ../../../webrtc/Bindings */ "../../../core/build/core/src/webrtc/Bindings.js");
var webrtc_1 = __webpack_require__(/*! ../../../webrtc */ "../../../core/build/core/src/webrtc/index.js");
var Reporting_1 = __webpack_require__(/*! ../../../stats/Reporting */ "../../../core/build/core/src/stats/Reporting.js");
var stats_hive_1 = __webpack_require__(/*! ../statsjs/stats.hive */ "../../../core/build/core/src/common/techs/statsjs/stats.hive.js");
var options_hivejs_hive_1 = __webpack_require__(/*! ./options.hivejs.hive */ "../../../core/build/core/src/common/techs/hivejs/options.hivejs.hive.js");
var common_hive_1 = __webpack_require__(/*! ../../common.hive */ "../../../core/build/core/src/common/common.hive.js");
var HiveSessionInternal_1 = __webpack_require__(/*! ../../utils/HiveSessionInternal */ "../../../core/build/core/src/common/utils/HiveSessionInternal.js");
var HiveRequestFactory_1 = __webpack_require__(/*! ../../utils/HiveRequestFactory */ "../../../core/build/core/src/common/utils/HiveRequestFactory.js");
var PlayerManifestRequest_1 = __webpack_require__(/*! ../../../webrtc/requests/PlayerManifestRequest */ "../../../core/build/core/src/webrtc/requests/PlayerManifestRequest.js");
var basicutils_hive_1 = __webpack_require__(/*! ../../basicutils.hive */ "../../../core/build/core/src/common/basicutils.hive.js");
var logger_hive_1 = __webpack_require__(/*! ../../logger.hive */ "../../../core/build/core/src/common/logger.hive.js");
var PlayerRequest_1 = __webpack_require__(/*! ../../../webrtc/requests/PlayerRequest */ "../../../core/build/core/src/webrtc/requests/PlayerRequest.js");
var SessionRegistry_1 = __webpack_require__(/*! ../../session/SessionRegistry */ "../../../core/build/core/src/common/session/SessionRegistry.js");
var HiveJS = /** @class */ (function (_super) {
    __extends(HiveJS, _super);
    /**
     * create a new HiveJS tech instance
     * @param plugin the Plugin
     * @param newOptions default + user defined options
     * @param statsJsInstance the initialized statsJS instance to fallback in case the
     * protocol is not supported by HiveJS
     */
    function HiveJS(plugin, newOptions, statsJsInstance) {
        var _this = _super.call(this, plugin, newOptions) || this;
        _this.loggerId = '[HiveJS]';
        // setup Tech specific options
        _this.options_ = new options_hivejs_hive_1.HiveJSOptions();
        if (newOptions[HiveJS.techName] != undefined) {
            basicutils_hive_1.updateOptions(newOptions[HiveJS.techName], _this.options_);
        }
        // set the fallback instance of StatsJS
        _this.statsJS = statsJsInstance;
        return _this;
    }
    HiveJS.prototype.getName = function () {
        return HiveJS.techName;
    };
    HiveJS.prototype.getVersion = function () {
        return this.plugin.getPluginVersion();
    };
    HiveJS.prototype.needsReportingInstance = function () {
        return true;
    };
    /**
     * check if HiveJs code is included in the page and the browser supports WebRTC Datachannels
     * @returns {Promise<T>}
     */
    HiveJS.prototype.isReady = function () {
        // first check if there is Hive.js in the page
        if (webrtc_1.default.getInstance) {
            // then check if webrtc datachannel are supported
            if (navigator && navigator.userAgent && HiveJS.isBrowserSupported(navigator.userAgent)) {
                return Q.resolve(true);
            }
            else {
                return Q.reject(new common_hive_1.HiveTechError(common_hive_1.HiveTechErrorCode.NOT_READY, 'WebRTC DataChannels not supported by browser'));
            }
        }
        else {
            return Q.reject(new common_hive_1.HiveTechError(common_hive_1.HiveTechErrorCode.NOT_READY, 'Not included in the page'));
        }
    };
    /**
     * method called by comm.onActivateSession when needs to check if a manifest source
     * corresponds to a certain session. The source can either be obtained by the player once it
     * reported a 'loaded metadata' or directly from the caught HiveRequestManifest.
     *
     * If the session corresponds to the source, we check if the player is using HiveGenericRequests
     * and HiveJs correctly supports the protocol, otherwise we downgrade the session
     *
     * @param source
     * @param session
     * @param isWamsStrict
     * @returns {boolean}
     */
    HiveJS.prototype.isActive = function (source, session, isWamsStrict) {
        if (isWamsStrict === void 0) { isWamsStrict = false; }
        // first check if it's AMS stream with rewrite
        var sourceLower = source.toLowerCase();
        var manifestDomainMatcher = this.plugin.options().manifestDomainMatcher;
        var _a = basicutils_hive_1.isSourceAllowed(source, session.manifest, manifestDomainMatcher, isWamsStrict), isAllowed = _a.isAllowed, needsOverride = _a.needsOverride, isWams = _a.isWams;
        if (isAllowed) {
            if (isWams) {
                if (sourceLower.indexOf('.ism/manifest(format=mpd-time-csf)') > -1) {
                    if (this.manifestRequest) {
                        // HiveJs supports this manifest and the player uses HiveRequestFactory, all good!
                        session.ticket.setManifestUrl(source);
                        return true;
                    }
                    else {
                        // HiveJS supports the manifest, but the player is not using HiveRequest
                        return this.downgradeSessionTech(session, 'The player does not use HiveRequest, downgrading to StatsJS');
                    }
                }
                else {
                    // HiveJs does not support this protocol
                    return this.downgradeSessionTech(session, 'Protocol not supported by HiveJS tech, downgrading to StatsJS');
                }
            }
            else {
                if (this.manifestRequest) {
                    // Only switch ticket source if needed
                    if (needsOverride) {
                        session.ticket.setManifestUrl(source);
                    }
                    return true;
                }
                return this.downgradeSessionTech(session, 'The player does not use HiveRequest, downgrading to StatsJS');
            }
        }
        return false;
    };
    HiveJS.prototype.closeSession = function (session, completeClose) {
        if (window && window['deactivateXHRInterceptor'])
            window['deactivateXHRInterceptor']();
        _super.prototype.closeSession.call(this, session, completeClose);
        var peer = webrtc_1.default.getInstance();
        // this code is after the super.closeSession because we need to flush the last snapshots before clearing all the connections
        if (completeClose) {
            // If we completely close the session, we want to remove any info from the HiveRequestFactory
            HiveRequestFactory_1.HiveRequestFactory.clearPlugin(this.plugin.getPluginId());
            SessionRegistry_1.SessionRegistry.getInstance().unregister(this.plugin, session);
            if (peer) {
                peer.onStateChange(this.plugin.getPluginId(), Reporting_1.ClientState.STOP);
                // If we completely close the session, we want to reinitialize the tracker manager in order to have a new dispatcher at the service client
                peer.serviceClientDisconnected();
            }
        }
        else if (peer) {
            peer.onStateChange(this.plugin.getPluginId(), Reporting_1.ClientState.IDLE);
        }
    };
    /**
     * called by isActive to downgrade a certain session from HiveJS to StatsJS
     * @param session
     * @param downgradeReason
     * @returns {boolean}
     */
    HiveJS.prototype.downgradeSessionTech = function (session, downgradeReason) {
        // downgrade this session's tech to StatsJS
        session.tech = this.statsJS;
        // make sure next requests use directly XMLHttpRequest
        HiveRequestFactory_1.HiveRequestFactory.register(this.statsJS);
        // if it was intercepted, resolve the manifest request without hivejs
        // NOT: for now this should not happened since on AMP only DASH requests using HiveRequest
        if (this.manifestRequest) {
            this.manifestRequest.resolve();
        }
        this.manifestRequest = undefined;
        // log the downgrade reason and trigger it on the user-defined HiveJS.onError callback
        this.plugin.logger().warn(this.loggerId + " " + downgradeReason);
        this.onError(new common_hive_1.HiveTechError(common_hive_1.HiveTechErrorCode.SESSION_ERROR, downgradeReason));
        if (window && window['deactivateXHRInterceptor'])
            window['deactivateXHRInterceptor']();
        return true;
    };
    /**
     * called by HiveRequestManifest when intercepts a manifest request from the player
     * so we can then either resolve the request directly or pass it to Hive.JS
     * @param req
     */
    HiveJS.prototype.setManifestRequest = function (req) {
        this.manifestRequest = req;
    };
    HiveJS.prototype.resetTech = function () {
    };
    /**
     * The HiveJS support was confirmed by isActive therefore we upgrade the bindings to full HiveJS
     * making sure initialize the Hive Bindings as UPGRADE
     * @param session
     */
    HiveJS.prototype.onActiveSession = function (session) {
        var _this = this;
        // upgrade missing bindings (isUpgradeFromStats = true)
        Framework_1.Framework.getPeerContext().apply(new Bindings_1.WebRTCBindings(true));
        // load and start the Peer instance with a reporting instance
        var peer = webrtc_1.default.getInstance();
        // reset the peer before initialization
        peer.onStateChange(this.plugin.getPluginId(), Reporting_1.ClientState.STOP);
        if (this.checkForAndroidDevice()) {
            // If this is an android device then we need to inform the peer to act analogously
            peer.setUpAndroidDevice(true);
        }
        peer.start(session.reportingInstance, this.options_).then(function (manifest) {
            // reset the local counters
            _this.initStats();
            // init metrics, update the techInfo and streamInfo provider
            _this.ri = session.reportingInstance;
            _this.ri.renderStatsCallback = _this.options_.renderStatsCallback;
            _this.ri.updateTechInfo(webrtc_1.default.getInfo());
            _this.ri.statsClient.init(_this.ri.statsStore, session.ticket.sessionId);
            if (_this.plugin.options().testId) {
                _this.ri.statsStore.initTestId(_this.plugin.options().testId);
            }
            if (session.authenticationToken) {
                var swarm = peer.getSwarmFromPluginId(_this.plugin.getPluginId());
                if (swarm) {
                    swarm.contextManager.currentContext.setAuthenticationToken(session.authenticationToken);
                }
            }
            // make sure that the original manifest request is then received by Hive.js
            if (_this.manifestRequest) {
                peer.request(_this.manifestRequest, _this.plugin.getPluginId());
            }
            // init track snapshot with manifest request
            _this.ri.trackManager.manifestRequested(session.ticket.sessionId, _this.plugin.getPlayerSource(), 200);
            // flush the tech events collected so far
            var events = _this.plugin.flushTechEvents();
            if (events && events.length > 0) {
                _this.ri.trackManager.handleTechEvents(events);
            }
            // flush the init step events previously collected
            var initStepEvents = _this.plugin.getInitStepTimers().flushEvents();
            _this.ri.trackManager.handleInitStepEvents(initStepEvents, session.id);
            _this.ri.statsStore.streamInfoProvider.setTextTrackProvider({ getTextTracks: function () { return _this.plugin.getTextTracks(); } });
            _this.plugin.updateIntegrationInfo(_this.ri);
        });
        // execute user defined callback
        if (this.options().onActiveSession != undefined) {
            try {
                this.options().onActiveSession(session.toHiveSession());
            }
            catch (e) {
                logger_hive_1.ErrorMonitor.getInstance().logError('exception in user-defined onActiveSession callback', this.loggerId, e);
            }
        }
    };
    HiveJS.prototype.onStateChange = function (session, isIdle) {
    };
    HiveJS.prototype.generateSession = function (ticketUrl, ticket, manifest, reportingInstance) {
        var session = new HiveSessionInternal_1.HiveSessionInternal(ticketUrl, ticket, manifest, reportingInstance, this.plugin.options().onSessionStateChange);
        session.SDN = true;
        session.id = session.ticket.sessionId;
        return session;
    };
    HiveJS.prototype.accountExtendedStats = function () {
    };
    // We check if the browser runs inside an Android device.=
    HiveJS.prototype.checkForAndroidDevice = function () {
        var parser = new ua_parser_js_1.UAParser();
        parser.setUA(navigator.userAgent);
        if (parser.getOS().name == 'Android') {
            return true;
        }
        return false;
    };
    /**
     * We explicitly do not support mobile safari.
     * We support safari version 12 and greater.
     * We support all other browsers that have WebRTC datachannel.
     */
    HiveJS.isBrowserSupported = function (userAgent) {
        try {
            var parser = new ua_parser_js_1.UAParser(userAgent);
            var browser = parser.getBrowser();
            if (browser.name === 'Mobile Safari')
                return false;
            if (browser.name === 'Safari')
                return parseInt(browser.major, 10) >= 12;
            return typeof RTCPeerConnection.prototype.createDataChannel === 'function';
        }
        catch (err) {
            return false;
        }
    };
    HiveJS.prototype.getPluginId = function () {
        return this.plugin.getPluginId();
    };
    HiveJS.prototype.createManifestRequest = function (pluginId) {
        return new PlayerManifestRequest_1.PlayerManifestRequest(pluginId);
    };
    HiveJS.prototype.createRequest = function (pluginId) {
        return new PlayerRequest_1.PlayerRequest(pluginId);
    };
    HiveJS.prototype.supportsXhrInterception = function () {
        return true;
    };
    HiveJS.techName = 'HiveJS';
    return HiveJS;
}(stats_hive_1.StatsJS));
exports.HiveJS = HiveJS;
//# sourceMappingURL=hivejs.hive.js.map

/***/ }),

/***/ "../../../core/build/core/src/common/techs/hivejs/options.hivejs.hive.js":
/*!************************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/common/techs/hivejs/options.hivejs.hive.js ***!
  \************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.HiveJSOptions = void 0;
var options_hive_1 = __webpack_require__(/*! ../../options.hive */ "../../../core/build/core/src/common/options.hive.js");
/**
 * Configurable Options valid only for the HiveJS Tech
 */
var HiveJSOptions = /** @class */ (function (_super) {
    __extends(HiveJSOptions, _super);
    function HiveJSOptions() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * minimum version of HiveJS allowed to run
         * @type {string}
         * @default {3.0.0}
         */
        _this.minVersion = '3.0.0';
        /**
         * Callback function to pass statistics about the current Hive session. If
         * given a string, the option represents a named function in the
         * this-or-ancestor window.
         * @type {@link HiveRenderStatsCallback}
         */
        _this.renderStatsCallback = function (stats) { };
        /**
         * Some CDNs use headers and/or query parameters for authentication. The
         * player is aware of those parameters, but the prefetcher is not. Use these
         * settings to make the Prefetcher save query parameters and/or headers from
         * the player request to use in future prefetch requests.
         */
        _this.requestCache = {};
        /**
         * Seconds of fragments to trim out for both HLS and DASH Streams, while
         * Hive webRTC is enabled.
         * N.B.: this config changes the offset time to the live point and
         * the Hive Peroformances!
         * The values are in seconds
         */
        _this.maximumTrimming = undefined;
        return _this;
    }
    return HiveJSOptions;
}(options_hive_1.HiveTechOptions));
exports.HiveJSOptions = HiveJSOptions;
//# sourceMappingURL=options.hivejs.hive.js.map

/***/ }),

/***/ "../../../core/build/core/src/common/techs/statsjs/options.stats.hive.js":
/*!************************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/common/techs/statsjs/options.stats.hive.js ***!
  \************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.StatsJSUrlConfigurableOptions = exports.StatsJSOptions = void 0;
var options_hive_1 = __webpack_require__(/*! ../../options.hive */ "../../../core/build/core/src/common/options.hive.js");
var comm_hive_1 = __webpack_require__(/*! ../../comm.hive */ "../../../core/build/core/src/common/comm.hive.js");
/**
 * Configurable Options valid only for the StatsJS Tech
 */
var StatsJSOptions = /** @class */ (function (_super) {
    __extends(StatsJSOptions, _super);
    function StatsJSOptions() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * Enables XHR interception in the Stats Only tech.
         * @type {boolean}
         * @default true
         */
        _this.enableXhrInterception = comm_hive_1.BuildParameters.STATS_MANIFEST_INTERCEPTION_ENABLED;
        return _this;
    }
    return StatsJSOptions;
}(options_hive_1.HiveTechOptions));
exports.StatsJSOptions = StatsJSOptions;
var StatsJSUrlConfigurableOptions = /** @class */ (function () {
    function StatsJSUrlConfigurableOptions() {
        /**
         * For the Stats Only tech, overrides the use of XHR interception.
         */
        this.hiveEnableXhrInterception = 'enableXhrInterception';
    }
    return StatsJSUrlConfigurableOptions;
}());
exports.StatsJSUrlConfigurableOptions = StatsJSUrlConfigurableOptions;
//# sourceMappingURL=options.stats.hive.js.map

/***/ }),

/***/ "../../../core/build/core/src/common/techs/statsjs/stats.hive.js":
/*!****************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/common/techs/statsjs/stats.hive.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.StatsJS = void 0;
var stats_1 = __webpack_require__(/*! ../../../stats */ "../../../core/build/core/src/stats/index.js");
var Q = __webpack_require__(/*! @hivestreaming/q */ "../../../node_modules/@hivestreaming/q/q.js");
var HiveSessionInternal_1 = __webpack_require__(/*! ../../utils/HiveSessionInternal */ "../../../core/build/core/src/common/utils/HiveSessionInternal.js");
var HiveRequestFactory_1 = __webpack_require__(/*! ../../utils/HiveRequestFactory */ "../../../core/build/core/src/common/utils/HiveRequestFactory.js");
var basicutils_hive_1 = __webpack_require__(/*! ../../basicutils.hive */ "../../../core/build/core/src/common/basicutils.hive.js");
var options_stats_hive_1 = __webpack_require__(/*! ./options.stats.hive */ "../../../core/build/core/src/common/techs/statsjs/options.stats.hive.js");
var Reporting_1 = __webpack_require__(/*! ../../../stats/Reporting */ "../../../core/build/core/src/stats/Reporting.js");
var Track_1 = __webpack_require__(/*! ../../../stats/Track */ "../../../core/build/core/src/stats/Track.js");
var comm_hive_1 = __webpack_require__(/*! ../../comm.hive */ "../../../core/build/core/src/common/comm.hive.js");
var logger_hive_1 = __webpack_require__(/*! ../../logger.hive */ "../../../core/build/core/src/common/logger.hive.js");
var BrowserLogger_1 = __webpack_require__(/*! ../../../core/BrowserLogger */ "../../../core/build/core/src/core/BrowserLogger.js");
var Framework_1 = __webpack_require__(/*! ../../../core/Framework */ "../../../core/build/core/src/core/Framework.js");
var SnapshotAccountingManager_1 = __webpack_require__(/*! ../../../stats/SnapshotAccountingManager */ "../../../core/build/core/src/stats/SnapshotAccountingManager.js");
var PlayerRequest_1 = __webpack_require__(/*! ../../../stats/requests/PlayerRequest */ "../../../core/build/core/src/stats/requests/PlayerRequest.js");
var PlayerManifestRequest_1 = __webpack_require__(/*! ../../../stats/requests/PlayerManifestRequest */ "../../../core/build/core/src/stats/requests/PlayerManifestRequest.js");
var EntityType_1 = __webpack_require__(/*! ../../../core/entity/EntityType */ "../../../core/build/core/src/core/entity/EntityType.js");
var EntityRequest_1 = __webpack_require__(/*! ../../../core/entity/EntityRequest */ "../../../core/build/core/src/core/entity/EntityRequest.js");
var ContextManager_1 = __webpack_require__(/*! ../../../stats/context/ContextManager */ "../../../core/build/core/src/stats/context/ContextManager.js");
var ErrorCodes = __webpack_require__(/*! ../../error.hive */ "../../../core/build/core/src/common/error.hive.js");
var StatsJS = /** @class */ (function () {
    function StatsJS(plugin, newOptions) {
        this.loggerId = '[StatsJS]';
        this.isActiveChecked = false;
        this.manifestIntercepted = false;
        this.plugin = plugin;
        this.options_ = new options_stats_hive_1.StatsJSOptions();
        this.videoContextManager = new ContextManager_1.VideoContextManager();
        this.snapshotAccountingManager = new SnapshotAccountingManager_1.SnapshotAccountingManager();
        if (newOptions[StatsJS.techName] !== undefined)
            basicutils_hive_1.updateOptions(newOptions[StatsJS.techName], this.options_);
        basicutils_hive_1.parseParameterOptions(window.location.href, new options_stats_hive_1.StatsJSUrlConfigurableOptions(), this.options_);
    }
    StatsJS.prototype.getName = function () {
        return StatsJS.techName;
    };
    StatsJS.prototype.id = function () {
        return '[' + StatsJS.techName + '] ';
    };
    StatsJS.prototype.getVersion = function () {
        return this.plugin.getPluginVersion();
    };
    StatsJS.prototype.needsReportingInstance = function () {
        return true;
    };
    StatsJS.prototype.isReady = function () {
        return Q.resolve(true);
    };
    /**
     * initialize a session on Stats/HiveJS with a ticket and an initialized ReportingInstance.
     * If the tech is ready, by default we initialize the session, without actually binding
     * all the components to the peer context.
     * Only when the first manifest request is received, we will decide if Hive.js supports
     * the protocol or not.
     *
     * To intercept the first manifest request HiveRequestFactory will return
     * a special HiveRequestManifest initialized with this instance of HiveJs tech object.
     *
     * If the player performs a manifest request through HiveRequestManifest,
     * this tech will intercept it and evaluate if we actually support that protocol or not.
     * If supported, it will extend the bindings for all remaining HiveJS components, otherwise
     * it will revert the tech for the initialized session to StatsJS
     *
     * @param ticketUrl
     * @param ri
     * @returns {Q.Promise<HiveSessionInternal>}
     */
    StatsJS.prototype.initSession = function (ticketUrl, _agentPicker, ri) {
        var _this = this;
        return this.isReady().then(function () {
            _this.isActiveChecked = false;
            _this.initStats();
            // manifest protocol check
            var manifestUrl = ri.ticket.getManifestUrlWithQuery();
            manifestUrl = manifestUrl.indexOf('//') === 0 ? location.protocol + manifestUrl : manifestUrl;
            var session = _this.generateSession(ticketUrl, ri.ticket, manifestUrl, ri);
            // we make sure that we intercept the first manifest request
            // so we can determine if we support the protocol
            comm_hive_1.SessionRegistry.getInstance().register(_this.plugin, session);
            HiveRequestFactory_1.HiveRequestFactory.register(_this);
            if (window && window['activateXHRInterceptor']) {
                window['activateXHRInterceptor'](_this.plugin.loggerLevel() > BrowserLogger_1.HiveLoggerLevel.info, _this.plugin.getPluginId());
            }
            // wait for the connectivity info, site matching and configurations and track the timings
            _this.plugin.getInitStepTimers().start(Track_1.InitStep.TIME_TO_CONN_INFO_SUCCESS);
            return ri.connInfoProvider.getConnectivityInfo()
                .then(function () { return _this.plugin.getInitStepTimers().stop(Track_1.InitStep.TIME_TO_CONN_INFO_SUCCESS); })
                .catch(function (error) {
                _this.plugin.getInitStepTimers().stop(Track_1.InitStep.TIME_TO_CONN_INFO_SUCCESS, false, Track_1.InitStep.TIME_TO_CONN_INFO_FAIL);
                logger_hive_1.ErrorMonitor.getInstance().logError('Error getting connectivity info', _this.loggerId, ErrorCodes.HIVE_COMM_PLUGIN.GET_CONNECTIVITY_INFO, error);
            })
                .then(function () { return session; });
        });
    };
    StatsJS.prototype.getInitSessionTimeout = function () {
        return this.options().initTimeout;
    };
    StatsJS.prototype.isActive = function (source, session, isWamsStrict) {
        var manifestDomainMatcher = this.plugin.options().manifestDomainMatcher;
        var _a = basicutils_hive_1.isSourceAllowed(source, session.manifest, manifestDomainMatcher, isWamsStrict), isAllowed = _a.isAllowed, needsOverride = _a.needsOverride;
        if (!this.isActiveChecked) {
            if (!this.manifestIntercepted) {
                this.plugin.logger().info('The player does not use HiveRequest');
            }
            this.isActiveChecked = true;
            if (isAllowed && needsOverride) {
                session.ticket.setManifestUrl(source);
            }
        }
        return isAllowed;
    };
    /**
     * close AMP session resetting the stats client
     * @param session
     */
    StatsJS.prototype.closeSession = function (session, completeClose) {
        if (window && window['deactivateXHRInterceptor'])
            window['deactivateXHRInterceptor']();
        if (session.reportingInstance && stats_1.default.getInstance().hasSession(session.id)) {
            this.plugin.logger().debug(this.loggerId + " stopping session [" + session.id + "] complete close: " + completeClose);
            // sending the latest collecting data before closing the session!
            // We need to flush the track snapshot synchronously; otherwise, the
            // WebSocket may be dead by the time the track snapshot's schedule
            // triggers.
            session.reportingInstance.trackClient.flushLastTrackSnapshot();
            session.reportingInstance.statsClient.flushLastMetricSnapshot();
            session.reportingInstance.statsClient.reset(completeClose);
        }
        if (completeClose) {
            // We also close the connection and remove any info from the HiveRequestFactory in order to regenerate the websocket with backend starting with the right ticket data!
            HiveRequestFactory_1.HiveRequestFactory.clearPlugin(this.plugin.getPluginId());
            stats_1.default.getInstance().close(session.id);
        }
        else {
            this.onStateChange(session, true);
        }
    };
    StatsJS.prototype.onStateChange = function (session, isIdle) {
        var newState = isIdle ? Reporting_1.ClientState.IDLE : Reporting_1.ClientState.PLAY;
        this.plugin.logger().notice('[HiveComm] client state: ' + Reporting_1.ClientState[newState]);
        if (session.reportingInstance) {
            session.reportingInstance.onStateChange(newState);
        }
    };
    StatsJS.prototype.handleStats = function (session, stats) {
        var _this = this;
        var newBuffering = 0;
        var height = stats.height, width = stats.width;
        if (this.state.currentTotalBuffering < stats.totalBuffering) {
            newBuffering = stats.totalBuffering - this.state.currentTotalBuffering;
            this.state.currentTotalBuffering = stats.totalBuffering;
        }
        // wait for an existing reporting instance before sending player stats
        session.getReportingInstance().then(function () {
            if (height !== _this.state.currentWindowHeight || width !== _this.state.currentWindowWidth) {
                var value = width + "x" + height;
                session.reportingInstance.trackManager.handlePlayerEvent(session.ticket.sessionId, Track_1.PlayerEvents.WINDOW_SIZE, { value: value });
                _this.state.currentWindowHeight = height;
                _this.state.currentWindowWidth = width;
            }
            session.reportingInstance.statsStore.addBuffering(newBuffering, stats.bufferLength);
            session.reportingInstance.statsStore.handleStats(stats);
            session.reportingInstance.trackManager.handlePlayerStats(stats.playingPoint, stats.bufferLength, stats.totalBuffering);
        }).done();
        return Q.resolve(true);
    };
    StatsJS.prototype.handleEvent = function (session, event, eventObj, async) {
        if (async === void 0) { async = true; }
        if (async) {
            // wait for an existing reporting instance before sending player event
            return session.getReportingInstance().then(function (ri) {
                ri.trackManager.handlePlayerEvent(session.ticket.sessionId, event, eventObj);
            });
        }
        else {
            var ri = session.reportingInstance;
            if (!ri) {
                logger_hive_1.ErrorMonitor.getInstance().logError('No reporting instance to handle synchronous event', this.id(), ErrorCodes.HIVE_COMM_PLUGIN.NO_REPORTING_INSTANCE, eventObj);
                return Q.reject();
            }
            try {
                ri.trackManager.handlePlayerEvent(session.ticket.sessionId, event, eventObj);
                return Q.resolve(true);
            }
            catch (_a) {
                return Q.reject();
            }
        }
    };
    StatsJS.prototype.handleTechEvent = function (session, event) {
        // wait for an existing reporting instance before sending tech events
        session.getReportingInstance().then(function () {
            session.reportingInstance.trackManager.handleTechEvents([event]);
        }).done();
        return Q.resolve(true);
    };
    StatsJS.prototype.onError = function (error) {
        var proceedOnError = true;
        if (this.options().onError != undefined) {
            try {
                // Continue tech fallback unless provided 'onError' explicitly returns 'false'
                if (this.options_.onError(error) === false) {
                    proceedOnError = false;
                }
            }
            catch (e) {
                logger_hive_1.ErrorMonitor.getInstance().logError('exception in user-defined onError callback', this.id(), e);
            }
        }
        return proceedOnError;
    };
    StatsJS.prototype.onActiveSession = function (session) {
        var _this = this;
        // reset internal counters
        this.initStats();
        session.getReportingInstance().then(function (ri) {
            // init metrics and streamInfo provider
            _this.ri = ri;
            // initialize stream metadata provider with the
            // information available before parsing the manifest
            // set hasBeenLive to use plugin.isLive in case XHR interception is not supported and metadataProvider isn't updated.
            var metadataProvider = {
                getStreamProtocol: function () { return (_this.plugin.getStreamProtocol()); },
                hasBeenLive: function () { return _this.plugin.isLive(); },
                getMetadataInfo: function () { return ([]); }
            };
            // initialize video context manager
            _this.videoContextManager.init(_this.ri, session.id);
            _this.videoContextManager.initContext(_this.ri.ticket, _this.options_);
            if (session.authenticationToken) {
                _this.videoContextManager.currentContext.setAuthenticationToken(session.authenticationToken);
            }
            // initialize stream info provider
            _this.ri.statsStore.streamInfoProvider.init(session.ticket, metadataProvider, { getTextTracks: function () { return _this.plugin.getTextTracks(); } });
            // update the player/plugin info
            _this.plugin.updateIntegrationInfo(_this.ri);
            // initialize the periodic metric snapshots
            _this.ri.statsClient.init(_this.ri.statsStore, session.id);
            if (_this.plugin.options().testId) {
                _this.ri.statsStore.initTestId(_this.plugin.options().testId);
            }
            // init track snapshot with manifest request
            _this.ri.trackManager.manifestRequested(session.ticket.sessionId, _this.plugin.getPlayerSource(), 200);
            // init the snapshot accounting manager
            _this.snapshotAccountingManager.init(_this.ri);
            // flush the tech events collected so far
            var events = _this.plugin.flushTechEvents();
            if (events && events.length > 0)
                _this.ri.trackManager.handleTechEvents(events);
            // flush the init step events previously collected
            var initStepEvents = _this.plugin.getInitStepTimers().flushEvents();
            _this.ri.trackManager.handleInitStepEvents(initStepEvents, session.id);
            if (_this.options_.onActiveSession != undefined) {
                try {
                    _this.options_.onActiveSession(session.toHiveSession());
                }
                catch (e) {
                    logger_hive_1.ErrorMonitor.getInstance().logError('exception in user-defined onActiveSession callback', _this.id(), e);
                }
            }
        }).done();
    };
    StatsJS.prototype.onTechTimeout = function () {
    };
    StatsJS.prototype.resetTech = function () {
    };
    StatsJS.prototype.setPlugin = function (plugin) {
        this.plugin = plugin;
    };
    StatsJS.prototype.options = function () {
        return this.options_;
    };
    StatsJS.prototype.initStats = function () {
        this.state = {
            currentTotalBuffering: 0,
            currentWindowWidth: null,
            currentWindowHeight: null
        };
    };
    StatsJS.prototype.generateSession = function (ticketUrl, ticket, manifest, ri) {
        var session = new HiveSessionInternal_1.HiveSessionInternal(ticketUrl, ticket, manifest, ri, this.plugin.options().onSessionStateChange);
        session.SDN = false;
        session.id = ticket.sessionId;
        return session;
    };
    StatsJS.prototype.getPluginId = function () {
        return this.plugin.getPluginId();
    };
    StatsJS.prototype.createManifestRequest = function (pluginId) {
        var _this = this;
        var xhr = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.HTTP_REQUEST);
        var request = new PlayerManifestRequest_1.PlayerManifestRequest(xhr, pluginId);
        request.onready = function (status, url) {
            if (status !== EntityRequest_1.EntityRequestStatus.SUCCEEDED) {
                logger_hive_1.ErrorMonitor.getInstance().logError('Error intercepting manifest request', url);
                return;
            }
            _this.plugin.logger().debug('Intercepted Manifest Request ' + url);
            var currentContext = _this.videoContextManager.currentContext;
            // parse the manifest
            currentContext.metadataReceived(request);
            // update stream info provider
            _this.ri.statsStore.streamInfoProvider.updateStreamMetadataProvider(currentContext);
            // update the quality level tracker
            _this.ri.statsStore.streamInfoProvider.setQualityLevelTracker(currentContext.getQualityLevelTracker());
        };
        return xhr;
    };
    StatsJS.prototype.createRequest = function (pluginId) {
        var _this = this;
        var currentContext = this.videoContextManager.currentContext;
        var xhr = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.HTTP_REQUEST);
        var request = new PlayerRequest_1.PlayerRequest(xhr, currentContext.getMetadata());
        request.onready = function (status) {
            currentContext.requestReceived(request).then(function () {
                _this.snapshotAccountingManager.accountFallbackRequest(request);
                if (status !== EntityRequest_1.EntityRequestStatus.SUCCEEDED)
                    return;
                switch (request.getEntityType()) {
                    case EntityType_1.EntityType.AUDIO:
                        {
                            currentContext.updateFragmentMetadata(request);
                        }
                        break;
                    case EntityType_1.EntityType.VIDEO:
                        {
                            currentContext.updateBandwidth(request);
                            currentContext.updateQualityLevel(request);
                            currentContext.updateFragmentMetadata(request);
                            currentContext.updateFragmentDownload(request);
                        }
                        break;
                }
            });
        };
        return xhr;
    };
    StatsJS.prototype.supportsXhrInterception = function () {
        // Since we do not have type-checking on partner-provided plugin options, wrap
        // in Boolean() call to ensure proper type return
        return Boolean(this.options_.enableXhrInterception);
    };
    /**
     * called by HiveRequestManifest when intercepts a manifest request from the player
     * so we can then either resolve the request directly or pass it to Hive.JS
     * @param req
     */
    StatsJS.prototype.setManifestIntercepted = function () {
        this.manifestIntercepted = true;
    };
    StatsJS.techName = 'StatsJS';
    return StatsJS;
}());
exports.StatsJS = StatsJS;
//# sourceMappingURL=stats.hive.js.map

/***/ }),

/***/ "../../../core/build/core/src/common/techs/techs.hive.js":
/*!********************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/common/techs/techs.hive.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.TechName = exports.Techs = void 0;
/**
 * list of available Hive Techs
 *
 * N.B. Please insert new techs just at the bottom of the list, in order to keep the status code for the plugins
 * consistent, since it is dependent by the value of this enumeration
 * Check test: 'when the hive plugin successfully starts, we get the code of the tech active'
 */
var Techs;
(function (Techs) {
    /**
     * use the in-browser Hive client to retrieve the video from the CDN or the P2P Network
     * HiveJS works only on browser that support WebRTC Datachannels (Chrome +38, Firefox +31 or Opera)
     */
    Techs[Techs["HiveJS"] = 0] = "HiveJS";
    /**
     * use the Java installed Hive client to retrieve the video from the CDN or the P2P Network
     */
    Techs[Techs["HiveJava"] = 1] = "HiveJava";
    /**
     * use only the browser telemetry package for Hive Insights
     */
    Techs[Techs["StatsJS"] = 2] = "StatsJS";
})(Techs = exports.Techs || (exports.Techs = {}));
var TechName;
(function (TechName) {
    TechName["StatsJS"] = "StatsJS";
    TechName["HiveJava"] = "HiveJava";
    TechName["HiveJS"] = "HiveJS";
})(TechName = exports.TechName || (exports.TechName = {}));
//# sourceMappingURL=techs.hive.js.map

/***/ }),

/***/ "../../../core/build/core/src/common/utils/HivePlayerStats.js":
/*!*************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/common/utils/HivePlayerStats.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.HivePlayerStats = void 0;
var HivePlayerStats = /** @class */ (function () {
    function HivePlayerStats(playingPoint, bufferLength, totalBuffering, width, height, fullscreen, playingTime, playerVolume, captionLanguage) {
        this._playingPoint = playingPoint;
        this._bufferLength = bufferLength;
        this._totalBuffering = totalBuffering;
        this._width = Math.round(width);
        this._height = Math.round(height);
        this._fullscreen = fullscreen;
        this._playingTime = playingTime;
        this._playerVolume = playerVolume;
        this._captionLanguage = captionLanguage;
        this.replaceNaNs();
    }
    Object.defineProperty(HivePlayerStats.prototype, "fullscreen", {
        get: function () {
            return this._fullscreen;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(HivePlayerStats.prototype, "height", {
        get: function () {
            return this._height;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(HivePlayerStats.prototype, "width", {
        get: function () {
            return this._width;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(HivePlayerStats.prototype, "totalBuffering", {
        get: function () {
            return this._totalBuffering;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(HivePlayerStats.prototype, "bufferLength", {
        get: function () {
            return this._bufferLength;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(HivePlayerStats.prototype, "playingPoint", {
        get: function () {
            return this._playingPoint;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(HivePlayerStats.prototype, "playingTime", {
        get: function () {
            return this._playingTime;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(HivePlayerStats.prototype, "playerVolume", {
        get: function () {
            return this._playerVolume;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(HivePlayerStats.prototype, "captionLanguage", {
        get: function () {
            return this._captionLanguage;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * This method normalizes playerPoint, bufferLength and totalBuffering since we noticed that in multiple players
     * especially at early stage of the stream, can have inconsistent data. So set it to 0
     */
    HivePlayerStats.prototype.replaceNaNs = function () {
        if (isNaN(this.playingPoint))
            this._playingPoint = 0;
        if (isNaN(this.bufferLength))
            this._bufferLength = 0;
        if (isNaN(this.totalBuffering))
            this._totalBuffering = 0;
        if (isNaN(this.playingTime))
            this._playingTime = 0;
        if (isNaN(this._playerVolume))
            this._playerVolume = 0;
    };
    return HivePlayerStats;
}());
exports.HivePlayerStats = HivePlayerStats;
//# sourceMappingURL=HivePlayerStats.js.map

/***/ }),

/***/ "../../../core/build/core/src/common/utils/HiveRequestFactory.js":
/*!****************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/common/utils/HiveRequestFactory.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.HiveRequestFactory = void 0;
var logger_hive_1 = __webpack_require__(/*! ../logger.hive */ "../../../core/build/core/src/common/logger.hive.js");
var HiveRequestFactory = /** @class */ (function () {
    function HiveRequestFactory(pluginId) {
        this.pluginId = pluginId;
    }
    HiveRequestFactory.prototype.createXMLHttpRequest = function () {
        // if no session is passed try to pick the first registered tech
        if (!this.pluginId) {
            if (Object.keys(HiveRequestFactory.handlers).length === 0) {
                HiveRequestFactory.logError('No registered default HiveRequestFactory tech', HiveRequestFactory.loggerId);
                return new XMLHttpRequest();
            }
            else {
                this.pluginId = Object.keys(HiveRequestFactory.handlers)[0];
            }
        }
        var handler = HiveRequestFactory.handlers[this.pluginId];
        // if the session doesn't match any registered tech return a default XMLHttpRequest
        if (!handler) {
            HiveRequestFactory.logError('no registered HiveRequestFactory tech for plugin', { pluginId: this.pluginId });
            return new XMLHttpRequest();
        }
        var delegate = handler.delegate;
        // the very first request is always a manifest request
        if (!handler.manifestRequested) {
            handler.manifestRequested = true;
            return delegate.createManifestRequest(this.pluginId);
        }
        // handle any subsequent requests
        return delegate.createRequest(this.pluginId);
    };
    HiveRequestFactory.register = function (delegate) {
        var tech = delegate.getName();
        var pluginId = delegate.getPluginId();
        if (!this.handlers[pluginId]) {
            this.handlers[pluginId] = { tech: tech, delegate: delegate, manifestRequested: false };
        }
    };
    HiveRequestFactory.clear = function () {
        this.handlers = {};
    };
    HiveRequestFactory.clearPlugin = function (pluginId) {
        if (this.handlers[pluginId]) {
            delete this.handlers[pluginId];
        }
    };
    HiveRequestFactory.clearPluginState = function (pluginId) {
        if (this.handlers[pluginId]) {
            var handler = this.handlers[pluginId];
            handler.manifestRequested = false;
        }
    };
    HiveRequestFactory.logError = function (message, loggerIdOrData) {
        if (!this.errorLogged) {
            this.errorLogged = true;
            logger_hive_1.ErrorMonitor.getInstance().logError(message, loggerIdOrData);
        }
    };
    HiveRequestFactory.loggerId = '[HiveRequestFactory]';
    HiveRequestFactory.handlers = {};
    HiveRequestFactory.errorLogged = false;
    return HiveRequestFactory;
}());
exports.HiveRequestFactory = HiveRequestFactory;
//# sourceMappingURL=HiveRequestFactory.js.map

/***/ }),

/***/ "../../../core/build/core/src/common/utils/HiveSessionInternal.js":
/*!*****************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/common/utils/HiveSessionInternal.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.HiveSessionInternal = exports.SessionState = void 0;
var Q = __webpack_require__(/*! @hivestreaming/q */ "../../../node_modules/@hivestreaming/q/q.js");
var logger_hive_1 = __webpack_require__(/*! ../logger.hive */ "../../../core/build/core/src/common/logger.hive.js");
var common_hive_1 = __webpack_require__(/*! ../common.hive */ "../../../core/build/core/src/common/common.hive.js");
var error_hive_1 = __webpack_require__(/*! ../error.hive */ "../../../core/build/core/src/common/error.hive.js");
var SessionState;
(function (SessionState) {
    SessionState["INITIALIZED"] = "INITIALIZED";
    SessionState["ACTIVE"] = "ACTIVE";
    SessionState["IDLE"] = "IDLE";
    SessionState["CLOSED"] = "CLOSED";
})(SessionState = exports.SessionState || (exports.SessionState = {}));
var HiveSessionInternal = /** @class */ (function () {
    function HiveSessionInternal(ticketUrl, ticket, manifest, reportingInstance, stateChangeCb) {
        this.loggerId = '[HiveSessionInternal]';
        this.idle = false;
        this.ticketUrl = ticketUrl;
        this.ticket = ticket;
        this.manifest = manifest;
        if (typeof stateChangeCb === 'function') {
            this.stateChangeCb = stateChangeCb;
        }
        this.deferReportingInstance = Q.defer();
        this.reportingInstance = reportingInstance;
        if (this.reportingInstance) {
            this.deferReportingInstance.resolve(this.reportingInstance);
        }
    }
    HiveSessionInternal.prototype.isActive = function (source, isWamsStrict) {
        if (isWamsStrict === void 0) { isWamsStrict = false; }
        if (this.tech !== null)
            return this.tech.isActive(source, this, isWamsStrict);
        return false;
    };
    HiveSessionInternal.prototype.updateIdleState = function (isIdle) {
        if (this.idle != isIdle) {
            this.idle = isIdle;
            if (this.tech)
                this.tech.onStateChange(this, isIdle);
            var state = this.idle ? SessionState.IDLE : SessionState.ACTIVE;
            this.notifyStateChange(state);
        }
    };
    HiveSessionInternal.prototype.getTechName = function () {
        return this.tech && this.tech.getName() || undefined;
    };
    HiveSessionInternal.prototype.isIdle = function () {
        return this.idle;
    };
    HiveSessionInternal.prototype.close = function (completeClose) {
        // Not calling updateIdleState() as we explicitly call tech.closeSession here
        this.idle = true;
        if (this.tech != null)
            this.tech.closeSession(this, completeClose);
        this.notifyStateChange(SessionState.CLOSED);
    };
    HiveSessionInternal.prototype.toString = function () {
        return this.ticket.toString();
    };
    HiveSessionInternal.prototype.toHiveSession = function () {
        var s = new common_hive_1.HiveSession();
        s.id = this.id;
        s.ticketUrl = this.ticketUrl;
        s.manifest = this.manifest;
        s.tech = this.tech.getName();
        return s;
    };
    /**
     * Returns a promise for the session active reporting instance.
     * In case of tech downgrade to stats, a session might have been initialized without
     * an active reporting instance
     */
    HiveSessionInternal.prototype.getReportingInstance = function () {
        return this.deferReportingInstance.promise;
    };
    /**
     * sets the session active reporting instance and resolves the pending promise
     * @param reportingInstance
     */
    HiveSessionInternal.prototype.setReportingInstance = function (reportingInstance) {
        this.reportingInstance = reportingInstance;
        this.deferReportingInstance.resolve(this.reportingInstance);
    };
    /**
     * Notifies a session state change by sending a 'SessionStateChangeMessage',
     * through the 'onSessionStateChange' callback given as a plugin option
     *
     * @param state {@link SessionState} the new session state
     */
    HiveSessionInternal.prototype.notifyStateChange = function (state) {
        if (this.stateChangeCb) {
            try {
                this.stateChangeCb({ id: this.id, state: state, time: Date.now() });
            }
            catch (e) {
                logger_hive_1.ErrorMonitor.getInstance().logError('Exception in user-defined Generic onSessionStateChange callback', this.loggerId, error_hive_1.HIVE_COMM_PLUGIN.ON_SESSION_STATE_CHANGE_CB_ERROR, e);
            }
        }
    };
    /**
     * true if the tech expects the player to utilize XHR manipulation.
     */
    HiveSessionInternal.prototype.supportsXhrInterception = function () {
        return this.tech ? this.tech.supportsXhrInterception() : false;
    };
    return HiveSessionInternal;
}());
exports.HiveSessionInternal = HiveSessionInternal;
//# sourceMappingURL=HiveSessionInternal.js.map

/***/ }),

/***/ "../../../core/build/core/src/common/utils/HiveTech.js":
/*!******************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/common/utils/HiveTech.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.AgentPicker = void 0;
var AgentPicker;
(function (AgentPicker) {
    AgentPicker[AgentPicker["javaAgent"] = 0] = "javaAgent";
    AgentPicker[AgentPicker["boosterIfPossible"] = 1] = "boosterIfPossible";
})(AgentPicker = exports.AgentPicker || (exports.AgentPicker = {}));
//# sourceMappingURL=HiveTech.js.map

/***/ }),

/***/ "../../../core/build/core/src/common/utils/SensitiveInfoUtils.js":
/*!****************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/common/utils/SensitiveInfoUtils.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.SensitiveInfoUtils = void 0;
var ClientConfigs_1 = __webpack_require__(/*! ../../webrtc/ClientConfigs */ "../../../core/build/core/src/webrtc/ClientConfigs.js");
var Framework_1 = __webpack_require__(/*! ../../core/Framework */ "../../../core/build/core/src/core/Framework.js");
/**
 * This class has the same functionality of the SensitivityInfoUtils in the java client. It will obfuscate/remove all the sensible data if {@link Options.restrictedConnectivityInfo} is true
 * and following the instruction of {@link } and {@link } in order to obfuscate id address and remove the Hostname
 */
var SensitiveInfoUtils = /** @class */ (function () {
    function SensitiveInfoUtils() {
    }
    /**
     * This method "cleans" the private ip address if specified in the init configuration of the plugin
     * @param  {NetworkInfo} networkInfo
     * @returns string
     */
    SensitiveInfoUtils.getPrivateIp = function (networkInfo) {
        var privateIpAddr = networkInfo.getPrivateIp();
        if (this.shouldObfuscate() && privateIpAddr) {
            privateIpAddr = privateIpAddr.replace(/[0-9]*$/, '0');
        }
        return privateIpAddr;
    };
    /**
     * This method "cleans" the hostname if specified in the init configuration of the plugin
     * @param  {PeerConnectivityInfoInt} pc
     * @returns string
     */
    SensitiveInfoUtils.getHostname = function (pc) {
        if (this.shouldObfuscate()) {
            return ClientConfigs_1.HiveConfig.SensitiveInfo.hiddenHostnameValue;
        }
        return pc.getHostName();
    };
    SensitiveInfoUtils.shouldObfuscate = function () {
        try {
            if (!this.configStore)
                this.configStore = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.CONFIG_STORE);
            var shouldObfuscate = this.configStore.getConfig('pii.obfuscationEnabled');
            return ClientConfigs_1.HiveConfig.SensitiveInfo.restrictedConnectivityInfo || shouldObfuscate;
        }
        catch (error) {
            return false;
        }
    };
    return SensitiveInfoUtils;
}());
exports.SensitiveInfoUtils = SensitiveInfoUtils;
//# sourceMappingURL=SensitiveInfoUtils.js.map

/***/ }),

/***/ "../../../core/build/core/src/common/utils/SessionStorageUtil.js":
/*!****************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/common/utils/SessionStorageUtil.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.SessionStorageUtil = void 0;
/**
 * Utility class for SessionStorage
 * NOTE:
 * In FF4, if disabled, window.localStorage should === null.
 * Normally, we could not test that directly and need to do a
 * `('localStorage' in window)` test first because otherwise Firefox will
 * throw bugzil.la/365772 if cookies are disabled
 *
 * Similarly, in Chrome with "Block third-party cookies and site data" enabled,
 * attempting to access `window.sessionStorage` will throw an exception. crbug.com/357625
 *
 * Also in iOS5 Private Browsing mode, attempting to use localStorage.setItem
 * will throw the exception:
 *      QUOTA_EXCEEDED_ERROR DOM Exception 22.
 *
 * Peculiarly, getItem and removeItem calls do not throw.
 *
 * So we have to do all accesses in throw catch.
 */
var SessionStorageUtil = /** @class */ (function () {
    function SessionStorageUtil() {
    }
    SessionStorageUtil.getItem = function (key) {
        try {
            if (window.sessionStorage)
                return window.sessionStorage.getItem(key);
            return null;
        }
        catch (e) {
            return null;
        }
    };
    SessionStorageUtil.setItem = function (key, value) {
        try {
            if (window.sessionStorage) {
                window.sessionStorage.setItem(key, value);
                return true;
            }
            return false;
        }
        catch (e) {
            return false;
        }
    };
    SessionStorageUtil.removeItem = function (key) {
        try {
            if (window.sessionStorage)
                window.sessionStorage.removeItem(key);
        }
        catch (e) {
            return null;
        }
    };
    return SessionStorageUtil;
}());
exports.SessionStorageUtil = SessionStorageUtil;
//# sourceMappingURL=SessionStorageUtil.js.map

/***/ }),

/***/ "../../../core/build/core/src/common/utils/StatsChecker.js":
/*!**********************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/common/utils/StatsChecker.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.StatsChecker = void 0;
/**
 * Utility class for detecting if the player is idle based on how
 * the stats are changing
 */
var StatsChecker = /** @class */ (function () {
    function StatsChecker(maxPeriod) {
        this.maxPeriod = maxPeriod;
    }
    /**
     * check if the stats are evolving and return true
     * iff they didn't change for more than maxPeriod
     * @param newStats
     * @returns {boolean}
     */
    StatsChecker.prototype.check = function (newStats) {
        var now = Date.now();
        if (!this.isEqual(this.previousStats, newStats))
            this.lastStatsChange = now;
        this.previousStats = newStats;
        return (now - this.lastStatsChange) >= this.maxPeriod;
    };
    /**
     * verifies that two stats did not change more than a small threshold
     * comparing playingPoint, bufferLength and totalBuffering
     * @returns boolean
     */
    StatsChecker.prototype.isEqual = function (prev, next) {
        if (prev && next) {
            // computes the differences and return false only if any is larger than a certain threshold
            var diffArray = [(next.playingPoint - prev.playingPoint), (next.bufferLength - prev.bufferLength), (next.totalBuffering - prev.totalBuffering)];
            return diffArray.reduce(function (curr, diff) {
                return curr && (Math.abs(diff) < 10);
            }, true);
        }
        else
            return false;
    };
    return StatsChecker;
}());
exports.StatsChecker = StatsChecker;
//# sourceMappingURL=StatsChecker.js.map

/***/ }),

/***/ "../../../core/build/core/src/common/utils/StreamLiveChecker.js":
/*!***************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/common/utils/StreamLiveChecker.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.StreamLiveChecker = void 0;
var m3u8_1 = __webpack_require__(/*! @hivestreaming/m3u8 */ "../../../node_modules/@hivestreaming/m3u8/index.js");
var DashParser_1 = __webpack_require__(/*! @hivestreaming/dashjs/build/es5/src/dash/parser/DashParser */ "../../../node_modules/@hivestreaming/dashjs/build/es5/src/dash/parser/DashParser.js");
var basicutils_hive_1 = __webpack_require__(/*! ../basicutils.hive */ "../../../core/build/core/src/common/basicutils.hive.js");
var Utils_1 = __webpack_require__(/*! ../../core/Utils */ "../../../core/build/core/src/core/Utils.js");
var logger_hive_1 = __webpack_require__(/*! ../logger.hive */ "../../../core/build/core/src/common/logger.hive.js");
var ErrorCodes = __webpack_require__(/*! ../error.hive */ "../../../core/build/core/src/common/error.hive.js");
var getErrorMessage = function (e) {
    if (e instanceof Error) {
        return e.message;
    }
    else {
        try {
            return JSON.stringify(e);
        }
        catch (_a) {
            return e.toString();
        }
    }
};
var StreamLiveChecker = /** @class */ (function () {
    function StreamLiveChecker() {
    }
    StreamLiveChecker.isLive = function (playerTech, manifestUrl) {
        playerTech = playerTech.toLowerCase();
        switch (playerTech) {
            case 'azurehtml5js':
                return this.isLiveDASH(manifestUrl);
            case 'html5': /** Intentional fallthrough */
            case 'html5fairplayhls':
                return this.isLiveHLS(manifestUrl);
        }
        /** Assume assets are Live */
        logger_hive_1.ErrorMonitor.getInstance().logError('Could not find valid playerTech for StreamLiveChecker', this.loggerId, ErrorCodes.GENERIC_ERROR, { playerTech: playerTech });
        return Promise.resolve(true);
    };
    StreamLiveChecker.isLiveHLS = function (manifestUrl) {
        return __awaiter(this, void 0, void 0, function () {
            var parse, content, manifest, uri, absolutePlaylistUrl, content_1, chunklist, e_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 5, , 6]);
                        parse = function (content) { var parser = new m3u8_1.Parser(); parser.push(content); return parser.manifest; };
                        return [4 /*yield*/, basicutils_hive_1.ajaxGetPromise(manifestUrl)];
                    case 1:
                        content = _a.sent();
                        manifest = parse(content);
                        if (!manifest.endList) return [3 /*break*/, 2];
                        return [2 /*return*/, false];
                    case 2:
                        if (!(manifest.playlists && manifest.playlists.length)) return [3 /*break*/, 4];
                        uri = manifest.playlists[0].uri;
                        absolutePlaylistUrl = Utils_1.resolveUrl(manifestUrl, uri);
                        return [4 /*yield*/, basicutils_hive_1.ajaxGetPromise(absolutePlaylistUrl)];
                    case 3:
                        content_1 = _a.sent();
                        chunklist = parse(content_1);
                        if (chunklist.endList) {
                            return [2 /*return*/, false];
                        }
                        _a.label = 4;
                    case 4: return [3 /*break*/, 6];
                    case 5:
                        e_1 = _a.sent();
                        logger_hive_1.ErrorMonitor.getInstance().logError('Error determing live status in HLS for StreamLiveChecker', this.loggerId, ErrorCodes.GENERIC_ERROR, { error: getErrorMessage(e_1) });
                        return [3 /*break*/, 6];
                    case 6: return [2 /*return*/, true];
                }
            });
        });
    };
    StreamLiveChecker.isLiveDASH = function (manifestUrl) {
        return __awaiter(this, void 0, void 0, function () {
            var parser, content, manifest, isLive, e_2;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        parser = DashParser_1.default().create();
                        return [4 /*yield*/, basicutils_hive_1.ajaxGetPromise(manifestUrl)];
                    case 1:
                        content = _a.sent();
                        manifest = parser.parse(content);
                        isLive = manifest.type === 'static' ? false : true;
                        return [2 /*return*/, isLive];
                    case 2:
                        e_2 = _a.sent();
                        logger_hive_1.ErrorMonitor.getInstance().logError('Error determing live status in DASH for StreamLiveChecker', this.loggerId, ErrorCodes.GENERIC_ERROR, { error: getErrorMessage(e_2) });
                        return [3 /*break*/, 3];
                    case 3: return [2 /*return*/, true];
                }
            });
        });
    };
    StreamLiveChecker.loggerId = '[StreamLiveChecker] ';
    return StreamLiveChecker;
}());
exports.StreamLiveChecker = StreamLiveChecker;
//# sourceMappingURL=StreamLiveChecker.js.map

/***/ }),

/***/ "../../../core/build/core/src/common/utils/TimeDuration.js":
/*!**********************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/common/utils/TimeDuration.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.TimeDuration = void 0;
var logger_hive_1 = __webpack_require__(/*! ../logger.hive */ "../../../core/build/core/src/common/logger.hive.js");
var TimeDuration = /** @class */ (function () {
    /**
     * Create a representation of a time duration independent from the time scale passed
     * @param duration time in time scale units
     * @param timescale unit of duration, duration/timescale must return the number of seconds of the duration
     * hence the timescale unit of measure is 1/s
     */
    function TimeDuration(duration, timescale) {
        this.timescale = timescale;
        this.duration = duration;
        if ((this.duration / this.timescale <= TimeDuration.TIMESCALE_LOWER_BOUND_SECS) || (this.duration / this.timescale >= TimeDuration.TIMESCALE_UPPER_BOUND_SECS)) {
            logger_hive_1.ErrorMonitor.getInstance().logError("Segment time duration value outside interval duration: " + this.duration + ", timescale " + this.timescale + ", value in seconds " + this.duration / this.timescale + ", interval in seconds [" + TimeDuration.TIMESCALE_LOWER_BOUND_SECS + "," + TimeDuration.TIMESCALE_UPPER_BOUND_SECS + "]");
        }
    }
    TimeDuration.prototype.ms = function () {
        return Math.round(this.secs() * 1000);
    };
    TimeDuration.prototype.secs = function () {
        return this.duration / this.timescale;
    };
    TimeDuration.prototype.value = function () {
        return this.duration;
    };
    TimeDuration.TIMESCALE_MILLISECONDS = 1000;
    TimeDuration.TIMESCALE_SECONDS = 1;
    TimeDuration.TIMESCALE_LOWER_BOUND_SECS = .5; // 0.5 seconds
    TimeDuration.TIMESCALE_UPPER_BOUND_SECS = 100; // 100 seconds
    return TimeDuration;
}());
exports.TimeDuration = TimeDuration;
//# sourceMappingURL=TimeDuration.js.map

/***/ }),

/***/ "../../../core/build/core/src/common/utils/TimeoutResolver.js":
/*!*************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/common/utils/TimeoutResolver.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.TimeoutResolver = void 0;
/**
* Returns the timeout for the /version.json request based on the OS. If the user is on Mac and macReadyCheckTimeout
* is != -1 then we will return macReadyCheckTimeout otherwise we use readyCheckTimeout for Windows and Mac
*/
var TimeoutResolver = /** @class */ (function () {
    function TimeoutResolver() {
    }
    TimeoutResolver.prototype.getTimeout = function (readyCheckTimeout, macReadyCheckTimeout, logger) {
        if (isNaN(readyCheckTimeout)) {
            logger.debug("readyCheckTimeout is " + readyCheckTimeout + ". Setting it to 0");
            readyCheckTimeout = 0;
        }
        else
            readyCheckTimeout = Number(readyCheckTimeout);
        if (isNaN(macReadyCheckTimeout)) {
            logger.debug("macReadyCheckTimeout is " + macReadyCheckTimeout + ". Setting it to 0");
            macReadyCheckTimeout = 0;
        }
        else
            macReadyCheckTimeout = Number(macReadyCheckTimeout);
        if (window.navigator.platform.match(/Mac/gi) && macReadyCheckTimeout > -1)
            return macReadyCheckTimeout;
        else
            return readyCheckTimeout;
    };
    return TimeoutResolver;
}());
exports.TimeoutResolver = TimeoutResolver;
//# sourceMappingURL=TimeoutResolver.js.map

/***/ }),

/***/ "../../../core/build/core/src/common/utils/VisibilityChangeListener.js":
/*!**********************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/common/utils/VisibilityChangeListener.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.VisibilityChangeListener = void 0;
/**
 * VisibilityChange class manager detects when the page is in background (behind another tab)
 * or minimized. It does not detect is the browser is not on focus.
 * On Chrome < 57 and Firefox < 52 the video rendering might slow down (pause and buffering) when the tab is in background
 * so we want to track when this happens to distinguish these buffering event from the network ones.
 *
 */
var VisibilityChangeListener = /** @class */ (function () {
    function VisibilityChangeListener() {
        if (VisibilityChangeListener.instance) {
            throw new Error('Error: Instantiation failed: Use VisibilityChangeListener.getInstance() instead of new.');
        }
        // Set the name of the hidden property and the change event for visibility
        if (typeof document.hidden !== 'undefined') { // Opera 12.10 and Firefox 18 and later support
            this.hidden = 'hidden';
            this.visibilityChange = 'visibilitychange';
        }
        else if (typeof document['msHidden'] !== 'undefined') {
            this.hidden = 'msHidden';
            this.visibilityChange = 'msvisibilitychange';
        }
        else if (typeof document['webkitHidden'] !== 'undefined') {
            this.hidden = 'webkitHidden';
            this.visibilityChange = 'webkitvisibilitychange';
        }
        // Check if the browser supports addEventListener or the Page Visibility API
        if (!(typeof document.addEventListener === 'undefined' || typeof document[this.hidden] === 'undefined')) {
            // Handle page visibility change
            document.addEventListener(this.visibilityChange, this.callListeners.bind(this), false);
        }
        else {
            if (VisibilityChangeListener.logger)
                VisibilityChangeListener.logger.debug('warn - visibilityChange listener not supported');
        }
        this.listeners = [];
    }
    /**
     * return a singleton visibility change listener
     * NOTE: this operation might raise an exception so always getInstance in a try catch!
     * @returns {VisibilityChangeListener}
     */
    VisibilityChangeListener.getInstance = function (logger) {
        if (logger)
            this.logger = logger;
        if (this.instance === undefined)
            this.instance = new VisibilityChangeListener();
        return this.instance;
    };
    VisibilityChangeListener.prototype.callListeners = function () {
        var _this = this;
        var visible = !document[this.hidden];
        this.listeners.forEach(function (listener) {
            listener.call(_this, visible);
        });
    };
    /**
     * Add a visibilityChange listener.
     * Is possible to add more than one.
     * @param listener: (isVisible) => any
     */
    VisibilityChangeListener.prototype.setVisibilityChangeListener = function (listener) {
        this.listeners.push(listener);
    };
    VisibilityChangeListener.prototype.cleanListeners = function () {
        document.removeEventListener(this.visibilityChange, this.callListeners, false);
        this.listeners.length = 0;
    };
    return VisibilityChangeListener;
}());
exports.VisibilityChangeListener = VisibilityChangeListener;
//# sourceMappingURL=VisibilityChangeListener.js.map

/***/ }),

/***/ "../../../core/build/core/src/core/Bindings.js":
/*!**********************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/core/Bindings.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Definitions = void 0;
var Definitions = /** @class */ (function () {
    function Definitions() {
    }
    Definitions.CACHE = 'CACHE';
    Definitions.CENTRAL_FRAGMENT = 'CENTRAL_FRAGMENT';
    Definitions.CONNECTIVITY_INFO_PROVIDER = 'CONNECTIVITY_INFO_PROVIDER';
    Definitions.CONTEXT_RESOLVER = 'CONTEXT_RESOLVER';
    Definitions.DCACHE = 'DCACHE';
    Definitions.FALLBACK_REQUESTER = 'FALLBACK_REQUESTER';
    Definitions.FRAGMENT_METADATA_METRICS_PROVIDER = 'FRAGMENT_METADATA_METRICS_PROVIDER';
    Definitions.FRAGMENT_DOWNLOAD_METRICS_PROVIDER = 'FRAGMENT_DOWNLOAD_METRICS_PROVIDER';
    Definitions.HTTP_MANAGER = 'HTTP_MANAGER';
    Definitions.HTTP_REQUEST = 'HTTP_REQUEST';
    Definitions.IDENTITY_PROVIDER = 'IDENTITY_PROVIDER';
    Definitions.IN_PARTNERSHIP = 'IN_PARTNERSHIP';
    Definitions.IN_PREFETCHER_PARTNERSHIP = 'IN_PREFETCHER_PARTNERSHIP';
    Definitions.IP_SPOOFING = 'IP_SPOOFING';
    Definitions.LIVE_CACHE = 'LIVE_CACHE';
    Definitions.LOCALITY_CLIENT = 'LOCALITY_CLIENT';
    Definitions.LOCALITY_SCORE = 'LOCALITY_SCORE';
    Definitions.LOGGER = 'LOGGER';
    Definitions.MEMBERSHIP = 'MEMBERSHIP';
    Definitions.NETWORK = 'NETWORK';
    Definitions.PEER_NODE_INFO = 'PEER_NODE_INFO';
    Definitions.OBJECT_INDEX = 'OBJECT_INDEX';
    Definitions.OUT_PARTNERSHIP = 'OUT_PARTNERSHIP';
    Definitions.OUT_PREFETCHER_PARTNERSHIP = 'OUT_PREFETCHER_PARTNERSHIP';
    Definitions.P2P_REQUESTER = 'P2P_REQUESTER';
    Definitions.P2P_VIDEO_PREFETCHER = 'P2P_VIDEO_PREFETCHER';
    Definitions.PARTNERSHIP = 'PARTNERSHIP';
    Definitions.PEER = 'PEER';
    Definitions.PEER_CONNECTIVITY_INFO = 'PEER_CONNECTIVITY_INFO';
    Definitions.PICKER = 'PICKER';
    Definitions.PREFETCH_MANAGER = 'PREFETCH_MANAGER';
    Definitions.REPORTING = 'REPORTING';
    Definitions.REQUEST_TRACKER = 'REQUEST_TRACKER';
    Definitions.RESPONDER = 'RESPONDER';
    Definitions.RTC_MANAGER = 'RTC_MANAGER';
    Definitions.SCORE_UPDATER = 'SCORE_UPDATER';
    Definitions.SERVER_MANAGER = 'SERVER_MANAGER';
    Definitions.SERVICES_CLIENT = 'SERVICES_CLIENT';
    Definitions.SNAP_STATS_MANAGER = 'SNAP_STATS_MANAGER';
    Definitions.STATS_CLIENT = 'STATS_CLIENT';
    Definitions.STATS_NODE_INFO = 'STATS_NODE_INFO';
    Definitions.STATS_STORE = 'STATS_STORE';
    Definitions.STREAM_INFO_METRICS_PROVIDER = 'STREAM_INFO_METRICS_PROVIDER';
    Definitions.TICKET_RESOLVER = 'TICKET_RESOLVER';
    Definitions.TIMER = 'TIMER';
    Definitions.TRACKER_CLIENT = 'TRACKER_CLIENT';
    Definitions.TRACKER_MANAGER = 'TRACKER_MANAGER';
    Definitions.TRACK_CLIENT = 'TRACK_CLIENT';
    Definitions.TRACK_MANAGER = 'TRACK_MANAGER';
    Definitions.TRANSPORT = 'TRANSPORT';
    Definitions.VOD_CACHE = 'VOD_CACHE';
    Definitions.QUALITY_LEVEL_TRACKER = 'QUALITY_LEVEL_TRACKER';
    Definitions.QUALITY_LEVEL_METRICS_PROVIDER = 'QUALITY_LEVEL_METRICS_PROVIDER';
    Definitions.REMOTE_CONFIG_MANAGER = 'REMOTE_CONFIG_MANAGER';
    Definitions.CONFIG_STORE = 'CONFIG_STORE';
    Definitions.BOOSTER_CLIENT = 'BOOSTER_CLIENT';
    Definitions.EXTERNAL_CANDIDATES = 'EXTERNAL_CANDIDATES';
    return Definitions;
}());
exports.Definitions = Definitions;
//# sourceMappingURL=Bindings.js.map

/***/ }),

/***/ "../../../core/build/core/src/core/BrowserLogger.js":
/*!***************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/core/BrowserLogger.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.BrowserLogger = exports.HiveLoggerLevel = void 0;
var HiveConfig_1 = __webpack_require__(/*! ./HiveConfig */ "../../../core/build/core/src/core/HiveConfig.js");
var HashMap = __webpack_require__(/*! @hivestreaming/collections/map */ "../../../node_modules/@hivestreaming/collections/map.js");
/**
 * the Browser logger used for real time app in browser uses directly console as logging facility
 */
var HiveLoggerLevel;
(function (HiveLoggerLevel) {
    HiveLoggerLevel[HiveLoggerLevel["off"] = 0] = "off";
    HiveLoggerLevel[HiveLoggerLevel["error"] = 1] = "error";
    HiveLoggerLevel[HiveLoggerLevel["warn"] = 2] = "warn";
    HiveLoggerLevel[HiveLoggerLevel["notice"] = 3] = "notice";
    HiveLoggerLevel[HiveLoggerLevel["info"] = 4] = "info";
    HiveLoggerLevel[HiveLoggerLevel["debug"] = 5] = "debug";
    HiveLoggerLevel[HiveLoggerLevel["trace"] = 6] = "trace";
})(HiveLoggerLevel = exports.HiveLoggerLevel || (exports.HiveLoggerLevel = {}));
var BrowserLogger = /** @class */ (function () {
    function BrowserLogger() {
        this.timestamp = function () {
        };
        this.bindingsMap = new HashMap();
        this.level = HiveLoggerLevel.debug;
        this.timestamp.toString = function () {
            var m = new Date();
            var dateString = ('0' + m.getUTCHours()).slice(-2) + ':' +
                ('0' + m.getUTCMinutes()).slice(-2) + ':' +
                ('0' + m.getUTCSeconds()).slice(-2) + ':' +
                ('00' + m.getUTCMilliseconds()).slice(-3);
            return '[' + dateString + ']';
        };
        // construct a logger object based on console if it's defined
        // otherwise it with simply a empty log function
        this.logger = ((typeof console === 'undefined') ? {
            log: function () {
            }
        } : console);
        // some browser only define console.log therefore we manually point
        // the missing ones to log
        if (!this.logger['trace'])
            this.logger.trace = this.logger.log;
        if (!this.logger['debug'])
            this.logger.debug = this.logger.log;
        if (!this.logger['info'])
            this.logger.info = this.logger.log;
        if (!this.logger['warn'])
            this.logger.warn = this.logger.log;
        if (!this.logger['error'])
            this.logger.error = this.logger.log;
        this.setLevel(HiveLoggerLevel[this.level]);
    }
    /**
     * setLevel will first check if the global HiveConfig.Framework.HiveDebugLevel
     * is set. This value will have priority over any other level.
     * Otherwise it will try to apply the level passed as argument.
     * @param level
     * @type string
     */
    BrowserLogger.prototype.setLevel = function (level, session) {
        if (HiveConfig_1.HiveConfig.Framework.HiveDebugLevel && HiveLoggerLevel[HiveConfig_1.HiveConfig.Framework.HiveDebugLevel] != undefined) {
            this.level = HiveLoggerLevel[HiveConfig_1.HiveConfig.Framework.HiveDebugLevel];
        }
        else {
            if (HiveLoggerLevel[level] != undefined) {
                this.level = HiveLoggerLevel[level];
            }
            else
                console.log('Wrong logging level: ' + level, HiveLoggerLevel);
        }
        this.applyLevel(session);
    };
    /**
     * generate a console wrapper binding all our logging calls
     * to the matching console ones, or empty ones, depending on the level.
     */
    BrowserLogger.prototype.applyLevel = function (session) {
        var newBindings = {
            log: this.bindFunction(this.logger.log, HiveLoggerLevel.error, session),
            error: this.bindFunction(this.logger.error, HiveLoggerLevel.error, session),
            warn: this.bindFunction(this.logger.warn, HiveLoggerLevel.warn, session),
            notice: this.bindFunction(this.logger.info, HiveLoggerLevel.notice, session),
            info: this.bindFunction(this.logger.info, HiveLoggerLevel.info, session),
            debug: this.bindFunction(this.logger.debug, HiveLoggerLevel.debug, session),
            trace: this.bindFunction(this.logger.trace, HiveLoggerLevel.trace, session)
        };
        if (session)
            this.bindingsMap.set(session, newBindings);
        else
            this.bindings = newBindings;
    };
    /**
     * return a function binded to console if the level is enabled
     * otherwise return empty function (no logging)
     */
    BrowserLogger.prototype.bindFunction = function (toBind, bindLevel, session) {
        if (this.level >= bindLevel) {
            try {
                if (HiveConfig_1.HiveConfig.Framework.LoggerTimestamp) {
                    if (session) {
                        // use string concatenation for session so preload can pick it up before applying the function
                        return Function.prototype.bind.call(toBind, console, 'S[' + session + '] %s', this.timestamp);
                    }
                    else {
                        return Function.prototype.bind.call(toBind, console, '%s', this.timestamp);
                    }
                }
                else {
                    if (session) {
                        return Function.prototype.bind.call(toBind, console, 'S[' + session + ']');
                    }
                    else {
                        return Function.prototype.bind.call(toBind, console);
                    }
                }
            }
            catch (e) {
            }
        }
        else
            return function () {
            };
    };
    /**
     * returns the console wrapper
     */
    BrowserLogger.prototype.log = function (session) {
        if (session) {
            if (!this.bindingsMap.has(session))
                this.setLevel(HiveLoggerLevel[this.level], session);
            return this.bindingsMap.get(session);
        }
        return this.bindings;
    };
    BrowserLogger.prototype.bindBooster = function (url, authorization) {
        return;
    };
    BrowserLogger.prototype.flush = function () {
        return;
    };
    return BrowserLogger;
}());
exports.BrowserLogger = BrowserLogger;
//# sourceMappingURL=BrowserLogger.js.map

/***/ }),

/***/ "../../../core/build/core/src/core/Constants.js":
/*!***********************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/core/Constants.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Constants = void 0;
var build_defaults_1 = __webpack_require__(/*! ../common/build.defaults */ "../../../core/build/core/src/common/build.defaults.js");
var Constants = /** @class */ (function () {
    function Constants() {
    }
    Constants.NETWORK_DISCOVERY_SERVICE = 'ws://127.0.0.1:8000/hive';
    Constants.PROD_SERVICE_ENDPOINT = 'wss://bee.hivestreaming.com:443/v1/hivejs';
    Constants.LOCAL_SERVICE_ENDPOINT = 'ws://127.0.0.1:8001/v1/hivejs';
    Constants.TEST_SERVICE_ENDPOINT = 'wss://bee-test.hivestreaming.com:443/v1/hivejs';
    Constants.DEV_SERVICE_ENDPOINT = 'wss://bee-dev.hivestreaming.com:443/v1/hivejs';
    Constants.LABS_TEST_SERVICE_ENDPOINT = 'wss://labs-hivejs.test.hivestreaming.net:443/v1/hivejs';
    Constants.LABS_PROD_SERVICE_ENDPOINT = 'wss://labs-hivejs.prod.hivestreaming.net:443/v1/hivejs';
    Constants.TEST_STREAM_AUTH_SERVICE_ENDPOINT = 'https://api-test.hivestreaming.com/v1/auth/stream';
    Constants.PROD_STREAM_AUTH_SERVICE_ENDPOINT = 'https://api.hivestreaming.com/v1/auth/stream';
    Constants.DEV_JWT_AUTH_SERVICE_ENDPOINT = 'https://api-dev.hivestreaming.com/v1/auth/jwt';
    Constants.TEST_JWT_AUTH_SERVICE_ENDPOINT = 'https://api-test.hivestreaming.com/v1/auth/jwt';
    Constants.PROD_JWT_AUTH_SERVICE_ENDPOINT = 'https://api.hivestreaming.com/v1/auth/jwt';
    Constants.ICE_SERVERS = {
        'iceServers': [
            { url: 'stun:stun.hivestreaming.com:3478' }
        ]
    };
    Constants.STATS_INTERVAL = 30000;
    Constants.TRACK_INTERVAL = 60000 * 5;
    Constants.FIRST_TRACK_INTERVAL = 80000;
    Constants.FLUSH_TRACK_INTERVAL = 1000;
    Constants.RETRIEVE_NETWORK_INFO_INTERVAL = 120000;
    Constants.MAX_RECONNECT_TIMEOUT = 30000;
    Constants.MAX_PENDING_MESSAGES = 100;
    Constants.MAX_TIME_IN_SEND_QUEUE = 10000;
    Constants.SEND_PRIVATE_IP_CUSTOM_SNAPSHOT = false;
    Constants.USE_PERSISTENT_IDENTITY = build_defaults_1.BuildParameters.USE_PERSISTENT_IDENTITY;
    Constants.USE_STORE_IP_DB = build_defaults_1.BuildParameters.USE_STORE_IP_DB;
    // the minimum time between re-connects (milliseconds)
    Constants.MIN_CONNECT_INTERVAL = 250;
    /**
     * internal timeout for fetching only candidates from WebRTC.
     */
    Constants.TIMEOUT_CANDIDATES_GATHERING = 2000;
    /**
     * timeout for retrieving the whole connectivity info, including
     * candidates, booster, external candidates and remote-config site matching.
     */
    Constants.TIMEOUT_RETRIEVING_CONNECTIVITY_INFO = 4000;
    Constants.TIMEOUT_EXTERNAL_CANDIDATES_GATHERING = 1500;
    Constants.TIMEOUT_ESTABLISH_CANDIDATES_CONNECTION_EXTERNAL = 2000;
    return Constants;
}());
exports.Constants = Constants;
//# sourceMappingURL=Constants.js.map

/***/ }),

/***/ "../../../core/build/core/src/core/Context.js":
/*!*********************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/core/Context.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Context = void 0;
var inversify = __webpack_require__(/*! inversify */ "../../../node_modules/inversify/dist/inversify.js");
var Context = /** @class */ (function () {
    function Context(id) {
        this.id = id;
        this.context = new inversify.Kernel();
    }
    Context.prototype.apply = function (bindings) {
        bindings.apply(this.context);
    };
    return Context;
}());
exports.Context = Context;
//# sourceMappingURL=Context.js.map

/***/ }),

/***/ "../../../core/build/core/src/core/Framework.js":
/*!***********************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/core/Framework.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.Framework = void 0;
var inversify = __webpack_require__(/*! inversify */ "../../../node_modules/inversify/dist/inversify.js");
var HashMap = __webpack_require__(/*! @hivestreaming/collections/map */ "../../../node_modules/@hivestreaming/collections/map.js");
var Bindings_1 = __webpack_require__(/*! ./Bindings */ "../../../core/build/core/src/core/Bindings.js");
var Context_1 = __webpack_require__(/*! ./Context */ "../../../core/build/core/src/core/Context.js");
var Deferred_1 = __webpack_require__(/*! ./scheduler/Deferred */ "../../../core/build/core/src/core/scheduler/Deferred.js");
var Log = /** @class */ (function () {
    function Log() {
    }
    Log.getId = function () {
        return '[' + Framework.time() + '] [' + Framework.getPeerContext().id + ']';
    };
    return Log;
}());
var Framework = /** @class */ (function () {
    function Framework() {
    }
    /**
     * first function to call when initializing the Framework
     * @param bindings
     */
    Framework.startup = function (bindings) {
        this.startTime = new Date();
        bindings.apply(this.kernel);
        this.timerScheduler = this.kernel.resolve(Bindings_1.Definitions.TIMER);
        this.logger_ = this.kernel.resolve(Bindings_1.Definitions.LOGGER);
        this.simulated = this.timerScheduler.isSimulated();
        this.isPurging = false;
        this.timerScheduler.init();
    };
    /**
     * method that group the calls needed to fully initialize the Framework.
     * It also counts the number of plugin instances that tries to initialize the Framework so
     * when calling the {@link Framework.purge} method, we can decide if actually destroy the Framework
     * (because no other instance uses it)or not
     *
     * @param {string} id
     * @param {Bindings} bindigns
     * @param {Bindings} peerContextBindings
     *
     */
    Framework.startFramework = function (id, bindings, peerContextBindings) {
        if (this.pluginCounter < 1) {
            this.startup(bindings);
            this.initPeerContext(id, peerContextBindings);
            this.switchContext(id);
        }
        this.pluginCounter += 1;
    };
    /**
     * start the internal network manager
     */
    Framework.startNet = function () {
        this.network = this.kernel.resolve(Bindings_1.Definitions.NETWORK);
        this.network.init();
    };
    /**
     * @returns the network manager
     */
    Framework.net = function () {
        return this.network;
    };
    /**
     * @returns reference to the simulation context
     */
    Framework.system = function () {
        return this.kernel;
    };
    /**
     * @returns the simulation context logger
     */
    Framework.logger = function () {
        return this.logger_;
    };
    /**
     * @returns the simulation timer scheduler
     */
    Framework.timer = function () {
        return this.timerScheduler;
    };
    /**
     * @param contextId the identifier of the node
     * @returns the context of the specified node
     */
    Framework.getKernelWC = function (contextId) {
        return this.contexts.get(contextId);
    };
    /**
     * initialize a new peer isolated context with the specified identifier and bindings
     */
    Framework.initPeerContext = function (id, bindings) {
        var context = new Context_1.Context(id);
        context.apply(bindings);
        this.contexts.set(id, context);
        return context;
    };
    /**
     * switch the current execution context into that of a specific peer
     */
    Framework.switchContext = function (contextId) {
        this.currentContext = this.getKernelWC(contextId);
    };
    /**
     * Instantiates a component with the specific tag into the current context
     * The component implementation is defined in the context bindings
     */
    Framework.resolve = function (tag) {
        if (this.currentContext != null) {
            return this.currentContext.context.resolve(tag);
        }
        else
            console.warn('undefined context');
        return null;
    };
    /**
     * return the active peer context
     */
    Framework.getPeerContext = function () {
        return this.currentContext;
    };
    /**
     * equivalent to Date.now(), returns the elapsed millisecond from the beginning of time,
     * which is epoch in real time, or the beginning of a simulation
     * @returns elapsed time in milliseconds
     */
    Framework.time = function () {
        if (this.timerScheduler)
            return this.timerScheduler.time();
        else {
            throw new Error('Framework.time called on purged Framework');
        }
    };
    Framework.setTimeout = function (callback, delay, persistClearAll) {
        if (persistClearAll === void 0) { persistClearAll = false; }
        if (!this.timerScheduler || this.isPurging)
            throw new Error('Framework.setTimeout called on purging / purged Framework');
        return this.timerScheduler.setTimeout(callback, delay, persistClearAll);
    };
    Framework.clearTimeout = function (task) {
        return this.timerScheduler.clearTimeout(task);
    };
    Framework.setInterval = function (callback, delay) {
        if (!this.timerScheduler || this.isPurging)
            throw new Error('Framework.setInterval called on purging / purged Framework');
        return this.timerScheduler.setInterval(callback, delay);
    };
    Framework.clearInterval = function (task) {
        return this.timerScheduler.clearInterval(task);
    };
    /**
     * starts the simulation loop
     */
    Framework.proceed = function () {
        return this.timerScheduler.proceed();
    };
    /**
     * removes the scheduled events and clears all the simulation and peer contexts
     */
    Framework.purge = function (force) {
        if (force === void 0) { force = false; }
        if (force) {
            var done = this.doPurge(force);
            this.pluginCounter = 0;
            return done;
        }
        // keep count of the remaining Framework instances and purge if none are left
        if (this.pluginCounter > 0) {
            this.pluginCounter -= 1;
            if (this.pluginCounter === 0) {
                return this.doPurge();
            }
        }
        return new Deferred_1.Deferred().resolvedPromise();
    };
    /**
     * The parameter force was added for running the unit tests. In our implementations it assumes de default value 'false'.
     * @param force {boolean} - force the clearAll to stop all timeouts, even when 'persistClearAll' = true.
     */
    Framework.doPurge = function (force) {
        var _this = this;
        if (force === void 0) { force = false; }
        this.isPurging = true;
        var deferred = new Deferred_1.Deferred();
        if (this.timerScheduler) {
            this.timerScheduler.clearAll(force).then(function () {
                if (_this.isPurging) {
                    _this.reset();
                }
                deferred.resolve();
            });
        }
        else
            deferred.resolve();
        return deferred.promise;
    };
    Framework.reset = function () {
        this.kernel.unbindAll();
        this.kernel = new inversify.Kernel();
        this.contexts = new HashMap();
        this.currentContext = null;
        this.startTime = null;
        this.simulated = false;
        this.seed = null;
        this.timerScheduler = null;
        this.network = null;
        this.logger_ = null;
    };
    /**
     * init the random generator with a specific seed
     */
    Framework.initRandom = function (seedValue) {
        this.seed = seedValue;
    };
    /**
     * return a random float between 0 and 1
     */
    Framework.random = function () {
        /*
         * NOTE: on a long simulation, seed can become 0 and then force the
         * next random to re-initialize the seed, which breakes the determinism.
         * Lesson learned, always check for number variables to exist in the
         * right way (no '!seed')
         */
        if (this.seed == null)
            this.seed = new Date().getTime();
        this.seed = (this.seed * 9301 + 49297) % 233280;
        return this.seed / 233280;
    };
    /**
     * returns the startup time of the framework context
     */
    Framework.startedAt = function () {
        return this.startTime;
    };
    /**
     * @returns true if the framework in running in simulated mode
     */
    Framework.isSimulated = function () {
        return this.simulated;
    };
    Framework.Log = Log;
    Framework.Definitions = Bindings_1.Definitions;
    Framework.pluginCounter = 0;
    // the framework keeps track of his own context, the peer contexts, and the current active one
    Framework.kernel = new inversify.Kernel();
    Framework.contexts = new HashMap();
    Framework.simulated = false;
    return Framework;
}());
exports.Framework = Framework;
// only add Framework to global in node (for simulation timed promises)
if (true) {
    global['Framework'] = Framework;
}
//# sourceMappingURL=Framework.js.map
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../node_modules/webpack/buildin/global.js */ "../../../node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "../../../core/build/core/src/core/HiveConfig.js":
/*!************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/core/HiveConfig.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.HiveConfig = void 0;
/**
 * Framework related configurable fields
 */
var Framework = /** @class */ (function () {
    function Framework() {
    }
    /**
     * enable the timestamp prepend to HiveLogger console logs
     * @type {boolean}
     */
    Framework.LoggerTimestamp = false;
    return Framework;
}());
/**
 * Debugging logs of big thrift objects.
 * By default these logs should be false in order not to create huge logs
 * on the client
 */
var DebugLogs = /** @class */ (function () {
    function DebugLogs() {
    }
    /**
     * Metric snapshots object (Stats.ts)
     * 0 => off
     * 1 => json
     * 2 => object
     * 3 => json + object
     * @type {number}
     */
    DebugLogs.MetricSnapshotLogs = 0;
    /**
     * Track snapshot object (Track.ts)
     * 0 => off
     * 1 => json
     * @type {number}
     */
    DebugLogs.TrackSnapshotLogs = 0;
    return DebugLogs;
}());
var HiveConfig = /** @class */ (function () {
    function HiveConfig() {
    }
    HiveConfig.Framework = Framework;
    HiveConfig.DebugLogs = DebugLogs;
    return HiveConfig;
}());
exports.HiveConfig = HiveConfig;
if (typeof window != 'undefined') {
    if (typeof window['HiveConfig'] === 'undefined')
        window['HiveConfig'] = {};
    window['HiveConfig']['Framework'] = HiveConfig.Framework;
    window['HiveConfig']['DebugLogs'] = HiveConfig.DebugLogs;
}
//# sourceMappingURL=HiveConfig.js.map

/***/ }),

/***/ "../../../core/build/core/src/core/HiveServices.js":
/*!**************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/core/HiveServices.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.logger = exports.Message = exports.loggerId = void 0;
var logger_hive_1 = __webpack_require__(/*! ../common/logger.hive */ "../../../core/build/core/src/common/logger.hive.js");
var ErrorCodes = __webpack_require__(/*! ../common/error.hive */ "../../../core/build/core/src/common/error.hive.js");
var logger_;
exports.loggerId = '[HiveServices] ';
var Message = /** @class */ (function () {
    function Message(service, msgId, msg) {
        this.msgId = msgId;
        this.service = service;
        this.msg = msg;
    }
    Message.prototype.serialize = function () {
        try {
            var serviceIdArray = new Uint8Array([this.service >> 8, this.service & 0xFF]);
            var msgIdArray = new Uint8Array([this.msgId]);
            var msgArray = [serviceIdArray, msgIdArray, this.msg];
            return new Blob(msgArray, { type: 'application/octet-binary' });
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error serializing message to send to the services', Message.loggerId, ErrorCodes.HIVE_SERVICES_CODES.SERIALIZE_MESSAGE, error);
            throw new Error(error);
        }
    };
    Message.extract = function (data) {
        try {
            var allStr = String.fromCharCode.apply(null, new Uint8Array(data));
            var byteStr = String.fromCharCode.apply(null, new Uint8Array(data.slice(3)));
            var srv = new Uint8Array(data.slice(0, 2)); // first two bytes is the service
            var msgId = new Uint8Array(data.slice(2, 3)); // third byte is the message id
            var srvId = (srv[0] << 8) + srv[1];
            return new Message(srvId, msgId[0], byteStr);
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error extracting message from the services', this.loggerId, ErrorCodes.HIVE_SERVICES_CODES.EXTRACT_MESSAGE, error);
            throw new Error(error);
        }
    };
    Message.loggerId = '[Message] ';
    return Message;
}());
exports.Message = Message;
/**
 * initialize a singleton logger instance trying to reuse a shared HiveLoggerInstance
 * initialized by HiveStats Framework, otherwise creating a new one based on console, if available
 */
function logger() {
    // if it was previously defined, return the logger
    if (logger_)
        return logger_;
    // if the global HiveLoggerInstance has been defined
    // by Hive stats, bind this logger to the same instance
    var HiveLoggerInstance = window && window['window'] ? window['window']['HiveLoggerInstance'] : undefined;
    if (typeof HiveLoggerInstance != 'undefined' && HiveLoggerInstance.log && HiveLoggerInstance.debug &&
        HiveLoggerInstance.info && HiveLoggerInstance.warn && HiveLoggerInstance.error)
        logger_ = HiveLoggerInstance;
    // otherwise create our own logger binding console if possible
    // but we won't be able to set the correct logging level
    if (!logger_) {
        // check if console is defined
        var isConsole = !(typeof window.console === 'undefined');
        // bind a generic log function
        var log = (!isConsole) ? function () {
        } : console.log.bind(console);
        // try to bind every level to the correct console one, otherwise fallback to 'log'
        logger_ = {
            log: log,
            debug: (isConsole && window.console['debug']) ? window.console.debug.bind(console) : log,
            info: (isConsole && window.console['info']) ? window.console.info.bind(console) : log,
            warn: (isConsole && window.console['warn']) ? window.console.warn.bind(console) : log,
            error: (isConsole && window.console['error']) ? window.console.error.bind(console) : log
        };
    }
    return logger_;
}
exports.logger = logger;
//# sourceMappingURL=HiveServices.js.map

/***/ }),

/***/ "../../../core/build/core/src/core/Logger.js":
/*!********************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/core/Logger.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Logger = void 0;
var BoosterLogger_1 = __webpack_require__(/*! ../webrtc/booster/BoosterLogger */ "../../../core/build/core/src/webrtc/booster/BoosterLogger.js");
var BrowserLogger_1 = __webpack_require__(/*! ./BrowserLogger */ "../../../core/build/core/src/core/BrowserLogger.js");
var Logger = /** @class */ (function () {
    function Logger() {
        this.browserLogger = new BrowserLogger_1.BrowserLogger();
        this.browserLog = this.browserLogger.log();
        this.boosterLogger = new BoosterLogger_1.BoosterLogger();
    }
    Logger.prototype.log = function () {
        return this;
    };
    Logger.prototype.debug = function (message) {
        var optionalParams = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            optionalParams[_i - 1] = arguments[_i];
        }
        this.browserLog.debug(message, optionalParams);
        this.boosterLogger.addToBuffer('debug', [message, optionalParams]);
    };
    Logger.prototype.error = function (message) {
        var optionalParams = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            optionalParams[_i - 1] = arguments[_i];
        }
        this.browserLog.error(message, optionalParams);
        this.boosterLogger.addToBuffer('error', [message, optionalParams]);
    };
    Logger.prototype.info = function (message) {
        var optionalParams = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            optionalParams[_i - 1] = arguments[_i];
        }
        this.browserLog.info(message, optionalParams);
        this.boosterLogger.addToBuffer('info', [message, optionalParams]);
    };
    Logger.prototype.warn = function (message) {
        var optionalParams = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            optionalParams[_i - 1] = arguments[_i];
        }
        this.browserLog.warn(message, optionalParams);
        this.boosterLogger.addToBuffer('warn', [message, optionalParams]);
    };
    Logger.prototype.trace = function (message) {
        var optionalParams = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            optionalParams[_i - 1] = arguments[_i];
        }
        this.browserLog.trace(message, optionalParams);
        this.boosterLogger.addToBuffer('trace', [message, optionalParams]);
    };
    Logger.prototype.notice = function (message) {
        var optionalParams = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            optionalParams[_i - 1] = arguments[_i];
        }
        this.browserLog.notice(message, optionalParams);
        this.boosterLogger.addToBuffer('notice', [message, optionalParams]);
    };
    Logger.prototype.bindBooster = function (url, authorization) {
        this.boosterLogger.start(url.toString(), authorization);
    };
    Logger.prototype.setLevel = function (level, session) {
        this.browserLogger.setLevel(level, session);
        this.browserLog = this.browserLogger.log();
    };
    Logger.prototype.flush = function () {
        this.boosterLogger.flush();
    };
    return Logger;
}());
exports.Logger = Logger;
//# sourceMappingURL=Logger.js.map

/***/ }),

/***/ "../../../core/build/core/src/core/RealTimeBindings.js":
/*!******************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/core/RealTimeBindings.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.RealTimeBindings = void 0;
var inversify = __webpack_require__(/*! inversify */ "../../../node_modules/inversify/dist/inversify.js");
var Bindings_1 = __webpack_require__(/*! ./Bindings */ "../../../core/build/core/src/core/Bindings.js");
var RealTimeScheduler_1 = __webpack_require__(/*! ./scheduler/RealTimeScheduler */ "../../../core/build/core/src/core/scheduler/RealTimeScheduler.js");
var Logger_1 = __webpack_require__(/*! ./Logger */ "../../../core/build/core/src/core/Logger.js");
var RealTimeBindings = /** @class */ (function () {
    function RealTimeBindings() {
    }
    RealTimeBindings.prototype.apply = function (kernel) {
        kernel.bind(new inversify.TypeBinding(Bindings_1.Definitions.TIMER, RealTimeScheduler_1.RealTimeScheduler, inversify.TypeBindingScopeEnum.Singleton));
        kernel.bind(new inversify.TypeBinding(Bindings_1.Definitions.LOGGER, Logger_1.Logger, inversify.TypeBindingScopeEnum.Singleton));
    };
    return RealTimeBindings;
}());
exports.RealTimeBindings = RealTimeBindings;
//# sourceMappingURL=RealTimeBindings.js.map

/***/ }),

/***/ "../../../core/build/core/src/core/Tech.js":
/*!******************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/core/Tech.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.TechInfo = void 0;
var Framework_1 = __webpack_require__(/*! ../core/Framework */ "../../../core/build/core/src/core/Framework.js");
var build_defaults_1 = __webpack_require__(/*! ../common/build.defaults */ "../../../core/build/core/src/common/build.defaults.js");
var Tech = /** @class */ (function () {
    function Tech(name, tag) {
        this.version = build_defaults_1.BuildParameters.CORE_VERSION;
        this.name = name;
        this.tag = tag;
    }
    Tech.prototype.getInstance = function () {
        return Framework_1.Framework.resolve(this.tag);
    };
    Tech.prototype.getName = function () {
        return this.name;
    };
    Tech.prototype.getVersion = function () {
        return this.version;
    };
    Tech.prototype.getInfo = function () {
        return TechInfo.fromTech(this);
    };
    return Tech;
}());
exports.default = Tech;
var TechInfo = /** @class */ (function () {
    function TechInfo(name, version) {
        this.name = name;
        this.version = version;
    }
    TechInfo.fromTech = function (tech) {
        return new TechInfo(tech.getName(), tech.getVersion());
    };
    return TechInfo;
}());
exports.TechInfo = TechInfo;
//# sourceMappingURL=Tech.js.map

/***/ }),

/***/ "../../../core/build/core/src/core/Utils.js":
/*!*******************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/core/Utils.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __spreadArray = (this && this.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.stringToRTCIceCandidateInfo = exports.isMdnsAddress = exports.isIpAddress = exports.isSet = exports.TypedEventEmitter = exports.escapeRegex = exports.REGEX_CLEANER = exports.createEvent = exports.stringToArrayBuffer = exports.avg = exports.relToAbsUrl = exports.getUrlQueryParams = exports.removeQueryParams = exports.resolveUrl = exports.getEnumString = exports.getEnumValues = exports.getEnumNames = exports.sameArray = exports.shuffleArray = exports.getParameterByName = exports.arrayBufferToString = exports.removeArrayItem = exports.copyBuffer = exports.appendBuffer = exports.genFragmentId = exports.FragmentCounter = exports.Bandwidth = exports.ThriftSerializer = exports.StatsAccumulator = exports.StateDurationCounter = exports.Counter = void 0;
var URI = __webpack_require__(/*! urijs */ "../../../node_modules/urijs/src/URI.js");
var Thrift = __webpack_require__(/*! @hivestreaming/thrift */ "../../../node_modules/@hivestreaming/thrift/src/thrift.js");
var Framework_1 = __webpack_require__(/*! ./Framework */ "../../../core/build/core/src/core/Framework.js");
var events_1 = __webpack_require__(/*! events */ "../../../node_modules/events/events.js");
var models_1 = __webpack_require__(/*! ../webrtc/booster/models */ "../../../core/build/core/src/webrtc/booster/models/index.js");
var Counter = /** @class */ (function () {
    function Counter(positiveOnly) {
        if (positiveOnly === void 0) { positiveOnly = true; }
        this.count = 0;
        this.positiveOnly = positiveOnly;
    }
    Counter.prototype.increment = function () {
        this.count++;
        return this.count;
    };
    Counter.prototype.decrement = function () {
        this.count = this.positiveOnly ? Math.max(0, --this.count) : --this.count;
        return this.count;
    };
    Counter.prototype.get = function () {
        return this.count;
    };
    return Counter;
}());
exports.Counter = Counter;
/**
 * Class to keep track of time spent in a "started" state.
 */
var StateDurationCounter = /** @class */ (function () {
    /**
     * Construct a new `StateDurationCounter`.
     * @param timestamp If provided, the state will be "started" at this timestamp.
     */
    function StateDurationCounter(timestamp) {
        this.timestamps = [];
        this.hasRollover = false;
        if (typeof timestamp !== 'undefined') {
            this.start(timestamp);
        }
    }
    /**
     * Switch the state to "started"
     * @param timestamp Current timestamp
     */
    StateDurationCounter.prototype.start = function (timestamp) {
        if (timestamp === void 0) { timestamp = Framework_1.Framework.time(); }
        if (this.lastEntry)
            return;
        this.lastEntry = {
            start: timestamp,
            end: undefined
        };
        this.timestamps.push(this.lastEntry);
    };
    /**
     * Switch the state to "stopped"
     * @param timestamp Current timestamp
     */
    StateDurationCounter.prototype.stop = function (timestamp) {
        if (timestamp === void 0) { timestamp = Framework_1.Framework.time(); }
        if (!this.lastEntry)
            return;
        // Since `this.lastEntry` points by reference to `this.timestamps` last
        // value, we modify the object in place, afterwards clearing the
        // reference held in `lastEntry` to signify that "we are no longer in
        // 'started' state"
        this.lastEntry.end = timestamp;
        this.lastEntry = undefined;
        this.hasRollover = false;
    };
    /**
     * Returns the duration spent in the started state since the last call to
     * `getAndReset()`.
     * @param timestamp Timestamp of current time.
     * @param rolloverValue Used as a clock skew helper. If specified and the
     * state has always been "started" since the last `getAndReset()`, this
     * value will be returned if provided.
     */
    StateDurationCounter.prototype.getAndReset = function (timestamp, rolloverValue) {
        if (timestamp === void 0) { timestamp = Framework_1.Framework.time(); }
        var old = this.lastEntry;
        var rollover = this.hasRollover;
        if (old) {
            this.stop(timestamp);
        }
        var retVal = (rollover ? rolloverValue : 0) || this.timestamps.reduce(function (prev, _a) {
            var start = _a.start, end = _a.end;
            return prev + end - start;
        }, 0);
        this.timestamps.length = 0;
        if (old) {
            this.start(timestamp);
            this.hasRollover = true;
        }
        return retVal;
    };
    /**
     * Resets all interal data associated with this `StateDurationCounter`.
     */
    StateDurationCounter.prototype.reset = function () {
        this.hasRollover = false;
        this.lastEntry = undefined;
        this.timestamps.length = 0;
    };
    StateDurationCounter.prototype.isStarted = function () {
        return Boolean(this.lastEntry);
    };
    return StateDurationCounter;
}());
exports.StateDurationCounter = StateDurationCounter;
var StatsAccumulator = /** @class */ (function () {
    function StatsAccumulator() {
        this.reset();
    }
    /**
     * accumulates a positive number
     * @param statNumber
     */
    StatsAccumulator.prototype.add = function (statNumber) {
        if (statNumber <= 0)
            return;
        this._sum += statNumber;
        this._counter++;
        if (statNumber > this._max)
            this._max = statNumber;
        if (statNumber < this._min)
            this._min = statNumber;
    };
    StatsAccumulator.prototype.min = function (reset) {
        if (reset === void 0) { reset = true; }
        var min = this._min == Number.POSITIVE_INFINITY ? 0 : this._min;
        if (reset)
            this.reset();
        return min;
    };
    StatsAccumulator.prototype.max = function (reset) {
        if (reset === void 0) { reset = true; }
        var max = this._max == Number.NEGATIVE_INFINITY ? 0 : this._max;
        if (reset)
            this.reset();
        return max;
    };
    StatsAccumulator.prototype.sum = function (reset) {
        if (reset === void 0) { reset = true; }
        var sum = this._sum;
        if (reset)
            this.reset();
        return sum;
    };
    StatsAccumulator.prototype.avg = function (reset) {
        if (reset === void 0) { reset = true; }
        var average = this._counter > 0 ? this._sum / this._counter : 0;
        if (reset)
            this.reset();
        return average;
    };
    StatsAccumulator.prototype.reset = function () {
        this._min = Number.POSITIVE_INFINITY;
        this._max = Number.NEGATIVE_INFINITY;
        this._sum = 0;
        this._counter = 0;
    };
    return StatsAccumulator;
}());
exports.StatsAccumulator = StatsAccumulator;
var ThriftSerializer = /** @class */ (function () {
    function ThriftSerializer() {
        this.transport = new Thrift.TXHRTransport();
        this.protocol = new Thrift.TJSONProtocol(this.transport);
    }
    ThriftSerializer.prototype.serialize = function (messageObject, messageName, messageId) {
        this.protocol.writeMessageBegin(messageName, Thrift.MessageType.ONEWAY, messageId);
        messageObject.write(this.protocol);
        this.protocol.writeMessageEnd();
        var buffer = this.transport.getSendBuffer();
        // this.logger.debug("SEND BUFFER: ", buffer);
        // REMOVE thrift headers
        var pr = this.getPosition(buffer, ',', 4);
        var bufferToSend = buffer.slice(pr + 1, buffer.length - 1);
        // this.logger.debug("SEND BUFFER AFTER MANIPULATION: ", bufferToSend);
        return bufferToSend;
    };
    ThriftSerializer.prototype.deserialize = function (msg, messageName, messageId, thriftObject) {
        var augResp = '[' + messageId + ', "' + messageName + '", 4, 0,' + msg + ']';
        this.transport.setRecvBuffer(augResp);
        var ret = this.protocol.readMessageBegin();
        var resp = new thriftObject();
        resp.read(this.protocol);
        this.protocol.readMessageEnd();
        return resp;
    };
    ThriftSerializer.prototype.getPosition = function (str, delimiter, occurrence) {
        return str.split(delimiter, occurrence).join(delimiter).length;
    };
    return ThriftSerializer;
}());
exports.ThriftSerializer = ThriftSerializer;
var Bandwidth = /** @class */ (function () {
    function Bandwidth(elapsedMs, byteLength) {
        if (elapsedMs !== undefined && byteLength !== undefined) {
            this.bandwidth = Math.min(Bandwidth.MAX_CAP, (byteLength / elapsedMs * 8000));
        }
    }
    /**
     *
     * @returns {boolean} true if the object was initialized with a valid bandwidth value
     */
    Bandwidth.prototype.isValid = function () {
        return this.bandwidth !== undefined;
    };
    /**
     * initialized a bandwidth value directly
     * @param bandwidth in bit per seconds
     * @returns {Utils.Bandwidth}
     */
    Bandwidth.prototype.setBitPerSecond = function (bandwidth) {
        this.bandwidth = Math.max(Bandwidth.MAX_CAP, bandwidth);
        return this;
    };
    /**
     * applies smoothing average to current bandwidth value with new bandwith
     * @param bandwidth
     */
    Bandwidth.prototype.smooth = function (bandwidth) {
        if (bandwidth.isValid()) {
            if (this.isValid())
                this.bandwidth = this.bandwidth * (1 - Bandwidth.ALPHA) + bandwidth.bandwidth * Bandwidth.ALPHA;
            else
                this.bandwidth = bandwidth.bandwidth;
        }
    };
    /**
     * @param byteLength
     * @returns {number} transmission type at the current bandwidth in milliseconds
     */
    Bandwidth.prototype.getTransmissionTime = function (byteLength) {
        if (this.isValid()) {
            return Math.round(((byteLength * 8000) / this.bandwidth));
        }
        else
            return NaN;
    };
    Bandwidth.prototype.toBitPerSecond = function () {
        if (this.isValid())
            return this.bandwidth;
        else
            return NaN;
    };
    Bandwidth.prototype.toKilobitPerSecond = function () {
        if (this.isValid())
            return (this.bandwidth / 1000);
        else
            return NaN;
    };
    Bandwidth.prototype.toMegabitPerSecond = function () {
        if (this.isValid())
            return (this.bandwidth / 1000000);
        else
            return NaN;
    };
    Bandwidth.prototype.toHumanReadable = function () {
        if (this.isValid()) {
            if (this.bandwidth > 1000000)
                return (this.bandwidth / 1000000).toFixed(2) + 'Mb/s';
            if (this.bandwidth > 1000)
                return (this.bandwidth / 1000).toFixed(2) + 'Kb/s';
            return this.bandwidth + 'b/s';
        }
        else
            return 'NaN';
    };
    /**
     * smooth constant for averages
     */
    Bandwidth.ALPHA = 0.25;
    /**
     * maximum value for measured bandwidth to avoid measurements error to generate weird spikes
     * @default 100Mbps
     */
    Bandwidth.MAX_CAP = 1e8;
    /**
     * TODO: use this minimum data size in byte to perform a valid measurement
     */
    Bandwidth.DATA_SIZE_THRESHOLD = 1e4;
    return Bandwidth;
}());
exports.Bandwidth = Bandwidth;
exports.FragmentCounter = new Counter();
function genFragmentId(url, range) {
    if (!range) {
        return url;
    }
    else {
        return url + '-' + range;
    }
}
exports.genFragmentId = genFragmentId;
function appendBuffer(buffer1, buffer2) {
    var tmp = new Uint8Array(buffer1.byteLength + buffer2.byteLength);
    tmp.set(new Uint8Array(buffer1), 0);
    tmp.set(new Uint8Array(buffer2), buffer1.byteLength);
    return tmp.buffer;
}
exports.appendBuffer = appendBuffer;
function copyBuffer(buffer1) {
    var tmp = new Uint8Array(buffer1.byteLength);
    tmp.set(new Uint8Array(buffer1), 0);
    return tmp.buffer;
}
exports.copyBuffer = copyBuffer;
function removeArrayItem(array, item, onlyFirst) {
    if (onlyFirst === void 0) { onlyFirst = true; }
    for (var i = 0; i < array.length;) {
        if (array[i] === item) {
            array.splice(i, 1);
            if (onlyFirst)
                break;
        }
        else
            i++;
    }
}
exports.removeArrayItem = removeArrayItem;
function arrayBufferToString(buffer) {
    return String.fromCharCode.apply(null, new Uint8Array(buffer));
}
exports.arrayBufferToString = arrayBufferToString;
function getParameterByName(name) {
    name = name.replace(/[\[]/, '\\[').replace(/[\]]/, '\\]');
    var regex = new RegExp('[\\?&]' + name + '=([^&#]*)'), results = regex.exec(location.search);
    return results == null ? '' : decodeURIComponent(results[1].replace(/\+/g, ' '));
}
exports.getParameterByName = getParameterByName;
function shuffleArray(array) {
    for (var i = array.length - 1; i > 0; i--) {
        var j = Math.floor(Framework_1.Framework.random() * (i + 1));
        var temp = array[i];
        array[i] = array[j];
        array[j] = temp;
    }
    return array;
}
exports.shuffleArray = shuffleArray;
/**
 * compares two scalar arrays (numbers, strings, objects by reference, functions by reference)
 */
function sameArray(array1, array2) {
    return (array1 === null || array1 === void 0 ? void 0 : array1.length) === (array2 === null || array2 === void 0 ? void 0 : array2.length) && (array1 === null || array1 === void 0 ? void 0 : array1.every(function (value, index) { return value === array2[index]; }));
}
exports.sameArray = sameArray;
function getEnumNames(e) {
    var a = new Array();
    for (var item in e)
        if (e.hasOwnProperty(item) && !/^\d+$/.test(item))
            a.push(item);
    return a;
}
exports.getEnumNames = getEnumNames;
function getEnumValues(e) {
    return Object.keys(e).map(function (v) { return parseInt(v, 10); }).filter(function (v) { return !isNaN(v); });
}
exports.getEnumValues = getEnumValues;
function getEnumString(enumItem, key) {
    if (enumItem[key])
        return enumItem[key];
    else
        return null;
}
exports.getEnumString = getEnumString;
function resolveUrl(baseUrl, relativeUrl) {
    return new URI(relativeUrl).absoluteTo(baseUrl).toString();
}
exports.resolveUrl = resolveUrl;
function removeQueryParams(url) {
    if (url === void 0) { url = ''; }
    /* In a WAMS event the manifest in the ticket might be defined as ...ism/Manifest,
    but the request ends with ...ism/Manifest(format=mpd-time-csf), so we
    remove the ending to normalize it to ...ism/Manifest instead of ...ism/Manifest(format=mpd-time-csf) */
    var index = url.toLowerCase().indexOf('(format=mpd-time-csf)');
    if (index != -1)
        url = url.substr(0, index);
    index = url.indexOf('?');
    if (index == -1)
        index = url.length;
    return url.substr(0, index);
}
exports.removeQueryParams = removeQueryParams;
function getUrlQueryParams(url) {
    return new URI(url).search(true);
}
exports.getUrlQueryParams = getUrlQueryParams;
// Mainly a copy from urijs, but without the encoding of params
function relToAbsUrl(relativeUrl) {
    var uri = new URI(relativeUrl);
    var origin = uri.origin();
    var query = uri.query();
    var _path = uri.path();
    var _was_relative;
    var _leadingParents;
    var _parent;
    var _pos;
    var leadingDoubleSlash = relativeUrl.startsWith('//');
    // handle relative paths
    if (_path.charAt(0) !== '/') {
        _was_relative = true;
        _path = '/' + _path;
    }
    // handle relative files (as opposed to directories)
    if (_path.slice(-3) === '/..' || _path.slice(-2) === '/.') {
        _path += '/';
    }
    // resolve simples
    _path = _path
        .replace(/\/\//g, '||')
        .replace(/(\/(\.\/)+)|(\/\.$)/g, '/')
        .replace(/\/{2,}/g, '/')
        .replace(/\|\|/g, '//');
    // remember leading parents
    if (_was_relative) {
        _leadingParents = _path.substring(1).match(/^(\.\.\/)+/) || '';
        if (_leadingParents) {
            _leadingParents = _leadingParents[0];
        }
    }
    // resolve parents
    while (true) {
        _parent = _path.search(/\/\.\.(\/|$)/);
        if (_parent === -1) {
            // no more ../ to resolve
            break;
        }
        else if (_parent === 0) {
            // top level cannot be relative, skip it
            _path = _path.substring(3);
            continue;
        }
        _pos = _path.substring(0, _parent).lastIndexOf('/');
        if (_pos === -1) {
            _pos = _parent;
        }
        _path = _path.substring(0, _pos) + _path.substring(_parent + 3);
    }
    return (leadingDoubleSlash ? '//' : '') + origin + _path + (query ? "?" + query : '');
}
exports.relToAbsUrl = relToAbsUrl;
function avg(data) {
    if (data.length == 0)
        return 0.0;
    var sum = data.reduce(function (a, b) {
        return a + b;
    });
    return sum / data.length;
}
exports.avg = avg;
function stringToArrayBuffer(string) {
    var buffer = new ArrayBuffer(string.length);
    var bufferView = new Uint8Array(buffer);
    for (var i = 0, length_1 = string.length; i < length_1; i++) {
        bufferView[i] = string.charCodeAt(i);
    }
    return buffer;
}
exports.stringToArrayBuffer = stringToArrayBuffer;
/**
 * Returns a new Event-type object, with the currentTarget and target properties modified. This must utilize
 * Object.defineProperties as the currentTarget and target values are not writable.
 * @param  {EventConstructor} EventConstructor A constructor function that returns a new Event object, eg. ProgressEvent
 * @param {string} type The type of the event, eg. "progress"
 * @param  {object} [eventInitDict] Initialization object to set the returned event's properties, eg { "bubbles": false }. This
 * can be an existing Event object, in which case the original Event's properties are copied.
 * @param {any} [overrideCurrentTarget] The target of the event, if different from what is provided in eventInitDict
 * @returns {new EventConstructor} The newly created event.
 */
function createEvent(EventConstructor, type, eventInitDict, overrideCurrentTarget) {
    var event = new EventConstructor(type, eventInitDict);
    var currentTarget = overrideCurrentTarget || eventInitDict.currentTarget;
    if (currentTarget) {
        Object.defineProperties(event, {
            currentTarget: { value: currentTarget, enumerable: true, writable: false },
            target: { value: currentTarget, enumerable: true, writable: false }
        });
    }
    return event;
}
exports.createEvent = createEvent;
exports.REGEX_CLEANER = /[-\/\\^$*+?.()|[\]{}]/g;
function escapeRegex(regex) {
    return regex.replace(exports.REGEX_CLEANER, '\\$&');
}
exports.escapeRegex = escapeRegex;
var TypedEventEmitter = /** @class */ (function (_super) {
    __extends(TypedEventEmitter, _super);
    function TypedEventEmitter() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    TypedEventEmitter.prototype.on = function (event, listener) {
        return _super.prototype.on.call(this, event, listener);
    };
    TypedEventEmitter.prototype.emit = function (event) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        return _super.prototype.emit.apply(this, __spreadArray([event], args));
    };
    return TypedEventEmitter;
}(events_1.EventEmitter));
exports.TypedEventEmitter = TypedEventEmitter;
/**
 * checks whether a variable is not undefined or null.
 * Returns true also if it's a 0 number
 */
function isSet(accessor) {
    return accessor !== undefined && accessor !== null;
}
exports.isSet = isSet;
function isIpAddress(address) {
    var ipRegex = /^([0-9]{1,3}(\.[0-9]{1,3}){3})$/;
    return ipRegex.test(address);
}
exports.isIpAddress = isIpAddress;
function isMdnsAddress(address) {
    var mdnsRegex = /^[0-9A-F]{8}-[0-9A-F]{4}-4[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}.local$/i;
    return mdnsRegex.test(address);
}
exports.isMdnsAddress = isMdnsAddress;
function stringToRTCIceCandidateInfo(candidate) {
    var candidateStr = 'candidate:';
    var pos = candidate.indexOf(candidateStr) + candidateStr.length;
    var _a = candidate.substr(pos).split(' '), foundation = _a[0], component = _a[1], protocol = _a[2], priority = _a[3], address = _a[4], port = _a[5], type = _a[7];
    var addressType = models_1.AddressType.NA;
    if (isIpAddress(address)) {
        addressType = models_1.AddressType.IP;
    }
    else if (isMdnsAddress(address)) {
        addressType = models_1.AddressType.MDNS;
    }
    return {
        'component': component,
        'type': type,
        'foundation': foundation,
        'protocol': protocol,
        'address': address,
        'port': port,
        'priority': Number(priority),
        'addressType': addressType
    };
}
exports.stringToRTCIceCandidateInfo = stringToRTCIceCandidateInfo;
//# sourceMappingURL=Utils.js.map

/***/ }),

/***/ "../../../core/build/core/src/core/client/Connection.js":
/*!*******************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/core/client/Connection.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.HiveServicesConnection = void 0;
var Q = __webpack_require__(/*! @hivestreaming/q */ "../../../node_modules/@hivestreaming/q/q.js");
var HiveServices = __webpack_require__(/*! ../HiveServices */ "../../../core/build/core/src/core/HiveServices.js");
var Constants_1 = __webpack_require__(/*! ../Constants */ "../../../core/build/core/src/core/Constants.js");
var QueuedMessage = /** @class */ (function () {
    function QueuedMessage(msg, expiresAfter) {
        this.msg = msg;
        this.expiresAt = Date.now() + expiresAfter;
        this.onSend = Q.defer();
    }
    QueuedMessage.prototype.hasExpired = function () {
        return Date.now() >= this.expiresAt;
    };
    return QueuedMessage;
}());
// keeps the connection to the service up by sending pings and tries to
// reconnect on failure
var HiveServicesConnection = /** @class */ (function () {
    /*
     * Create a new websocket connection to the HiveServices backend.
     * Tries to re-connect to the server forever on failure, backs off with an
     * exponential increase until a max value. Initiates the connection on
     * instance creation.
     *
     * `endpoint` - The endpoint where the service is running
     * `maxReconnectTimeout` - max milliseconds before retrying
     * `maxPendingMessages` - indicates the max number of queued messages possible
     * `maxTimeInSendQueue` - milliseconds until a queued message expires
     *
     */
    function HiveServicesConnection(endpoint, maxReconnectTimeout, maxPendingMessages, maxTimeInSendQueue, heartbeatPeriod, timeObj, forceHeartbeat) {
        if (maxReconnectTimeout === void 0) { maxReconnectTimeout = 30000; }
        if (maxPendingMessages === void 0) { maxPendingMessages = 100; }
        if (maxTimeInSendQueue === void 0) { maxTimeInSendQueue = 30000; }
        if (heartbeatPeriod === void 0) { heartbeatPeriod = 15000; }
        if (timeObj === void 0) { timeObj = Date; }
        if (forceHeartbeat === void 0) { forceHeartbeat = false; }
        // the interval between connection attempts, this is double for each failed
        // attempt until the threshold maxReconnectTimeout
        // initial connection is immediate
        this.connectInterval = 1;
        // the return from setInterval
        this.connectTimeoutId = -1;
        // timestamp when the connection was established
        this.connectedTs = -1;
        // a map for dispatching messages, from string to a function. New functions
        // are registered with on()
        this.dispatcher = {};
        // list of functions called on error, subscribe using onerror
        this.notifyErrors = [];
        // list of functions called on connection open, subscribe using onconnect
        this.notifyConnect = [];
        // heartbeat function
        this.useHeartbeat = false;
        // true if the automatic reconnection is allowed.
        // false if the connection is explicitly closed
        this.autoReconnect = true;
        this.endpoint = endpoint;
        this.sendQueue = Array();
        this.maxReconnectTimeout = maxReconnectTimeout;
        this.maxPendingMessages = maxPendingMessages;
        this.maxTimeInSendQueue = maxTimeInSendQueue;
        this.heartbeatPeriod = heartbeatPeriod;
        this.timeObj = timeObj;
        // activate the heartbeat only if forced or IE9/10/11/Edge
        this.useHeartbeat = forceHeartbeat ||
            (/MSIE 10/i.test(navigator.userAgent)) ||
            (/MSIE 9/i.test(navigator.userAgent) || /rv:11.0/i.test(navigator.userAgent)) ||
            (/Edge./i.test(navigator.userAgent));
    }
    HiveServicesConnection.prototype.dispatch = function (msg) {
        // try to find the function, otherwise log a warning
        var key = msg.service + '_' + msg.msgId;
        var f = this.dispatcher[key];
        if (f != null)
            f(msg);
        else
            HiveServices.logger().error(HiveServices.loggerId + 'Could not find a dispatcher for ', key, Object.keys(this.dispatcher));
    };
    /*
     * Dispatch a message based on service and msg type id.
     */
    HiveServicesConnection.prototype.on = function (service, msgId, f) {
        // assign to the dispatcher overwriting any previous pair
        this.dispatcher[service + '_' + msgId] = f;
    };
    HiveServicesConnection.prototype.onerror = function (f) {
        this.notifyErrors.push(f);
    };
    HiveServicesConnection.prototype.onconnect = function (f) {
        this.notifyConnect.push(f);
    };
    HiveServicesConnection.prototype.newWebSocket = function () {
        var _this = this;
        if (!window['WebSocket']) {
            this.notifyErrors.forEach(function (f) {
                return f('WebSocket not defined');
            });
            return;
        }
        var ws = new WebSocket(this.endpoint);
        ws.binaryType = 'arraybuffer';
        ws.onopen = function (ev) {
            // reset the reconnection variables
            _this.resetTimeout();
            HiveServices.logger().debug(HiveServices.loggerId + 'HiveServicesConnection established to ' + _this.endpoint);
            _this.connectedTs = new _this.timeObj().getTime();
            // send all queued messages
            _this.sendQueued();
            _this.notifyConnect.forEach(function (f) {
                return f(_this);
            });
            // heartbeat
            _this.resetHeartbeat();
            _this.scheduleHeartbeat();
        };
        ws.onclose = function (ev) {
            _this.close(_this.autoReconnect);
            _this.connect();
        };
        ws.onmessage = function (ev) {
            var message = HiveServices.Message.extract(ev.data);
            _this.dispatch(message);
        };
        ws.onerror = function (ev) {
            _this.close(true);
            _this.notifyErrors.forEach(function (f) {
                return f(ev.toString());
            });
        };
        return ws;
    };
    HiveServicesConnection.prototype.isOpen = function () {
        return this.ws != null &&
            this.ws.readyState == this.ws.OPEN;
    };
    /**
     * attempt to establish a websocket assigned to this Connection object
     */
    HiveServicesConnection.prototype.connect = function (autoReconnect) {
        var _this = this;
        // reset the autoReconnect if the connect call was explicit
        if (autoReconnect)
            this.autoReconnect = true;
        // stop the connection attempt if the autoReconnect is disabled
        if (!this.autoReconnect)
            return;
        // if its not in closed or closing state, then we are already connected
        // or are trying to connect
        if (this.isOpen() == true) {
            return;
        }
        // check if there is an active timeout
        if (this.connectTimeoutId > 0) {
            return;
        }
        // If the connection has lasted for at least maxReconnectTimeout, reset
        // the reconnect interval. Otherwise double the connectInterval but make
        // sure its never bigger than the maxReconnectTimeout.
        if (this.connectedTs > -1 && new this.timeObj().getTime() - this.connectedTs > this.maxReconnectTimeout) {
            this.connectInterval = Constants_1.Constants.MIN_CONNECT_INTERVAL;
            this.connectedTs = -1;
        }
        else {
            this.connectInterval = Math.min(this.connectInterval * 2, this.maxReconnectTimeout);
        }
        // try to connect again after the timeout
        this.connectTimeoutId = window.setTimeout(function () {
            // reset the id and call connect
            _this.connectTimeoutId = -1;
            HiveServices.logger().debug(HiveServices.loggerId + 'Connection attempt to ' + _this.endpoint + ' [t:' + _this.connectInterval + ' hb:' + _this.useHeartbeat + ']');
            // replace the current websocket connection with a new one that tries to
            // connect
            _this.ws = _this.newWebSocket();
            // cap the connect interval to the minimum after the first connection
            _this.connectInterval = Math.max(_this.connectInterval, Constants_1.Constants.MIN_CONNECT_INTERVAL);
        }, this.connectInterval);
    };
    HiveServicesConnection.prototype.resetTimeout = function () {
        if (this.connectTimeoutId > -1) {
            clearTimeout(this.connectTimeoutId);
            this.connectTimeoutId = -1;
        }
    };
    HiveServicesConnection.prototype.close = function (reconnect) {
        this.autoReconnect = reconnect != undefined ? reconnect : false;
        HiveServices.logger().debug(HiveServices.loggerId + 'Closing connection [reconnect:' + this.autoReconnect + ']');
        this.resetTimeout();
        if (this.ws != null) {
            this.ws.close();
            this.ws = null;
        }
    };
    // sends all queued messages
    HiveServicesConnection.prototype.sendQueued = function () {
        while (this.sendQueue.length > 0) {
            var lastMsg = this.sendQueue.pop();
            try {
                if (lastMsg.hasExpired()) {
                    lastMsg.onSend.reject(new Error('Message expired'));
                }
                else {
                    // when writing on the ws, reset the heartbeat and resolve the msg sent promise
                    this.resetHeartbeat();
                    this.ws.send(lastMsg.msg.serialize());
                    lastMsg.onSend.resolve();
                }
            }
            catch (e) {
                if (e.code === DOMException.INVALID_STATE_ERR) {
                    // not open, requeue the message and break the loop
                    this.sendQueue.push(lastMsg);
                    break;
                }
                HiveServices.logger().error(HiveServices.loggerId + 'Failed to send the message, dropped: ', e.code, e.name);
                // couldnt send the message, forward the exception
                lastMsg.onSend.reject(e);
            }
        }
        // after flushing the queue, schedule next heartbeat
        this.scheduleHeartbeat();
    };
    HiveServicesConnection.prototype.resetHeartbeat = function () {
        if (this.heartbeatTimeoutId) {
            clearTimeout(this.heartbeatTimeoutId);
            this.heartbeatTimeoutId = null;
        }
    };
    HiveServicesConnection.prototype.scheduleHeartbeat = function () {
        var _this = this;
        if (this.useHeartbeat && !this.heartbeatTimeoutId)
            this.heartbeatTimeoutId = window.setInterval(function () {
                _this.send(new HiveServices.Message(HiveStreamingServices.HIVEJS_KEEPALIVE, 0, ''));
            }, this.heartbeatPeriod);
    };
    /**
     * Send a message over the connection.
     */
    HiveServicesConnection.prototype.send = function (msg, expireAfter) {
        if (expireAfter === void 0) { expireAfter = this.maxTimeInSendQueue; }
        // check if there are too many messages queued
        if (this.sendQueue.length >= this.maxPendingMessages)
            throw new Error('HiveServices connection cannot queue more messages');
        var queuedMsg = new QueuedMessage(msg, expireAfter);
        this.sendQueue.push(queuedMsg);
        if (this.ws) {
            this.sendQueued();
        }
        else {
            HiveServices.logger().warn(HiveServices.loggerId + ' The websocket is closed, messages are being queued');
        }
        return queuedMsg.onSend.promise;
    };
    /**
     * Activate or deactivate the Connection heartbeat on the websocket
     */
    HiveServicesConnection.prototype.setHeartbeat = function (active) {
        this.useHeartbeat = active;
        if (this.useHeartbeat)
            this.scheduleHeartbeat();
    };
    HiveServicesConnection.prototype.isConnected = function () {
        return this.ws != null;
    };
    return HiveServicesConnection;
}());
exports.HiveServicesConnection = HiveServicesConnection;
//# sourceMappingURL=Connection.js.map

/***/ }),

/***/ "../../../core/build/core/src/core/connectivity/ConnectivityInfoProvider.js":
/*!***************************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/core/connectivity/ConnectivityInfoProvider.js ***!
  \***************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ServiceResponse = void 0;
var ServiceResponse;
(function (ServiceResponse) {
    ServiceResponse[ServiceResponse["TRACKER"] = 0] = "TRACKER";
    ServiceResponse[ServiceResponse["REMOTE_CONFIG"] = 1] = "REMOTE_CONFIG";
})(ServiceResponse = exports.ServiceResponse || (exports.ServiceResponse = {}));
//# sourceMappingURL=ConnectivityInfoProvider.js.map

/***/ }),

/***/ "../../../core/build/core/src/core/connectivity/NodeConnectivityInfo.js":
/*!***********************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/core/connectivity/NodeConnectivityInfo.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.NodeConnectivityInfo = void 0;
var NetworkInfo_1 = __webpack_require__(/*! ../network/NetworkInfo */ "../../../core/build/core/src/core/network/NetworkInfo.js");
var StatsNetworkInfo_1 = __webpack_require__(/*! ../network/StatsNetworkInfo */ "../../../core/build/core/src/core/network/StatsNetworkInfo.js");
var models_1 = __webpack_require__(/*! ../../webrtc/booster/models */ "../../../core/build/core/src/webrtc/booster/models/index.js");
var Utils_1 = __webpack_require__(/*! ../Utils */ "../../../core/build/core/src/core/Utils.js");
var Framework_1 = __webpack_require__(/*! ../Framework */ "../../../core/build/core/src/core/Framework.js");
/**
 * this class manages the flow of connectivity information coming from the
 * connInfo providers:
 * - WebRTC candidates
 * - Booster
 * - backend services (remote config/tracker)
 *
 * All these inputs are used for the following goals:
 * - keep the Network Info object updated with the default interface
 * info (IP, nic, site, public IP). If we can't tell the default network
 * it should still pick one to be reported.
 * - keep track of all interfaces, if we can't identify a default one, to
 * help WebRTC establishing connections by smudging mdns candidates
 *
 * Flow:
 * 1. Conn Provider should set booster extended network info
 * 2. Conn Provider should collect candidates (local and external) and pass all
 * the known private IPs
 * 3. Conn Info should inizialize the Network Info with the discovered interfaces + the booster info
 * 4. Conn Provider should provide more info from services (site matching from Remote Config, public info from tracker)
 * and Conn Info should update the Network Info
 *
 * @see StatsJSConnectivityProvider for more details
 */
var NodeConnectivityInfo = /** @class */ (function () {
    function NodeConnectivityInfo() {
        this.loggerId = '[ConnectivityInfo] ';
        /**
         * the final holder of the network info to be reported via metrics and track snapshots.
         * currently we can only report one 'default' interface at the time, so this object
         * will contain one private IP, its nic info, matching site info, and public IP info.
         */
        this.networkInfo = new StatsNetworkInfo_1.StatsNetworkInfo();
        /**
         * list of known local interfaces.
         * It will be one if we know the default interface for sure (one IP, or Booster helped picking it).
         * It will be more than one if can't tell which one is the default (no Booster).
         */
        this.interfaceAddresses = [];
        this.logger = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.LOGGER).log();
    }
    NodeConnectivityInfo.prototype.setExtendedNetworkInfo = function (extendedNetworkInfo) {
        this.extendedNetworkInfo = extendedNetworkInfo;
    };
    NodeConnectivityInfo.prototype.getExtendedNetworkInfo = function () {
        return this.extendedNetworkInfo;
    };
    NodeConnectivityInfo.prototype.setHostName = function (hostName) {
        this.hostname = hostName;
    };
    NodeConnectivityInfo.prototype.getHostName = function () {
        return this.hostname;
    };
    NodeConnectivityInfo.prototype.getNetworkInfo = function () {
        return this.networkInfo;
    };
    /**
     * Returns the default interface's IP address or all the known interfaces address
     * These addresses can be used to potentially multiply/smudge mdns candidates on connection establishment
     * when plugin has only access to one mDNS interface and:
     * - Booster provides the default interface (or all of them)
     * - TLE external frame provides all local interfaces (but we can't tell the default one)
     */
    NodeConnectivityInfo.prototype.getInterfaces = function () {
        return this.interfaceAddresses;
    };
    /**
     * Goal: update and return a default address or a list of ordered addresses,
     * and initialize connectivity info with it. The list is then used to gather site info.
     *
     * Input is a fresh list of available interfaces addresses from webrtc.
     * If there are extended info from the Booster, check if either we have no webrtc interfaces,
     * or at least the first interface is found on the booster. In that case let the booster provide
     * interface's address, or a list of addresses and return them.
     * If there is no extended info and the list is empty, reset previously existing network info.
     * Otherwise check the fresh list against the previously stored one, and if anything changed
     * (new/missing addresses or different order) it will update the connectivity info with the new first IP
     * and return the fresh list
     */
    NodeConnectivityInfo.prototype.setInterfaces = function (privateIps) {
        if (privateIps.length == 0) {
            if (this.validExtendedInfo()) {
                // check if there are no webrtc interfaces or the first one matches any from booster
                this.interfaceAddresses = this.getDefaultExtendedInterface();
                if (this.interfaceAddresses.length > 0) {
                    this.buildConnectivityInfo(this.interfaceAddresses[0]);
                    return;
                }
            }
            // if we got no private interfaces and no booster info, we reset the network info object
            if (Utils_1.isSet(this.networkInfo.getPrivateIp())) {
                this.interfaceAddresses = [];
                this.networkInfo = new StatsNetworkInfo_1.StatsNetworkInfo();
                this.logger.debug(this.loggerId + 'reset network info ' + JSON.stringify(this.networkInfo));
            }
        }
        else {
            // we have updated private IPs from WebRTC. In this case we use extended info
            // only to help pick the default interface routing to google DNS.
            if (this.validExtendedInfo() && privateIps.length > 1) {
                this.interfaceAddresses = this.pickDefaultInterface(privateIps);
                this.buildConnectivityInfo(this.interfaceAddresses[0]);
                return;
            }
            //  Otherwise just pick the first one if anything changed
            if (!Utils_1.sameArray(this.interfaceAddresses, privateIps)) {
                // the list of privateIPs changed, update the connectivity info with the new highest prio IP
                this.interfaceAddresses = privateIps;
                this.buildConnectivityInfo(this.interfaceAddresses[0]);
            }
        }
    };
    /**
     * Updates the connectivity info with partial information from the services or booster
     * From the webRTC-based connectivity provider or Booster we might get a new (suggested) private IP.
     * From the services it expects privateIP -> site matching, or public IP / external AS info.
     * It will reset the state only if the new suggested privateIP doesn't match the current one.
     * Services returning privateIP->site might change the privateIP later if they return a different default network out of
     * that list.
     */
    NodeConnectivityInfo.prototype.updateConnectivityInfo = function (privateIp, siteId, isVpn, publicIp, externalAsId) {
        this.buildConnectivityInfo(privateIp, siteId, isVpn, publicIp, externalAsId);
    };
    /**
     * Filter out TCP candidates and refine mDNS ones.
     *
     * The goal is to avoid peering over TCP, and try to establish direct connection
     * between LANs, without being limited by the mDNS resolution boundaries.
     * Also, in Chrome we can actually establish connections also via
     * interfaces that are not the default one of the interfaces. Firefox can't.
     *
     * If the candidate is mDNS, and we have a default interface
     * or a list of known interfaces, then return a list of candidates with:
     * - the mDNS one
     * - one duplicated candidate with the mDNS address replaced for every known IP address.
     *
     *
     * @see StatsJSConnectivityProvider for more details
     */
    NodeConnectivityInfo.prototype.refineCandidate = function (candidate) {
        var address = candidate.address;
        var protocol = candidate.protocol;
        // filter out all non UDP candidates
        if ((protocol === null || protocol === void 0 ? void 0 : protocol.toLowerCase()) != 'udp') {
            return [];
        }
        var privateIps = this.getInterfaces();
        var candidates = [candidate];
        if (privateIps.length > 0 && Utils_1.isMdnsAddress(address)) {
            privateIps.map(function (privateIp) {
                var newCandidate = candidate.toJSON();
                newCandidate.candidate = newCandidate.candidate.replace(address, privateIp);
                candidates.push(new RTCIceCandidate(newCandidate));
            });
        }
        return candidates;
    };
    /**
     * build or update the network info object based on the picked private IP, services feedbacks and extended info.
     * Give always priority to the info coming from the services, and fallack to booster extended info
     */
    NodeConnectivityInfo.prototype.buildConnectivityInfo = function (privateIp, siteId, isVpn, publicIp, externalAsId) {
        var _this = this;
        var updated = false;
        // we check if the current network info match the freshly retrieved IP
        if (Utils_1.isSet(privateIp) && privateIp != this.networkInfo.getPrivateIp()) {
            // the network must have changed, we need to reset the state with the new private IP
            this.networkInfo = new StatsNetworkInfo_1.StatsNetworkInfo();
            this.networkInfo.setPrivateIp(privateIp);
            updated = true;
        }
        if (Utils_1.isSet(siteId) && siteId != this.networkInfo.getSiteId()) {
            this.networkInfo.setSiteId(siteId);
            updated = true;
        }
        if (Utils_1.isSet(isVpn) && isVpn != this.networkInfo.isVpn()) {
            this.networkInfo.setVpn(isVpn);
            updated = true;
        }
        if (Utils_1.isSet(publicIp) && publicIp != this.networkInfo.getPublicIp()) {
            this.networkInfo.setPublicIp(publicIp);
            updated = true;
        }
        if (Utils_1.isSet(externalAsId) && externalAsId != this.networkInfo.getExternalAsId()) {
            this.networkInfo.setExternalAsId(externalAsId);
            updated = true;
        }
        // if possible, extend the network info with extended booster info
        if (this.validExtendedInfo()) {
            var defaultInterface = this.extendedNetworkInfo.interfaces.find(function (i) { return i.address.find(function (a) { return a.value == _this.networkInfo.getPrivateIp(); }); });
            if (defaultInterface) {
                // update the nic name
                if (Utils_1.isSet(defaultInterface.nic) && defaultInterface.nic.name != this.networkInfo.getNicName()) {
                    this.setNicInfo(defaultInterface.nic);
                    updated = true;
                }
                // update the site if it's not already set
                if (!Utils_1.isSet(this.networkInfo.getSiteId()) || this.networkInfo.getSiteId() == 0) {
                    this.networkInfo.setSiteId(defaultInterface.site.id);
                    this.networkInfo.setVpn(defaultInterface.site.vpn);
                }
            }
            // finally update the public IP if it was not done yet
            if (!Utils_1.isSet(this.networkInfo.getPublicIp())) {
                this.networkInfo.setPublicIp(this.extendedNetworkInfo.publicAddress.address);
                this.networkInfo.setExternalAsId(this.extendedNetworkInfo.publicAddress.as);
                updated = true;
            }
        }
        if (updated) {
            this.logger.notice(this.loggerId + 'updated network info ' + JSON.stringify(this.networkInfo));
        }
    };
    NodeConnectivityInfo.prototype.validExtendedInfo = function () {
        var _a, _b;
        return ((_b = (_a = this.extendedNetworkInfo) === null || _a === void 0 ? void 0 : _a.interfaces) === null || _b === void 0 ? void 0 : _b.length) > 0;
    };
    /**
     * Set the booster nic info and match the network type to the
     * correct string value (NicType) expected by Insights
     */
    NodeConnectivityInfo.prototype.setNicInfo = function (nic) {
        this.networkInfo.setNicName(nic.name);
        if (nic.connectionType === models_1.ConnectionType.ETHERNET) {
            this.networkInfo.setNic(NetworkInfo_1.NicType.ETHERNET);
        }
        else if (nic.connectionType === models_1.ConnectionType.WIRELESS) {
            this.networkInfo.setNic(NetworkInfo_1.NicType.WIRELESS);
        }
        else {
            this.networkInfo.setNic(NetworkInfo_1.NicType.UNKNOWN);
        }
    };
    /**
     * This method is used when we have NO candidates IPs already, so we need to rely on Booster info.
     * It tries to find the default interface by either looking for the one with the mDNS address, or routing to 8.8.8.8
     * (Those interfaces should always match, but mDNS resolution might timeout in the Booster).
     * If it can't find a default interface returns all reported IP addresses
     */
    NodeConnectivityInfo.prototype.getDefaultExtendedInterface = function () {
        var _a;
        var interfaces = new Array();
        if (this.validExtendedInfo()) {
            // search the default interface looking up the one returning also mdns address or routing to 8.8.8.8
            var networkInterface = this.extendedNetworkInfo.interfaces.find(function (i) { return i.address.some(function (a) { return a.type === models_1.AddressType.MDNS; }); });
            if (!networkInterface) {
                var googleDnsRoute_1 = (_a = this.extendedNetworkInfo.routes) === null || _a === void 0 ? void 0 : _a.find(function (route) { return route.domain == '8.8.8.8'; });
                if (googleDnsRoute_1) {
                    networkInterface = this.extendedNetworkInfo.interfaces.find(function (i) { return i.address.some(function (a) { return a.value == googleDnsRoute_1.interface; }); });
                }
            }
            // if we found a default interface, return ONLY that one, otherwise return all known interfaces' IP
            if (networkInterface) {
                interfaces = [networkInterface.address.find(function (a) { return a.type === models_1.AddressType.IP; }).value];
            }
            else {
                interfaces = this.extendedNetworkInfo.interfaces.map(function (i) { return i.address.find(function (a) { return a.type === models_1.AddressType.IP; }).value; });
            }
        }
        return interfaces;
    };
    /**
     * This method is used when we have more than one IP candidate and we need
     * the booster extended info to pick the one used for routing to google DNS
     * or return all of them in the same order if none matches
     */
    NodeConnectivityInfo.prototype.pickDefaultInterface = function (privateIps) {
        var _a, _b, _c;
        var googleDnsRoute = (_c = (_b = (_a = this.extendedNetworkInfo) === null || _a === void 0 ? void 0 : _a.routes) === null || _b === void 0 ? void 0 : _b.find(function (route) { return route.domain == '8.8.8.8'; })) === null || _c === void 0 ? void 0 : _c.interface;
        if (googleDnsRoute && (privateIps === null || privateIps === void 0 ? void 0 : privateIps.indexOf(googleDnsRoute)) > -1) {
            return [googleDnsRoute];
        }
        return privateIps;
    };
    return NodeConnectivityInfo;
}());
exports.NodeConnectivityInfo = NodeConnectivityInfo;
//# sourceMappingURL=NodeConnectivityInfo.js.map

/***/ }),

/***/ "../../../core/build/core/src/core/context/ContextManager.js":
/*!************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/core/context/ContextManager.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ContextManager = void 0;
var Dash_1 = __webpack_require__(/*! ../metadata/dash/Dash */ "../../../core/build/core/src/core/metadata/dash/Dash.js");
var Hls_1 = __webpack_require__(/*! ../metadata/hls/Hls */ "../../../core/build/core/src/core/metadata/hls/Hls.js");
var ContextManager = /** @class */ (function () {
    function ContextManager() {
    }
    ContextManager.prototype.initContext = function (ticket, hiveTechOptions) {
        var foundContext = null;
        var manifest = ticket.getManifestUrlWithQuery();
        this.hiveTechOptions = hiveTechOptions;
        if (Hls_1.Hls.isValidContext(manifest, this.logger, this.getContextMatcher('HLS'))) {
            this.currentContext = foundContext = this.createHlsContext(ticket);
        }
        else if (Dash_1.Dash.isValidContext(manifest, this.logger, this.getContextMatcher('DASH'))) {
            this.currentContext = foundContext = this.createDashContext(ticket);
        }
        else {
            this.logger.warn('COULD NOT FIND A CONTEXT FOR ' + manifest);
        }
        if (foundContext != null)
            this.restartContext(this.currentContext);
        return foundContext;
    };
    ContextManager.prototype.getContextMatcher = function (type) {
        if (type === 'HLS') {
            return this.hiveTechOptions && this.hiveTechOptions.contextMatcher && this.hiveTechOptions.contextMatcher.hls;
        }
        else if (type == 'DASH') {
            return this.hiveTechOptions && this.hiveTechOptions.contextMatcher && this.hiveTechOptions.contextMatcher.dash;
        }
        else {
            return this.hiveTechOptions && this.hiveTechOptions.contextMatcher;
        }
    };
    ContextManager.prototype.restartContext = function (context) { };
    return ContextManager;
}());
exports.ContextManager = ContextManager;
//# sourceMappingURL=ContextManager.js.map

/***/ }),

/***/ "../../../core/build/core/src/core/entity/EntityRequest.js":
/*!**********************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/core/entity/EntityRequest.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.EntityRequestStatus = void 0;
var EntityRequestStatus;
(function (EntityRequestStatus) {
    EntityRequestStatus[EntityRequestStatus["CREATED"] = 0] = "CREATED";
    EntityRequestStatus[EntityRequestStatus["STARTED"] = 1] = "STARTED";
    EntityRequestStatus[EntityRequestStatus["SUCCEEDED"] = 2] = "SUCCEEDED";
    EntityRequestStatus[EntityRequestStatus["ABORTED"] = 3] = "ABORTED";
    EntityRequestStatus[EntityRequestStatus["FAILED"] = 4] = "FAILED";
    EntityRequestStatus[EntityRequestStatus["TIMEDOUT"] = 5] = "TIMEDOUT";
})(EntityRequestStatus = exports.EntityRequestStatus || (exports.EntityRequestStatus = {}));
//# sourceMappingURL=EntityRequest.js.map

/***/ }),

/***/ "../../../core/build/core/src/core/entity/EntityType.js":
/*!*******************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/core/entity/EntityType.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.EntityType = void 0;
var EntityType;
(function (EntityType) {
    EntityType[EntityType["AUDIO"] = 0] = "AUDIO";
    EntityType[EntityType["VIDEO"] = 1] = "VIDEO";
    EntityType[EntityType["METADATA"] = 2] = "METADATA";
    EntityType[EntityType["OTHER"] = 3] = "OTHER";
    EntityType[EntityType["SUBTITLES"] = 4] = "SUBTITLES";
})(EntityType = exports.EntityType || (exports.EntityType = {}));
//# sourceMappingURL=EntityType.js.map

/***/ }),

/***/ "../../../core/build/core/src/core/entity/video/VideoEntityCharacteristics.js":
/*!*****************************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/core/entity/video/VideoEntityCharacteristics.js ***!
  \*****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.VideoEntityCharacteristics = void 0;
var EntityType_1 = __webpack_require__(/*! ../EntityType */ "../../../core/build/core/src/core/entity/EntityType.js");
var jsrsasign_1 = __webpack_require__(/*! @hivestreaming/jsrsasign */ "../../../node_modules/@hivestreaming/jsrsasign/lib/jsrsasign.js");
var VideoEntityCharacteristics = /** @class */ (function () {
    function VideoEntityCharacteristics(url, entity, binary, segmentId, duration, qualityLevel, cacheable, contextId) {
        var clearStreamId = (contextId ? contextId : url).replace(/http(s)?:\/\//, '');
        var urlHashed = jsrsasign_1.CryptoJS.SHA1(clearStreamId).toString(jsrsasign_1.CryptoJS.enc.Hex);
        this.url = url;
        this.entity = entity;
        this.binary = binary;
        this.segmentId = segmentId;
        this.duration = duration;
        this.qualityLevel = qualityLevel;
        this.cacheable = cacheable;
        this.entityId = [urlHashed, segmentId, qualityLevel ? qualityLevel.id : null].join('-');
    }
    VideoEntityCharacteristics.fromSegment = function (segment) {
        return new VideoEntityCharacteristics(segment.absoluteUrl, segment.entityType, true, segment.id, segment.duration.ms(), segment.qualityLevel, true);
    };
    VideoEntityCharacteristics.prototype.getEntityType = function () {
        return this.entity;
    };
    VideoEntityCharacteristics.prototype.getSegmentId = function () {
        return this.segmentId;
    };
    VideoEntityCharacteristics.prototype.getDuration = function () {
        return this.duration;
    };
    VideoEntityCharacteristics.prototype.getQualityLevel = function () {
        return this.qualityLevel;
    };
    VideoEntityCharacteristics.prototype.isCacheable = function () {
        return this.cacheable;
    };
    VideoEntityCharacteristics.prototype.isBinary = function () {
        return this.binary;
    };
    VideoEntityCharacteristics.prototype.getEntityId = function () {
        return this.entityId;
    };
    VideoEntityCharacteristics.prototype.getUrl = function () {
        return this.url;
    };
    VideoEntityCharacteristics.prototype.toString = function () {
        return EntityType_1.EntityType[this.getEntityType()] + '-' + this.getEntityId();
    };
    return VideoEntityCharacteristics;
}());
exports.VideoEntityCharacteristics = VideoEntityCharacteristics;
//# sourceMappingURL=VideoEntityCharacteristics.js.map

/***/ }),

/***/ "../../../core/build/core/src/core/identity/Identity.js":
/*!*******************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/core/identity/Identity.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Identity = void 0;
/**
 * Identity object will provide two type of string identification
 * the p2pId will be used as identifier in the p2p swarm (signalling, tracker)
 * the reportingId will be used as identifier in Insights (Metrics Snapshot, Track Snapshots)
 *
 * If initialized only with p2pId, reportingId will be the same value
 */
var Identity = /** @class */ (function () {
    function Identity(p2pId, reportingId) {
        this.p2pId = p2pId;
        this.reportingId = reportingId;
    }
    Identity.prototype.getPeerId = function () {
        return this.p2pId;
    };
    Identity.prototype.getReportingId = function () {
        return this.reportingId ? this.reportingId : this.p2pId;
    };
    Identity.prototype.setReportingId = function (reportingId) {
        this.reportingId = reportingId;
    };
    return Identity;
}());
exports.Identity = Identity;
//# sourceMappingURL=Identity.js.map

/***/ }),

/***/ "../../../core/build/core/src/core/identity/PersistentIdentityProvider.js":
/*!*************************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/core/identity/PersistentIdentityProvider.js ***!
  \*************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.PersistentReportingIdentityProvider = exports.PersistentIdentityProvider = void 0;
var uuid = __webpack_require__(/*! uuid */ "../../../node_modules/uuid/index.js");
var Q = __webpack_require__(/*! @hivestreaming/q */ "../../../node_modules/@hivestreaming/q/q.js");
var Framework_1 = __webpack_require__(/*! ../Framework */ "../../../core/build/core/src/core/Framework.js");
var Constants_1 = __webpack_require__(/*! ../Constants */ "../../../core/build/core/src/core/Constants.js");
var Identity_1 = __webpack_require__(/*! ./Identity */ "../../../core/build/core/src/core/identity/Identity.js");
var PersistentIdentityProvider = /** @class */ (function () {
    function PersistentIdentityProvider() {
        this.storeName = 'IdentityStore';
        this.dbName = 'IdentityDB';
        this.myId = null;
        if (Framework_1.Framework && Framework_1.Framework.resolve(Framework_1.Framework.Definitions.LOGGER)) {
            this.logger = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.LOGGER).log();
        }
        else {
            this.logger = console;
        }
    }
    PersistentIdentityProvider.prototype.initDB = function () {
        var _this = this;
        var defer = Q.defer();
        if (!indexedDB) {
            this.indexedDB = window.indexedDB || window['mozIndexedDB'] || window['webkitIndexedDB'] || window['msIndexedDB'];
        }
        var open = indexedDB.open(this.dbName);
        open.onupgradeneeded = function () {
            var db = open.result;
            var store = db.createObjectStore(_this.storeName, { keyPath: 'id' });
        };
        open.onsuccess = function () {
            var db = open.result;
            defer.resolve(db);
        };
        open.onerror = function (ev) {
            defer.reject(open.error);
        };
        return defer.promise;
    };
    PersistentIdentityProvider.prototype.getIdentity = function () {
        var _this = this;
        if (this.identityPromise) {
            return this.identityPromise;
        }
        var defer = Q.defer();
        if (!this.myId) {
            if (Constants_1.Constants.USE_PERSISTENT_IDENTITY && this.indexedDB) {
                var persistenceTimer_1 = setTimeout(function () {
                    _this.logger.warn('[HiveComm] timeout retrieving persistent Reporting ID - generating random one');
                    _this.myId = _this.generateUUID();
                    _this.logger.debug('[HiveComm] Generated Reporting UUID: ' + _this.myId);
                    defer.resolve(new Identity_1.Identity(_this.myId));
                }, 4000);
                try {
                    var dbOpen = this.initDB();
                    dbOpen.then(function (db) {
                        var tx = db.transaction(_this.storeName, 'readwrite');
                        var store = tx.objectStore(_this.storeName);
                        var getUUID = store.get('MYID');
                        getUUID.onsuccess = function () {
                            clearTimeout(persistenceTimer_1);
                            if (_this.myId) {
                                defer.resolve(new Identity_1.Identity(_this.myId));
                            }
                            else if (getUUID.result == null || !Constants_1.Constants.USE_PERSISTENT_IDENTITY) {
                                var uuid_1 = _this.generateUUID();
                                // persisting the uuid
                                _this.storeGeneratedUUID(db, uuid_1);
                                defer.resolve(new Identity_1.Identity(_this.myId));
                            }
                            else {
                                var uuid_2 = getUUID.result.value;
                                _this.logger.debug('[HiveComm] Retrieved persistent Reporting UUID: ' + uuid_2);
                                _this.myId = uuid_2;
                                db.close();
                                defer.resolve(new Identity_1.Identity(_this.myId));
                            }
                        };
                        getUUID.onerror = function (e) {
                            clearTimeout(persistenceTimer_1);
                            if (!_this.myId) {
                                _this.logger.warn('[HiveComm] error retrieving persistent Reporting UUID: ' + e);
                                _this.myId = _this.generateUUID();
                                _this.logger.debug('[HiveComm] Generated Reporting UUID: ' + _this.myId);
                            }
                            defer.resolve(new Identity_1.Identity(_this.myId));
                        };
                    }).fail(function (err) {
                        clearTimeout(persistenceTimer_1);
                        if (!_this.myId) {
                            _this.logger.warn('[HiveComm] error opening indexedDB - generating random Reporting ID. Error: ' + err);
                            _this.myId = _this.generateUUID();
                            _this.logger.debug('[HiveComm] Generated Reporting UUID: ' + _this.myId);
                        }
                        defer.resolve(new Identity_1.Identity(_this.myId));
                    });
                }
                catch (e) {
                    // Persistence error
                    this.myId = this.generateUUID();
                    this.logger.debug('[HiveComm] Persistence error - Generate  Reporting UUID: ' + this.myId, e);
                    defer.resolve(new Identity_1.Identity(this.myId));
                }
            }
            else {
                // Persistence disabled
                this.myId = this.generateUUID();
                this.logger.debug('[HiveComm] Persistence disabled - Generate  Reporting UUID: ' + this.myId);
                defer.resolve(new Identity_1.Identity(this.myId));
            }
        }
        else {
            defer.resolve(new Identity_1.Identity(this.myId));
        }
        this.identityPromise = defer.promise;
        return this.identityPromise;
    };
    PersistentIdentityProvider.prototype.storeGeneratedUUID = function (db, uuid) {
        // persisting the uuid
        var tx2 = db.transaction(this.storeName, 'readwrite');
        var store2 = tx2.objectStore(this.storeName);
        store2.put({ id: 'MYID', value: uuid });
        tx2.oncomplete = function () {
            db.close();
        };
        this.logger.debug('[HiveComm] Generated Reporting UUID: ' + uuid);
        this.myId = uuid;
    };
    PersistentIdentityProvider.prototype.generateUUID = function () {
        return uuid.v4();
    };
    return PersistentIdentityProvider;
}());
exports.PersistentIdentityProvider = PersistentIdentityProvider;
var PersistentReportingIdentityProvider = /** @class */ (function (_super) {
    __extends(PersistentReportingIdentityProvider, _super);
    function PersistentReportingIdentityProvider() {
        return _super.call(this) || this;
    }
    PersistentReportingIdentityProvider.prototype.getIdentity = function () {
        var _this = this;
        if (this.reportingIdentityPromise) {
            return this.reportingIdentityPromise;
        }
        var defer = Q.defer();
        _super.prototype.getIdentity.call(this).then(function (identity) {
            // P2PId should be randomly generated. This is used for p2p connections.
            // Especially on multiple streams we need same p2pid and reporting id for peers
            // that are on the same tab. Peers on different tabs should have the same reporting id
            // but different p2p id
            var p2pId = _this.generateUUID();
            var reportingId = identity.getReportingId();
            var newIdentity = new Identity_1.Identity(p2pId, reportingId);
            defer.resolve(newIdentity);
        }).fail(function (err) {
            var uuid = _this.generateUUID();
            var newIdentity = new Identity_1.Identity(uuid);
            defer.resolve(newIdentity);
        });
        this.reportingIdentityPromise = defer.promise;
        return this.reportingIdentityPromise;
    };
    return PersistentReportingIdentityProvider;
}(PersistentIdentityProvider));
exports.PersistentReportingIdentityProvider = PersistentReportingIdentityProvider;
//# sourceMappingURL=PersistentIdentityProvider.js.map

/***/ }),

/***/ "../../../core/build/core/src/core/metadata/MetadataInfo.js":
/*!***********************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/core/metadata/MetadataInfo.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.MetadataInfo = void 0;
__webpack_require__(/*! hivejs-protocol/services/metrics_types */ "../../../protocol/services/metrics_types.js");
var MetadataInfoMetric = hive.snapshots.MetadataInfo;
var Framework_1 = __webpack_require__(/*! ../Framework */ "../../../core/build/core/src/core/Framework.js");
var logger_hive_1 = __webpack_require__(/*! ../../common/logger.hive */ "../../../core/build/core/src/common/logger.hive.js");
var MetadataInfo = /** @class */ (function () {
    function MetadataInfo(timescale, streamMetadata, segments) {
        // Adding this for testing purposes, to  identify ManifestInfo objects
        this[_a] = 'MetadataInfo';
        this.loggerId = '[ MetadataInfo ]';
        this.timestamp = Framework_1.Framework.time();
        this.timescale = timescale;
        this.streamMetadata = streamMetadata;
        if (segments) {
            this.segmentIds = segments;
            this.autogenerated = true;
        }
        else {
            this.segmentIds = new Array();
            this.autogenerated = false;
        }
    }
    MetadataInfo.prototype.addSegment = function (segmentId, popFirst) {
        if (this.segmentIds.indexOf(segmentId) < 0) {
            this.segmentIds.push(segmentId);
            if (popFirst) {
                this.segmentIds.shift();
            }
        }
    };
    MetadataInfo.prototype.setMetadataInfo = function (firstFragment, lastFragment, duration, availableFragments) {
        this.firstFragment = firstFragment;
        this.lastFragment = lastFragment;
        this.avgDuration = duration;
        this.availableFragments = availableFragments;
    };
    MetadataInfo.prototype.updateMetadataInfo = function () {
        if (this.segmentIds.length > 0 && this.firstFragment) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Metadata info set with both list of segments and raw data!', this.loggerId);
            return;
        }
        else if (this.availableFragments === undefined) {
            this.availableFragments = this.segmentIds.length;
            if (this.segmentIds.length > 0) {
                this.firstFragment = this.segmentIds[0];
                this.lastFragment = this.segmentIds[this.segmentIds.length - 1];
            }
            this.avgDuration = this.calculateAvgDuration();
        }
    };
    MetadataInfo.prototype.getMetadataInfoMetric = function () {
        this.updateMetadataInfo();
        var metadataInfo = new MetadataInfoMetric();
        metadataInfo.timestamp = this.timestamp;
        metadataInfo.availableFragments = this.availableFragments;
        metadataInfo.firstFragment = this.firstFragment;
        metadataInfo.lastFragment = this.lastFragment;
        metadataInfo.avgDuration = Math.round(this.avgDuration);
        metadataInfo.trimmedFragments = this.trimmedSegments;
        metadataInfo.autogenerated = this.autogenerated;
        metadataInfo.timescale = this.timescale;
        return metadataInfo;
    };
    MetadataInfo.prototype.calculateAvgDuration = function () {
        var _this = this;
        var durations = 0;
        this.segmentIds.forEach(function (segmentUrl) {
            var segment = _this.streamMetadata.getSegment(segmentUrl);
            if (segment)
                durations += segment.duration.ms();
            else
                logger_hive_1.ErrorMonitor.getInstance().logError('ID in the segments list not found in StreamMetadata', _this.loggerId);
        });
        return Math.round(durations / this.segmentIds.length);
    };
    return MetadataInfo;
}());
exports.MetadataInfo = MetadataInfo;
_a = Symbol.toStringTag;
//# sourceMappingURL=MetadataInfo.js.map

/***/ }),

/***/ "../../../core/build/core/src/core/metadata/MetadataInfoTracker.js":
/*!******************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/core/metadata/MetadataInfoTracker.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __spreadArray = (this && this.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MetadataInfoTracker = void 0;
var MetadataInfo_1 = __webpack_require__(/*! ./MetadataInfo */ "../../../core/build/core/src/core/metadata/MetadataInfo.js");
var MetadataInfoTracker = /** @class */ (function () {
    function MetadataInfoTracker(logger, streamMetadata) {
        this.logger = logger;
        this.metadataInfoList = [];
        this.streamMetadata = streamMetadata;
    }
    MetadataInfoTracker.prototype.reset = function () {
        this.metadataInfoList = [];
    };
    MetadataInfoTracker.prototype.setTimescale = function (timescale) {
        if (this.currentMetadataInfo)
            this.currentMetadataInfo.timescale = timescale;
        else
            this.logger.warn('No MetadataInfo initialized!');
    };
    /**
     * this method generates a new metadataInfo ready to get data from the parsed manifest like:
     * timescale, stream timewindow...
     * In case of DASH, where the manifest is downloaded only once the new metadatainfo is
     * generated based on the info extracted by the fragment download, so we need to duplicate
     * the first previous metadatainfo in order to have a consistent sliding time window
     * @param duplicate {boolean}
     */
    MetadataInfoTracker.prototype.initMetadataInfo = function (duplicate) {
        if (duplicate === void 0) { duplicate = false; }
        var duplicatedSegments = null;
        var timescale = null;
        try {
            if (duplicate) {
                var lastSegments = this.lastMetadataInfo.segmentIds;
                duplicatedSegments = __spreadArray([], lastSegments);
                timescale = this.lastMetadataInfo.timescale;
            }
            this.currentMetadataInfo = new MetadataInfo_1.MetadataInfo(timescale, this.streamMetadata, duplicatedSegments);
        }
        catch (error) {
            this.logger.warn('not able to get last metadata info');
        }
    };
    /**
     * this method adds Segment info on the current active MetadataInfo
     * In case of DASH where the manifest is not downloaded, we want to pop out the first Segment
     * of the duplicated Metadata info (see {@link initMetadataInfo} docs) to keep the sliding
     * timing window behaviour
     * @param segment {@link Segment}
     * @param popFirst {boolean}
     */
    MetadataInfoTracker.prototype.addSegment = function (segmentId, popFirst) {
        if (popFirst === void 0) { popFirst = false; }
        if (this.currentMetadataInfo)
            this.currentMetadataInfo.addSegment(segmentId, popFirst);
        else
            this.logger.warn('No MetadataInfo initialized!');
    };
    MetadataInfoTracker.prototype.setMetadataInfo = function (firstFragment, lastFragment, duration, availableFragments) {
        if (this.currentMetadataInfo)
            this.currentMetadataInfo.setMetadataInfo(firstFragment, lastFragment, duration, availableFragments);
        else
            this.logger.console.warn('No MetdataInfo initialized');
    };
    MetadataInfoTracker.prototype.setTrimmedSegmentCount = function (count) {
        if (this.currentMetadataInfo)
            this.currentMetadataInfo.trimmedSegments = count;
        else
            this.logger.warn('No MetadataInfo initialized!');
    };
    MetadataInfoTracker.prototype.storeCurrentMetadataInfo = function () {
        if (this.currentMetadataInfo) {
            this.metadataInfoList.push(this.currentMetadataInfo);
            this.lastMetadataInfo = this.currentMetadataInfo;
            this.currentMetadataInfo = null;
        }
        else {
            this.logger.warn('No MetadataInfo modified, so nothing was stored');
        }
    };
    MetadataInfoTracker.prototype.getMetrics = function (reset) {
        if (reset === void 0) { reset = true; }
        var cloneMetadataInfo = this.metadataInfoList.map(function (metadataInfo) { return metadataInfo.getMetadataInfoMetric(); });
        if (reset)
            this.reset();
        return cloneMetadataInfo;
    };
    return MetadataInfoTracker;
}());
exports.MetadataInfoTracker = MetadataInfoTracker;
//# sourceMappingURL=MetadataInfoTracker.js.map

/***/ }),

/***/ "../../../core/build/core/src/core/metadata/Segment.js":
/*!******************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/core/metadata/Segment.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Segment = void 0;
var Segment = /** @class */ (function () {
    function Segment(id, qualityLevel, duration, url, absoluteUrl, entityType) {
        this.id = id;
        this.qualityLevel = qualityLevel;
        this.duration = duration;
        this.url = url;
        this.absoluteUrl = absoluteUrl;
        this.entityType = entityType;
    }
    return Segment;
}());
exports.Segment = Segment;
//# sourceMappingURL=Segment.js.map

/***/ }),

/***/ "../../../core/build/core/src/core/metadata/StreamMetadataBase.js":
/*!*****************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/core/metadata/StreamMetadataBase.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.StreamMetadataBase = void 0;
var Framework_1 = __webpack_require__(/*! ../../core/Framework */ "../../../core/build/core/src/core/Framework.js");
var EntityType_1 = __webpack_require__(/*! ../entity/EntityType */ "../../../core/build/core/src/core/entity/EntityType.js");
var MetadataInfoTracker_1 = __webpack_require__(/*! ./MetadataInfoTracker */ "../../../core/build/core/src/core/metadata/MetadataInfoTracker.js");
var Utils = __webpack_require__(/*! ../Utils */ "../../../core/build/core/src/core/Utils.js");
var HashMap = __webpack_require__(/*! @hivestreaming/collections/map */ "../../../node_modules/@hivestreaming/collections/map.js");
var StreamMetadataBase = /** @class */ (function () {
    function StreamMetadataBase(parserOptions, sessionId, hiveTechOptions) {
        this.live = false;
        this.urlToSegment = new HashMap();
        this.qualityLevelToPlaylist = new HashMap();
        this.qualityLevelTracker = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.QUALITY_LEVEL_TRACKER);
        this.parserOptions = parserOptions;
        this.hiveTechOptions = hiveTechOptions;
        this.logger = Framework_1.Framework && Framework_1.Framework.resolve(Framework_1.Framework.Definitions.LOGGER) ?
            Framework_1.Framework.resolve(Framework_1.Framework.Definitions.LOGGER).log(sessionId) : console;
        this.metadataInfoTracker = new MetadataInfoTracker_1.MetadataInfoTracker(this.logger, this);
    }
    StreamMetadataBase.prototype.getManifestUrl = function () {
        return this.manifestUrl;
    };
    StreamMetadataBase.prototype.isLive = function () {
        return this.live;
    };
    StreamMetadataBase.prototype.availableQualityLevels = function (type) {
        return this.qualityLevelTracker.getAll(type);
    };
    StreamMetadataBase.prototype.getMetadataInfo = function () {
        return this.metadataInfoTracker.getMetrics();
    };
    StreamMetadataBase.prototype.setAuthenticationToken = function (token) {
        this.authenticationToken = token;
    };
    StreamMetadataBase.prototype.getQualityLevelTracker = function () {
        return this.qualityLevelTracker;
    };
    StreamMetadataBase.prototype.getSegment = function (segmentId, qualityLevel) {
        if (qualityLevel && this.qualityLevelToPlaylist.has(qualityLevel.id)) {
            var playlist = this.qualityLevelToPlaylist.get(qualityLevel.id);
            return playlist.idToSegment.get(segmentId);
        }
        else if (!qualityLevel) {
            var isAudioOnly_1 = this.qualityLevelToPlaylist.values().every(function (playlist, index) { return playlist.type === EntityType_1.EntityType.AUDIO; });
            var playlist = this.qualityLevelToPlaylist.filter(function (playlist) { return (playlist.type === EntityType_1.EntityType.VIDEO || isAudioOnly_1 || playlist.type === EntityType_1.EntityType.SUBTITLES) && playlist.idToSegment.has(segmentId); });
            return playlist.length > 0 ? playlist.values()[0].idToSegment.get(segmentId) : null;
        }
        return null;
    };
    StreamMetadataBase.prototype.getSegmentInfo = function (url) {
        url = Utils.removeQueryParams(url);
        return this.urlToSegment.get(url);
    };
    StreamMetadataBase.prototype.getNextSegmentInfo = function (url) {
        url = Utils.removeQueryParams(url);
        var segInfo = this.getSegmentInfo(url);
        return segInfo != null ? segInfo.next : null;
    };
    /**
     * Get the entity type.
     *
     * @throws
     * @param url Entity URL
     * @returns Entity type
     */
    StreamMetadataBase.prototype.getEntityType = function (url) {
        // We pass `undefined` for the logger here, because we don't want the
        // warning to show for fragment requests -- this function is called on
        // all HiveCache requests.
        if (this.isManifest(url, undefined)) {
            return EntityType_1.EntityType.METADATA;
        }
        else if (this.isInitialization(url) || this.isSynchronization(url)) {
            return EntityType_1.EntityType.OTHER;
        }
        var segmentInfo = this.getSegmentInfo(url);
        if (segmentInfo) {
            return segmentInfo.entityType;
        }
        throw new Error('Segment not found');
    };
    return StreamMetadataBase;
}());
exports.StreamMetadataBase = StreamMetadataBase;
//# sourceMappingURL=StreamMetadataBase.js.map

/***/ }),

/***/ "../../../core/build/core/src/core/metadata/dash/Dash.js":
/*!********************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/core/metadata/dash/Dash.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Dash = void 0;
var DashWamsMetadata_1 = __webpack_require__(/*! ./DashWamsMetadata */ "../../../core/build/core/src/core/metadata/dash/DashWamsMetadata.js");
var DashWowzaMetadata_1 = __webpack_require__(/*! ./DashWowzaMetadata */ "../../../core/build/core/src/core/metadata/dash/DashWowzaMetadata.js");
var Dash = /** @class */ (function () {
    function Dash() {
    }
    Dash.isValidContext = function (url, logger, regexMatcher) {
        return this.isManifest(url, logger, regexMatcher) || url.indexOf(Dash.FRAGMENT_EXTENSION) != -1;
    };
    Dash.isManifest = function (url, logger, regexMatcher) {
        var match = url.toLowerCase().indexOf(Dash.MANIFEST_EXTENSION.toLowerCase()) != -1 ||
            url.toLowerCase().indexOf(Dash.WOWZA_MANIFEST_EXTENSION.toLowerCase()) != -1;
        if (regexMatcher) {
            if (regexMatcher.test(url)) {
                return true;
            }
            else if (!match && logger) {
                logger.warn(this.loggerId + "Context matcher set to " + regexMatcher + " failed against " + url);
            }
        }
        return match;
    };
    Dash.isSegmentTemplate = function (manifest, url) {
        var matches = url.replace('_definst_/', '').match(new RegExp(manifest.replace('.mpd', '') + Dash.WOWZA_SEGMENT_TEMPLATE));
        return matches && matches.length > 0;
    };
    Dash.createMetadata = function (url, parserOptions, sessionId, hiveTechOptions) {
        return url.indexOf(Dash.WOWZA_MANIFEST_EXTENSION) > 0 ?
            new DashWowzaMetadata_1.DashWowzaMetadata(parserOptions, sessionId, hiveTechOptions) :
            new DashWamsMetadata_1.DashWamsMetadata(parserOptions, sessionId, hiveTechOptions);
    };
    Dash.loggerId = '[DASH] ';
    Dash.DASH_REQUEST_DISPERSION = 1;
    Dash.DASH_MINIMUM_FRAGMENTS_TO_INFER_BUFFERING = 2;
    Dash.DASH_DEFAULT_FRAGMENT_DURATION = 2000;
    Dash.DASH_MAX_PREFETCH_DISTANCE = 30000;
    Dash.DASH_MINIMUM_PREFETCH_DISTANCE = 10000;
    /**
     * Enable fragment decryption if supported.
     * Attempt to decrypt fragments is fundamental to ( the duration to calculate next fragment
     * for prefetch. If not active the peer will be forced to frequently download the manifest
     * to know the next fragments to prefetch, and anyhow  won't be able to prefetch fragments already on
     * the CDN but not yet advertised in the manifest (on WAMS usually 4/5 fragments).
     * @type {boolean}
     * @default true
     */
    Dash.DASH_DECRYPT = true;
    /**
     * Enable the frequent download of manifest to update the fragment list in case a stream is
     * encrypted and we cannot decrypt fragments (disabled/unsupported encryption/error decrypting).
     *
     * If set to false, and the decryption is not active/supported, the prefetch will not work anymore.
     *
     * @type {boolean}
     * @default true
     */
    Dash.DASH_METADATA_PREFETCH = true;
    Dash.DASH_METADATA_PREFETCH_ADJUST = 500;
    // seconds to trim for a $Number$-based manifest (eg. West Studio DASH)
    Dash.DASH_METADATA_NUMBER_TRIM = 16;
    // minimum fragments to keep in the manifest when trimming
    Dash.DASH_METADATA_NUMBER_MIN_FRAGMENTS = 3;
    // seconds to trim
    Dash.DASH_METADATA_TRIM = 10;
    // minimum fragments to keep in the manifest when trimming
    Dash.DASH_METADATA_MIN_FRAGMENTS = 3;
    Dash.MANIFEST_EXTENSION = '(format=mpd-time-csf)';
    Dash.WOWZA_MANIFEST_EXTENSION = '.mpd';
    Dash.WOWZA_SEGMENT_TEMPLATE = '_.*.mpd';
    Dash.FRAGMENT_EXTENSION = '.m4s';
    Dash.MANIFEST_COMMON_END = '.ism/';
    return Dash;
}());
exports.Dash = Dash;
//# sourceMappingURL=Dash.js.map

/***/ }),

/***/ "../../../core/build/core/src/core/metadata/dash/DashBitrateFilter.js":
/*!*********************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/core/metadata/dash/DashBitrateFilter.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.DashBitrateFilter = void 0;
var EntityType_1 = __webpack_require__(/*! ../../entity/EntityType */ "../../../core/build/core/src/core/entity/EntityType.js");
var Framework_1 = __webpack_require__(/*! ../../Framework */ "../../../core/build/core/src/core/Framework.js");
var DashBitrateFilter = /** @class */ (function () {
    function DashBitrateFilter(indexesToKeep, removeResolution, qualityLevelTracker) {
        var _this = this;
        /**
         * Takes the sorted index of the quality level as input (the quality level tracker sorts all
         * quality levels and assigns indexes in ascending order) and checks if the index
         * is in the list of indexes to be kept.
         *
         * @param sortedIndex - sorted index of the representation from the Quality Level tracker
         * @param bandwidth - Advertised bandwidth from the representation
         * @returns - Check if the representation should be removed or not
         */
        this.filterByIndex = function (sortedIndex, bandwidth) {
            return _this.indexesToKeep && !_this.indexesToKeep.includes(sortedIndex);
        };
        /**
         * Checks if the advertised bandwidth is higher than the max allowed bitrate set through
         * remote config
         *
         * @param sortedIndex - sorted index of the representation from the Quality Level tracker
         * @param bandwidth - Advertised bandwidth from the representation
         * @returns - Check if the representation should be removed or not
         */
        this.filterByBandwidth = function (sortedIndex, bandwidth) {
            return bandwidth > _this.maxBandwidth;
        };
        this.logger = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.LOGGER).log();
        this.configStore = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.CONFIG_STORE);
        this.qualityLevelTracker = qualityLevelTracker;
        this.indexesToKeep = indexesToKeep;
        this.removeResolution = removeResolution;
        this.maxBandwidth = 0;
    }
    DashBitrateFilter.prototype.setBitrateFilter = function () {
        if (this.indexesToKeep && this.indexesToKeep.length > 0)
            return this.filterByIndex;
        this.maxBandwidth = this.configStore.getConfig('stream.maxBandwidth');
        if (this.maxBandwidth) {
            return this.filterByBandwidth;
        }
        return null;
    };
    /**
     * This function filters out representations if the filter condition is met. The condition is
     * either based on a list of indexes to be kept or a maximum bandwidth that is allowed
     *
     * @param representations - array of representations present in the current AdaptationSet
     * @param removeSize - boolean indicating whether to remove width and height from the representation
     */
    DashBitrateFilter.prototype.filter = function (representations) {
        var shouldFilterBitrates = this.setBitrateFilter();
        var removeResolution = this.removeResolution || this.configStore.getConfig('stream.removeResolution');
        var bitrateIndexes = this.qualityLevelTracker.getBitrateIndexes(EntityType_1.EntityType.VIDEO);
        var keptQualityIds = [];
        representations.sort(function (r1, r2) {
            return bitrateIndexes.get(r1._id) - bitrateIndexes.get(r2._id);
        });
        for (var i = representations.length - 1; i >= 0; i--) {
            // remove the video dimensions for silent testing
            if (removeResolution) {
                delete representations[i]._width;
                delete representations[i]._height;
            }
            if (!shouldFilterBitrates)
                continue;
            // remove the quality levels
            var _a = representations[i], _id = _a._id, _bandwidth = _a._bandwidth;
            var sortedIndex = bitrateIndexes.get(_id);
            if (shouldFilterBitrates(sortedIndex, _bandwidth) && representations.length > 1) {
                representations.splice(i, 1);
                this.qualityLevelTracker.setQualityLevelFlitered(_id);
            }
            else
                keptQualityIds.push(_id);
        }
        this.logger.debug('DASH filtered-in quality levels: ' + keptQualityIds.reverse().join(', ') + ' - removed size: ' + removeResolution);
    };
    DashBitrateFilter.prototype.getContent = function () {
        return null;
    };
    return DashBitrateFilter;
}());
exports.DashBitrateFilter = DashBitrateFilter;
//# sourceMappingURL=DashBitrateFilter.js.map

/***/ }),

/***/ "../../../core/build/core/src/core/metadata/dash/DashMetadata.js":
/*!****************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/core/metadata/dash/DashMetadata.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.DashMetadata = void 0;
var DashParser_1 = __webpack_require__(/*! @hivestreaming/dashjs/build/es5/src/dash/parser/DashParser */ "../../../node_modules/@hivestreaming/dashjs/build/es5/src/dash/parser/DashParser.js");
var codem_isoboxer_1 = __webpack_require__(/*! @hivestreaming/codem-isoboxer */ "../../../node_modules/@hivestreaming/codem-isoboxer/dist/iso_boxer.js");
var xml2json_1 = __webpack_require__(/*! @hivestreaming/dashjs/build/es5/externals/xml2json */ "../../../node_modules/@hivestreaming/dashjs/build/es5/externals/xml2json.js");
var Framework_1 = __webpack_require__(/*! ../../Framework */ "../../../core/build/core/src/core/Framework.js");
var Representation_1 = __webpack_require__(/*! ./Representation */ "../../../core/build/core/src/core/metadata/dash/Representation.js");
var EntityType_1 = __webpack_require__(/*! ../../entity/EntityType */ "../../../core/build/core/src/core/entity/EntityType.js");
var Segment_1 = __webpack_require__(/*! ../Segment */ "../../../core/build/core/src/core/metadata/Segment.js");
var DashAesManager_1 = __webpack_require__(/*! ./decrypter/DashAesManager */ "../../../core/build/core/src/core/metadata/dash/decrypter/DashAesManager.js");
var DashUnsupportedDecryptManager_1 = __webpack_require__(/*! ./decrypter/DashUnsupportedDecryptManager */ "../../../core/build/core/src/core/metadata/dash/decrypter/DashUnsupportedDecryptManager.js");
var Dash_1 = __webpack_require__(/*! ./Dash */ "../../../core/build/core/src/core/metadata/dash/Dash.js");
var ClientConfigs_1 = __webpack_require__(/*! ../../../webrtc/ClientConfigs */ "../../../core/build/core/src/webrtc/ClientConfigs.js");
var logger_hive_1 = __webpack_require__(/*! ../../../common/logger.hive */ "../../../core/build/core/src/common/logger.hive.js");
var ErrorCodes = __webpack_require__(/*! ../../../common/error.hive */ "../../../core/build/core/src/common/error.hive.js");
var sprintf_js_1 = __webpack_require__(/*! sprintf-js */ "../../../node_modules/sprintf-js/src/sprintf.js");
var Utils = __webpack_require__(/*! ../../Utils */ "../../../core/build/core/src/core/Utils.js");
var parse_xsd_duration_1 = __webpack_require__(/*! parse-xsd-duration */ "../../../node_modules/parse-xsd-duration/dist/index.js");
var StreamMetadataBase_1 = __webpack_require__(/*! ../StreamMetadataBase */ "../../../core/build/core/src/core/metadata/StreamMetadataBase.js");
var DashBitrateFilter_1 = __webpack_require__(/*! ./DashBitrateFilter */ "../../../core/build/core/src/core/metadata/dash/DashBitrateFilter.js");
var TimeDuration_1 = __webpack_require__(/*! ../../../common/utils/TimeDuration */ "../../../core/build/core/src/common/utils/TimeDuration.js");
var DashMetadata = /** @class */ (function (_super) {
    __extends(DashMetadata, _super);
    function DashMetadata(parserOptions, sessionId, hiveTechOptions) {
        var _this = _super.call(this, parserOptions, sessionId, hiveTechOptions) || this;
        _this.loggerId = '[DASH METADATA] ';
        _this.numericRepresentation = false;
        var indexesToKeep = _this.parseQualityLevelsToFilter() || [];
        _this.bitrateFilter = new DashBitrateFilter_1.DashBitrateFilter(indexesToKeep, ClientConfigs_1.HiveConfig.Dash.DashRemoveBitrateSize, _this.qualityLevelTracker);
        _this.parser = DashParser_1.default().create();
        return _this;
    }
    DashMetadata.prototype.getStreamProtocol = function () {
        return StreamProtocol.DASH;
    };
    DashMetadata.prototype.isManifest = function (url, logger) {
        var matcher = this.hiveTechOptions && this.hiveTechOptions.contextMatcher && this.hiveTechOptions.contextMatcher.dash;
        return Dash_1.Dash.isManifest(url, logger, matcher);
    };
    DashMetadata.prototype.parseBaseUrl = function (url) {
        var base = '';
        if (url.indexOf('/') !== -1) {
            if (url.indexOf('?') !== -1) {
                url = url.substring(0, url.indexOf('?'));
            }
            base = url.substring(0, url.lastIndexOf('/') + 1);
        }
        return base;
    };
    DashMetadata.prototype.parse = function (url, content, prefetch) {
        var _this = this;
        try {
            this.metadataInfoTracker.initMetadataInfo();
            this.manifestUrl = url;
            this.manifest = this.parser.parse(content);
            var baseUrl_1 = this.manifest.hasOwnProperty('Location') ? this.parseBaseUrl(this.manifest.Location) : this.parseBaseUrl(this.manifestUrl);
            if (this.manifest.hasOwnProperty('BaseURL')) {
                if (baseUrl_1 !== this.manifest.BaseURL.toString())
                    baseUrl_1 += this.manifest.BaseURL;
            }
            this.live = this.manifest.type === 'static' ? false : true;
            var period_1 = this.manifest.Period_asArray[0];
            var availabilityStartTime_1 = this.manifest.availabilityStartTime;
            if (period_1.AdaptationSet_asArray) {
                var isAudioOnly_1 = period_1.AdaptationSet_asArray.every(function (adaptation) {
                    var mimeType = adaptation.mimeType ? adaptation.mimeType : adaptation.Representation_asArray[0].mimeType;
                    var entityType = _this.getPlaylistType(mimeType);
                    return entityType == EntityType_1.EntityType.AUDIO;
                });
                period_1.AdaptationSet_asArray.forEach(function (adaptation) {
                    // extract if video or audio adaptation
                    var mimeType = adaptation.mimeType ? adaptation.mimeType : adaptation.Representation_asArray[0].mimeType;
                    var entityType = _this.getPlaylistType(mimeType);
                    if (entityType === EntityType_1.EntityType.VIDEO && adaptation.ContentProtection) {
                        _this.initProtection(adaptation.ContentProtection);
                    }
                    // the segmentTemplate might be both on the adaption or on each representation
                    var generalTemplate = adaptation.SegmentTemplate;
                    adaptation.Representation_asArray && adaptation.Representation_asArray.forEach(function (representation) {
                        var qualityLevel = _this.qualityLevelTracker.add(entityType, {
                            id: representation.id,
                            bitrate: parseInt(representation.bandwidth),
                            width: representation.width,
                            height: representation.height,
                            label: representation.label
                        });
                        var isExisting = _this.qualityLevelToPlaylist.has(representation.id);
                        var representationInt = isExisting ? _this.qualityLevelToPlaylist.get(representation.id) : new Representation_1.Representation();
                        // the segmentTemplate on the representation takes precedence over the adaptation one
                        var segmentTemplate = representation.SegmentTemplate ? representation.SegmentTemplate : generalTemplate;
                        representationInt.type = entityType;
                        representationInt.qualityLevel = qualityLevel;
                        representationInt.timescale = parseInt(segmentTemplate.timescale) || 1;
                        if (entityType === EntityType_1.EntityType.VIDEO || isAudioOnly_1)
                            _this.metadataInfoTracker.setTimescale(representationInt.timescale);
                        representationInt.representationId = representation.id;
                        // BANDWIDTH_TAG is used by AMP DASH stream, instead REPRESENTATION_ID is used by the Wowza DASH
                        representationInt.initialization = (adaptation === null || adaptation === void 0 ? void 0 : adaptation.BaseURL) ? baseUrl_1 + '' + (adaptation === null || adaptation === void 0 ? void 0 : adaptation.BaseURL) + segmentTemplate.initialization : baseUrl_1 + '' + segmentTemplate.initialization;
                        representationInt.initialization = representationInt.initialization.replace(DashMetadata.BANDWIDTH_TAG, '' + representationInt.qualityLevel.bitrate);
                        representationInt.initialization = representationInt.initialization.replace(DashMetadata.REPRESENTATION_ID, '' + representationInt.representationId);
                        representationInt.initialization = Utils.relToAbsUrl(representationInt.initialization);
                        representationInt.mediaTemplate = (adaptation === null || adaptation === void 0 ? void 0 : adaptation.BaseURL) ? baseUrl_1 + '' + (adaptation === null || adaptation === void 0 ? void 0 : adaptation.BaseURL) + segmentTemplate.media : baseUrl_1 + '' + segmentTemplate.media;
                        representationInt.mediaTemplate = representationInt.mediaTemplate.replace(DashMetadata.BANDWIDTH_TAG, '' + representationInt.qualityLevel.bitrate);
                        representationInt.mediaTemplate = representationInt.mediaTemplate.replace(DashMetadata.REPRESENTATION_ID, '' + representationInt.representationId);
                        representationInt.mediaTemplate = Utils.relToAbsUrl(representationInt.mediaTemplate);
                        // generate the segment RegExp from the template
                        representationInt.mediaPattern = _this.getRepresentationPattern(Utils.removeQueryParams(representationInt.mediaTemplate));
                        // if it's a numerical template (West Dash) extract start duration, umber and period
                        if (representationInt.mediaTemplate.match(DashMetadata.NUMBER_TAG)) {
                            representationInt.segmentTemplateDuration = parseInt(segmentTemplate.duration);
                            if (!representationInt.segmentTemplateDuration) {
                                throw new Error('Expected duration on SegmentTemplate for Number-based template');
                            }
                            representationInt.startNumber = parseInt(segmentTemplate.startNumber) || 0;
                            representationInt.periodStart = parseInt(period_1.start) || 0;
                            var now = Framework_1.Framework.time();
                            var fragmentDuration = (representationInt.segmentTemplateDuration / representationInt.timescale) * 1000;
                            var lastFragmentAvailable = Math.floor((now - (new Date(availabilityStartTime_1).getTime() + period_1.start * 1000)) / fragmentDuration);
                            _this.metadataInfoTracker.setMetadataInfo(representationInt.startNumber, lastFragmentAvailable, representationInt.segmentTemplateDuration, (lastFragmentAvailable - representationInt.startNumber));
                            _this.numericRepresentation = true;
                        }
                        else {
                            // extract the segments urls and ids
                            _this.extractTs(segmentTemplate.SegmentTimeline_asArray[0].S_asArray, representationInt, isAudioOnly_1);
                        }
                        if (!isExisting) {
                            _this.qualityLevelToPlaylist.set(qualityLevel.id, representationInt);
                        }
                    });
                });
            }
            var parsedManifest = this.parserOptions.regenerate && this.getEntityType(url) !== EntityType_1.EntityType.SUBTITLES ? this.regenerateManifest(content, prefetch) : content;
            this.metadataInfoTracker.storeCurrentMetadataInfo();
            return parsedManifest;
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error parsing the metadata', this.loggerId, ErrorCodes.DASH_METADATA_CODES.PARSE_METADATA, error);
            throw new Error(error);
        }
    };
    /**
     * extract a RegExp pattern from the mediaSegment Template that can be
     * used to match fragment urls to representations
     * TODO: handle comas in time and number
     */
    DashMetadata.prototype.getRepresentationPattern = function (segmentTemplate) {
        var representationPattern = segmentTemplate.replace(/[|\\{}()[\]^$+*?.]/g, '\\$&');
        /* In West manifests the segment template looks like: "$RepresentationID$/$Number%05d$.m4v"
        So we try to transform that $Number%05d$ to a regex like (\d{5}) */
        var match = representationPattern.match(/\\\$Number%(\d+)d\\\$/);
        if (match)
            representationPattern = representationPattern.replace('\\$Number%' + match[1] + 'd\\$', '(\\d{' + parseInt(match[1]) + '})');
        representationPattern = representationPattern.replace('\\$Time\\$', '([0-9]*)');
        representationPattern = representationPattern.replace('\\$Number\\$', '([0-9]*)');
        var regexPattern = new RegExp(representationPattern, 'i');
        return regexPattern;
    };
    DashMetadata.prototype.extractTs = function (segmentTimeLine, representation, isAudioOnly) {
        var _this = this;
        if (isAudioOnly === void 0) { isAudioOnly = false; }
        try {
            var mediaTemplate_1 = representation.mediaTemplate, qualityLevel_1 = representation.qualityLevel, type_1 = representation.type, idToSegment_1 = representation.idToSegment;
            var prevSegment_1;
            var trySegment_1 = function (id, qualityLevel, duration, timescale, uri, absoluteUrl, entityType) {
                var segment;
                if (idToSegment_1.has(id)) {
                    segment = idToSegment_1.get(id);
                }
                else {
                    var timeDuration = new TimeDuration_1.TimeDuration(duration, timescale);
                    segment = new Segment_1.Segment(id, qualityLevel, timeDuration, uri, absoluteUrl, entityType);
                    var urlNoQueryParams = Utils.removeQueryParams(uri);
                    _this.urlToSegment.set(urlNoQueryParams, segment);
                    idToSegment_1.set(id, segment);
                }
                if (prevSegment_1)
                    prevSegment_1.next = segment;
                prevSegment_1 = segment;
                if (type_1 === EntityType_1.EntityType.VIDEO || isAudioOnly) {
                    /** This must be done even for already found fragments. The
                     * MetadataInfoTracker must have knowledge of everything
                     * within this metadata. */
                    _this.metadataInfoTracker.addSegment(segment.id);
                }
            };
            var ts_1 = 0;
            var previousDuration_1 = 0;
            segmentTimeLine.forEach(function (v) {
                if (v.d) {
                    // if is the first fragment, see if it has a timestamp
                    if (v.t)
                        ts_1 = parseInt(v.t);
                    else
                        ts_1 += previousDuration_1;
                    var currentDuration = parseInt(v.d);
                    var uri = mediaTemplate_1.replace(DashMetadata.TIME_TAG, ts_1 + '');
                    trySegment_1(ts_1, qualityLevel_1, currentDuration, representation.timescale, uri, uri, type_1);
                    // we check if there are more repetitions of this fragment
                    var count = 0;
                    if (v.r)
                        count = parseInt(v.r);
                    for (var j = 0; j < count; j++) {
                        ts_1 += currentDuration;
                        var uri_1 = mediaTemplate_1.replace(DashMetadata.TIME_TAG, ts_1 + '');
                        trySegment_1(ts_1, qualityLevel_1, currentDuration, representation.timescale, uri_1, uri_1, type_1);
                    }
                    previousDuration_1 = currentDuration;
                }
            });
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error extracting segment maps', this.loggerId, ErrorCodes.DASH_METADATA_CODES.EXTRACT_SEGMENT_MAPS, error);
            throw new Error(error);
        }
    };
    /**
     * initialize the protection manager
     * currently we support only AES-128
     */
    DashMetadata.prototype.initProtection = function (contentProtection) {
        try {
            if (contentProtection) {
                if (contentProtection.CryptoPeriod) {
                    // instantiate the protectionManager
                    var cryptoPeriod = contentProtection.CryptoPeriod;
                    if (!this.protection || (this.protection.isFailed() || !(this.protection instanceof DashAesManager_1.DashAesManager)))
                        this.protection = new DashAesManager_1.DashAesManager(cryptoPeriod.keyUriTemplate, cryptoPeriod.IV, this.authenticationToken);
                }
                else {
                    // unsupported encryption
                    if (!this.protection || !(this.protection instanceof DashUnsupportedDecryptManager_1.DashUnsupportedDecryptManager))
                        this.protection = new DashUnsupportedDecryptManager_1.DashUnsupportedDecryptManager();
                }
                // if the decryption is enabled, init the protectionManager
                if (this.protection && Dash_1.Dash.DASH_DECRYPT)
                    this.protection.init();
            }
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error initializing the protection', this.loggerId, ErrorCodes.DASH_METADATA_CODES.INIT_PROTECTION, error);
            throw new Error(error);
        }
    };
    DashMetadata.prototype.getRepresentation = function (url) {
        url = Utils.removeQueryParams(url);
        return this.qualityLevelToPlaylist.values().find(function (representation) { return representation.mediaPattern.test(url); });
    };
    DashMetadata.prototype.getSegmentInfo = function (url) {
        url = Utils.removeQueryParams(url);
        var segment = _super.prototype.getSegmentInfo.call(this, url);
        if (segment) {
            return segment;
        }
        try {
            var representation = this.getRepresentation(url);
            if (representation) {
                var matches = url.match(representation.mediaPattern);
                if (matches) {
                    var segmentId = parseInt(matches[1]);
                    return this.getSegment(segmentId, representation.qualityLevel);
                }
            }
            throw new Error("No representation for " + url);
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error getting the segment info', this.loggerId, ErrorCodes.DASH_METADATA_CODES.GET_SEGMENT_INFO, error);
            return null;
        }
    };
    DashMetadata.prototype.getEntityType = function (url) {
        try {
            return _super.prototype.getEntityType.call(this, url);
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error getting the entity type based on a url', this.loggerId, ErrorCodes.DASH_CONTEXT_CODES.GET_ENTITY_TYPE, {
                detailedError: error,
                url: url
            });
            return EntityType_1.EntityType.OTHER;
        }
    };
    DashMetadata.prototype.getTimescale = function (url) {
        url = Utils.removeQueryParams(url);
        try {
            var representation = this.getRepresentation(url);
            return representation.timescale;
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error getting the representation for timescale', this.loggerId, ErrorCodes.DASH_METADATA_CODES.GET_SEGMENT_DISTANCE, error);
            return 10000;
        }
    };
    DashMetadata.prototype.isInitialization = function (url) {
        url = Utils.removeQueryParams(url);
        return this.qualityLevelToPlaylist.values().some(function (r) { return Utils.removeQueryParams(r.initialization) === url; });
    };
    DashMetadata.prototype.isSynchronization = function (url) {
        if (this.manifest.hasOwnProperty('UTCTiming')) {
            return this.manifest.UTCTiming.value === url;
        }
        return false;
    };
    DashMetadata.prototype.getAvailability = function (segmentId, qualityLevel) {
        var representation = this.qualityLevelToPlaylist.get(qualityLevel.id);
        if (representation) {
            /**
             * The "old" way, where the representation has a static list of segments. If it was previously parsed, the static
             * list only constaints segments that already exist
             */
            if (representation.idToSegment.length) {
                return 1;
            }
            else {
                /**
                 * Based on the details in section 4.3.2.2, the Segment Information is derived as:
                 *    k1 = 1
                 *    k2 = ceil(PDURATION/SDURATION)
                 *    for k = 1, ..., k2
                 *       o SAST[k] = START + PSTART + k*SDURATION
                 *       o SAET[k] = SAST[k] + TSB + SDURATION
                 */
                var now = Framework_1.Framework.time();
                var durationInMillis = (representation.segmentTemplateDuration / representation.timescale) * 1000;
                var availabilityStart = this.manifest.availabilityStartTime.getTime() +
                    (this.manifest.Period.start || 0) +
                    (segmentId - representation.startNumber + 1) * durationInMillis;
                return Math.max(1, availabilityStart - now);
            }
        }
        return 1;
    };
    DashMetadata.prototype.segmentDistance = function (previousSegmentId, previousSegmentQualityLevel, currentSegmentId, currentSegmentQualityLevel) {
        try {
            var representation = this.qualityLevelToPlaylist.get(currentSegmentQualityLevel.id);
            if (representation) {
                if (representation.idToSegment.has(previousSegmentId) && representation.idToSegment.has(currentSegmentId)) {
                    var previousSegment = representation.idToSegment.get(previousSegmentId);
                    var currentSegment = representation.idToSegment.get(currentSegmentId);
                    var distance = 0;
                    var nextSegment = previousSegment;
                    while (nextSegment && nextSegment != currentSegment) {
                        distance += nextSegment.duration.ms();
                        nextSegment = nextSegment.next;
                    }
                    return distance;
                }
                else {
                    if (representation.segmentTemplateDuration) {
                        return (currentSegmentId - previousSegmentId) * representation.segmentTemplateDuration / representation.timescale * 1000;
                    }
                }
            }
            return 0;
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error extracting the segment distance', this.loggerId, ErrorCodes.DASH_METADATA_CODES.GET_SEGMENT_DISTANCE, error);
            return 0;
        }
    };
    /**
     * extract duration logic for MP4 fragments
     *
     * parse the buffer into ISO boxes and fetch tfhd and trun.
     * in video fragments 'trun' box contains a list of 'samples' (frames) and each sample
     * has his own 'sample_duration'. So just loop and sum it up.
     *
     * In audio fragments instead the 'tfhd' box defines the fix 'default_sample_duration'
     * while the 'trun' 'samples' only define the number of samples. So just
     * multiply the number of samples for the default duration.
     *
     */
    DashMetadata.prototype.extractDuration = function (buffer) {
        try {
            if (buffer instanceof Uint8Array)
                buffer = buffer.buffer;
            var parsedFile = codem_isoboxer_1.parseBuffer(buffer);
            var tfhdBox = parsedFile.fetch('tfhd');
            var trunBox = parsedFile.fetch('trun');
            var defaultSampleDuration = tfhdBox ? tfhdBox.default_sample_duration : 0;
            if (trunBox) {
                var duration_1 = 0;
                trunBox.samples.forEach(function (sample) {
                    duration_1 += sample.sample_duration;
                });
                if (isNaN(duration_1) && defaultSampleDuration > 0)
                    duration_1 = defaultSampleDuration * trunBox.samples.length;
                return duration_1;
            }
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error extracting duration from the buffer', this.loggerId, ErrorCodes.DASH_METADATA_CODES.EXTRACT_DURATION, error);
            return 0;
        }
    };
    DashMetadata.prototype.regenerateManifest = function (originalManifest, isPrefetch) {
        if (!isPrefetch && this.live) {
            try {
                // preserve xml declaration
                var xmlDeclarationMatch = originalManifest.match(/^<\?xml\s[^?]+\?>/);
                // parse the xml into a json
                var x2js = new xml2json_1.default({
                    escapeMode: true,
                    useDoubleQuotes: true,
                    arrayAccessForm: 'property'
                });
                var manifest = x2js.xml_str2json(originalManifest);
                // trim the live fragments
                if (this.live)
                    this.trimFragments(manifest);
                // filter quality levels
                this.filterQualityLevels(manifest);
                var regeneratedManifest = x2js.json2xml_str(manifest);
                if (xmlDeclarationMatch) {
                    regeneratedManifest = xmlDeclarationMatch[0] + regeneratedManifest;
                }
                return regeneratedManifest;
            }
            catch (error) {
                this.logger.error(error);
            }
        }
        return originalManifest;
    };
    // if Hive webRTC the options will have the maxmimumTrimming (when set) and it will be used
    // to override the default trimming values
    DashMetadata.prototype.getTrimmingValues = function () {
        var hivejsOptions = this.hiveTechOptions;
        if (hivejsOptions && hivejsOptions.maximumTrimming && hivejsOptions.maximumTrimming.dash)
            return { dashMetadataTrim: hivejsOptions.maximumTrimming.dash, dashMetadataNumberTrim: hivejsOptions.maximumTrimming.dash };
        return { dashMetadataTrim: Dash_1.Dash.DASH_METADATA_TRIM, dashMetadataNumberTrim: Dash_1.Dash.DASH_METADATA_NUMBER_TRIM };
    };
    DashMetadata.prototype.trimFragments = function (manifest) {
        var _this = this;
        // minimum fragments to keep in the manifest
        var toKeep = Math.max(1, Dash_1.Dash.DASH_METADATA_MIN_FRAGMENTS);
        var _a = this.getTrimmingValues(), dashMetadataTrim = _a.dashMetadataTrim, dashMetadataNumberTrim = _a.dashMetadataNumberTrim;
        // minimum seconds to trim away
        var secondsToRemove = Math.max(1, dashMetadataTrim);
        var trimmedResults = [];
        // counters of removed fragments and total durations
        var count = 0;
        var removedDuration = 0;
        var handledNumberTemplate = false;
        // access the MPD.Period.AdaptationSet video and try to trim the known template structures
        if (manifest.MPD && manifest.MPD.Period && manifest.MPD.Period.AdaptationSet_asArray) {
            manifest.MPD.Period.AdaptationSet_asArray.forEach(function (adaptationSet) {
                if (handledNumberTemplate)
                    return;
                /**
                 * Intrado's new version of DASH has manifest ordered as AdaptationSet -> Representation -> SegmentTemplate
                 * while the old number templates use AdaptationSet -> SegmentTemplate
                 */
                var segmentTemplate = adaptationSet.SegmentTemplate;
                if (adaptationSet.Representation && adaptationSet.Representation.SegmentTemplate)
                    segmentTemplate = adaptationSet.Representation.SegmentTemplate;
                if ((segmentTemplate && segmentTemplate._media && segmentTemplate._media.match(DashMetadata.NUMBER_TAG))) {
                    // first we check if it's a number template (i.e. West Dash)
                    handledNumberTemplate = true;
                    var now = Framework_1.Framework.time();
                    manifest.MPD.Period._start = manifest.MPD.Period._start || 'PT0S';
                    var orig = manifest.MPD.Period._start;
                    var period = parse_xsd_duration_1.default(orig);
                    var timescale = parseInt(segmentTemplate._timescale) || 1;
                    var fragmentDuration = (parseInt(segmentTemplate._duration) / timescale) * 1000;
                    var lastFragmentAvailable = Math.floor((now - (new Date(manifest.MPD._availabilityStartTime).getTime() + period * 1000)) / fragmentDuration);
                    // Calculate number of available fragments, _excluding_ the DASH_METADATA_NUMBER_MIN_FRAGMENTS
                    var availableFragmentsToRemove = Math.max(0, lastFragmentAvailable - Dash_1.Dash.DASH_METADATA_NUMBER_MIN_FRAGMENTS);
                    var wishfulNumFragsToRemove = Math.ceil(dashMetadataNumberTrim * 1000 / fragmentDuration);
                    var removableFragments = Math.max(0, Math.min(availableFragmentsToRemove, wishfulNumFragsToRemove));
                    _this.metadataInfoTracker.setTrimmedSegmentCount(removableFragments);
                    var secondsToRemove_1 = removableFragments > 0 ? ((removableFragments) * fragmentDuration) / 1000 : 0;
                    try {
                        manifest.MPD.Period._start = "PT" + (period + secondsToRemove_1) + "S";
                        _this.logger.debug("Trimmed " + secondsToRemove_1 + " from period start " + orig + " => " + manifest.MPD.Period._start);
                    }
                    catch (error) {
                        _this.logger.warn("Could not modify period: " + error);
                    }
                }
                else if (_this.isVideoSegmentTemplate(adaptationSet) && adaptationSet.Representation_asArray) {
                    // WAMS case, segment timeline in the adaptation
                    var trimmed_1 = _this.trimSegmentTimeline(adaptationSet.SegmentTemplate, secondsToRemove, toKeep);
                    adaptationSet.Representation_asArray.forEach(function (representation) {
                        trimmed_1.bandwidth = parseInt(representation._bandwidth) || 0;
                        trimmedResults.push(trimmed_1);
                    });
                }
                else if (adaptationSet.Representation_asArray && adaptationSet.Representation_asArray.length > 0) {
                    // possibly Facebook Live case, segment timeline in each representation
                    adaptationSet.Representation_asArray.forEach(function (representation) {
                        if (_this.isVideoRepresentationSegmentTemplate(representation)) {
                            var trimmed = _this.trimSegmentTimeline(representation.SegmentTemplate, secondsToRemove, toKeep);
                            trimmed.bandwidth = parseInt(representation._bandwidth) || 0;
                            trimmedResults.push(trimmed);
                        }
                    });
                }
            });
        }
        return manifest;
    };
    /** Check if a representation is a video representation
     * @param  {any} representation
     */
    DashMetadata.prototype.isVideoRepresentationSegmentTemplate = function (representation) {
        return representation && (representation._mimeType === 'video/mp4' ||
            representation._contentType === 'video' ||
            (representation.SegmentTemplate && representation.SegmentTemplate._media && representation.SegmentTemplate._media.indexOf('video') > -1));
    };
    DashMetadata.prototype.trimSegmentTimeline = function (segmentTemplate, secondsToRemove, toKeep) {
        // counters of removed fragments and total durations
        var count = 0;
        var removedDuration = 0;
        var timeline = segmentTemplate.SegmentTimeline.S_asArray;
        // read the timescale and update total time to remove
        var timescale = parseInt(segmentTemplate._timescale);
        var timeToRemove = secondsToRemove * timescale;
        // first step, calculate the last segment index + repetition to keep
        // starting from the beginning
        var lastToKeep = 0;
        var lastRepetitionToKeep = 0;
        for (var i = 0; i < timeline.length; i++) {
            if (toKeep > 0) {
                var segment = timeline[i];
                lastToKeep = i;
                var r = segment._r ? parseInt(segment._r) : 1;
                if (r > toKeep) {
                    lastRepetitionToKeep = toKeep;
                    toKeep = 0;
                }
                else {
                    toKeep -= r;
                    lastRepetitionToKeep = r;
                }
            }
            else
                break;
        }
        // second step, start from the bottom to remove segments or reduce repetitions
        // making sure not to remove fragments before the lastToKeep index
        for (var j = timeline.length - 1; j >= 0; j--) {
            if (timeToRemove > 0 && j >= lastToKeep) {
                var segment = timeline[j];
                var r = segment._r ? parseInt(segment._r) : 1;
                var d = 0;
                if (segment._d)
                    d = parseInt(segment._d);
                else
                    throw new Error('missing segment duration');
                var totalDurationSegments = (r * d);
                // if the total duration of this segment's repetitions is lower than the amount of time
                // to remove (and we don't affect the lastToKeep index), remove the entire segment
                if ((j > lastToKeep || j == lastToKeep && lastRepetitionToKeep == 0) && timeToRemove >= totalDurationSegments) {
                    timeToRemove -= totalDurationSegments;
                    timeline.splice(j, 1);
                    count += r;
                    removedDuration += totalDurationSegments;
                }
                else {
                    // calculate how many repetitions we need to decrease this segment to trim correctly
                    var toRemove = Math.ceil(timeToRemove / d);
                    if (j == lastToKeep)
                        toRemove = Math.min(toRemove, r - lastRepetitionToKeep);
                    var removingTime = d * toRemove;
                    segment._r = (r - toRemove) + '';
                    timeToRemove -= removingTime;
                    count += toRemove;
                    removedDuration += removingTime;
                }
            }
            else
                break;
        }
        this.metadataInfoTracker.setTrimmedSegmentCount(count);
        var removedSeconds = removedDuration / timescale * 1000;
        this.logger.debug('DASH trimmed ' + count + ' segments for total duration: ' + removedSeconds);
        return { count: count, removed: removedDuration };
    };
    /**
     * Here we check if the segment template is a video one and we distinguish between the two formats
     * Dash AMP and Dash Wowza
     * @param adaptationSet
     * @returns {any|boolean}
     */
    DashMetadata.prototype.isVideoSegmentTemplate = function (adaptationSet) {
        try {
            if (!adaptationSet)
                return false;
            if (adaptationSet._mimeType === 'video/mp4' ||
                adaptationSet._contentType === 'video' ||
                (adaptationSet.SegmentTemplate && adaptationSet.SegmentTemplate._media && adaptationSet.SegmentTemplate._media.indexOf('video') > -1)) {
                return !!(adaptationSet.SegmentTemplate.SegmentTimeline);
            }
        }
        catch (error) {
            this.logger.error(error);
        }
        return false;
    };
    DashMetadata.prototype.parseQualityLevelsToFilter = function () {
        var DashFilterBitrates = ClientConfigs_1.HiveConfig.Dash.DashFilterBitrates;
        if (DashFilterBitrates) {
            try {
                var indexes = typeof DashFilterBitrates === 'string' ?
                    DashFilterBitrates.split(',') : DashFilterBitrates;
                return indexes.map(function (value) { return parseInt(value); }).filter(function (value) { return !isNaN(value); });
            }
            catch (e) {
                logger_hive_1.ErrorMonitor.getInstance().logError('Error parsing DashFilterBitrates', this.loggerId, ErrorCodes.DASH_METADATA_CODES.PARSE_BITRATES_TO_FILTER, e);
            }
        }
    };
    DashMetadata.prototype.filterQualityLevels = function (manifest) {
        var _this = this;
        if (manifest.MPD && manifest.MPD.Period) {
            manifest.MPD.Period.AdaptationSet.forEach(function (adaptationSet) {
                // we check if the adaptation has a representation array, and it contains a video segment template
                // or the representations internally contain video segment templates
                if (adaptationSet.Representation_asArray && (_this.isVideoSegmentTemplate(adaptationSet) ||
                    adaptationSet.Representation_asArray.every(function (r) { return _this.isVideoRepresentationSegmentTemplate(r); }))) {
                    var representationsArray = adaptationSet.Representation_asArray;
                    _this.bitrateFilter.filter(representationsArray);
                }
            });
        }
    };
    DashMetadata.prototype.getPlaylistType = function (type) {
        if (type.indexOf('audio') !== -1)
            return EntityType_1.EntityType.AUDIO;
        if (type.indexOf('application/mp4') !== -1 || type.indexOf('text/vtt') !== -1)
            return EntityType_1.EntityType.SUBTITLES;
        return EntityType_1.EntityType.VIDEO;
    };
    DashMetadata.prototype.getSegment = function (segmentId, qualityLevel) {
        var segment = _super.prototype.getSegment.call(this, segmentId, qualityLevel);
        if (segment) {
            return segment;
        }
        try {
            var representation = qualityLevel ? this.qualityLevelToPlaylist.get(qualityLevel.id) : this.qualityLevelToPlaylist.values().find(function (representation) { return representation.type === EntityType_1.EntityType.VIDEO; });
            if (representation && representation.segmentTemplateDuration) {
                var uri = representation.mediaTemplate.replace(DashMetadata.NUMBER_TAG, function (repl, fmt) {
                    return sprintf_js_1.sprintf(fmt || '%d', segmentId);
                });
                var timeDuration = new TimeDuration_1.TimeDuration(representation.segmentTemplateDuration, representation.timescale);
                var segment_1 = new Segment_1.Segment(segmentId, representation.qualityLevel, timeDuration, uri, uri, representation.type);
                this.urlToSegment.set(Utils.removeQueryParams(uri), segment_1);
                return segment_1;
            }
            return null;
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error getting the segment', this.loggerId, ErrorCodes.DASH_METADATA_CODES.GET_SEGMENT, error);
            return null;
        }
    };
    DashMetadata.BANDWIDTH_TAG = '$Bandwidth$';
    DashMetadata.TIME_TAG = '$Time$';
    DashMetadata.REPRESENTATION_ID = '$RepresentationID$';
    DashMetadata.NUMBER_TAG = /\$Number([^$]+)?\$/;
    return DashMetadata;
}(StreamMetadataBase_1.StreamMetadataBase));
exports.DashMetadata = DashMetadata;
//# sourceMappingURL=DashMetadata.js.map

/***/ }),

/***/ "../../../core/build/core/src/core/metadata/dash/DashWamsMetadata.js":
/*!********************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/core/metadata/dash/DashWamsMetadata.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.DashWamsMetadata = void 0;
var DashMetadata_1 = __webpack_require__(/*! ./DashMetadata */ "../../../core/build/core/src/core/metadata/dash/DashMetadata.js");
var Segment_1 = __webpack_require__(/*! ../Segment */ "../../../core/build/core/src/core/metadata/Segment.js");
var Dash_1 = __webpack_require__(/*! ./Dash */ "../../../core/build/core/src/core/metadata/dash/Dash.js");
var Q = __webpack_require__(/*! @hivestreaming/q */ "../../../node_modules/@hivestreaming/q/q.js");
var EntityType_1 = __webpack_require__(/*! ../../entity/EntityType */ "../../../core/build/core/src/core/entity/EntityType.js");
var TimeDuration_1 = __webpack_require__(/*! ../../../common/utils/TimeDuration */ "../../../core/build/core/src/common/utils/TimeDuration.js");
var DashWamsMetadata = /** @class */ (function (_super) {
    __extends(DashWamsMetadata, _super);
    function DashWamsMetadata() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    DashWamsMetadata.prototype.requestReceived = function (request) {
        var _this = this;
        // check for the entity type
        var entityType = this.getEntityType(request.getRequestUrl());
        if (entityType !== EntityType_1.EntityType.VIDEO && entityType !== EntityType_1.EntityType.AUDIO) {
            return Q.resolve(false);
        }
        // check if we already know the next segment
        var currentSegment = this.getSegmentInfo(request.getRequestUrl());
        if (!currentSegment || currentSegment.next) {
            return Q.resolve(false);
        }
        var fragmentReceived = Q.defer();
        // if the decryption is active, try decrypting the fragment and then extracting
        // otherwise extract the duration directly
        var extractDuration = Q.defer();
        if (this.protection) {
            if (Dash_1.Dash.DASH_DECRYPT)
                this.protection.canDecrypt().then(function (canDecrypt) {
                    if (canDecrypt)
                        _this.protection.decrypt(request.getResponse()).then(function (decrypted) {
                            extractDuration.resolve(_this.extractDuration(decrypted));
                        }).fail(function (err) { return extractDuration.reject(true); });
                    else
                        extractDuration.reject(false);
                });
            else
                extractDuration.reject(false);
        }
        else {
            try {
                var duration = this.extractDuration(request.getResponse());
                extractDuration.resolve(duration);
            }
            catch (e) {
                this.logger.warn('error extracting duration', e);
                extractDuration.reject(true);
            }
        }
        if (entityType === EntityType_1.EntityType.VIDEO)
            this.metadataInfoTracker.initMetadataInfo(true);
        // once the duration has been extracted, generate the missing segment for every quality level
        extractDuration.promise.then(function (duration) {
            if (!isNaN(duration)) {
                var nextSegmentTs_1 = currentSegment.id + duration;
                _this.logger.debug('found next fragment: ' + currentSegment.id + ' -> ' + nextSegmentTs_1 + ' duration: ' + duration);
                _this.qualityLevelToPlaylist.forEach(function (representation) {
                    if (representation.type === currentSegment.entityType) {
                        var prevSegmentUrl = representation.mediaTemplate.replace(DashMetadata_1.DashMetadata.TIME_TAG, currentSegment.id + '');
                        var nextSegmentUrl = representation.mediaTemplate.replace(DashMetadata_1.DashMetadata.TIME_TAG, nextSegmentTs_1 + '');
                        var timeDuration = new TimeDuration_1.TimeDuration(duration, representation.timescale);
                        var prevSegment = _this.urlToSegment.get(prevSegmentUrl);
                        if (!_this.urlToSegment.has(nextSegmentUrl) && prevSegment) {
                            prevSegment.duration = timeDuration;
                            /**
                             * WE USE THE DURATION OF THE CURRENT FRAGMENT FOR THE NEXT ONE AS WELL BECAUSE IT'S MISSING
                             */
                            var segment = new Segment_1.Segment(nextSegmentTs_1, representation.qualityLevel, timeDuration, nextSegmentUrl, nextSegmentUrl, prevSegment.entityType);
                            if (segment.entityType === EntityType_1.EntityType.VIDEO)
                                _this.metadataInfoTracker.addSegment(nextSegmentTs_1, true);
                            prevSegment.next = segment;
                            _this.urlToSegment.set(nextSegmentUrl, segment);
                            representation.idToSegment.set(nextSegmentTs_1, segment);
                        }
                    }
                });
            }
            if (entityType === EntityType_1.EntityType.VIDEO)
                _this.metadataInfoTracker.storeCurrentMetadataInfo();
            fragmentReceived.resolve(false);
        }).fail(function (reevaluate) {
            _this.logger.debug('could not extract duration from ' + request.getRequestUrl() + ' [reevaluate: ' + reevaluate + ']');
            if (entityType === EntityType_1.EntityType.VIDEO)
                _this.metadataInfoTracker.storeCurrentMetadataInfo();
            fragmentReceived.resolve(reevaluate);
        });
        return fragmentReceived.promise;
    };
    return DashWamsMetadata;
}(DashMetadata_1.DashMetadata));
exports.DashWamsMetadata = DashWamsMetadata;
//# sourceMappingURL=DashWamsMetadata.js.map

/***/ }),

/***/ "../../../core/build/core/src/core/metadata/dash/DashWowzaMetadata.js":
/*!*********************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/core/metadata/dash/DashWowzaMetadata.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.DashWowzaMetadata = void 0;
var DashMetadata_1 = __webpack_require__(/*! ./DashMetadata */ "../../../core/build/core/src/core/metadata/dash/DashMetadata.js");
var Q = __webpack_require__(/*! @hivestreaming/q */ "../../../node_modules/@hivestreaming/q/q.js");
var EntityType_1 = __webpack_require__(/*! ../../entity/EntityType */ "../../../core/build/core/src/core/entity/EntityType.js");
var DashWowzaMetadata = /** @class */ (function (_super) {
    __extends(DashWowzaMetadata, _super);
    function DashWowzaMetadata() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /** Wowza Dash Manifests support MPD Location-Tag https://www.wowza.com/docs/how-to-do-mpeg-dash-streaming#mpd_location , which
     *  means that the first manifest request will contain a new url to be used for the following manifest requests to update the
     *  metadata playlist. So that will be the new base url for all future requests.
     */
    DashWowzaMetadata.prototype.requestReceived = function (request) {
        // check for the entity type
        var entityType = this.getEntityType(request.getRequestUrl());
        if (entityType !== EntityType_1.EntityType.VIDEO && entityType !== EntityType_1.EntityType.AUDIO) {
            return Q.resolve(false);
        }
        // check if we already know the next segment
        var currentSegment = this.getSegmentInfo(request.getRequestUrl());
        if (!currentSegment || currentSegment.next) {
            return Q.resolve(false);
        }
        currentSegment.next = this.getSegment(currentSegment.id + 1, currentSegment.qualityLevel);
        return Q.resolve(false);
    };
    return DashWowzaMetadata;
}(DashMetadata_1.DashMetadata));
exports.DashWowzaMetadata = DashWowzaMetadata;
//# sourceMappingURL=DashWowzaMetadata.js.map

/***/ }),

/***/ "../../../core/build/core/src/core/metadata/dash/Representation.js":
/*!******************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/core/metadata/dash/Representation.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Representation = void 0;
var SortedMap = __webpack_require__(/*! @hivestreaming/collections/sorted-map */ "../../../node_modules/@hivestreaming/collections/sorted-map.js");
var Representation = /** @class */ (function () {
    function Representation() {
        this.idToSegment = new SortedMap();
    }
    return Representation;
}());
exports.Representation = Representation;
//# sourceMappingURL=Representation.js.map

/***/ }),

/***/ "../../../core/build/core/src/core/metadata/dash/decrypter/DashAesManager.js":
/*!****************************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/core/metadata/dash/decrypter/DashAesManager.js ***!
  \****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.DashAesManager = void 0;
var Q = __webpack_require__(/*! @hivestreaming/q */ "../../../node_modules/@hivestreaming/q/q.js");
var Framework_1 = __webpack_require__(/*! ../../../Framework */ "../../../core/build/core/src/core/Framework.js");
var logger_hive_1 = __webpack_require__(/*! ../../../../common/logger.hive */ "../../../core/build/core/src/common/logger.hive.js");
var ErrorCodes = __webpack_require__(/*! ../../../../common/error.hive */ "../../../core/build/core/src/common/error.hive.js");
/**
 * extend the lib.d.ts Algorithm class with `iv` for AES-CBC
 */
var DashExtAlgorithm = /** @class */ (function () {
    function DashExtAlgorithm(name, iv) {
        this.name = name;
        this.iv = iv;
    }
    return DashExtAlgorithm;
}());
/**
 * Class that handles the AES 128 Encryption using CryptoSubtle browser
 * api, same as AMP. Works on Chrome, Firefox and Chrome.
 * - Downloads the key with the auth token and imports it.
 * - Transforms the Initialization Vector from hex to byte array
 * - decrypts a fragment
 */
var DashAesManager = /** @class */ (function () {
    function DashAesManager(keyUrl, ivStr, token) {
        this.loggerId = '[DASH AES Manager] ';
        this.AES_ALGORITHM_NAME = 'AES-CBC';
        this.failed = false;
        this.logger = Framework_1.Framework && Framework_1.Framework.resolve(Framework_1.Framework.Definitions.LOGGER) ?
            Framework_1.Framework.resolve(Framework_1.Framework.Definitions.LOGGER).log() : console;
        this.keyUrl = keyUrl;
        this.ivStr = ivStr;
        this.logger.debug(this.loggerId + 'Starting Dash AES Manager');
        if (token)
            this.token = token;
    }
    /**
     * parse the IV and acquire key and initialize the canDecrypt promise
     * that will be resolved if the key is correctly imported
     */
    DashAesManager.prototype.init = function () {
        var _this = this;
        try {
            // parse IV
            this.initIv();
            // init key acquisition
            var canDecryptDefer_1 = Q.defer();
            this.initKey().then(function () {
                return canDecryptDefer_1.resolve(true);
            }).fail(function (err) {
                logger_hive_1.ErrorMonitor.getInstance().logError('Error initializing key', _this.loggerId, ErrorCodes.DASH_AES_MANAGER_CODES.INIT_KEY, err);
                canDecryptDefer_1.resolve(false);
            });
            this.canDecryptPromise = canDecryptDefer_1.promise;
        }
        catch (err) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error initializing AES Manager', this.loggerId, ErrorCodes.DASH_AES_MANAGER_CODES.INIT_AES_MANAGER, err);
        }
    };
    /**
     * returns a promise that resolves true if the key is correctly imported and there were no
     * error decrypting fragments so far
     *
     * If the manager has not been initialized, it will directly resolve false
     * @returns {any}
     */
    DashAesManager.prototype.canDecrypt = function () {
        if (this.canDecryptPromise)
            return this.canDecryptPromise;
        return Q.resolve(false);
    };
    /**
     * download the key and import it, don't init it many times
     */
    DashAesManager.prototype.initKey = function () {
        var _this = this;
        if (this.keyPromise)
            return this.keyPromise;
        var defer = Q.defer();
        this.downloadKey().then(function (key) {
            window.crypto.subtle.importKey(// It returns a PromiseLike<>
            'raw', key, _this.AES_ALGORITHM_NAME, false, // whether the key is extractable (i.e. can be used in exportKey)
            ['decrypt'] // can be "encrypt", "decrypt", "wrapKey", or "unwrapKey"
            ).then(function (cryptoKey) {
                defer.resolve(cryptoKey);
            }).catch(function (err) {
                defer.reject('error importing key: ' + err.toString());
            });
        }).catch(function (err) { return defer.reject(err); });
        this.keyPromise = defer.promise;
        return this.keyPromise;
    };
    /**
     * transform the IV from hex to Uint8Array
     */
    DashAesManager.prototype.initIv = function () {
        // eslint-disable-next-line no-var
        for (var i = 2, len = this.ivStr.length, a = []; i < len; i += 2)
            a.push(parseInt(this.ivStr.substr(i, 2), 16));
        this.iv = new Uint8Array(a);
    };
    /**
     * decrypt a data arraybuffer
     * @param data
     * @returns {Promise<T>}
     */
    DashAesManager.prototype.decrypt = function (data) {
        var _this = this;
        var defer = Q.defer();
        // initialize extended algorithm
        var algo = new DashExtAlgorithm(this.AES_ALGORITHM_NAME, this.iv);
        // TODO we need to add a timeout here in case keyPromise never returns something.
        // decrypt content
        this.keyPromise.then(function (cryptoKey) {
            window.crypto.subtle.decrypt(algo, cryptoKey, // from generateKey or importKey above
            data // ArrayBuffer of the data
            ).then(function (decrypted) {
                defer.resolve(decrypted);
            });
        }).catch(function (err) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error decrypting arraybuffer', _this.loggerId, ErrorCodes.DASH_AES_MANAGER_CODES.DECRYPT_BUFFER, err);
            // in case of decrypt error, update the canDecrypt promise
            _this.failed = true;
            _this.canDecryptPromise = Q.resolve(false);
            defer.reject(err);
        });
        return defer.promise;
    };
    /**
     * download the key
     * @returns {Promise<T>}
     */
    DashAesManager.prototype.downloadKey = function () {
        var _this = this;
        var deferred = Q.defer();
        var xhr = new XMLHttpRequest();
        xhr.responseType = 'arraybuffer';
        xhr.open('GET', this.keyUrl);
        if (this.token)
            xhr.setRequestHeader('Authorization', this.token);
        xhr.onload = function () {
            if (xhr.status === 200) {
                var key = new Uint8Array(xhr.response);
                deferred.resolve(key);
            }
            else {
                logger_hive_1.ErrorMonitor.getInstance().logError('Error downloading key', _this.loggerId, ErrorCodes.DASH_AES_MANAGER_CODES.DOWNLOAD_KEY_ONLOAD, xhr.status);
                deferred.reject('error downloading key - status: ' + xhr.status);
            }
        };
        xhr.onerror = function () {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error downloading key', _this.logger, ErrorCodes.DASH_AES_MANAGER_CODES.DOWNLOAD_KEY);
            deferred.reject('error downloading key');
        };
        xhr.send();
        return deferred.promise;
    };
    DashAesManager.prototype.isFailed = function () {
        return this.failed;
    };
    return DashAesManager;
}());
exports.DashAesManager = DashAesManager;
//# sourceMappingURL=DashAesManager.js.map

/***/ }),

/***/ "../../../core/build/core/src/core/metadata/dash/decrypter/DashUnsupportedDecryptManager.js":
/*!*******************************************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/core/metadata/dash/decrypter/DashUnsupportedDecryptManager.js ***!
  \*******************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.DashUnsupportedDecryptManager = void 0;
var Q = __webpack_require__(/*! @hivestreaming/q */ "../../../node_modules/@hivestreaming/q/q.js");
var DashUnsupportedDecryptManager = /** @class */ (function () {
    function DashUnsupportedDecryptManager() {
    }
    DashUnsupportedDecryptManager.prototype.init = function () {
    };
    DashUnsupportedDecryptManager.prototype.canDecrypt = function () {
        return Q.resolve(false);
    };
    DashUnsupportedDecryptManager.prototype.decrypt = function (encrypted) {
        return Q.reject('unsupported');
    };
    DashUnsupportedDecryptManager.prototype.isFailed = function () {
        return false;
    };
    return DashUnsupportedDecryptManager;
}());
exports.DashUnsupportedDecryptManager = DashUnsupportedDecryptManager;
//# sourceMappingURL=DashUnsupportedDecryptManager.js.map

/***/ }),

/***/ "../../../core/build/core/src/core/metadata/hls/Hls.js":
/*!******************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/core/metadata/hls/Hls.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Hls = void 0;
var HlsMetadata_1 = __webpack_require__(/*! ./HlsMetadata */ "../../../core/build/core/src/core/metadata/hls/HlsMetadata.js");
var Hls = /** @class */ (function () {
    function Hls() {
    }
    Hls.isValidContext = function (url, logger, regexMatcher) {
        return this.isManifest(url, logger, regexMatcher) || url.indexOf(Hls.FRAGMENT_EXTENSION) != -1;
    };
    Hls.isManifest = function (url, logger, regexMatcher) {
        var match = url.toLowerCase().indexOf(Hls.MANIFEST_EXTENSION.toLowerCase()) != -1 ||
            Hls.MANIFEST_EXTENSION_AZURE.exec(url) != null;
        if (regexMatcher) {
            if (regexMatcher.test(url)) {
                return true;
            }
            else if (!match && logger) {
                logger.warn(this.loggerId + "Context matcher set to " + regexMatcher + " failed against " + url);
            }
        }
        return match;
    };
    Hls.createMetadata = function (parserOptions, sessionId, hiveTechOptions) {
        return new HlsMetadata_1.HlsMetadata(parserOptions, sessionId, hiveTechOptions);
    };
    Hls.loggerId = '[HLS] ';
    Hls.HLS_REQUEST_DISPERSION = 1;
    Hls.HLS_MINIMUM_FRAGMENTS_TO_INFER_BUFFERING = 2;
    Hls.HLS_MAX_PREFETCH_DISTANCE = 30000;
    Hls.HLS_DEFAULT_FRAGMENT_DURATION = 4000;
    Hls.HLS_METADATA_PREFETCH_ADJUST = 500;
    Hls.HLS_METADATA_PREFETCH = true;
    Hls.HLS_MINIMUM_PREFETCH_DISTANCE = 10000;
    Hls.HLS_METADATA_TRIM = 16;
    Hls.HLS_METADATA_MIN_FRAGMENTS = 3;
    Hls.MANIFEST_EXTENSION = '.m3u8';
    Hls.MANIFEST_EXTENSION_AZURE = /format(?:=|%3D)m3u8-aapl/i;
    Hls.FRAGMENT_EXTENSION = '.ts';
    return Hls;
}());
exports.Hls = Hls;
//# sourceMappingURL=Hls.js.map

/***/ }),

/***/ "../../../core/build/core/src/core/metadata/hls/HlsBitrateFilter.js":
/*!*******************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/core/metadata/hls/HlsBitrateFilter.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.HlsBitrateFilter = void 0;
var jsrsasign_1 = __webpack_require__(/*! @hivestreaming/jsrsasign */ "../../../node_modules/@hivestreaming/jsrsasign/lib/jsrsasign.js");
var Framework_1 = __webpack_require__(/*! ../../Framework */ "../../../core/build/core/src/core/Framework.js");
var Utils = __webpack_require__(/*! ../../Utils */ "../../../core/build/core/src/core/Utils.js");
var HlsBitrateFilter = /** @class */ (function () {
    function HlsBitrateFilter(manifestUrl, qualityLevelTracker, content) {
        this.logger = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.LOGGER).log();
        this.configStore = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.CONFIG_STORE);
        this.qualityLevelTracker = qualityLevelTracker;
        this.manifestUrl = manifestUrl;
        this.content = content;
    }
    HlsBitrateFilter.prototype.filter = function (playlists) {
        var maxBandwidth = this.configStore.getConfig('stream.maxBandwidth');
        var removeResolution = this.configStore.getConfig('stream.removeResolution');
        playlists.sort(function (playlist1, playlist2) {
            return playlist1.attributes.BANDWIDTH - playlist2.attributes.BANDWIDTH;
        });
        if (removeResolution)
            this.removeResolution();
        if (!maxBandwidth)
            return;
        for (var i = playlists.length - 1; i >= 0; i--) {
            var _a = playlists[i], uri = _a.uri, attributes = _a.attributes;
            var bandwidth = attributes.BANDWIDTH ? attributes.BANDWIDTH : 0;
            if (bandwidth > maxBandwidth && playlists.length > 1) {
                playlists.splice(i, 1);
                var absoluteUrl = Utils.resolveUrl(this.manifestUrl, uri);
                var trimmedUrl = Utils.removeQueryParams(absoluteUrl);
                var qualityId = jsrsasign_1.CryptoJS.SHA1(trimmedUrl).toString(jsrsasign_1.CryptoJS.enc.Hex);
                this.qualityLevelTracker.setQualityLevelFlitered(qualityId);
                this.removeBitrateFromManifest(bandwidth);
                this.logger.debug("Removed playlist with bitrate " + bandwidth);
            }
        }
    };
    HlsBitrateFilter.prototype.getContent = function () {
        return this.content;
    };
    HlsBitrateFilter.prototype.removeBitrateFromManifest = function (bandwidth) {
        var lines = this.content.split('\n');
        for (var i = lines.length - 2; i >= 0; i--) {
            if (lines[i].startsWith('#EXT-X-STREAM-INF') && lines[i].indexOf("BANDWIDTH=" + bandwidth) > -1) {
                lines.splice(i, 2);
            }
        }
        this.content = lines.join('\n');
    };
    HlsBitrateFilter.prototype.removeResolution = function () {
        var lines = this.content.split('\n');
        for (var i = lines.length - 2; i >= 0; i--) {
            if (lines[i].startsWith('#EXT-X-STREAM-INF') && lines[i].indexOf('RESOLUTION=') > -1) {
                lines[i] = lines[i].replace(/RESOLUTION=[\d]+x[\d]+[,]?/, '');
            }
        }
        this.content = lines.join('\n');
    };
    return HlsBitrateFilter;
}());
exports.HlsBitrateFilter = HlsBitrateFilter;
//# sourceMappingURL=HlsBitrateFilter.js.map

/***/ }),

/***/ "../../../core/build/core/src/core/metadata/hls/HlsMetadata.js":
/*!**************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/core/metadata/hls/HlsMetadata.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.HlsMetadata = void 0;
var Q = __webpack_require__(/*! @hivestreaming/q */ "../../../node_modules/@hivestreaming/q/q.js");
var logger_hive_1 = __webpack_require__(/*! ../../../common/logger.hive */ "../../../core/build/core/src/common/logger.hive.js");
var m3u8 = __webpack_require__(/*! @hivestreaming/m3u8 */ "../../../node_modules/@hivestreaming/m3u8/index.js");
var HashMap = __webpack_require__(/*! @hivestreaming/collections/map */ "../../../node_modules/@hivestreaming/collections/map.js");
var Playlist_1 = __webpack_require__(/*! ./Playlist */ "../../../core/build/core/src/core/metadata/hls/Playlist.js");
var Segment_1 = __webpack_require__(/*! ../Segment */ "../../../core/build/core/src/core/metadata/Segment.js");
var Utils = __webpack_require__(/*! ../../Utils */ "../../../core/build/core/src/core/Utils.js");
var Hls_1 = __webpack_require__(/*! ./Hls */ "../../../core/build/core/src/core/metadata/hls/Hls.js");
var ErrorCodes = __webpack_require__(/*! ../../../common/error.hive */ "../../../core/build/core/src/common/error.hive.js");
var StreamMetadataBase_1 = __webpack_require__(/*! ../StreamMetadataBase */ "../../../core/build/core/src/core/metadata/StreamMetadataBase.js");
var jsrsasign_1 = __webpack_require__(/*! @hivestreaming/jsrsasign */ "../../../node_modules/@hivestreaming/jsrsasign/lib/jsrsasign.js");
var EntityType_1 = __webpack_require__(/*! ../../entity/EntityType */ "../../../core/build/core/src/core/entity/EntityType.js");
var HlsBitrateFilter_1 = __webpack_require__(/*! ./HlsBitrateFilter */ "../../../core/build/core/src/core/metadata/hls/HlsBitrateFilter.js");
var TimeDuration_1 = __webpack_require__(/*! ../../../common/utils/TimeDuration */ "../../../core/build/core/src/common/utils/TimeDuration.js");
var HlsMetadata = /** @class */ (function (_super) {
    __extends(HlsMetadata, _super);
    function HlsMetadata(parserOptions, sessionId, hiveTechOptions) {
        var _this = _super.call(this, parserOptions, sessionId, hiveTechOptions) || this;
        _this.loggerId = '[HLS METADATA] ';
        /** Used primarily for context checking, to see if a requested URL is a manifest. */
        _this.urlToPlaylist = new HashMap();
        _this.initializedMaster = false;
        return _this;
    }
    HlsMetadata.prototype.getStreamProtocol = function () {
        return StreamProtocol.HLS;
    };
    HlsMetadata.prototype.isManifest = function (url, logger) {
        var matcher = this.hiveTechOptions && this.hiveTechOptions.contextMatcher && this.hiveTechOptions.contextMatcher.hls;
        return Hls_1.Hls.isManifest(url, logger, matcher);
    };
    /**
     * parse manifest or playlist based on the context and update the internal state
     * @param url
     * @param content
     */
    HlsMetadata.prototype.parse = function (url, content) {
        try {
            var parser = new m3u8.Parser();
            parser.push(content);
            if (parser.manifest.playlists) {
                // it's a manifest
                this.bitrateFilter = new HlsBitrateFilter_1.HlsBitrateFilter(url, this.qualityLevelTracker, content);
                this.initManifest(url, parser.manifest);
                this.bitrateFilter.filter(parser.manifest.playlists);
                content = this.bitrateFilter.getContent();
            }
            else if (parser.manifest.segments) {
                // it's a playlist
                this.metadataInfoTracker.initMetadataInfo();
                var updateResult = this.updatePlaylist(url, parser.manifest);
                if (updateResult && updateResult.playlist) {
                    this.live = !updateResult.playlist.endList;
                }
                if (this.live && this.parserOptions.regenerate && this.getEntityType(url) !== EntityType_1.EntityType.SUBTITLES) {
                    var trimmingResult = this.trimPlaylist(parser.manifest, content);
                    var trimmedPlaylist = trimmingResult.trimmedPlaylist, trimmedCount = trimmingResult.trimmedCount, secondsTrimmed = trimmingResult.secondsTrimmed;
                    this.metadataInfoTracker.setTrimmedSegmentCount(trimmedCount);
                    this.logger.debug('HLS manifest trimmed ' + trimmedCount + ' segments (' + secondsTrimmed + 's) - ' +
                        'new segments:[' + updateResult.newSegments.map(function (s) { return s.id + ':' + s.duration.secs() + 's'; }) + ']');
                    this.metadataInfoTracker.storeCurrentMetadataInfo();
                    return trimmedPlaylist;
                }
                // If the manifest is not trimmed (e.g.: stats2.0) we need to
                // store the new metadata info before sending back the content
                this.metadataInfoTracker.storeCurrentMetadataInfo();
            }
            else {
                logger_hive_1.ErrorMonitor.getInstance().logError('Error parsing metadata', this.loggerId, ErrorCodes.HLS_METADATA_CODES.PARSE_METADATA, {
                    detailedError: 'Manifest has no bitrates or playlist has no segments',
                    url: url
                });
            }
            return content;
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error parsing metadata', this.loggerId, ErrorCodes.HLS_METADATA_CODES.PARSE_METADATA, {
                detailedError: error,
                url: url
            });
            return content;
        }
    };
    HlsMetadata.prototype.getEntityType = function (url) {
        try {
            return _super.prototype.getEntityType.call(this, url);
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error getting the entityType', this.loggerId, ErrorCodes.HLS_CONTEXT_CODES.GET_ENTITY_TYPE, {
                detailedError: error,
                url: url
            });
            return EntityType_1.EntityType.OTHER;
        }
    };
    HlsMetadata.prototype.hasPlaylist = function (url) {
        url = Utils.removeQueryParams(url);
        return this.urlToPlaylist.has(url);
    };
    HlsMetadata.prototype.getPlaylist = function (url) {
        url = Utils.removeQueryParams(url);
        return this.urlToPlaylist.get(url);
    };
    HlsMetadata.prototype.getUrlToPlaylist = function () {
        return this.urlToPlaylist;
    };
    HlsMetadata.prototype.getQualityLevelToPlaylist = function () {
        return this.qualityLevelToPlaylist;
    };
    /**
     * resets the current internal state, playlists and segments.
     * maintains the reference of the new master manifest and initializes the playlists
     * @param url without query params
     * @param manifest
     */
    HlsMetadata.prototype.initManifest = function (url, manifest) {
        var _this = this;
        this.manifestUrl = url;
        this.manifest = manifest;
        this.initializedMaster = true;
        this.manifest.playlists.forEach(function (_a) {
            var uri = _a.uri, attributes = _a.attributes;
            var absolutePlaylistUrl = Utils.resolveUrl(_this.manifestUrl, uri);
            var bitrate = attributes.BANDWIDTH ? attributes.BANDWIDTH : 0;
            var resolution = attributes.RESOLUTION;
            if (attributes.TYPE === 'VIDEO' && !Number.isInteger(bitrate)) {
                logger_hive_1.ErrorMonitor.getInstance().logError('Segment Bitrate is a Float', { 'bitrate': bitrate });
                bitrate = Math.round(bitrate);
            }
            var width = resolution ? resolution.width : null;
            var height = resolution ? resolution.height : null;
            var label = attributes.NAME || null;
            var type = _this.getPlaylistType(attributes.TYPE);
            _this.createPlaylist(absolutePlaylistUrl, bitrate, width, height, label, type);
        });
    };
    HlsMetadata.prototype.getPlaylistType = function (type) {
        switch (type) {
            case 'AUDIO':
                return EntityType_1.EntityType.AUDIO;
            case 'SUBTITLES':
                return EntityType_1.EntityType.SUBTITLES;
            default:
                return EntityType_1.EntityType.VIDEO;
        }
    };
    HlsMetadata.prototype.createPlaylist = function (absoluteUrl, bitrate, width, height, label, type) {
        var trimmedUrl = Utils.removeQueryParams(absoluteUrl);
        var qualityId = jsrsasign_1.CryptoJS.SHA1(trimmedUrl).toString(jsrsasign_1.CryptoJS.enc.Hex);
        var playlist = new Playlist_1.Playlist();
        playlist.type = type;
        playlist.qualityLevel = this.qualityLevelTracker.add(playlist.type, {
            id: qualityId,
            bitrate: bitrate,
            width: width,
            height: height,
            label: label
        });
        playlist.absoluteUri = absoluteUrl;
        this.urlToPlaylist.set(trimmedUrl, playlist);
        this.qualityLevelToPlaylist.set(qualityId, playlist);
    };
    /**
     * updates a playlist object with the latest manifest and generates the segment info.
     * Returns the updated playlist object and the list of the new segments found
     * @param absoluteUrl without query params
     * @param manifest
     */
    HlsMetadata.prototype.updatePlaylist = function (absoluteUrl, manifest) {
        var _this = this;
        try {
            /*
             * If the stream has no master manifest, but just a playlist (e.g.
             * MediaPlatform), we'll create a QualityLevel object for it and
             * initialize the playlist for it. We assume the type is VIDEO.
             */
            if (!this.initializedMaster && this.qualityLevelTracker.getAll().length === 0) {
                this.createPlaylist(absoluteUrl, 1, null, null, null, EntityType_1.EntityType.VIDEO);
            }
            var playlist_1 = this.getPlaylist(absoluteUrl);
            if (!playlist_1) {
                logger_hive_1.ErrorMonitor.getInstance().logError('Playlist url does not match any playlist in the master file', this.loggerId, ErrorCodes.HLS_METADATA_CODES.PLAYLIST_MISMATCH, { url: absoluteUrl });
                return;
            }
            var id_1 = (manifest.mediaSequence != null ? manifest.mediaSequence : 0);
            var segments_1 = [];
            var previousSegmentId = id_1 - 1;
            var previousSegment_1 = playlist_1.idToSegment.get(previousSegmentId);
            var newSegments_1 = [];
            manifest.segments.forEach(function (segment) {
                var absoluteSegmentUrl = Utils.resolveUrl(absoluteUrl, segment.uri);
                var qualityLevel = playlist_1.qualityLevel;
                /** @TODO implement the same new Segment caching behavior like in DashMetadata */
                // HLS uses seconds as duration in the manifest so we set the timescale accordingly
                var timeDuration = new TimeDuration_1.TimeDuration(segment.duration, TimeDuration_1.TimeDuration.TIMESCALE_SECONDS);
                var newSegment = new Segment_1.Segment(id_1, qualityLevel, timeDuration, segment.uri, absoluteSegmentUrl, playlist_1.type);
                _this.metadataInfoTracker.addSegment(newSegment.id);
                // track new segments
                if (!_this.getSegmentInfo(absoluteSegmentUrl))
                    newSegments_1.push(newSegment);
                _this.urlToSegment.set(Utils.removeQueryParams(absoluteSegmentUrl), newSegment);
                playlist_1.idToSegment.set(id_1, newSegment);
                segments_1.push(newSegment);
                // We check for the previous and update the next property
                if (previousSegment_1) {
                    previousSegment_1.next = newSegment;
                }
                previousSegment_1 = newSegment;
                id_1++;
            });
            playlist_1.update(manifest.mediaSequence, manifest.discontinuitySequence, manifest.endList, manifest.targetDuration, segments_1);
            return { playlist: playlist_1, newSegments: newSegments_1 };
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error updating the playlist', this.loggerId, ErrorCodes.HLS_METADATA_CODES.UPDATE_PLAYLIST, error);
            return null;
        }
    };
    HlsMetadata.prototype.getTrimmingValues = function () {
        var hiveJsOptions = this.hiveTechOptions;
        if (hiveJsOptions && hiveJsOptions.maximumTrimming && hiveJsOptions.maximumTrimming.hls)
            return hiveJsOptions.maximumTrimming.hls;
        return Hls_1.Hls.HLS_METADATA_TRIM;
    };
    /**
     * generates a manifest string without the last segments. Segments are removed from the bottom, until
     * the sum of their removed duration is >= HLS.HLS_METADATA_MIN_FRAGMENTS.
     * Returns the trimmed manifest and number of segments and seconds trimmed away
     */
    HlsMetadata.prototype.trimPlaylist = function (playlist, content) {
        try {
            var lines = content.split('\n');
            var minFragments = Math.max(1, Hls_1.Hls.HLS_METADATA_MIN_FRAGMENTS);
            var metadataTrim = this.getTrimmingValues();
            var lastSegment = null;
            var timeCounter = 0;
            var fragmentCounter = 0;
            for (var i = playlist.segments.length - 1; i > minFragments - 1; i--) {
                lastSegment = playlist.segments[i];
                if (timeCounter >= metadataTrim) {
                    break;
                }
                else {
                    fragmentCounter++;
                    timeCounter += lastSegment.duration;
                }
            }
            var trimmed = '';
            if (lastSegment) {
                for (var i = 0; i < lines.length; i++) {
                    trimmed = trimmed + lines[i] + '\n';
                    if (lines[i].trim() === lastSegment.uri) {
                        break;
                    }
                }
            }
            else {
                trimmed = lines.join('\n') + '\n';
                this.logger.debug('HLS trimming disabled (minFragments = ' + minFragments + ', segments.length = ' + playlist.segments.length + ')');
            }
            return { trimmedPlaylist: trimmed, trimmedCount: fragmentCounter, secondsTrimmed: timeCounter };
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error trimming the playlist', this.loggerId, ErrorCodes.HLS_METADATA_CODES.TRIM_PLAYLIST, error);
            throw new Error(error);
        }
    };
    HlsMetadata.prototype.requestReceived = function (request) {
        return Q.resolve(false);
    };
    HlsMetadata.prototype.isInitialization = function (url) {
        /** HLS has no concept of initialization segments */
        return false;
    };
    HlsMetadata.prototype.isSynchronization = function (url) {
        /** HLS has no concept of synchronization between client and server */
        return false;
    };
    return HlsMetadata;
}(StreamMetadataBase_1.StreamMetadataBase));
exports.HlsMetadata = HlsMetadata;
//# sourceMappingURL=HlsMetadata.js.map

/***/ }),

/***/ "../../../core/build/core/src/core/metadata/hls/Playlist.js":
/*!***********************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/core/metadata/hls/Playlist.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Playlist = void 0;
var SortedMap = __webpack_require__(/*! @hivestreaming/collections/sorted-map */ "../../../node_modules/@hivestreaming/collections/sorted-map.js");
var Playlist = /** @class */ (function () {
    function Playlist() {
        this.idToSegment = new SortedMap();
    }
    Playlist.prototype.update = function (mediaSequence, discontinuitySequence, endList, targetDuration, segments) {
        this.mediaSequence = mediaSequence;
        this.discontinuitySequence = discontinuitySequence;
        this.endList = endList;
        this.targetDuration = targetDuration;
        this.segments = segments;
        this.updated = true;
    };
    return Playlist;
}());
exports.Playlist = Playlist;
//# sourceMappingURL=Playlist.js.map

/***/ }),

/***/ "../../../core/build/core/src/core/metrics/DefaultFragmentDownloadMetricsProvider.js":
/*!************************************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/core/metrics/DefaultFragmentDownloadMetricsProvider.js ***!
  \************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.DefaultFragmentDownloadMetricsProvider = void 0;
var FragmentDownload = hive.snapshots.FragmentDownload;
var EntityType_1 = __webpack_require__(/*! ../entity/EntityType */ "../../../core/build/core/src/core/entity/EntityType.js");
var DefaultFragmentDownloadMetricsProvider = /** @class */ (function () {
    function DefaultFragmentDownloadMetricsProvider() {
        this.metrics = [];
    }
    DefaultFragmentDownloadMetricsProvider.prototype.getMetrics = function () {
        var metrics = this.metrics;
        this.metrics = [];
        return metrics;
    };
    /**
     * Add a new request to the metrics. This method is used differently based
     * on Hive Tech used:
     * - When using Stats, all requests come from the player.
     *   - `StatsJS#createRequest`
     *   - `onloadend` callback [custom Hive-added property `onready`]
     *   - `VideoContextBase#updateFragmentDownload` adds all requests as `type
     *     == PLAYER` and `origin == CDN`.
     * - When using WebRTC...
     *   - from the Prefetcher:
     *     - `HiveCache#fallbackRequestSuccessful` or
     *       `HiveCache#p2pRequestSuccessful`
     *     - `VideoContextBase#fragmentReceived`
     *     - `VideoContextBase#updateFragmentDownload` [only executed for
     *       prefetched requests] will add requests as `type == PREFETCH` and
     *       `origin == CDN` (if from `fallbackRequestSuccessful`) or `origin ==
     *       P2P` (if from `p2pRequestSuccessful`).
     *   - from the Player:
     *     - `HiveCache#fallbackRequestSuccessful` or
     *       `HiveCache#p2pRequestSuccessful` or
     *       `HiveCache#deliverAlreadyCached`
     *     - `HiveCache#respondToPlayer` [only executed for player requests]
     *       will add requests as `type == PLAYER` and `origin == CDN` (if from
     *       `fallbackRequestSuccessful`) or `origin == P2P` (if from
     *       `p2pRequestSuccessful`) or `origin == CACHE` (if from
     *       `deliverAlreadyCached`).
     * @param request Request
     * @param type What made the request (`PREFETCH` or `PLAYER`)
     * @param origin Where the response came from (`CDN`, `P2P`, or `CACHE`)
     */
    DefaultFragmentDownloadMetricsProvider.prototype.add = function (request, type, origin) {
        // We only care about VIDEO requests
        if (request.getEntityType() === EntityType_1.EntityType.VIDEO) {
            this.metrics.push(new FragmentDownload({
                fragmentUrl: request.getRequestUrl(),
                startTimestamp: request.startedTime,
                endTimestamp: request.finishedTime,
                origin: origin,
                type: type,
                qualityLevelId: request.getEntityCharacteristics().getQualityLevel().id
            }));
        }
    };
    return DefaultFragmentDownloadMetricsProvider;
}());
exports.DefaultFragmentDownloadMetricsProvider = DefaultFragmentDownloadMetricsProvider;
//# sourceMappingURL=DefaultFragmentDownloadMetricsProvider.js.map

/***/ }),

/***/ "../../../core/build/core/src/core/metrics/DefaultFragmentMetadataMetricsProvider.js":
/*!************************************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/core/metrics/DefaultFragmentMetadataMetricsProvider.js ***!
  \************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.DefaultFragmentMetadataMetricsProvider = void 0;
var FragmentMetadata = hive.snapshots.FragmentMetadata;
var EntityType_1 = __webpack_require__(/*! ../entity/EntityType */ "../../../core/build/core/src/core/entity/EntityType.js");
var DefaultFragmentMetadataMetricsProvider = /** @class */ (function () {
    function DefaultFragmentMetadataMetricsProvider() {
        this.metrics = [];
    }
    DefaultFragmentMetadataMetricsProvider.prototype.add = function (segment, size) {
        var fragmentMetadata = new FragmentMetadata();
        fragmentMetadata.url = segment.absoluteUrl;
        fragmentMetadata.size = size;
        fragmentMetadata.duration = this.getDuration(segment);
        fragmentMetadata.qualityLevelId = segment.qualityLevel.id;
        switch (segment.entityType) {
            case EntityType_1.EntityType.AUDIO:
                fragmentMetadata.contentType = ContentType.AUDIO;
                break;
            case EntityType_1.EntityType.VIDEO:
                fragmentMetadata.contentType = ContentType.VIDEO;
                break;
            default:
                fragmentMetadata.contentType = null;
                break;
        }
        this.metrics.push(fragmentMetadata);
    };
    DefaultFragmentMetadataMetricsProvider.prototype.setMetadata = function (metadata) {
        this.metadata = metadata;
    };
    DefaultFragmentMetadataMetricsProvider.prototype.getMetrics = function () {
        var metrics = this.metrics;
        this.metrics = [];
        return metrics;
    };
    DefaultFragmentMetadataMetricsProvider.prototype.getDuration = function (segment) {
        return segment.duration.ms();
    };
    return DefaultFragmentMetadataMetricsProvider;
}());
exports.DefaultFragmentMetadataMetricsProvider = DefaultFragmentMetadataMetricsProvider;
//# sourceMappingURL=DefaultFragmentMetadataMetricsProvider.js.map

/***/ }),

/***/ "../../../core/build/core/src/core/metrics/DefaultQualityLevelMetricsProvider.js":
/*!********************************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/core/metrics/DefaultQualityLevelMetricsProvider.js ***!
  \********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.DefaultQualityLevelMetricsProvider = void 0;
var QualityLevel = hive.snapshots.QualityLevel;
var DefaultQualityLevelMetricsProvider = /** @class */ (function () {
    function DefaultQualityLevelMetricsProvider() {
    }
    DefaultQualityLevelMetricsProvider.prototype.setQualityLevelTracker = function (qualityLevelTracker) {
        this.qualityLevelTracker = qualityLevelTracker;
    };
    DefaultQualityLevelMetricsProvider.prototype.getMetrics = function () {
        if (!this.qualityLevelTracker)
            return [];
        var qualityLevels = this.qualityLevelTracker.getAll();
        var metrics = qualityLevels.map(function (qualityLevel) {
            var qualityLevelMetric = new QualityLevel();
            qualityLevelMetric.id = qualityLevel.id;
            qualityLevelMetric.width = qualityLevel.width || null;
            qualityLevelMetric.height = qualityLevel.height || null;
            qualityLevelMetric.label = qualityLevel.label || null;
            qualityLevelMetric.bitrates = qualityLevel.bitrateHistory.filter(function (bitrate) { return bitrate != null; });
            qualityLevelMetric.filtered = qualityLevel.filtered;
            return qualityLevelMetric;
        });
        // Clear the bitrate history so the same data won't be sent again.
        // Only keep the current bitrate in the history list.
        qualityLevels.forEach(function (qualityLevel) { return qualityLevel.resetBitrateHistory(); });
        return metrics;
    };
    return DefaultQualityLevelMetricsProvider;
}());
exports.DefaultQualityLevelMetricsProvider = DefaultQualityLevelMetricsProvider;
//# sourceMappingURL=DefaultQualityLevelMetricsProvider.js.map

/***/ }),

/***/ "../../../core/build/core/src/core/metrics/DefaultStreamInfoMetricsProvider.js":
/*!******************************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/core/metrics/DefaultStreamInfoMetricsProvider.js ***!
  \******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.DefaultStreamInfoMetricsProvider = void 0;
var Framework_1 = __webpack_require__(/*! ../Framework */ "../../../core/build/core/src/core/Framework.js");
var DefaultStreamInfoMetricsProvider = /** @class */ (function () {
    function DefaultStreamInfoMetricsProvider() {
        this.qualityLevelMetricsProvider = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.QUALITY_LEVEL_METRICS_PROVIDER);
    }
    DefaultStreamInfoMetricsProvider.prototype.init = function (manifestUrlProvider, metadataProvider, textTrackProvider) {
        this.manifestUrlProvider = manifestUrlProvider;
        this.metadataProvider = metadataProvider;
        this.textTrackProvider = textTrackProvider;
    };
    DefaultStreamInfoMetricsProvider.prototype.updateStreamMetadataProvider = function (metadataProvider) {
        this.metadataProvider = metadataProvider;
    };
    DefaultStreamInfoMetricsProvider.prototype.setQualityLevelTracker = function (qualityLevelTracker) {
        this.qualityLevelMetricsProvider.setQualityLevelTracker(qualityLevelTracker);
    };
    DefaultStreamInfoMetricsProvider.prototype.setTextTrackProvider = function (textTrackProvider) {
        this.textTrackProvider = textTrackProvider;
    };
    DefaultStreamInfoMetricsProvider.prototype.getMetrics = function () {
        var _a = this, manifestUrlProvider = _a.manifestUrlProvider, metadataProvider = _a.metadataProvider, textTrackProvider = _a.textTrackProvider;
        var streamInfo = new hive.snapshots.StreamInfo();
        streamInfo.url = manifestUrlProvider.getManifestUrlWithQuery();
        streamInfo.streamProtocol = metadataProvider.getStreamProtocol();
        streamInfo.streamType = metadataProvider.hasBeenLive() ? StreamType.LIVE : StreamType.VOD;
        streamInfo.qualityLevels = this.qualityLevelMetricsProvider.getMetrics();
        streamInfo.metadataInfo = metadataProvider.getMetadataInfo();
        streamInfo.textTracks = textTrackProvider.getTextTracks();
        return streamInfo;
    };
    return DefaultStreamInfoMetricsProvider;
}());
exports.DefaultStreamInfoMetricsProvider = DefaultStreamInfoMetricsProvider;
//# sourceMappingURL=DefaultStreamInfoMetricsProvider.js.map

/***/ }),

/***/ "../../../core/build/core/src/core/network/NetworkInfo.js":
/*!*********************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/core/network/NetworkInfo.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.NicType = void 0;
var NicType;
(function (NicType) {
    NicType["ETHERNET"] = "ETH";
    NicType["WIRELESS"] = "WLAN";
    NicType["UNKNOWN"] = "UNKNOWN";
})(NicType = exports.NicType || (exports.NicType = {}));
//# sourceMappingURL=NetworkInfo.js.map

/***/ }),

/***/ "../../../core/build/core/src/core/network/StatsNetworkInfo.js":
/*!**************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/core/network/StatsNetworkInfo.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.StatsNetworkInfo = void 0;
var StatsNetworkInfo = /** @class */ (function () {
    function StatsNetworkInfo() {
        this.externalAs = 0;
        this.siteId = 0;
        this.vpn = false;
    }
    StatsNetworkInfo.prototype.setPublicIp = function (publicIp) {
        this.publicIp = publicIp;
    };
    StatsNetworkInfo.prototype.getPublicIp = function () {
        return this.publicIp;
    };
    StatsNetworkInfo.prototype.setExternalAsId = function (externalAs) {
        this.externalAs = externalAs;
    };
    StatsNetworkInfo.prototype.getExternalAsId = function () {
        return this.externalAs;
    };
    StatsNetworkInfo.prototype.setMacAddress = function (macAddress) {
        this.macAddress = macAddress;
    };
    StatsNetworkInfo.prototype.getMacAddress = function () {
        return this.macAddress;
    };
    StatsNetworkInfo.prototype.setNic = function (nic) {
        this.nic = nic;
    };
    StatsNetworkInfo.prototype.getNic = function () {
        return this.nic;
    };
    StatsNetworkInfo.prototype.setNicName = function (nicName) {
        this.nicName = nicName;
    };
    StatsNetworkInfo.prototype.getNicName = function () {
        return this.nicName;
    };
    StatsNetworkInfo.prototype.setPrivateIp = function (privateIp) {
        this.privateIp = privateIp;
    };
    StatsNetworkInfo.prototype.getPrivateIp = function () {
        return this.privateIp;
    };
    StatsNetworkInfo.prototype.setNetmask = function (netmask) {
        this.netmask = netmask;
    };
    StatsNetworkInfo.prototype.getNetmask = function () {
        return this.netmask;
    };
    StatsNetworkInfo.prototype.setCidr = function (cidr) {
        this.cidr = cidr;
    };
    StatsNetworkInfo.prototype.getCidr = function () {
        return null;
    };
    StatsNetworkInfo.prototype.setSiteId = function (siteId) {
        this.siteId = siteId;
    };
    StatsNetworkInfo.prototype.getSiteId = function () {
        return this.siteId;
    };
    StatsNetworkInfo.prototype.setVpn = function (vpn) {
        this.vpn = vpn;
    };
    StatsNetworkInfo.prototype.isVpn = function () {
        return this.vpn;
    };
    return StatsNetworkInfo;
}());
exports.StatsNetworkInfo = StatsNetworkInfo;
//# sourceMappingURL=StatsNetworkInfo.js.map

/***/ }),

/***/ "../../../core/build/core/src/core/quality-level/DefaultQualityLevelTracker.js":
/*!******************************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/core/quality-level/DefaultQualityLevelTracker.js ***!
  \******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __spreadArray = (this && this.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DefaultQualityLevelTracker = void 0;
var HashMap = __webpack_require__(/*! @hivestreaming/collections/map */ "../../../node_modules/@hivestreaming/collections/map.js");
var QualityLevel_1 = __webpack_require__(/*! ./QualityLevel */ "../../../core/build/core/src/core/quality-level/QualityLevel.js");
var EntityType_1 = __webpack_require__(/*! ../entity/EntityType */ "../../../core/build/core/src/core/entity/EntityType.js");
var DefaultQualityLevelTracker = /** @class */ (function () {
    function DefaultQualityLevelTracker() {
        this.videoQualityLevels = [];
        this.audioQualityLevels = [];
    }
    DefaultQualityLevelTracker.prototype.add = function (entityType, data) {
        var id = data.id, bitrate = data.bitrate, width = data.width, height = data.height, label = data.label;
        var qualityLevel = new QualityLevel_1.QualityLevel(id, bitrate, width, height, label);
        var qualityLevels;
        switch (entityType) {
            case EntityType_1.EntityType.VIDEO:
                qualityLevels = this.videoQualityLevels;
                break;
            case EntityType_1.EntityType.AUDIO:
                qualityLevels = this.audioQualityLevels;
                break;
            default: return qualityLevel;
        }
        var existingQualityLevel = qualityLevels.find(function (qualityLevel) { return qualityLevel.id === id; });
        if (existingQualityLevel) {
            qualityLevel = existingQualityLevel;
            if (qualityLevel.bitrate !== bitrate) {
                qualityLevel.bitrate = bitrate;
                qualityLevel.bitrateHistory.push(bitrate);
            }
            if (qualityLevel.width !== width)
                qualityLevel.width = width;
            if (qualityLevel.height !== height)
                qualityLevel.height = height;
            if (qualityLevel.label !== label)
                qualityLevel.label = label;
            return qualityLevel;
        }
        qualityLevels.push(qualityLevel);
        this.setBitrateIndexes(qualityLevels);
        return qualityLevel;
    };
    DefaultQualityLevelTracker.prototype.get = function (id) {
        return this.videoQualityLevels.find(function (qualityLevel) { return qualityLevel.id === id; });
    };
    DefaultQualityLevelTracker.prototype.getAll = function (entityType) {
        switch (entityType) {
            case EntityType_1.EntityType.VIDEO: return this.videoQualityLevels;
            case EntityType_1.EntityType.AUDIO: return this.audioQualityLevels;
            default: return __spreadArray(__spreadArray([], this.audioQualityLevels), this.videoQualityLevels);
        }
    };
    DefaultQualityLevelTracker.prototype.getBitrateIndexes = function (entityType) {
        return this.getAll(entityType).reduce(function (result, qualityLevel) {
            result.set(qualityLevel.id, qualityLevel.bitrateIndex);
            return result;
        }, new HashMap());
    };
    DefaultQualityLevelTracker.prototype.setQualityLevelFlitered = function (id) {
        var qualityLevelFiltered = this.get(id);
        qualityLevelFiltered.filtered = true;
    };
    DefaultQualityLevelTracker.prototype.reset = function () {
        this.videoQualityLevels = [];
        this.audioQualityLevels = [];
    };
    DefaultQualityLevelTracker.prototype.setBitrateIndexes = function (qualityLevels) {
        qualityLevels
            .sort(function (a, b) { return a.bitrate - b.bitrate; })
            .forEach(function (qualityLevel, index) { return qualityLevel.bitrateIndex = index; });
    };
    return DefaultQualityLevelTracker;
}());
exports.DefaultQualityLevelTracker = DefaultQualityLevelTracker;
//# sourceMappingURL=DefaultQualityLevelTracker.js.map

/***/ }),

/***/ "../../../core/build/core/src/core/quality-level/QualityLevel.js":
/*!****************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/core/quality-level/QualityLevel.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.QualityLevel = void 0;
var QualityLevel = /** @class */ (function () {
    function QualityLevel(id, bitrate, width, height, label, filtered) {
        this.id = id;
        this.bitrate = bitrate;
        this.bitrateIndex = null;
        this.bitrateHistory = [bitrate];
        this.width = width;
        this.height = height;
        this.label = label;
        this.filtered = filtered || false;
    }
    QualityLevel.from = function (value) {
        return new QualityLevel(value.id, value.bitrate);
    };
    QualityLevel.prototype.compareTo = function (qualityLevel) {
        if (this.id === qualityLevel.id)
            return 0;
        return this.bitrateIndex - qualityLevel.bitrateIndex;
    };
    QualityLevel.prototype.resetBitrateHistory = function () {
        this.bitrateHistory = [this.bitrate];
    };
    return QualityLevel;
}());
exports.QualityLevel = QualityLevel;
//# sourceMappingURL=QualityLevel.js.map

/***/ }),

/***/ "../../../core/build/core/src/core/scheduler/Deferred.js":
/*!********************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/core/scheduler/Deferred.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Deferred = void 0;
var Deferred = /** @class */ (function () {
    function Deferred() {
        var _this = this;
        // Use node promises because Q promises are based on Framework.setTimeout()
        this._promise = new Promise(function (resolve, reject) {
            _this._resolve = resolve;
            _this._reject = reject;
        });
    }
    Deferred.prototype.resolvedPromise = function (value) {
        this.resolve(value);
        return this._promise;
    };
    Object.defineProperty(Deferred.prototype, "promise", {
        get: function () {
            return this._promise;
        },
        enumerable: false,
        configurable: true
    });
    Deferred.prototype.resolve = function (value) {
        this._resolve(value);
    };
    Deferred.prototype.reject = function (reason) {
        this._reject(reason);
    };
    return Deferred;
}());
exports.Deferred = Deferred;
//# sourceMappingURL=Deferred.js.map

/***/ }),

/***/ "../../../core/build/core/src/core/scheduler/RealTimeScheduler.js":
/*!*****************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/core/scheduler/RealTimeScheduler.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.RealTimeScheduler = void 0;
var HashSet = __webpack_require__(/*! @hivestreaming/collections/set */ "../../../node_modules/@hivestreaming/collections/set.js");
var HashMap = __webpack_require__(/*! @hivestreaming/collections/map */ "../../../node_modules/@hivestreaming/collections/map.js");
var Deferred_1 = __webpack_require__(/*! ./Deferred */ "../../../core/build/core/src/core/scheduler/Deferred.js");
// enable a verbose debugging of all setTimeouts and setIntervals on warning to validate the stacktrace
var TIMEOUTS_VERBOSE_LOGGING = false;
var RealTimeScheduler = /** @class */ (function () {
    function RealTimeScheduler() {
        this.pendingTimeouts = new HashMap();
        this.pendingIntervals = new HashSet();
        // we check if we are running the realTime scheduler in node or browser
        if (typeof global !== 'undefined') {
            this.module = global;
        }
        else
            this.module = window;
    }
    RealTimeScheduler.prototype.init = function () {
        this.clearAllDeferred = undefined;
    };
    RealTimeScheduler.prototype.isSimulated = function () {
        return false;
    };
    RealTimeScheduler.prototype.setTimeoutWithPC = function (callback, context, delay) {
        return undefined;
    };
    RealTimeScheduler.prototype.proceed = function () {
        // nothing do to
        return null;
    };
    RealTimeScheduler.prototype.time = function () {
        return +(new Date());
    };
    RealTimeScheduler.prototype.setTimeout = function (callback, delay, persistClearAll) {
        var _this = this;
        if (persistClearAll === void 0) { persistClearAll = false; }
        var task = this.module.setTimeout(function () {
            _this.pendingTimeouts.delete(task);
            if (TIMEOUTS_VERBOSE_LOGGING)
                console.warn('TRIGGERING TIMEOUT ' + task + '(' + _this.pendingTimeouts.length + ')');
            callback();
            if (_this.pendingTimeouts.length === 0 && _this.clearAllDeferred) {
                _this.clearAllDeferred.resolve();
                _this.clearAllDeferred = undefined;
            }
        }, delay);
        this.pendingTimeouts.set(task, persistClearAll);
        if (TIMEOUTS_VERBOSE_LOGGING)
            console.warn('ADDING TIMEOUT ' + task + ' ' + delay + '(' + this.pendingTimeouts.length + ')');
        return task;
    };
    RealTimeScheduler.prototype.clearTimeout = function (task) {
        this.pendingTimeouts.delete(task);
        if (TIMEOUTS_VERBOSE_LOGGING)
            console.warn('CLEARING TIMEOUT ' + task + '(' + this.pendingTimeouts.length + ')');
        this.module.clearTimeout(task);
        return true;
    };
    RealTimeScheduler.prototype.setInterval = function (callback, delay) {
        var _this = this;
        var task = this.module.setInterval(function () {
            if (TIMEOUTS_VERBOSE_LOGGING)
                console.warn('TRIGGERING INTERVAL: ' + task + ' (' + _this.pendingIntervals.length + ')');
            callback();
        }, delay);
        this.pendingIntervals.hiveAdd(task);
        if (TIMEOUTS_VERBOSE_LOGGING)
            console.warn('ADDING INTERVAL: ' + task + ' - ' + delay + ' (' + this.pendingIntervals.length + ')');
        return task;
    };
    RealTimeScheduler.prototype.clearInterval = function (task) {
        this.pendingIntervals.delete(task);
        if (TIMEOUTS_VERBOSE_LOGGING)
            console.warn('CLEARING INTERVAL: ' + task + ' (' + this.pendingIntervals.length + ')');
        this.module.clearInterval(task);
        return true;
    };
    /**
     * cleanup all pending timeouts and intervals on purge
     * use only for Unit tests cleanup
     * @param force If true, clears the 'persistClearAll' timeouts, not supposed to be. Added for testing cleanup.
     */
    RealTimeScheduler.prototype.clearAll = function (force) {
        var _this = this;
        if (force === void 0) { force = false; }
        // enable this to verify that there are purged pending timeouts
        if (TIMEOUTS_VERBOSE_LOGGING)
            console.warn('CLEARING TIMEOUTS: ' + this.pendingTimeouts.length + ' - CLEARING INTERVALS: ' + this.pendingIntervals.length);
        this.pendingTimeouts.forEach(function (persistClearAll, task) {
            if (force || !persistClearAll) {
                _this.clearTimeout(task);
            }
        });
        var def = new Deferred_1.Deferred();
        this.pendingIntervals.forEach(function (task) { return _this.clearInterval(task); });
        if (this.pendingTimeouts.length === 0) {
            def.resolve();
        }
        else {
            this.clearAllDeferred = def;
        }
        return def.promise;
    };
    return RealTimeScheduler;
}());
exports.RealTimeScheduler = RealTimeScheduler;
//# sourceMappingURL=RealTimeScheduler.js.map
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../node_modules/webpack/buildin/global.js */ "../../../node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "../../../core/build/core/src/core/ticket/DefaultTicketResolver.js":
/*!******************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/core/ticket/DefaultTicketResolver.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.DefaultTicketResolver = void 0;
__webpack_require__(/*! hivejs-protocol/services/services_types */ "../../../protocol/services/services_types.js");
var Q = __webpack_require__(/*! @hivestreaming/q */ "../../../node_modules/@hivestreaming/q/q.js");
var HashMap = __webpack_require__(/*! @hivestreaming/collections/map */ "../../../node_modules/@hivestreaming/collections/map.js");
var Framework_1 = __webpack_require__(/*! ../Framework */ "../../../core/build/core/src/core/Framework.js");
var Ticket_1 = __webpack_require__(/*! ./Ticket */ "../../../core/build/core/src/core/ticket/Ticket.js");
var PendingTicket_1 = __webpack_require__(/*! ./PendingTicket */ "../../../core/build/core/src/core/ticket/PendingTicket.js");
var build_defaults_1 = __webpack_require__(/*! ../../common/build.defaults */ "../../../core/build/core/src/common/build.defaults.js");
var SERVICE_ENDPOINT_CUSTOM = build_defaults_1.BuildParameters.SERVICE_ENDPOINT_CUSTOM;
var CUSTOM_TICKET_REGEXP = build_defaults_1.BuildParameters.CUSTOM_TICKET_REGEXP;
/**
 * the ticket resolver registers the ticket response listeners on the active connection
 * and verifies them with the services response
 */
var DefaultTicketResolver = /** @class */ (function () {
    function DefaultTicketResolver() {
        this.pendingTickets = new HashMap();
        this.logger = (Framework_1.Framework.resolve(Framework_1.Framework.Definitions.LOGGER) || console).log();
        this.logger.debug('INIT TICKET RESOLVER');
    }
    /**
     * register the ticket on the connection
     * @param connection
     * @param ticket
     * @returns {Promise<Ticket>}
     */
    DefaultTicketResolver.prototype.resolve = function (connection, ticket) {
        var _this = this;
        var deferred = Q.defer();
        if (connection) {
            // setup the handler for ticket resolved on connection
            connection.on(HiveStreamingServices.HIVEJS_TICKETS, 0, function (msg) {
                _this.handleTicketResponse(msg);
            });
            // setup the handler for ticket resolved on explicit ticket request
            connection.on(HiveStreamingServices.HIVEJS_TICKETS, 2, function (msg) {
                _this.handleTicketResponse(msg);
            });
            // add the ticket to the pending ones
            this.pendingTickets.set(ticket, new PendingTicket_1.PendingTicket(deferred));
        }
        return deferred.promise;
    };
    /**
     * handles the service response, checking if any registered ticket corresponds
     * to it, and verifies it
     * @param msg
     */
    DefaultTicketResolver.prototype.handleTicketResponse = function (msg) {
        var _this = this;
        var responseTs = new Date().getTime();
        var parsed = JSON.parse(msg.msg);
        var found = false;
        this.pendingTickets.forEach(function (ref, ticket) {
            if (_this.isSameTicket(ticket, parsed)) {
                found = true;
                var ticketLocal = _this.verifyTicket(ticket, parsed);
                if (ticketLocal) {
                    ticketLocal.requestTs = ref.requestTs;
                    ticketLocal.responseTs = responseTs;
                    ref.deferred.resolve(ticketLocal);
                }
                else
                    ref.deferred.reject('Ticket verification failed');
                _this.pendingTickets.delete(ticketLocal);
            }
        });
        if (!found)
            this.logger.warn('no pending ticket matching: ' + msg.msg);
    };
    DefaultTicketResolver.prototype.createTicket = function (ticketUrl) {
        var ticketRegexp = new RegExp('^https?://api(?:-test|-dev)?\\.hivestreaming\\.com/v1/events/(?:wildcard/)?');
        if (SERVICE_ENDPOINT_CUSTOM)
            ticketRegexp = new RegExp(CUSTOM_TICKET_REGEXP);
        if (ticketRegexp.test(ticketUrl)) {
            return Ticket_1.Ticket.fromUrl(ticketUrl);
        }
        return null;
    };
    /**
     * compares a ticket with a resolved ticket returned by the services
     * @param ticket
     * @param ticketResponse
     * @returns {boolean}
     */
    DefaultTicketResolver.prototype.isSameTicket = function (ticket, ticketResponse) {
        return (ticket.getPartnerId() === ticketResponse.SiteId &&
            ticket.getCustomerId() === ticketResponse.CROId &&
            ticket.getContentId() === ticketResponse.ContentId);
    };
    /**
     * parses the resolve ticket resolved by the services
     * and verifies the signature
     * @param ticket
     * @param ticketResponse
     * @returns {Ticket}
     */
    DefaultTicketResolver.prototype.verifyTicket = function (ticket, ticketResponse) {
        ticket.updateFromTicketResponse(ticketResponse);
        if (ticket.verifySignature()) {
            return ticket;
        }
        return null;
    };
    return DefaultTicketResolver;
}());
exports.DefaultTicketResolver = DefaultTicketResolver;
//# sourceMappingURL=DefaultTicketResolver.js.map

/***/ }),

/***/ "../../../core/build/core/src/core/ticket/PendingTicket.js":
/*!**********************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/core/ticket/PendingTicket.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.PendingTicket = void 0;
var PendingTicket = /** @class */ (function () {
    function PendingTicket(deferred) {
        this.requestTs = new Date().getTime();
        this.deferred = deferred;
    }
    return PendingTicket;
}());
exports.PendingTicket = PendingTicket;
//# sourceMappingURL=PendingTicket.js.map

/***/ }),

/***/ "../../../core/build/core/src/core/ticket/Ticket.js":
/*!***************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/core/ticket/Ticket.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Ticket = exports.TicketType = void 0;
var uuid = __webpack_require__(/*! uuid */ "../../../node_modules/uuid/index.js");
var URI = __webpack_require__(/*! urijs */ "../../../node_modules/urijs/src/URI.js");
var jsrsasign_1 = __webpack_require__(/*! @hivestreaming/jsrsasign */ "../../../node_modules/@hivestreaming/jsrsasign/lib/jsrsasign.js");
var build_defaults_1 = __webpack_require__(/*! ../../common/build.defaults */ "../../../core/build/core/src/common/build.defaults.js");
var TicketType;
(function (TicketType) {
    TicketType[TicketType["PROD"] = 0] = "PROD";
    TicketType[TicketType["TEST"] = 1] = "TEST";
    TicketType[TicketType["DEV"] = 2] = "DEV";
    TicketType[TicketType["CUSTOM"] = 3] = "CUSTOM";
})(TicketType = exports.TicketType || (exports.TicketType = {}));
var Ticket = /** @class */ (function () {
    function Ticket(ticketUrl) {
        this.testId = null;
        this.originalManifest = null;
        this.ticketUrl = ticketUrl;
        this.sessionId = uuid.v4();
        var prodTicketRegExp = RegExp('(?:api\\.hivestreaming\\.com)');
        var testTicketRegExp = RegExp('(?:api-test\\.hivestreaming\\.com)');
        var devTicketRegExp = RegExp('(?:api-dev\\.hivestreaming\\.com)');
        var customTicketRegExp = RegExp(build_defaults_1.BuildParameters.CUSTOM_TICKET_REGEXP);
        if (this.ticketUrl) {
            if (prodTicketRegExp.test(ticketUrl))
                this.ticketType = TicketType.PROD;
            else if (testTicketRegExp.test(ticketUrl))
                this.ticketType = TicketType.TEST;
            else if (devTicketRegExp.test(ticketUrl))
                this.ticketType = TicketType.DEV;
            else if (build_defaults_1.BuildParameters.CUSTOM_TICKET_REGEXP && customTicketRegExp.test(ticketUrl))
                this.ticketType = TicketType.CUSTOM;
        }
    }
    Ticket.fromTuple = function (partnerId, customerId, contentId) {
        var ticket = new Ticket();
        ticket.partnerId = partnerId;
        ticket.customerId = customerId;
        ticket.contentId = contentId;
        return ticket;
    };
    Ticket.fromUrl = function (ticketUrl) {
        var ticket = new Ticket(ticketUrl);
        var uri = URI(ticketUrl);
        var parts = uri.path().split('/').slice(3);
        ticket.partnerId = parts[0];
        ticket.customerId = parts[1];
        ticket.contentId = parts[2];
        ticket.ticketId = parts[3];
        ticket.searchParams = __assign(__assign({}, ticket.searchParams), uri.query(true));
        return ticket;
    };
    Ticket.prototype.updateFromTicketResponse = function (ticketResponse) {
        this.contentId = ticketResponse.ContentId;
        this.partnerId = ticketResponse.SiteId;
        this.customerId = ticketResponse.CROId;
        this.signature = ticketResponse.Signature;
        this.manifestUrl = ticketResponse.SourceURL;
        this.searchParams = __assign(__assign({}, this.searchParams), ticketResponse.SourceURLParams);
    };
    Ticket.prototype.updateFromTuple = function (partnerId, customerId, contentId) {
        this.partnerId = partnerId;
        this.customerId = customerId;
        this.contentId = contentId;
    };
    Ticket.prototype.verifySignature = function () {
        var modulus = 'b6614c3e4cd1d14eed6b39ef2bf6b9a3e3d6dfcd26699d7270d887923bcbf83efb3dadb717c0bafb1d48dce361eb369b7cc46e57405ebfbdd86c3175532fe56cc77f473d345b2cb6feafb5ab0e24f364a3d259f27e4a2fd97468265bddfd3ddd3ac64251db650ca0280af2b2c45e8b1c8f040f2c433ac0a157d2b3fd91517253';
        var exponent = '010001';
        var keystring = this.contentId + this.partnerId + this.customerId + this.manifestUrl;
        // TODO when the HiveServices ticket resolve will support tokens (SourceURLParams we should append the param keys to the keystring)
        var key = new jsrsasign_1.RSAKey();
        key.setPublic(modulus, exponent);
        var b64Hex = jsrsasign_1.b64tohex(this.signature);
        return key.verifyString(keystring, b64Hex);
    };
    Ticket.prototype.getPartnerId = function () {
        return this.partnerId;
    };
    Ticket.prototype.getCustomerId = function () {
        return this.customerId;
    };
    Ticket.prototype.getContentId = function () {
        return this.contentId;
    };
    Ticket.prototype.getTicketId = function () {
        return this.ticketId;
    };
    Ticket.prototype.getTicketUrl = function () {
        return this.ticketUrl;
    };
    Ticket.prototype.getManifestUrl = function () {
        return this.manifestUrl;
    };
    Ticket.prototype.setManifestUrl = function (value) {
        var uri = URI(value);
        // adding manifest params while keeping ticket params
        this.searchParams = __assign(__assign({}, this.searchParams), uri.query(true));
        this.manifestUrl = uri.query('').valueOf();
        // reset the cached value
        this.manifestUrlWithQuery = null;
    };
    Ticket.prototype.getManifestUrlWithQuery = function () {
        if (!this.manifestUrlWithQuery) {
            this.manifestUrlWithQuery = this.manifestUrl ?
                URI(this.manifestUrl).query(this.searchParams).valueOf() : null;
        }
        return this.manifestUrlWithQuery;
    };
    Ticket.prototype.getSearchParams = function () {
        return this.searchParams;
    };
    Ticket.prototype.getEventInfo = function () {
        return '[' + this.partnerId + '/' + this.customerId + '/' + this.contentId + ']';
    };
    Ticket.prototype.getEventInfoArray = function () {
        return [this.partnerId, this.customerId, this.contentId];
    };
    Ticket.prototype.getFullEventInfo = function () {
        return this.manifestUrl + '-[' + this.partnerId + '/' + this.customerId + '/' + this.contentId + ']';
    };
    Ticket.prototype.toString = function () {
        return this.getEventInfo();
    };
    return Ticket;
}());
exports.Ticket = Ticket;
//# sourceMappingURL=Ticket.js.map

/***/ }),

/***/ "../../../core/build/core/src/stats/Bindings.js":
/*!***********************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/stats/Bindings.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.StatsBindings = void 0;
var inversify = __webpack_require__(/*! inversify */ "../../../node_modules/inversify/dist/inversify.js");
var Bindings_1 = __webpack_require__(/*! ../core/Bindings */ "../../../core/build/core/src/core/Bindings.js");
var Reporting_1 = __webpack_require__(/*! ./Reporting */ "../../../core/build/core/src/stats/Reporting.js");
var Track_1 = __webpack_require__(/*! ./Track */ "../../../core/build/core/src/stats/Track.js");
var Stats_1 = __webpack_require__(/*! ./Stats */ "../../../core/build/core/src/stats/Stats.js");
var StatsServiceClient_1 = __webpack_require__(/*! ./StatsServiceClient */ "../../../core/build/core/src/stats/StatsServiceClient.js");
var DefaultTicketResolver_1 = __webpack_require__(/*! ../core/ticket/DefaultTicketResolver */ "../../../core/build/core/src/core/ticket/DefaultTicketResolver.js");
var PersistentIdentityProvider_1 = __webpack_require__(/*! ../core/identity/PersistentIdentityProvider */ "../../../core/build/core/src/core/identity/PersistentIdentityProvider.js");
var NodeConnectivityInfo_1 = __webpack_require__(/*! ../core/connectivity/NodeConnectivityInfo */ "../../../core/build/core/src/core/connectivity/NodeConnectivityInfo.js");
var DefaultQualityLevelTracker_1 = __webpack_require__(/*! ../core/quality-level/DefaultQualityLevelTracker */ "../../../core/build/core/src/core/quality-level/DefaultQualityLevelTracker.js");
var DefaultQualityLevelMetricsProvider_1 = __webpack_require__(/*! ../core/metrics/DefaultQualityLevelMetricsProvider */ "../../../core/build/core/src/core/metrics/DefaultQualityLevelMetricsProvider.js");
var DefaultStatsNodeInfo_1 = __webpack_require__(/*! ./node-info/DefaultStatsNodeInfo */ "../../../core/build/core/src/stats/node-info/DefaultStatsNodeInfo.js");
var DefaultFragmentMetadataMetricsProvider_1 = __webpack_require__(/*! ../core/metrics/DefaultFragmentMetadataMetricsProvider */ "../../../core/build/core/src/core/metrics/DefaultFragmentMetadataMetricsProvider.js");
var DefaultStreamInfoMetricsProvider_1 = __webpack_require__(/*! ../core/metrics/DefaultStreamInfoMetricsProvider */ "../../../core/build/core/src/core/metrics/DefaultStreamInfoMetricsProvider.js");
var DefaultFragmentDownloadMetricsProvider_1 = __webpack_require__(/*! ../core/metrics/DefaultFragmentDownloadMetricsProvider */ "../../../core/build/core/src/core/metrics/DefaultFragmentDownloadMetricsProvider.js");
var StatsJSConnectivityProvider_1 = __webpack_require__(/*! ./StatsJSConnectivityProvider */ "../../../core/build/core/src/stats/StatsJSConnectivityProvider.js");
var DefaultRemoteConfigManager_1 = __webpack_require__(/*! ../webrtc/remote-config/DefaultRemoteConfigManager */ "../../../core/build/core/src/webrtc/remote-config/DefaultRemoteConfigManager.js");
var DefaultConfigStore_1 = __webpack_require__(/*! ../webrtc/config-store/DefaultConfigStore */ "../../../core/build/core/src/webrtc/config-store/DefaultConfigStore.js");
var DefaultPeerNodeInfo_1 = __webpack_require__(/*! ../webrtc/node-info/DefaultPeerNodeInfo */ "../../../core/build/core/src/webrtc/node-info/DefaultPeerNodeInfo.js");
var DefaultBoosterClient_1 = __webpack_require__(/*! ../webrtc/booster/DefaultBoosterClient */ "../../../core/build/core/src/webrtc/booster/DefaultBoosterClient.js");
var Logger_1 = __webpack_require__(/*! ../core/Logger */ "../../../core/build/core/src/core/Logger.js");
var ExternalCandidates_1 = __webpack_require__(/*! ./ExternalCandidates */ "../../../core/build/core/src/stats/ExternalCandidates.js");
var StatsBindings = /** @class */ (function () {
    function StatsBindings() {
    }
    StatsBindings.prototype.apply = function (kernel) {
        kernel.bind(new inversify.TypeBinding(Bindings_1.Definitions.REPORTING, Reporting_1.Reporting, inversify.TypeBindingScopeEnum.Singleton));
        kernel.bind(new inversify.TypeBinding(Bindings_1.Definitions.SERVICES_CLIENT, StatsServiceClient_1.StatsServiceClient, inversify.TypeBindingScopeEnum.Singleton));
        kernel.bind(new inversify.TypeBinding(Bindings_1.Definitions.TICKET_RESOLVER, DefaultTicketResolver_1.DefaultTicketResolver, inversify.TypeBindingScopeEnum.Singleton));
        kernel.bind(new inversify.TypeBinding(Bindings_1.Definitions.IDENTITY_PROVIDER, PersistentIdentityProvider_1.PersistentReportingIdentityProvider, inversify.TypeBindingScopeEnum.Singleton));
        kernel.bind(new inversify.TypeBinding(Bindings_1.Definitions.LOGGER, Logger_1.Logger, inversify.TypeBindingScopeEnum.Singleton));
        kernel.bind(new inversify.TypeBinding(Bindings_1.Definitions.CONFIG_STORE, DefaultConfigStore_1.DefaultConfigStore, inversify.TypeBindingScopeEnum.Singleton));
        kernel.bind(new inversify.TypeBinding(Bindings_1.Definitions.PEER_NODE_INFO, DefaultPeerNodeInfo_1.DefaultPeerNodeInfo, inversify.TypeBindingScopeEnum.Transient));
        kernel.bind(new inversify.TypeBinding(Bindings_1.Definitions.CONNECTIVITY_INFO_PROVIDER, StatsJSConnectivityProvider_1.StatsJSConnectivityProvider, inversify.TypeBindingScopeEnum.Singleton));
        kernel.bind(new inversify.TypeBinding(Bindings_1.Definitions.EXTERNAL_CANDIDATES, ExternalCandidates_1.ExternalCandidates, inversify.TypeBindingScopeEnum.Singleton));
        kernel.bind(new inversify.TypeBinding(Bindings_1.Definitions.PEER_CONNECTIVITY_INFO, NodeConnectivityInfo_1.NodeConnectivityInfo, inversify.TypeBindingScopeEnum.Singleton));
        if (typeof HiveOriginalXMLHttpRequest !== 'undefined')
            kernel.bind(new inversify.TypeBinding(Bindings_1.Definitions.HTTP_REQUEST, HiveOriginalXMLHttpRequest));
        else
            kernel.bind(new inversify.TypeBinding(Bindings_1.Definitions.HTTP_REQUEST, XMLHttpRequest));
        // Bindings for Stats Metrics and Track Snapshots
        kernel.bind(new inversify.TypeBinding(Bindings_1.Definitions.STATS_STORE, Stats_1.Store, inversify.TypeBindingScopeEnum.Transient));
        kernel.bind(new inversify.TypeBinding(Bindings_1.Definitions.STATS_CLIENT, Stats_1.Client, inversify.TypeBindingScopeEnum.Transient));
        kernel.bind(new inversify.TypeBinding(Bindings_1.Definitions.TRACK_MANAGER, Track_1.Manager, inversify.TypeBindingScopeEnum.Transient));
        kernel.bind(new inversify.TypeBinding(Bindings_1.Definitions.TRACK_CLIENT, Track_1.Client, inversify.TypeBindingScopeEnum.Transient));
        kernel.bind(new inversify.TypeBinding(Bindings_1.Definitions.QUALITY_LEVEL_TRACKER, DefaultQualityLevelTracker_1.DefaultQualityLevelTracker, inversify.TypeBindingScopeEnum.Transient));
        kernel.bind(new inversify.TypeBinding(Bindings_1.Definitions.QUALITY_LEVEL_METRICS_PROVIDER, DefaultQualityLevelMetricsProvider_1.DefaultQualityLevelMetricsProvider, inversify.TypeBindingScopeEnum.Transient));
        kernel.bind(new inversify.TypeBinding(Bindings_1.Definitions.STATS_NODE_INFO, DefaultStatsNodeInfo_1.DefaultStatsNodeInfo, inversify.TypeBindingScopeEnum.Transient));
        kernel.bind(new inversify.TypeBinding(Bindings_1.Definitions.STREAM_INFO_METRICS_PROVIDER, DefaultStreamInfoMetricsProvider_1.DefaultStreamInfoMetricsProvider, inversify.TypeBindingScopeEnum.Transient));
        kernel.bind(new inversify.TypeBinding(Bindings_1.Definitions.FRAGMENT_METADATA_METRICS_PROVIDER, DefaultFragmentMetadataMetricsProvider_1.DefaultFragmentMetadataMetricsProvider, inversify.TypeBindingScopeEnum.Transient));
        kernel.bind(new inversify.TypeBinding(Bindings_1.Definitions.FRAGMENT_DOWNLOAD_METRICS_PROVIDER, DefaultFragmentDownloadMetricsProvider_1.DefaultFragmentDownloadMetricsProvider, inversify.TypeBindingScopeEnum.Transient));
        kernel.bind(new inversify.TypeBinding(Bindings_1.Definitions.REMOTE_CONFIG_MANAGER, DefaultRemoteConfigManager_1.DefaultRemoteConfigManager, inversify.TypeBindingScopeEnum.Singleton));
        kernel.bind(new inversify.TypeBinding(Bindings_1.Definitions.BOOSTER_CLIENT, DefaultBoosterClient_1.DefaultBoosterClient, inversify.TypeBindingScopeEnum.Singleton));
    };
    return StatsBindings;
}());
exports.StatsBindings = StatsBindings;
//# sourceMappingURL=Bindings.js.map

/***/ }),

/***/ "../../../core/build/core/src/stats/CustomSnapshotProvider.js":
/*!*************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/stats/CustomSnapshotProvider.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.CustomSnapshotProvider = void 0;
var TrackContainer_1 = __webpack_require__(/*! hivejs-protocol/snapshots/TrackContainer */ "../../../protocol/snapshots/TrackContainer.js");
var Framework_1 = __webpack_require__(/*! ../core/Framework */ "../../../core/build/core/src/core/Framework.js");
var HiveServices_1 = __webpack_require__(/*! ../core/HiveServices */ "../../../core/build/core/src/core/HiveServices.js");
var HashMap = __webpack_require__(/*! @hivestreaming/collections/map */ "../../../node_modules/@hivestreaming/collections/map.js");
var ClientConfigs_1 = __webpack_require__(/*! ../webrtc/ClientConfigs */ "../../../core/build/core/src/webrtc/ClientConfigs.js");
/**
 * Static provider for sending custom track events.
 *  - App default name is CustomSnapshot
 *  - tags are by default the event info triplette (partner/customer/contentId).
 *    Passing custom tags will replace the event tags
 *  - name is important and is going to be last subfolder
 */
var CustomSnapshotProvider = /** @class */ (function () {
    function CustomSnapshotProvider() {
    }
    CustomSnapshotProvider.initClient = function (client, eventInfo, guid) {
        this.client = client;
        this.eventInfo = eventInfo;
        this.guid = guid;
    };
    CustomSnapshotProvider.sendTrackSnapshot = function (app, tags, name, guid, data) {
        var trackContainer = new TrackContainer_1.TrackContainer();
        trackContainer.app = app ? app : 'CustomSnapshot';
        trackContainer.guid = guid ? guid : this.guid;
        trackContainer.createdAt = Framework_1.Framework.time();
        trackContainer.name = name;
        if (tags)
            trackContainer.tags = tags;
        else
            trackContainer.tags = this.eventInfo;
        trackContainer.data = typeof data === 'string' ? JSON.parse(data) : data;
        this.send(trackContainer);
    };
    CustomSnapshotProvider.send = function (trackContainer) {
        var msg = new HiveServices_1.Message(HiveStreamingServices.HIVEJS_SNAPSHOTS, 2, JSON.stringify(trackContainer));
        if (this.client && this.allowed) {
            this.client.getConnection().send(msg);
        }
    };
    /**
     * Utility for not sending too often messages.
     * Bulks customData into one buffer that gets flushed when it reaches the limit
     *
     * TODO could be improved with a 'force flush' every X seconds
     */
    CustomSnapshotProvider.appendAndFlush = function (app, tags, name, guid, data, bufferLimit) {
        try {
            var key = app + (tags ? tags.join() : '') + name + guid;
            var buffer = this.bufferMap.has(key) ? this.bufferMap.get(key) : [];
            buffer.push(typeof data === 'string' ? JSON.parse(data) : data);
            if (buffer.length >= bufferLimit) {
                this.sendTrackSnapshot(app, tags, name, guid, { buffer: buffer });
                this.bufferMap.delete(key);
            }
            else
                this.bufferMap.set(key, buffer);
        }
        catch (e) {
            console.log(e);
        }
    };
    CustomSnapshotProvider.allowed = ClientConfigs_1.HiveConfig.CustomSnapshotProperties.enabled;
    CustomSnapshotProvider.bufferMap = new HashMap();
    return CustomSnapshotProvider;
}());
exports.CustomSnapshotProvider = CustomSnapshotProvider;
//# sourceMappingURL=CustomSnapshotProvider.js.map

/***/ }),

/***/ "../../../core/build/core/src/stats/ExternalCandidates.js":
/*!*********************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/stats/ExternalCandidates.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ExternalCandidates = void 0;
var Constants_1 = __webpack_require__(/*! ../core/Constants */ "../../../core/build/core/src/core/Constants.js");
var Framework_1 = __webpack_require__(/*! ../core/Framework */ "../../../core/build/core/src/core/Framework.js");
var Q = __webpack_require__(/*! @hivestreaming/q */ "../../../node_modules/@hivestreaming/q/q.js");
var Utils_1 = __webpack_require__(/*! ../core/Utils */ "../../../core/build/core/src/core/Utils.js");
var HashMap = __webpack_require__(/*! @hivestreaming/collections/map */ "../../../node_modules/@hivestreaming/collections/map.js");
var models_1 = __webpack_require__(/*! ../webrtc/booster/models */ "../../../core/build/core/src/webrtc/booster/models/index.js");
var logger_hive_1 = __webpack_require__(/*! ../common/logger.hive */ "../../../core/build/core/src/common/logger.hive.js");
var ErrorCodes = __webpack_require__(/*! ../common/error.hive */ "../../../core/build/core/src/common/error.hive.js");
/**
 * This class will listen for post messages sent to a certain topic, expecting to get webRTC candidates on the messages.
 * The IP address of this candidates will be stored.
 */
var ExternalCandidates = /** @class */ (function () {
    function ExternalCandidates() {
        this.loggerId = '[ExternalCandidates] ';
        this.logger = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.LOGGER).log();
        this.onMessageHandler = this.handleMessage.bind(this);
        this.externalIPCandidates = new Array();
    }
    ExternalCandidates.prototype.reset = function () {
        Framework_1.Framework.clearTimeout(this.externalCandidatesTimeoutId);
        this.pendingExternalCandidates = Q.defer();
        this.pendingExternalCandidates.resolve();
        this.externalIPCandidates = new Array();
        this.stopExternalCandidates();
    };
    ExternalCandidates.prototype.getExternalCandidatesIp = function () {
        return this.externalIPCandidates;
    };
    ExternalCandidates.prototype.setCandidateTopicName = function (candidateTopicName) {
        this.candidateTopicName = candidateTopicName;
    };
    /**
     * Request external candidates if the networkInfo is not present and the topic name is the one expected.
     * Returns a promise that will be rejected if we don't get the candidates on certain time or if the previous
     * condition is no true, otherwise returns a promise pending to resolve.
     */
    ExternalCandidates.prototype.requestCandidates = function () {
        var _this = this;
        this.pendingExternalCandidates = Q.defer();
        if (this.candidateTopicName) {
            this.listenExternalCandidates();
            window.top.postMessage(this.candidateTopicName, '*');
            this.logger.info(this.loggerId + 'External ICE candidates info requested');
            this.externalCandidatesTimeoutId = Framework_1.Framework.setTimeout(function () {
                _this.pendingExternalCandidates.reject('Waiting for external ICE candidates timed out');
            }, Constants_1.Constants.TIMEOUT_EXTERNAL_CANDIDATES_GATHERING);
        }
        else {
            this.pendingExternalCandidates.reject('No topic name set');
        }
        return this.pendingExternalCandidates.promise;
    };
    ExternalCandidates.prototype.listenExternalCandidates = function () {
        window.addEventListener('message', this.onMessageHandler);
    };
    ExternalCandidates.prototype.stopExternalCandidates = function () {
        window.removeEventListener('message', this.onMessageHandler);
    };
    ExternalCandidates.prototype.handleMessage = function (e) {
        if (e.data.topic === this.candidateTopicName) {
            // Parse if receiving stringified array
            this.setExternalCandidates(e.data.candidates);
        }
    };
    /**
     * On new candidates received this function is called. Clears/Resolves the part of the context that
     * informs if we are still waiting for them. Sets the candidates received in the context only with IP
     * candidates. The privateIp only will substitute mdns candidates.
     */
    ExternalCandidates.prototype.setExternalCandidates = function (candidatesString) {
        if (this.pendingExternalCandidates.promise.isPending()) {
            this.stopExternalCandidates();
            Framework_1.Framework.clearTimeout(this.externalCandidatesTimeoutId);
            try {
                var candidates = JSON.parse(candidatesString);
                this.logger.info(this.loggerId + 'Got external ICE candidates ' + candidates);
                this.externalIPCandidates = candidates.reduce(function (partialAcc, rawCandidate) {
                    var candidate = Utils_1.stringToRTCIceCandidateInfo(JSON.parse(rawCandidate).candidate);
                    if (candidate.protocol.toLowerCase() === 'udp' && candidate.addressType == models_1.AddressType.IP) {
                        partialAcc.set(candidate.address, candidate);
                    }
                    return partialAcc;
                }, new HashMap()).values();
                this.pendingExternalCandidates.resolve();
            }
            catch (e) {
                logger_hive_1.ErrorMonitor.getInstance().logError('Failed to parse external candidates', this.loggerId, ErrorCodes.HIVE_COMM_PLUGIN.PARSE_EXTERNAL_CANDIDATES, { candidatesString: candidatesString });
                this.pendingExternalCandidates.reject('failed to parse external candidates');
            }
        }
    };
    return ExternalCandidates;
}());
exports.ExternalCandidates = ExternalCandidates;
//# sourceMappingURL=ExternalCandidates.js.map

/***/ }),

/***/ "../../../core/build/core/src/stats/Reporting.js":
/*!************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/stats/Reporting.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ReportingInstance = exports.ReportingFilter = exports.Reporting = exports.ClientState = void 0;
var HashMap = __webpack_require__(/*! @hivestreaming/collections/map */ "../../../node_modules/@hivestreaming/collections/map.js");
var Q = __webpack_require__(/*! @hivestreaming/q */ "../../../node_modules/@hivestreaming/q/q.js");
var Framework_1 = __webpack_require__(/*! ../core/Framework */ "../../../core/build/core/src/core/Framework.js");
var Track_1 = __webpack_require__(/*! ./Track */ "../../../core/build/core/src/stats/Track.js");
var _1 = __webpack_require__(/*! ./ */ "../../../core/build/core/src/stats/index.js");
var ClientState;
(function (ClientState) {
    ClientState[ClientState["STOP"] = 0] = "STOP";
    ClientState[ClientState["IDLE"] = 1] = "IDLE";
    ClientState[ClientState["PLAY"] = 2] = "PLAY";
})(ClientState = exports.ClientState || (exports.ClientState = {}));
var Reporting = /** @class */ (function () {
    function Reporting() {
        this.p2pId = null;
        this.reportingId = null;
        this.sessionMap = new HashMap();
        this.logger = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.LOGGER).log();
        this.logger.debug('INIT REPORTING');
        this.serviceClient = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.SERVICES_CLIENT);
        this.identityProvider = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.IDENTITY_PROVIDER);
        this.ticketResolver = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.TICKET_RESOLVER);
        this.remoteConfigManager = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.REMOTE_CONFIG_MANAGER);
    }
    /**
     * Remove the specified session.
     * if there are no active sessions, close the websocket
     */
    Reporting.prototype.close = function (session) {
        if (session) {
            this.sessionMap.delete(session);
        }
        if (this.sessionMap.length == 0) {
            // close the websocket if there are no active sessions left
            this.serviceClient.close();
        }
    };
    Reporting.prototype.hasSession = function (sessionId) {
        return this.sessionMap.has(sessionId);
    };
    Reporting.prototype.initSession = function (pluginId, ticketUrl, proxy, options) {
        var _this = this;
        var deferred = Q.defer();
        var identityPromise = this.identityProvider.getIdentity();
        var ticket = typeof ticketUrl === 'string' ? this.ticketResolver.createTicket(ticketUrl) : ticketUrl;
        if (!ticket) {
            deferred.reject(new Error("Invalid ticket: " + ticketUrl));
            return deferred.promise;
        }
        ticket.pluginId = pluginId;
        if ((options === null || options === void 0 ? void 0 : options.testId) != null) {
            ticket.testId = options.testId;
        }
        if (options === null || options === void 0 ? void 0 : options.serviceEndpoint) {
            return identityPromise.then(function (identity) {
                return _this.initServices(identity, ticket, null, options.serviceEndpoint);
            }).fail(function (e) { return Q.reject(e); });
        }
        identityPromise.then(function (identity) {
            _this.initServices(identity, ticket, deferred);
        }).fail(deferred.reject);
        return deferred.promise;
    };
    Reporting.prototype.initServices = function (identity, ticket, deferred, serviceEndpoint) {
        var _this = this;
        this.p2pId = identity.getPeerId();
        this.reportingId = identity.getReportingId();
        var serviceConnection = this.serviceClient.init(this.p2pId, ticket, serviceEndpoint);
        this.serviceClient.connect();
        this.remoteConfigManager.init(this.serviceClient);
        if (serviceEndpoint) {
            return serviceConnection.promise.then(function (connection) {
                var tsId = ticket.sessionId;
                var ri;
                // if (this.statsStore.ticket == null || (this.statsStore.ticket != null && !this.sameTicket(ticket, this.statsStore.ticket))) {
                if (!_this.sessionMap.has(tsId)) {
                    var techInfo = _1.default.getInfo();
                    ri = new ReportingInstance(ticket, _this.serviceClient, techInfo, identity);
                    // init stats store with id and ticket
                    // don't activate yet the the stats client, wait for the session to be activated
                    ri.statsStore.init(_this.reportingId, ticket, techInfo, tsId);
                    // init the track manager and pass the ticket so it will start reporting track snapshots
                    ri.trackManager.init(_this.reportingId, techInfo);
                    ri.trackManager.ticketRequested(ticket);
                    // generate and return the reporting instance as placeholder of all the initialized stats components
                    _this.sessionMap.set(tsId, ri);
                    _this.logger.debug('SESSION ID SET ', tsId);
                }
                else {
                    ri = _this.sessionMap.get(tsId);
                    _this.logger.warn('SESSION ALREADY EXISTING ' + ri.statsStore.ticket);
                }
                return ri;
            }).fail(function (err) { return Q.reject(err); });
        }
        var ticketPromise = this.ticketResolver.resolve(serviceConnection.conn, ticket);
        var connPromise = serviceConnection.promise.then(function (connection) {
            var riPromise = ticketPromise.then(function (ticket) {
                var tsId = ticket.sessionId;
                // if (this.statsStore.ticket == null || (this.statsStore.ticket != null && !this.sameTicket(ticket, this.statsStore.ticket))) {
                if (!_this.sessionMap.has(tsId)) {
                    var techInfo = _1.default.getInfo();
                    var ri = new ReportingInstance(ticket, _this.serviceClient, techInfo, identity);
                    // init stats store with id and ticket
                    // don't activate yet the the stats client, wait for the session to be activated
                    ri.statsStore.init(_this.reportingId, ticket, techInfo, tsId);
                    // init the track manager and pass the ticket so it will start reporting track snapshots
                    ri.trackManager.init(_this.reportingId, techInfo);
                    ri.trackManager.ticketRequested(ticket);
                    // generate and return the reporting instance as placeholder of all the initialized stats components
                    _this.sessionMap.set(tsId, ri);
                    _this.logger.debug('SESSION ID SET ', tsId);
                    deferred.resolve(ri);
                    return ri;
                }
                else {
                    var ri = _this.sessionMap.get(tsId);
                    _this.logger.warn('SESSION ALREADY EXISTING ' + ri.statsStore.ticket);
                    deferred.resolve(ri);
                    return ri;
                }
            }).fail(function (err) { return deferred.reject(err ? err : 'Error resolving the ticket'); });
            connection.onerror(function (connection) {
                deferred.reject('Error establishing connection to Hive Services');
            });
            return riPromise;
        }).fail(function (err) { return (deferred.reject(err), null); });
        this.serviceClient.connect();
        return connPromise;
    };
    return Reporting;
}());
exports.Reporting = Reporting;
var ReportingFilter = /** @class */ (function () {
    function ReportingFilter(store) {
        this.threshold = 0;
        this.store = store;
    }
    ReportingFilter.prototype.shouldSend = function () {
        var _a, _b, _c, _d;
        var playingTime = (_d = (_c = (_b = (_a = this.store) === null || _a === void 0 ? void 0 : _a.totalSnapshot) === null || _b === void 0 ? void 0 : _b.player) === null || _c === void 0 ? void 0 : _c.playingTimeMs) !== null && _d !== void 0 ? _d : 0;
        var threshold = this.threshold;
        // If threshold is `0` (the default in both this class as well as
        // plugin options) this expression will always return true. playingTimeMs
        // should never be negative, but lets guard against undefined.
        var shouldSend = playingTime >= threshold;
        return { playingTime: playingTime, threshold: threshold, shouldSend: shouldSend };
    };
    ReportingFilter.prototype.setThreshold = function (threshold) {
        this.threshold = threshold;
    };
    return ReportingFilter;
}());
exports.ReportingFilter = ReportingFilter;
/**
 * Object placeholder for all the
 * session's initialized reporting components
 */
var ReportingInstance = /** @class */ (function () {
    function ReportingInstance(ticket, serviceClient, techInfo, identity) {
        this.ticket = ticket;
        this.serviceClient = serviceClient;
        this.techInfo = techInfo;
        this.identity = identity;
        this.statsStore = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.STATS_STORE);
        this.statsClient = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.STATS_CLIENT);
        this.trackManager = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.TRACK_MANAGER);
        this.trackClient = new Track_1.Client(this.trackManager);
        this.nodeInfo = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.STATS_NODE_INFO);
        this.setFilter(new ReportingFilter(this.statsStore));
        this.remoteConfigManager = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.REMOTE_CONFIG_MANAGER);
        this.remoteConfigManager.onConnected(this.ticket, this.statsStore);
        this.boosterClient = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.BOOSTER_CLIENT);
        this.connInfoProvider = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.CONNECTIVITY_INFO_PROVIDER);
        this.boosterClient.init(ticket);
    }
    ReportingInstance.prototype.updateTechInfo = function (techInfo) {
        this.techInfo = techInfo;
        this.statsStore.updateTechInfo(this.techInfo);
        this.trackManager.updateTechInfo(this.techInfo);
    };
    ReportingInstance.prototype.onStateChange = function (state) {
        this.statsClient.onStateChange(state);
    };
    /**
     * called when another initialized session has been
     * activated. Clear up the scheduled messages
     */
    ReportingInstance.prototype.deactivate = function () {
        this.trackClient.clearScheduledSend();
    };
    ReportingInstance.prototype.setThreshold = function (threshold) {
        this.filter.setThreshold(Number(threshold) || 0);
    };
    ReportingInstance.prototype.setFilter = function (filter) {
        this.filter = filter;
        this.trackClient.setFilter(filter);
        this.statsClient.setFilter(filter);
    };
    return ReportingInstance;
}());
exports.ReportingInstance = ReportingInstance;
//# sourceMappingURL=Reporting.js.map

/***/ }),

/***/ "../../../core/build/core/src/stats/SnapshotAccountingManager.js":
/*!****************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/stats/SnapshotAccountingManager.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.SnapshotAccountingManager = void 0;
var EntityRequest_1 = __webpack_require__(/*! ../core/entity/EntityRequest */ "../../../core/build/core/src/core/entity/EntityRequest.js");
var EntityType_1 = __webpack_require__(/*! ../core/entity/EntityType */ "../../../core/build/core/src/core/entity/EntityType.js");
var Utils_1 = __webpack_require__(/*! ../core/Utils */ "../../../core/build/core/src/core/Utils.js");
var ClientConfigs_1 = __webpack_require__(/*! ../webrtc/ClientConfigs */ "../../../core/build/core/src/webrtc/ClientConfigs.js");
var SnapshotAccountingManager = /** @class */ (function () {
    function SnapshotAccountingManager() {
        this.allowAudioMetricAccounting = ClientConfigs_1.HiveConfig.Stats.AudioAccounting === true;
    }
    SnapshotAccountingManager.prototype.init = function (reportingInstance) {
        this.nodeInfo = reportingInstance.nodeInfo;
        this.statsStore = reportingInstance.statsStore;
        this.accumulator = new Utils_1.StatsAccumulator();
        this.statsStore.updateFallbackAccumulator(this.accumulator);
    };
    SnapshotAccountingManager.prototype.accountPlayerRequest = function (entityCharacteristics) {
    };
    SnapshotAccountingManager.prototype.accountQualityLevelSwitch = function (switchUp) {
        if (switchUp) {
            this.statsStore.currentSnapshot.metrics.bitrateUpN++;
        }
        else {
            this.statsStore.currentSnapshot.metrics.bitrateDwnN++;
        }
    };
    SnapshotAccountingManager.prototype.accountFallbackRequest = function (request) {
        var isSubtitle = request.getEntityType() === EntityType_1.EntityType.SUBTITLES;
        if (isSubtitle)
            return;
        var notAudio = request.getEntityType() != EntityType_1.EntityType.AUDIO;
        if (this.allowAudioMetricAccounting || notAudio) {
            var throughput = this.nodeInfo.getSourceThroughput().toBitPerSecond();
            if (!isNaN(throughput)) {
                this.statsStore.currentSnapshot.metrics.srcThroughput = throughput;
            }
            var elapsed = request.finishedTime - request.startedTime;
            this.accumulator.add(elapsed);
            this.getTrafficStores(request).forEach(function (traffic) {
                if ([EntityType_1.EntityType.METADATA, EntityType_1.EntityType.OTHER].indexOf(request.getEntityType()) == -1) {
                    traffic.reqN++;
                    traffic.srcReqN++;
                    traffic.srcRespQt += request.getResponseSize();
                    traffic.srcReqQt += request.getResponseSize();
                    traffic.srcOverQt += request.getResponseSize();
                }
                else {
                    traffic.reqOtherN++;
                }
            });
        }
        switch (request.getStatus()) {
            case EntityRequest_1.EntityRequestStatus.SUCCEEDED:
                {
                    this.accountFallbackRequestSuccessful(request, NaN);
                }
                break;
            case EntityRequest_1.EntityRequestStatus.ABORTED:
            case EntityRequest_1.EntityRequestStatus.TIMEDOUT:
                {
                    this.accountFallbackRequestFailure(request, NaN);
                    this.statsStore.addNewResponseInfo(10);
                }
                break;
            case EntityRequest_1.EntityRequestStatus.FAILED:
                {
                    var status_1 = request.getXhrStatus();
                    if (status_1 > 0) {
                        this.statsStore.addNewResponseInfo(status_1);
                    }
                    else {
                        this.statsStore.addNewResponseInfo(404);
                    }
                    this.accountFallbackRequestFailure(request, NaN);
                }
                break;
        }
    };
    SnapshotAccountingManager.prototype.accountFallbackRequestSuccessful = function (request, throughput) {
        var notAudio = request.getEntityType() != EntityType_1.EntityType.AUDIO;
        if (this.allowAudioMetricAccounting || notAudio) {
            this.getTrafficStores(request).forEach(function (traffic) {
                if ([EntityType_1.EntityType.METADATA, EntityType_1.EntityType.OTHER].indexOf(request.getEntityType()) == -1) {
                    traffic.srcRespN++;
                    traffic.respFallbackN++;
                }
                else {
                    traffic.respFallbackOtherN++;
                }
            });
        }
    };
    SnapshotAccountingManager.prototype.accountFallbackRequestFailure = function (request, throughput) {
        var notAudio = request.getEntityType() != EntityType_1.EntityType.AUDIO;
        if (this.allowAudioMetricAccounting || notAudio) {
            this.getTrafficStores(request).forEach(function (traffic) {
                if ([EntityType_1.EntityType.METADATA, EntityType_1.EntityType.OTHER].indexOf(request.getEntityType()) == -1) {
                    traffic.srcRespErrN++;
                    traffic.respFallbackErrN++;
                }
                else {
                    traffic.respFallbackOthertErrN++;
                }
            });
        }
    };
    SnapshotAccountingManager.prototype.getTrafficStores = function (request) {
        var totalTraffic = this.statsStore.getTotalTrafficStoreCurrent();
        var stores = [totalTraffic];
        if (request.getEntityType() === EntityType_1.EntityType.VIDEO) {
            var characteristics = request.getEntityCharacteristics();
            var qualityLevel = characteristics.getQualityLevel();
            var qualityLevelTraffic = this.statsStore.getCurrentTrafficStoreQualityLevel(qualityLevel);
            stores.push(qualityLevelTraffic);
        }
        return stores;
    };
    return SnapshotAccountingManager;
}());
exports.SnapshotAccountingManager = SnapshotAccountingManager;
//# sourceMappingURL=SnapshotAccountingManager.js.map

/***/ }),

/***/ "../../../core/build/core/src/stats/Stats.js":
/*!********************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/stats/Stats.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Client = exports.Store = exports.Snapshot = void 0;
var SensitiveInfoUtils_1 = __webpack_require__(/*! ../common/utils/SensitiveInfoUtils */ "../../../core/build/core/src/common/utils/SensitiveInfoUtils.js");
var HashMap = __webpack_require__(/*! @hivestreaming/collections/map */ "../../../node_modules/@hivestreaming/collections/map.js");
var Thrift = __webpack_require__(/*! @hivestreaming/thrift */ "../../../node_modules/@hivestreaming/thrift/src/thrift.js");
__webpack_require__(/*! hivejs-protocol/services/metrics_types */ "../../../protocol/services/metrics_types.js");
__webpack_require__(/*! hivejs-protocol/services/common_types */ "../../../protocol/services/common_types.js");
var Framework_1 = __webpack_require__(/*! ../core/Framework */ "../../../core/build/core/src/core/Framework.js");
var Constants_1 = __webpack_require__(/*! ../core/Constants */ "../../../core/build/core/src/core/Constants.js");
var HiveServices_1 = __webpack_require__(/*! ../core/HiveServices */ "../../../core/build/core/src/core/HiveServices.js");
var Reporting_1 = __webpack_require__(/*! ./Reporting */ "../../../core/build/core/src/stats/Reporting.js");
var ClientConfigs_1 = __webpack_require__(/*! ../webrtc/ClientConfigs */ "../../../core/build/core/src/webrtc/ClientConfigs.js");
var logger_hive_1 = __webpack_require__(/*! ../common/logger.hive */ "../../../core/build/core/src/common/logger.hive.js");
var basicutils_hive_1 = __webpack_require__(/*! ../common/basicutils.hive */ "../../../core/build/core/src/common/basicutils.hive.js");
var techs_hive_1 = __webpack_require__(/*! ../common/techs/techs.hive */ "../../../core/build/core/src/common/techs/techs.hive.js");
var loggerId = '[SNAP] ';
/**
 * Snapshots accumulator object, roughly the same format as the thrift metrics snapshot
 */
var Snapshot = /** @class */ (function () {
    function Snapshot() {
        // Total
        this.metrics = new hive.snapshots.Metrics();
        this.totalTraffic = new hive.snapshots.Traffic();
        // QualityLevel
        this.qualityLevelTraffic = new HashMap();
        // Partners
        this.partnerTraffic = new HashMap();
        this.partnerMetrics = new HashMap();
        // Player
        this.player = new hive.snapshots.Player();
    }
    return Snapshot;
}());
exports.Snapshot = Snapshot;
/**
 * Object that accumulates metrics and generates the
 * metric snapshots
 */
var Store = /** @class */ (function () {
    function Store() {
        this.ticket = null;
        this.testId = null;
        this.responseInfo = new hive.snapshots.ServiceResponseInfo();
        this.fullReset();
    }
    /**
     * initialize the metrics with the registered identity
     * @param myId this is the reporting guid
     * @param ticket
     * @param techInfo: TechInfo
     * @param swarmId
     */
    Store.prototype.init = function (myId, ticket, techInfo, swarmId) {
        this.logger = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.LOGGER).log(swarmId);
        this.connInfoProvider = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.CONNECTIVITY_INFO_PROVIDER);
        this.streamInfoProvider = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.STREAM_INFO_METRICS_PROVIDER);
        this.fragmentMetadataProvider = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.FRAGMENT_METADATA_METRICS_PROVIDER);
        this.fragmentDownloadProvider = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.FRAGMENT_DOWNLOAD_METRICS_PROVIDER);
        this.logger.debug(loggerId + "INIT STATS STORE - Reporting ID: " + myId);
        this.myId = myId;
        this.ticket = ticket;
        this.updateTechInfo(techInfo);
    };
    Store.prototype.initTestId = function (testId) {
        this.testId = testId;
    };
    Store.prototype.updateStatsAccumulator = function (clientBufferStatsAccumulator) {
        this.clientBufferStatsAccumulator = clientBufferStatsAccumulator;
    };
    Store.prototype.updateTrackerStatsAccumulator = function (trackerStatsAccumulator) {
        this.trackerStatsAccumulator = trackerStatsAccumulator;
    };
    Store.prototype.updateRemoteConfigLatency = function (remoteConfigLatency) {
        this.remoteConfigLatency = remoteConfigLatency;
    };
    Store.prototype.updateFallbackAccumulator = function (fallbackAccumulator) {
        this.fallbackAccumulator = fallbackAccumulator;
    };
    Store.prototype.updateTechInfo = function (techInfo) {
        this.techInfo = techInfo;
    };
    Store.prototype.updateNodeInfo = function (nodeInfo) {
        this.nodeInfo = nodeInfo;
    };
    /**
     * reset all snapshot accumulator and initialize the non-optional metrics
     * It's called directly when resetting the StatsClient
     */
    Store.prototype.fullReset = function () {
        this.totalSnapshot = new Snapshot();
        this.myId = null;
        this.ticket = null;
        this.reset();
    };
    /**
     * reset periodic snapshot accumulator and initialize the non-optional metrics
     */
    Store.prototype.reset = function () {
        this.currentSnapshot = new Snapshot();
        // resetting to 0 the non-optional stats
        this.initTrafficStore(this.currentSnapshot.totalTraffic);
        this.initMetricStore(this.currentSnapshot);
        // Empty responseInfo array
        this.responseInfo.source = [];
    };
    /**
     * set the non-optional traffic metrics to 0
     */
    Store.prototype.initTrafficStore = function (trafficStore) {
        trafficStore.reqN = 0;
        trafficStore.respFallbackN = 0;
        trafficStore.respFallbackErrN = 0;
        trafficStore.respP2pN = 0;
        trafficStore.reqOtherN = 0;
        trafficStore.respFallbackOtherN = 0;
        trafficStore.respFallbackOthertErrN = 0;
        trafficStore.srcReqN = 0;
        trafficStore.srcRespN = 0;
        trafficStore.srcRespErrN = 0;
        trafficStore.srcReqQt = 0;
        trafficStore.srcRespQt = 0;
        trafficStore.srcOverQt = 0;
        trafficStore.srcOtherReqN = 0;
        trafficStore.srcOtherRespN = 0;
        trafficStore.srcOtherRespErrN = 0;
        trafficStore.srcOtherReqQt = 0;
        trafficStore.srcOtherRespQt = 0;
        trafficStore.srcOtherOverQt = 0;
        trafficStore.p2pSubReqN = 0;
        trafficStore.p2pSubRespN = 0;
        trafficStore.p2pSubRespPartN = 0.0;
        trafficStore.p2pSubRespErrN = 0.0;
        trafficStore.p2pSubRespExpN = 0;
        trafficStore.p2pSubReqQt = 0;
        trafficStore.p2pSubRespQt = 0;
        trafficStore.p2pDirectQt = 0;
        trafficStore.p2pRelayQt = 0;
        trafficStore.p2pNatQt = 0;
        trafficStore.p2pUdpbQt = 0;
        trafficStore.fallAgentRespN = 0;
        trafficStore.fallAgentPredHitN = 0;
        trafficStore.fallAgentFailedRespN = 0;
        trafficStore.fallAgenTrafficSuccessQt = 0;
        trafficStore.p2pAgentPredHitN = 0;
        trafficStore.p2pAgentPredMissN = 0;
        trafficStore.p2pAgentPredPartialHitN = 0;
        trafficStore.p2pAgenTrafficSuccessQt = 0;
        trafficStore.p2pAgenTrafficFailureQt = 0;
    };
    /**
     * set the non-optional metrics to 0
     */
    Store.prototype.initMetricStore = function (snapshot) {
        snapshot.metrics.videoBufN = 0;
        snapshot.metrics.videoBufQt = 0;
        snapshot.metrics.clientBufferMs = 0;
        snapshot.metrics.lookupNotFound = 0;
        snapshot.metrics.lookupTotal = 0;
        snapshot.metrics.lookupLatency = 0;
        snapshot.metrics.lookupReqAccept = 0;
        snapshot.metrics.lookupReqEstablished = 0;
        snapshot.metrics.lookupFailed = 0;
        snapshot.player.bufferingN = 0;
        snapshot.player.bufferingMs = 0;
        snapshot.player.playingTimeMs = 0;
    };
    /**
     * create a metric snapshot thrift object with the current snapshot.
     */
    Store.prototype.current = function () {
        var _this = this;
        var snapshot = new hive.snapshots.MetricSnapshot();
        snapshot.timestamp = Framework_1.Framework.time();
        snapshot.guid = this.myId;
        snapshot.sessionId = this.ticket.sessionId;
        snapshot.eventId = new EventId();
        snapshot.eventId.partnerId = this.ticket.getPartnerId();
        snapshot.eventId.customerId = this.ticket.getCustomerId();
        snapshot.eventId.contentId = this.ticket.getContentId();
        try {
            var clientInfo = new hive.snapshots.ClientInfo();
            clientInfo.clientType = this.techInfo.name === techs_hive_1.TechName.HiveJS ? ClientType.JS_DIRECT : ClientType.STATS_ONLY;
            if (this.techInfo.version) {
                var semanticVersion = this.techInfo.version.split('.');
                clientInfo.majorVersion = parseInt(semanticVersion[0]);
                clientInfo.minorVersion = parseInt(semanticVersion[1]);
                clientInfo.patchVersion = parseInt(semanticVersion[2]);
            }
            snapshot.client = clientInfo;
            if (this.testId != null) {
                var testInfo = new TestInfo();
                testInfo.testId = this.testId;
                snapshot.testInfo = testInfo;
            }
        }
        catch (err) {
            this.logger.warn(loggerId + "error setting Snapshot ClientInfo", err);
        }
        // add information about the agentInfo
        if (this.nodeInfo) {
            var agentInfo = new hive.snapshots.AgentInfo();
            agentInfo.firstTierBitrates = this.nodeInfo.getFirstTierQualityLevels().map(function (value) { return value.bitrate; });
            agentInfo.secondTierBitrates = this.nodeInfo.getSecondTierQualityLevels().map(function (value) { return value.bitrate; });
            snapshot.agentInfo = agentInfo;
        }
        // add information about the stream (VOD, protocol...)
        snapshot.streamInfo = this.streamInfoProvider.getMetrics();
        snapshot.fragments = this.fragmentMetadataProvider.getMetrics();
        snapshot.fetchedFragments = this.fragmentDownloadProvider.getMetrics();
        // for the traffic first add the total traffic with an empty traffic key
        snapshot.traffic = [];
        var trafficKey = new hive.snapshots.TrafficKey();
        snapshot.traffic.push({
            key: trafficKey,
            value: this.currentSnapshot.totalTraffic
        });
        // then add the separate quality levels
        this.currentSnapshot.qualityLevelTraffic.forEach(function (traffic, qualityLevel) {
            var trafficKey = new hive.snapshots.TrafficKey();
            trafficKey.qualityLevelId = qualityLevel;
            snapshot.traffic.push({
                key: trafficKey,
                value: traffic
            });
        });
        snapshot.metrics = this.currentSnapshot.metrics;
        // set the clientBuffer
        if (this.clientBufferStatsAccumulator) {
            snapshot.metrics.clientBufferMs = this.clientBufferStatsAccumulator.min();
        }
        // Add the tracker delay to the snapshot metrics
        if (this.trackerStatsAccumulator) {
            snapshot.metrics.trackerLatency = this.trackerStatsAccumulator.min();
        }
        // Add the CDN latency to the snapshot.metrics
        if (this.fallbackAccumulator) {
            snapshot.metrics.sourceLatency = this.fallbackAccumulator.min();
        }
        if (this.remoteConfigLatency) {
            snapshot.metrics.remoteConfigServiceLatency = this.remoteConfigLatency;
        }
        snapshot.player = this.currentSnapshot.player;
        // Add responseInfo to snapshot only when we have responseinfo values
        // Otherwise do not include anything in the snapshot
        if (this.responseInfo.source.length > 0) {
            snapshot.responseInfo = this.responseInfo;
        }
        if (this.p2pInfoProvider) {
            var partnersAccounting = this.p2pInfoProvider.getPartnerInfo();
            this.currentSnapshot.metrics.prtOutN = partnersAccounting.outPartners;
            this.currentSnapshot.metrics.prtInN = partnersAccounting.inPartners;
            // Get stats about the in-partners I have now
            var inPartnersSnaps_1 = this.p2pInfoProvider.getPartnerSnapshots();
            inPartnersSnaps_1.forEach(function (partnerSnap, reportingGuid) {
                _this.addTraffic(reportingGuid, partnerSnap, snapshot);
            });
            var removedInPartnerSnapshots = this.p2pInfoProvider.getAndResetRemovedPartnerSnapshots();
            // Get stats about the in-partners I had earlier
            removedInPartnerSnapshots.filter(function (partnerSnap, reportingGuid) {
                return !inPartnersSnaps_1.has(reportingGuid);
            }).forEach(function (partnerSnap, reportingGuid) {
                _this.addTraffic(reportingGuid, partnerSnap, snapshot);
            });
        }
        snapshot.connInfo = new hive.snapshots.ConnectivityInfo();
        var networkInfo = this.connInfoProvider.getSyncConnectivityInfo().getNetworkInfo();
        snapshot.connInfo.publicIp = networkInfo.getPublicIp();
        snapshot.connInfo.externalAs = networkInfo.getExternalAsId();
        snapshot.connInfo.privateIp = SensitiveInfoUtils_1.SensitiveInfoUtils.getPrivateIp(networkInfo);
        snapshot.connInfo.internalAs = networkInfo.getSiteId();
        snapshot.connInfo.isVpn = networkInfo.isVpn();
        return this.validateSnapshot(snapshot);
    };
    Store.prototype.validateSnapshot = function (snapshot, keysWithNaN) {
        if (keysWithNaN === void 0) { keysWithNaN = []; }
        var errors = basicutils_hive_1.reportNaNs(snapshot, 'snapshot');
        if (errors.length) {
            logger_hive_1.ErrorMonitor.getInstance().logError('NaN found in MetricSnapshot', loggerId, { keysWithNaN: errors, snapshot: snapshot });
        }
        keysWithNaN.length = 0;
        keysWithNaN.push.apply(keysWithNaN, errors);
        return snapshot;
    };
    Store.prototype.addTraffic = function (reportingGuid, partnerSnap, snapshot) {
        var partnerTraffic = this.currentSnapshot.partnerTraffic.get(reportingGuid);
        partnerSnap.traffic = partnerTraffic;
        if (!snapshot.partners) {
            snapshot.partners = [];
        }
        var pk = new hive.snapshots.PartnerKey();
        pk.partnerGuid = reportingGuid;
        snapshot.partners.push({
            key: pk,
            value: partnerSnap
        });
    };
    Store.prototype.addBuffering = function (newBufferingMs, playerBufferMs) {
        if (newBufferingMs > 0) {
            this.currentSnapshot.metrics.videoBufN++;
            this.currentSnapshot.metrics.videoBufQt += newBufferingMs;
            this.currentSnapshot.player.bufferingN++;
            this.currentSnapshot.player.bufferingMs += newBufferingMs;
        }
        this.currentSnapshot.player.playerBufferMs = playerBufferMs;
    };
    Store.prototype.handleStats = function (_a) {
        var playingTime = _a.playingTime, playerVolume = _a.playerVolume;
        if (playingTime > 0) {
            this.currentSnapshot.player.playingTimeMs += playingTime;
            this.totalSnapshot.player.playingTimeMs += playingTime;
        }
        this.currentSnapshot.player.playerVolume = playerVolume;
    };
    Store.prototype.getTotalTrafficStoreCurrent = function () {
        return this.currentSnapshot.totalTraffic;
    };
    Store.prototype.getTotalTrafficStorePermanent = function () {
        return this.totalSnapshot.totalTraffic;
    };
    Store.prototype.getPermanentTrafficStoreQualityLevel = function (qualityLevel) {
        if (!this.totalSnapshot.qualityLevelTraffic.has(qualityLevel.id)) {
            this.totalSnapshot.qualityLevelTraffic.set(qualityLevel.id, new hive.snapshots.Traffic());
        }
        return this.totalSnapshot.qualityLevelTraffic.get(qualityLevel.id);
    };
    Store.prototype.getCurrentTrafficStoreQualityLevel = function (qualityLevel) {
        if (!this.currentSnapshot.qualityLevelTraffic.has(qualityLevel.id)) {
            var trafficStore = new hive.snapshots.Traffic();
            this.initTrafficStore(trafficStore);
            this.currentSnapshot.qualityLevelTraffic.set(qualityLevel.id, trafficStore);
        }
        return this.currentSnapshot.qualityLevelTraffic.get(qualityLevel.id);
    };
    Store.prototype.initializePartnerTrafficStoreValues = function () {
        var partnerTraffic = new hive.snapshots.PartnerTraffic();
        partnerTraffic.p2pSuccReq = 0;
        partnerTraffic.p2pFailReq = 0;
        partnerTraffic.p2pPartReq = 0;
        partnerTraffic.p2pSuccReceived = 0;
        partnerTraffic.p2pSuccReceivedLow = 0;
        partnerTraffic.p2pFailReceived = 0;
        partnerTraffic.p2pSuccResp = 0;
        partnerTraffic.p2pFailResp = 0;
        partnerTraffic.p2pPartResp = 0;
        partnerTraffic.p2pSuccSent = 0;
        partnerTraffic.p2pSuccSentLow = 0;
        partnerTraffic.p2pFailSent = 0;
        return partnerTraffic;
    };
    Store.prototype.getPartnerTrafficStore = function (guid, snapshot) {
        if (!snapshot.partnerTraffic.has(guid)) {
            snapshot.partnerTraffic.set(guid, this.initializePartnerTrafficStoreValues());
        }
        return snapshot.partnerTraffic.get(guid);
    };
    Store.prototype.getPartnerTrafficStoreCurrent = function (guid) {
        return this.getPartnerTrafficStore(guid, this.currentSnapshot);
    };
    Store.prototype.getPartnerTrafficStorePermanent = function (guid) {
        return this.getPartnerTrafficStore(guid, this.totalSnapshot);
    };
    Store.prototype.setP2PInfoProvider = function (p2pInfoProvider) {
        this.p2pInfoProvider = p2pInfoProvider;
    };
    Store.prototype.serverConnected = function (guid) {
    };
    Store.prototype.addNewResponseInfo = function (statusCode) {
        // Loop over responseInfo and check if status code already exists
        // If it doesn't, create a new ResponseInfo object with count 1 and
        // push it into the array
        var statusCodeExists = false;
        this.responseInfo.source.forEach(function (responseInfo) {
            if (responseInfo.statusCode == statusCode) {
                responseInfo.count++;
                statusCodeExists = true;
            }
        });
        // If the status code doesn't exist in the current responseInfo
        // push a new ResponseInfo object into it
        if (!statusCodeExists) {
            this.responseInfo.source.push(new hive.snapshots.ResponseInfo({ statusCode: statusCode, count: 1 }));
        }
    };
    return Store;
}());
exports.Store = Store;
/**
 * Stats Client implementation. Once initialized with a Store, it will
 * periodically send a snapshot of the store through the Services Client
 */
var Client = /** @class */ (function () {
    function Client() {
        this.metricSnapshotLogs = isNaN(ClientConfigs_1.HiveConfig.DebugLogs.MetricSnapshotLogs) ? 0 : ClientConfigs_1.HiveConfig.DebugLogs.MetricSnapshotLogs;
        this.state = Reporting_1.ClientState.PLAY;
        this.client = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.SERVICES_CLIENT);
        this.transport = new Thrift.TXHRTransport();
        this.protocol = new Thrift.TJSONProtocol(this.transport);
    }
    /**
     * initialize the client with a Store to get snapshots from
     * activates the store and starts the periodic sending
     * @param store
     * @param swarmId
     */
    Client.prototype.init = function (store, swarmId) {
        this.logger = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.LOGGER).log(swarmId);
        this.logger.debug(loggerId + "INIT CLIENT STATS");
        // register the store and activate it
        this.store = store;
        this.startPeriodicSnapshot();
    };
    Client.prototype.startPeriodicSnapshot = function () {
        var _this = this;
        if (this.snapshotTimer > -1) {
            Framework_1.Framework.clearInterval(this.snapshotTimer);
        }
        this.snapshotTimer = Framework_1.Framework.setInterval(function () {
            _this.snapshot();
        }, Constants_1.Constants.STATS_INTERVAL);
    };
    Client.prototype.onStateChange = function (state) {
        this.state = state;
    };
    /**
     * This methods gather the partial collected data and flushes it to the backend
     * Used to get last data before the close of the session / watching
     * TODO: track the different type of snapshot as a flush
     */
    Client.prototype.flushLastMetricSnapshot = function () {
        if (this.store)
            return this.snapshot();
    };
    Client.prototype.reset = function (completeReset) {
        Framework_1.Framework.clearInterval(this.snapshotTimer);
        if (this.store) {
            if (completeReset === false)
                this.store.reset();
            else
                this.store.fullReset();
        }
    };
    /**
     * This method generates the snapshot and then forwards it.
     */
    Client.prototype.snapshot = function () {
        this.logger.debug(loggerId + "TAKING SNAPSHOT");
        try {
            var currentSnap = this.store.current();
            this.forward(currentSnap);
            this.store.reset();
        }
        catch (err) {
            this.logger.warn(loggerId + "ERROR FORWARDING SNAPSHOT", err);
        }
    };
    Client.prototype.forward = function (snap) {
        var _this = this;
        // TODO should we also check that the traffic didn't change?
        if (this.state === Reporting_1.ClientState.IDLE || this.state === Reporting_1.ClientState.STOP) {
            this.logger.debug(loggerId + "not send - state " + Reporting_1.ClientState[this.state]);
            return;
        }
        else if (this.filter) {
            var _a = this.filter.shouldSend(), playingTime = _a.playingTime, threshold = _a.threshold, shouldSend = _a.shouldSend;
            if (!shouldSend) {
                this.logger.debug(loggerId + "SKIPPING SNAPSHOT DUE TO REPORTING THRESHOLD: " + playingTime + " < " + threshold);
                return;
            }
        }
        if (this.client && this.client.getConnection()) {
            switch (this.metricSnapshotLogs) {
                case 0:
                default:
                    this.logger.debug(loggerId + "SENDING SNAPSHOT");
                    break;
                case 1:
                    this.logger.debug(loggerId + "SENDING SNAPSHOT " + JSON.stringify(snap));
                    break;
                case 2:
                    this.logger.debug(loggerId + "SENDING SNAPSHOT", snap);
                    break;
                case 3:
                    this.logger.debug(loggerId + "SENDING SNAPSHOT " + JSON.stringify(snap), snap);
                    break;
            }
            this.protocol.writeMessageBegin('SNAPSHOT', Thrift.MessageType.ONEWAY, 0);
            snap.write(this.protocol);
            this.protocol.writeMessageEnd();
            var buffer = this.transport.getSendBuffer();
            var pr = this.getPosition(buffer, ',', 4);
            var bufferToSend = buffer.slice(pr + 1, buffer.length - 1);
            var msg = new HiveServices_1.Message(HiveStreamingServices.HIVEJS_SNAPSHOTS, 1, bufferToSend);
            this.client.getConnection().send(msg).fail(function (error) {
                _this.logger.warn(loggerId + "PROBLEM: ", error);
            });
        }
    };
    Client.prototype.getPosition = function (str, delimiter, occurrence) {
        return str.split(delimiter, occurrence).join(delimiter).length;
    };
    Client.prototype.setFilter = function (filter) {
        this.filter = filter;
    };
    return Client;
}());
exports.Client = Client;
//# sourceMappingURL=Stats.js.map

/***/ }),

/***/ "../../../core/build/core/src/stats/StatsJSConnectivityProvider.js":
/*!******************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/stats/StatsJSConnectivityProvider.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.StatsJSConnectivityProvider = void 0;
var Q = __webpack_require__(/*! @hivestreaming/q */ "../../../node_modules/@hivestreaming/q/q.js");
var ConnectivityInfoProvider_1 = __webpack_require__(/*! ../core/connectivity/ConnectivityInfoProvider */ "../../../core/build/core/src/core/connectivity/ConnectivityInfoProvider.js");
var HashMap = __webpack_require__(/*! @hivestreaming/collections/map */ "../../../node_modules/@hivestreaming/collections/map.js");
var Framework_1 = __webpack_require__(/*! ../core/Framework */ "../../../core/build/core/src/core/Framework.js");
var ClientConfigs_1 = __webpack_require__(/*! ../webrtc/ClientConfigs */ "../../../core/build/core/src/webrtc/ClientConfigs.js");
var Constants_1 = __webpack_require__(/*! ../core/Constants */ "../../../core/build/core/src/core/Constants.js");
var CustomSnapshotProvider_1 = __webpack_require__(/*! ./CustomSnapshotProvider */ "../../../core/build/core/src/stats/CustomSnapshotProvider.js");
var BoosterClient_1 = __webpack_require__(/*! ../webrtc/booster/BoosterClient */ "../../../core/build/core/src/webrtc/booster/BoosterClient.js");
var Utils_1 = __webpack_require__(/*! ../core/Utils */ "../../../core/build/core/src/core/Utils.js");
var models_1 = __webpack_require__(/*! ../webrtc/booster/models */ "../../../core/build/core/src/webrtc/booster/models/index.js");
/**
 * This class periodically retrieves the viewer connectivity information used for reporting
 * and for establishing WebRTC connections.
 *
 * *The connInfoProvider only task is to collect all the info from different parts and update the connectivityInfo component.*
 * *All decisions are then taken by the connectivity info*
 *
 * There are several use cases we need to keep into considerations:
 * - **Chromium based browsers (Chrome/Edge)**
 *      - out-of-the-box generate only one mDNS obfuscated interface
 *      - when generating one interface, it will pick the one used to route to 8.8.8.8
 *      - can be configured via policy to not obfuscate the local IP
 *      - if user gave access to camera/mic, generates non-obfuscated candidates for all interfaces
 *      - generates only UDP candidates
 *      - manipulating a mDNS candidate by replacing the same interface's private IP allows establishing
 *        connections outside the LAN boundary.
 *      - manipulating a mDNS candidate by replacing private IPs of other interfaces actually allows
 *        establishing connections on those interfaces. Looks like chromium listens for a specific port
 *        on all interfaces.
 * - **Firefox**
 *      - same as chrome
 *      - generates both UDP and TCP candidates
 *      - manipulating a mDNS candidate by replacing the same interface's private IP enable establishing
 *        connections outside the LAN boundary.
 *      - manipulating a mDNS candidate by replacing private IPs of other interfaces doesn't help
 *        establishing connections on those interfaces. Looks like Firefox listens for a specific port on
 *        a specific interface.
 * - **Teams Live Events**
 *      - from jan 2023 they load our plugin in an src:doc iframe, forcing js to collect ALWAYS one
 *        obfuscated interface
 *      - TLE app periodically provides (external) candidates generated by the top frame, following the same
 *        rules as the browser
 *      - external candidates can be used for reporting and manipulating the mdns candidate
 * - **Teams Desktop App (Win/Mac)**
 *      - always gives full access to all interfaces, both top frame and src:doc iframe
 * - **Booster**
 *      - Booster will report all active interfaces, trying to resolve the mDNS candidate to one of them
 *      - Booster will also report the interfaces routing toward 8.8.8.8, api.hivestreaming.com and the manifest
 *
 * Our final goal is to try to determine the SINGLE private IP to report, match site info and apply configurations.
 * When our app has access to one interface, we try to determine its IP address.
 * When our app has access to all interfaces, we use booster's extended info to tell what's the default one, or
 * we let the remote config service logic pick one.
 * Customers can control the reported interface in VPN scenarios by split tunnelling the 8.8.8.8 address.
 * If we can't know for sure what interface is the default one, we pick the highest prio (candidate priority), but
 * we still keep track of all the interfaces addresses so that the Channel can smudge the candidates with all interfaces.
 *
 * **Logic:**
 * First collects local interfaces by pretending to establish a webRTC connection and collecting the local ICE candidates.
 * Candidate(s) address can be either in IP format, or mDNS.
 * If Booster is present, fetches extended network info (passing the mDNS addresses)
 * If Booster is not available, tries to fetch externally provided candidates (TLE only)
 * Finally all the collected addresses are passed and processed to the ConnectivityInfo that
 * helps picking the default network if possible.
 * With the final list of IP, trigger a remote config request.
 * The remote config server will try to match the IP(s) to one site, returning its ID and vpn value. These info are
 * finally used to extend even more the network info.
 *
 * **NOTE: only after returning the remote config, the connectivity info promise is resolved. If this whole operations
 * takes longer than 4 seconds, it will fail.**
 *
 * The TrackerClient helps collecting public IP and external AS when booster is not available
 */
var StatsJSConnectivityProvider = /** @class */ (function () {
    function StatsJSConnectivityProvider() {
        this.loggerId = '[ConnectivityProvider] ';
        // This hashmap contains all the candidates collected by the webrtc connection
        this.webRtcCollectedCandidates = new HashMap();
        this.privateIps = [];
        this.connInfoTimeoutId = null;
        // custom snapshots debugging
        this.customSnapArray = [];
        this.sentCustomSnap = false;
        this.logger = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.LOGGER).log();
        this.connectivityInfo = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.PEER_CONNECTIVITY_INFO);
        this.remoteConfigManager = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.REMOTE_CONFIG_MANAGER);
        this.boosterClient = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.BOOSTER_CLIENT);
        this.externalCandidates = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.EXTERNAL_CANDIDATES);
        this.startConnectivityInfoInterval();
        this.boosterClient.on(BoosterClient_1.BoosterEvents.INITIALIZED, this.refreshConnectivityInfo.bind(this));
    }
    StatsJSConnectivityProvider.prototype.setCandidateTopicName = function (candidateTopicName) {
        this.externalCandidates.setCandidateTopicName(candidateTopicName);
    };
    /**
     * We periodically clear the state of the class and request again the connectivityInfo
     * for updates on it
     */
    StatsJSConnectivityProvider.prototype.startConnectivityInfoInterval = function () {
        var _this = this;
        this.interval = Framework_1.Framework.setInterval(function () {
            _this.resetConnectivityInfo();
            _this.getConnectivityInfo();
        }, Constants_1.Constants.RETRIEVE_NETWORK_INFO_INTERVAL);
    };
    StatsJSConnectivityProvider.prototype.resetConnectivityInfo = function () {
        this.privateIps = [];
        this.webRtcCollectedCandidates = new HashMap();
        this.pendingConInfoPromise = null;
        Framework_1.Framework.clearTimeout(this.connInfoTimeoutId);
        this.externalCandidates.reset();
    };
    /**
     * Force a new connectivity info gathering (for example on ticket initialization).
     * If a connection info gathering is pending but the candidates are already collected,
     * queue a new collection (to try again to use the booster)
     */
    StatsJSConnectivityProvider.prototype.refreshConnectivityInfo = function () {
        var _this = this;
        var _a;
        if ((_a = this.pendingConInfoPromise) === null || _a === void 0 ? void 0 : _a.isPending()) {
            // if the gathering is already complete queue the refresh, otherwise ignore it
            if (!this.candidateGatheringPromise.isPending()) {
                this.pendingConInfoPromise.finally(function () { return _this.refreshConnectivityInfo(); });
            }
        }
        else {
            Framework_1.Framework.clearInterval(this.interval);
            this.resetConnectivityInfo();
            this.getConnectivityInfo();
            this.startConnectivityInfoInterval();
        }
    };
    /**
     * We request the connectivity info. If we have previously requested for connectivity info
     * we return the previous promise, if the promise was resolved already we will get immediately
     * a reference to the ConnectivityInfo
     */
    StatsJSConnectivityProvider.prototype.getConnectivityInfo = function () {
        if (!this.pendingConInfoPromise) {
            this.pendingConInfoPromise = this.retrieveConnectivityInfo();
        }
        return this.pendingConInfoPromise;
    };
    /**
     * This function returns the latest peer connectivity info information that we have collected.
     * If we haven't collected any info then the connectivityInfo will contain an empty object without having any information inside
     * @returns {ConnectivityInfo}
     */
    StatsJSConnectivityProvider.prototype.getSyncConnectivityInfo = function () {
        return this.connectivityInfo;
    };
    /**
     * In order to retrieve the connectivity info it asynchronously gather ICE candidates
     * and keeps track of the promise. Then in cascade tries to refine candidates with info
     * first with the Booster, otherwise with external iframe candidates (TLE).
     * Finally it generates a list of the IP addresses gathered and requests
     * remote config and site matching with that scope.
     *
     * The promise is resolved when all the process is complete, the remote configurations
     * are returned and site info updated, or if the whole operations times out after
     * {@link Constants.TIMEOUT_RETRIEVING_CONNECTIVITY_INFO} ms
     *
     * @returns {Promise<ConnectivityInfo>}
     */
    StatsJSConnectivityProvider.prototype.retrieveConnectivityInfo = function () {
        var _this = this;
        this.logger.debug(this.loggerId + 'retrieving fresh connectivity info');
        return Q.Promise(function (resolve, reject) {
            // global timeout for the whole connectivity info retrieval
            _this.connInfoTimeoutId = Framework_1.Framework.setTimeout(function () {
                reject({ supported: true, message: 'expired' });
            }, Constants_1.Constants.TIMEOUT_RETRIEVING_CONNECTIVITY_INFO);
            // quick check if webrtc is supported and if we are in silent test mode
            if (!ClientConfigs_1.HiveConfig.ConnInfo.detectPrivateIP || !_this.isDataChannelSupported()) {
                Framework_1.Framework.clearTimeout(_this.connInfoTimeoutId);
                var msg = ClientConfigs_1.HiveConfig.ConnInfo.detectPrivateIP ? 'webrtc datachannel not supported' :
                    'private IP detection disabled';
                reject({ supported: false, message: msg });
            }
            else {
                _this.candidateGatheringPromise = _this.gatherCandidates();
                _this.candidateGatheringPromise
                    .then(function () { return _this.requestBooster(); })
                    .then(function () { return _this.gatherExternalCandidates(); })
                    .then(function () {
                    _this.processCandidates();
                    return _this.fetchRemoteConfig();
                })
                    .finally(function () {
                    Framework_1.Framework.clearTimeout(_this.connInfoTimeoutId);
                    resolve(_this.connectivityInfo);
                });
            }
        });
    };
    /**
     * collect extended network info depending on LA availability,
     * handle all potential errors internally and always
     * resolve when completed
     */
    StatsJSConnectivityProvider.prototype.requestBooster = function () {
        var _this = this;
        return this.boosterClient.checkBoosterPresence()
            .then(function () { return _this.getExtendedNetworkInfo(); })
            .fail(function (error) {
            // reset previous info to rely only on private IPs detected
            _this.connectivityInfo.setExtendedNetworkInfo(undefined);
            _this.logger.debug(_this.loggerId + 'Could not get extended network info: ' + error);
        }).then();
    };
    /**
     * If we don't have extended network info meaning the Booster failed on doing so. We will try to use
     * an external component to complement our network information using post messages and try to get privateIps.
     */
    StatsJSConnectivityProvider.prototype.gatherExternalCandidates = function () {
        var _this = this;
        if (this.connectivityInfo.getExtendedNetworkInfo())
            return;
        return this.externalCandidates.requestCandidates()
            .fail(function (error) { return _this.logger.debug('Could not use external candidates info: ' + error); });
    };
    /**
     * Establish a dummy local connection capturing all ICE candidates and returning
     * promise for ICE candidates gathering complete
     */
    StatsJSConnectivityProvider.prototype.gatherCandidates = function () {
        var _this = this;
        return Q.Promise(function (resolve, reject) {
            // Create connection and data channel
            var localConnection = new RTCPeerConnection(null);
            localConnection.createDataChannel('sendChannel', { reliable: false });
            // Event listeners to trigger on every new candidate detected
            localConnection.onicecandidate = function (e) {
                if (e.candidate) {
                    _this.collectCandidateInfo(e.candidate.candidate);
                }
            };
            // Create offer, set session descriptions
            localConnection.createOffer()
                .then(function (offer) { return localConnection.setLocalDescription(offer); })
                .catch(function (e) {
                reject({ supported: true, message: e.message });
                Framework_1.Framework.clearTimeout(_this.connInfoTimeoutId);
                _this.logger.error(_this.loggerId + 'Failure creating offer: ' + e.message);
            });
            var gatheredTimeOut = Framework_1.Framework.setTimeout(function () {
                _this.logger.info(_this.loggerId + 'ICE gathering complete timed out - collected: ' + _this.webRtcCollectedCandidates.length);
                localConnection.close();
                resolve();
            }, Constants_1.Constants.TIMEOUT_CANDIDATES_GATHERING);
            localConnection.onicegatheringstatechange = function (e) {
                if ((localConnection === null || localConnection === void 0 ? void 0 : localConnection.iceGatheringState) == 'complete') {
                    try {
                        localConnection.close();
                        Framework_1.Framework.clearTimeout(gatheredTimeOut);
                        _this.logger.debug(_this.loggerId + 'ICE gathering completed - collected: ' + _this.webRtcCollectedCandidates.length);
                        resolve();
                    }
                    catch (e) {
                        _this.logger.debug('Failed to clear timeout - Framework was purged', e.message);
                    }
                }
            };
        });
    };
    /**
     * Once all candidates gathering and booster flow is completed,
     * process them to generate a list of private IPs ordered by priority
     * to set on the Network Info
     */
    StatsJSConnectivityProvider.prototype.processCandidates = function () {
        var _this = this;
        if (Constants_1.Constants.SEND_PRIVATE_IP_CUSTOM_SNAPSHOT && !this.sentCustomSnap) {
            setTimeout(function () {
                CustomSnapshotProvider_1.CustomSnapshotProvider.sendTrackSnapshot(null, null, 'local_ice', null, _this.customSnapArray);
            }, 5000);
            this.sentCustomSnap = true;
        }
        // merge local candidates with external ones, filter out
        // mdns and duplicates
        var collectedIps = this.webRtcCollectedCandidates
            .values()
            .concat(this.externalCandidates.getExternalCandidatesIp())
            .filter(function (c) { return c.addressType == models_1.AddressType.IP; })
            .sort(function (a, b) { return b.priority - a.priority; })
            .map(function (c) { return c.address; });
        collectedIps = Array.from(new Set(collectedIps));
        // update interfaces on the connectivityInfo which processes them and then fetch the final list
        this.connectivityInfo.setInterfaces(collectedIps);
        this.privateIps = this.connectivityInfo.getInterfaces();
        this.logger.debug(this.loggerId + 'Final private IP list [' + this.privateIps.join(',') + ']');
    };
    /**
     * Once the gathering of ICE Candidate has been completed uses the Booster to extend their
     * information
     */
    StatsJSConnectivityProvider.prototype.getExtendedNetworkInfo = function () {
        var _this = this;
        var addresses = this.webRtcCollectedCandidates.map(function (candidate) { return ({
            value: candidate.address, type: candidate.addressType
        }); });
        return this.boosterClient.getExtendedNetworkInfo(addresses).then(function (extendedNetworkInfo) {
            _this.connectivityInfo.setExtendedNetworkInfo(extendedNetworkInfo);
        }).fail(function (error) {
            _this.logger.warn(_this.loggerId + 'Get extended network failed with error: ' + error.message);
            throw error;
        });
    };
    /**
     * Always use private IPs input to request site info
     * just in case the video ticket doesn't match the agent's customer
     */
    StatsJSConnectivityProvider.prototype.fetchRemoteConfig = function () {
        return this.remoteConfigManager.requestRemoteConfigs({ privateIps: this.privateIps });
    };
    StatsJSConnectivityProvider.prototype.isDataChannelSupported = function () {
        try {
            return typeof RTCPeerConnection.prototype.createDataChannel === 'function';
        }
        catch (e) {
            return false;
        }
    };
    StatsJSConnectivityProvider.prototype.collectCandidateInfo = function (candidate) {
        var _a;
        var parsed = Utils_1.stringToRTCIceCandidateInfo(candidate);
        if (Constants_1.Constants.SEND_PRIVATE_IP_CUSTOM_SNAPSHOT && !this.sentCustomSnap) {
            this.customSnapArray.push(parsed);
        }
        if (((_a = parsed === null || parsed === void 0 ? void 0 : parsed.protocol) === null || _a === void 0 ? void 0 : _a.toLowerCase()) !== 'udp')
            return;
        // remove duplicates leaving the highest priority reported
        if (parsed.addressType != models_1.AddressType.NA) {
            var previousEntry = this.webRtcCollectedCandidates.get(parsed.address);
            if (!previousEntry || isNaN(previousEntry.priority) || parsed.priority > previousEntry.priority) {
                this.webRtcCollectedCandidates.set(parsed.address, parsed);
                this.logger.debug(this.loggerId + ("collected candidate " + parsed.address + " " + parsed.protocol + " " + parsed.priority));
            }
        }
    };
    /**
     * Either the remote config service or the tracker might return partial network info
     * The remote config service performs site matching over all IPs prioritizing VPNs, while
     * Tracker matches only one IP at the time, so we don't trust its matching.
     * The Tracker returns also public IP and external AS
     */
    StatsJSConnectivityProvider.prototype.handleServiceResponse = function (service, privateIp, siteId, isVpn, publicIp, externalAs) {
        switch (service) {
            case ConnectivityInfoProvider_1.ServiceResponse.REMOTE_CONFIG:
                this.connectivityInfo.updateConnectivityInfo(privateIp, siteId, isVpn);
                break;
            case ConnectivityInfoProvider_1.ServiceResponse.TRACKER:
                this.connectivityInfo.updateConnectivityInfo(null, null, null, publicIp, externalAs);
                break;
        }
    };
    return StatsJSConnectivityProvider;
}());
exports.StatsJSConnectivityProvider = StatsJSConnectivityProvider;
//# sourceMappingURL=StatsJSConnectivityProvider.js.map

/***/ }),

/***/ "../../../core/build/core/src/stats/StatsServiceClient.js":
/*!*********************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/stats/StatsServiceClient.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.StatsServiceClient = void 0;
var Q = __webpack_require__(/*! @hivestreaming/q */ "../../../node_modules/@hivestreaming/q/q.js");
var URI = __webpack_require__(/*! urijs */ "../../../node_modules/urijs/src/URI.js");
var Connection_1 = __webpack_require__(/*! ../core/client/Connection */ "../../../core/build/core/src/core/client/Connection.js");
var Framework_1 = __webpack_require__(/*! ../core/Framework */ "../../../core/build/core/src/core/Framework.js");
var Constants_1 = __webpack_require__(/*! ../core/Constants */ "../../../core/build/core/src/core/Constants.js");
var Ticket_1 = __webpack_require__(/*! ../core/ticket/Ticket */ "../../../core/build/core/src/core/ticket/Ticket.js");
var HiveServices_1 = __webpack_require__(/*! ../core/HiveServices */ "../../../core/build/core/src/core/HiveServices.js");
var build_defaults_1 = __webpack_require__(/*! ../common/build.defaults */ "../../../core/build/core/src/common/build.defaults.js");
var SERVICE_ENDPOINT_CUSTOM = build_defaults_1.BuildParameters.SERVICE_ENDPOINT_CUSTOM;
var TEST_OR_CUSTOM_PLUGIN = build_defaults_1.BuildParameters.SERVICE_ENDPOINT_TEST || build_defaults_1.BuildParameters.SERVICE_ENDPOINT_CUSTOM;
/**
 * currently this version will generate a Connection instance for each ticket to resolve,
 * and it will temporary maintain a reference to all of them.
 * When a ticket is activated, it will close the others connections.
 */
var StatsServiceClient = /** @class */ (function () {
    function StatsServiceClient() {
        this.loggerId = '[ServicesClient] ';
        this.logger = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.LOGGER).log();
        this.logger.debug(this.loggerId + "INIT SERVICE CLIENT");
    }
    StatsServiceClient.prototype.init = function (guid, ticket, serviceEndpoint) {
        var _this = this;
        if (serviceEndpoint) {
            if (this.connectionPromise)
                return { conn: this.connection, promise: this.connectionPromise };
            // create a new connection with the ticket resolve syntax
            var def_1 = Q.defer();
            var uri = new URI(serviceEndpoint);
            var endpoint = uri.addQuery({
                'connection-id': guid,
                'sendConfigs': 'true'
            }).toString();
            this.logger.debug(this.loggerId + "Connecting to serviceEndpoint " + endpoint);
            this.connection = new Connection_1.HiveServicesConnection(endpoint, Constants_1.Constants.MAX_RECONNECT_TIMEOUT, Constants_1.Constants.MAX_PENDING_MESSAGES, Constants_1.Constants.MAX_TIME_IN_SEND_QUEUE);
            // on connect resolve the promise
            this.connection.onconnect(function () {
                _this.logger.debug(_this.loggerId + "HIVE SERVICES CONNECTED");
                def_1.resolve(_this.connection);
            });
            this.connection.on(HiveStreamingServices.HIVEJS_TICKETS, 0, function (msg) {
                _this.logger.debug(_this.loggerId + "FAKED RESOLVING");
            });
            this.connection.onerror(function () {
                _this.logger.warn(_this.loggerId + "Hive Services Connection failed");
                def_1.reject(new Error('Hive Services Connection Failed'));
            });
            this.connectionPromise = def_1.promise;
            return { conn: this.connection, promise: this.connectionPromise };
            // always return the connection promise
        }
        if (!this.connectionPromise) {
            // create a new connection with the ticket resolve syntax
            var def_2 = Q.defer();
            var serviceEndpoint_1 = Constants_1.Constants.PROD_SERVICE_ENDPOINT;
            switch (ticket.ticketType) {
                case Ticket_1.TicketType.TEST:
                    if (TEST_OR_CUSTOM_PLUGIN)
                        serviceEndpoint_1 = Constants_1.Constants.TEST_SERVICE_ENDPOINT;
                    else
                        this.throwTicketError(def_2, 'test', 'production');
                    break;
                case Ticket_1.TicketType.DEV:
                    if (TEST_OR_CUSTOM_PLUGIN)
                        serviceEndpoint_1 = Constants_1.Constants.DEV_SERVICE_ENDPOINT;
                    else
                        this.throwTicketError(def_2, 'dev', 'production');
                    break;
                case Ticket_1.TicketType.CUSTOM:
                    if (SERVICE_ENDPOINT_CUSTOM)
                        serviceEndpoint_1 = build_defaults_1.BuildParameters.CUSTOM_BACKEND_ENDPOINT;
                    else {
                        this.throwTicketError(def_2, 'custom', 'production or test');
                    }
            }
            var uri = new URI(serviceEndpoint_1);
            var endpoint = uri.addQuery({
                'connection-id': guid,
                'partner_id': ticket.getPartnerId(),
                'customer_id': ticket.getCustomerId(),
                'content_id': ticket.getContentId(),
                'ticket': ticket.getTicketId(),
                'sendConfigs': 'true'
            }).toString();
            this.connection = new Connection_1.HiveServicesConnection(endpoint, Constants_1.Constants.MAX_RECONNECT_TIMEOUT, Constants_1.Constants.MAX_PENDING_MESSAGES, Constants_1.Constants.MAX_TIME_IN_SEND_QUEUE);
            // on connect resolve the promise
            this.connection.onconnect(function () {
                def_2.resolve(_this.connection);
            });
            this.connection.onerror(function () {
                _this.logger.warn('Hive Services Connection failed');
                def_2.reject(new Error('Hive Services Connection Failed'));
            });
            this.connectionPromise = def_2.promise;
        }
        else {
            // on connection established send another ticket request
            this.connectionPromise.then(function () {
                var jsonTicketRequest = {
                    partnerId: ticket.getPartnerId(),
                    customerId: ticket.getCustomerId(),
                    contentId: ticket.getContentId(),
                    secret: ticket.getTicketId()
                };
                var msg = new HiveServices_1.Message(HiveStreamingServices.HIVEJS_TICKETS, 1, JSON.stringify(jsonTicketRequest));
                _this.connection.send(msg);
            });
        }
        // always return the connection promise
        return { conn: this.connection, promise: this.connectionPromise };
    };
    /**
     * Throws an error and warns on the mismatch between the TicketType and the PluginType that is being used to revolved it
     */
    StatsServiceClient.prototype.throwTicketError = function (def, ticketType, pluginType) {
        this.logger.warn(this.loggerId + "Error trying to resolve " + ticketType + " ticket against " + pluginType + " services");
        def.reject(new Error(ticketType + " ticket in " + pluginType));
    };
    StatsServiceClient.prototype.connect = function () {
        if (this.connection)
            this.connection.connect(true);
    };
    /**
     * activates the single connection corresponding to the ticket
     * closing the remaining ones
     * @param ticket
     */
    StatsServiceClient.prototype.activate = function (ticket) {
        // noop
    };
    /**
     * returns the currently active connection, or the first established if
     * none has been activated yet (to send track snapshots with activation errors)
     * @returns {HiveServices.Connection}
     */
    StatsServiceClient.prototype.getConnection = function () {
        return this.connection;
    };
    /**
     * close all the initialized connections
     */
    StatsServiceClient.prototype.close = function () {
        if (this.connection) {
            this.connectionPromise = null;
            this.connection.close(false);
        }
    };
    return StatsServiceClient;
}());
exports.StatsServiceClient = StatsServiceClient;
//# sourceMappingURL=StatsServiceClient.js.map

/***/ }),

/***/ "../../../core/build/core/src/stats/Track.js":
/*!********************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/stats/Track.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.TechEventRecord = exports.TrackEventRecord = exports.Client = exports.Manager = exports.InitStepEvent = exports.IntegrationInfo = exports.InitStep = exports.PlayerEvents = void 0;
var SensitiveInfoUtils_1 = __webpack_require__(/*! ../common/utils/SensitiveInfoUtils */ "../../../core/build/core/src/common/utils/SensitiveInfoUtils.js");
var ua_parser_js_1 = __webpack_require__(/*! ua-parser-js */ "../../../node_modules/ua-parser-js/src/ua-parser.js");
var Q = __webpack_require__(/*! @hivestreaming/q */ "../../../node_modules/@hivestreaming/q/q.js");
var Framework_1 = __webpack_require__(/*! ../core/Framework */ "../../../core/build/core/src/core/Framework.js");
var Constants_1 = __webpack_require__(/*! ../core/Constants */ "../../../core/build/core/src/core/Constants.js");
var HiveServices_1 = __webpack_require__(/*! ../core/HiveServices */ "../../../core/build/core/src/core/HiveServices.js");
var ClientConfigs_1 = __webpack_require__(/*! ../webrtc/ClientConfigs */ "../../../core/build/core/src/webrtc/ClientConfigs.js");
var TrackContainer_1 = __webpack_require__(/*! hivejs-protocol/snapshots/TrackContainer */ "../../../protocol/snapshots/TrackContainer.js");
var TrackData_1 = __webpack_require__(/*! hivejs-protocol/snapshots/TrackData */ "../../../protocol/snapshots/TrackData.js");
var PeerInfo_1 = __webpack_require__(/*! hivejs-protocol/snapshots/PeerInfo */ "../../../protocol/snapshots/PeerInfo.js");
var IntegrationData_1 = __webpack_require__(/*! hivejs-protocol/snapshots/IntegrationData */ "../../../protocol/snapshots/IntegrationData.js");
var SessionData_1 = __webpack_require__(/*! hivejs-protocol/snapshots/SessionData */ "../../../protocol/snapshots/SessionData.js");
var Track = /** @class */ (function () {
    function Track() {
    }
    // track application
    Track.TRACK_APP = 'hive-client-track';
    // event name
    Track.TRACK_NAME = 'trackevent';
    // default event tag used in case of missing ticket
    Track.TRACK_DEFAULT_EVENT_TAG = 'NULLID';
    // the installed client version
    Track.CLIENT_VERSION = '';
    return Track;
}());
var loggerId = '[TRACK] ';
// This enum isn't constant, so that it can be exported by Core.
var PlayerEvents;
(function (PlayerEvents) {
    PlayerEvents[PlayerEvents["PLAYING"] = 0] = "PLAYING";
    PlayerEvents[PlayerEvents["BUFFERING"] = 1] = "BUFFERING";
    PlayerEvents[PlayerEvents["PAUSED"] = 2] = "PAUSED";
    PlayerEvents[PlayerEvents["SKIP"] = 3] = "SKIP";
    PlayerEvents[PlayerEvents["STOPPED"] = 4] = "STOPPED";
    PlayerEvents[PlayerEvents["ERROR"] = 5] = "ERROR";
    PlayerEvents[PlayerEvents["WINDOW_SIZE"] = 6] = "WINDOW_SIZE";
    PlayerEvents[PlayerEvents["FULLSCREEN"] = 7] = "FULLSCREEN";
    PlayerEvents[PlayerEvents["VISIBLE"] = 8] = "VISIBLE";
    PlayerEvents[PlayerEvents["HIDDEN"] = 9] = "HIDDEN";
    PlayerEvents[PlayerEvents["MUTED"] = 10] = "MUTED";
    PlayerEvents[PlayerEvents["LANGUAGE_SWITCH"] = 11] = "LANGUAGE_SWITCH";
    PlayerEvents[PlayerEvents["CAPTION_SWITCH"] = 12] = "CAPTION_SWITCH"; // 112
})(PlayerEvents = exports.PlayerEvents || (exports.PlayerEvents = {}));
var InitStep;
(function (InitStep) {
    InitStep[InitStep["TIME_TO_AUTH_TOKEN_ENDPOINT"] = 0] = "TIME_TO_AUTH_TOKEN_ENDPOINT";
    InitStep[InitStep["TIME_TO_AUTH_HIVE_ENDPOINT"] = 1] = "TIME_TO_AUTH_HIVE_ENDPOINT";
    InitStep[InitStep["TIME_TO_RI_INIT_SUCCESS"] = 2] = "TIME_TO_RI_INIT_SUCCESS";
    InitStep[InitStep["TIME_TO_TECH_INIT_SUCCESS"] = 3] = "TIME_TO_TECH_INIT_SUCCESS";
    InitStep[InitStep["TIME_TO_TECH_INIT_FAIL"] = 4] = "TIME_TO_TECH_INIT_FAIL";
    InitStep[InitStep["TIME_TO_CLIENT_NOT_READY"] = 5] = "TIME_TO_CLIENT_NOT_READY";
    InitStep[InitStep["TIME_TO_CLIENT_NOT_FOUND"] = 6] = "TIME_TO_CLIENT_NOT_FOUND";
    InitStep[InitStep["TIME_TO_OVERALL_AUTH"] = 7] = "TIME_TO_OVERALL_AUTH";
    InitStep[InitStep["TIME_TO_PLAYER_INIT"] = 8] = "TIME_TO_PLAYER_INIT";
    InitStep[InitStep["TIME_TO_SESSION_ACTIVATED"] = 9] = "TIME_TO_SESSION_ACTIVATED";
    InitStep[InitStep["TIME_TO_CONN_INFO_SUCCESS"] = 10] = "TIME_TO_CONN_INFO_SUCCESS";
    InitStep[InitStep["TIME_TO_CONN_INFO_FAIL"] = 11] = "TIME_TO_CONN_INFO_FAIL"; // 11
})(InitStep = exports.InitStep || (exports.InitStep = {}));
var InitStepTypeMap = (_a = {},
    _a[InitStep.TIME_TO_AUTH_TOKEN_ENDPOINT] = 0 /* REQUEST */,
    _a[InitStep.TIME_TO_AUTH_HIVE_ENDPOINT] = 0 /* REQUEST */,
    _a[InitStep.TIME_TO_RI_INIT_SUCCESS] = 0 /* REQUEST */,
    _a[InitStep.TIME_TO_TECH_INIT_SUCCESS] = 1 /* TECH */,
    _a[InitStep.TIME_TO_TECH_INIT_FAIL] = 1 /* TECH */,
    _a[InitStep.TIME_TO_CLIENT_NOT_READY] = 1 /* TECH */,
    _a[InitStep.TIME_TO_CLIENT_NOT_FOUND] = 1 /* TECH */,
    _a[InitStep.TIME_TO_OVERALL_AUTH] = 2 /* PLUGIN */,
    _a[InitStep.TIME_TO_PLAYER_INIT] = 2 /* PLUGIN */,
    _a[InitStep.TIME_TO_SESSION_ACTIVATED] = 2 /* PLUGIN */,
    _a[InitStep.TIME_TO_CONN_INFO_SUCCESS] = 0 /* REQUEST */,
    _a[InitStep.TIME_TO_CONN_INFO_FAIL] = 0 /* REQUEST */,
    _a);
/**
 * Temporary container for integration info
 * Not sent in track snap
 */
var IntegrationInfo = /** @class */ (function () {
    function IntegrationInfo() {
    }
    return IntegrationInfo;
}());
exports.IntegrationInfo = IntegrationInfo;
var NetworkChangedEvent = /** @class */ (function () {
    function NetworkChangedEvent() {
        this.type = 2 /* NETWORK_CHANGED */;
    }
    return NetworkChangedEvent;
}());
/**
 * Placeholder for an initStepEndEvent
 */
var InitStepEvent = /** @class */ (function () {
    function InitStepEvent(initStep, ts, duration) {
        this.initStep = initStep;
        this.ts = ts;
        this.duration = duration;
    }
    return InitStepEvent;
}());
exports.InitStepEvent = InitStepEvent;
var TrackData = /** @class */ (function (_super) {
    __extends(TrackData, _super);
    function TrackData() {
        var _this = _super.call(this) || this;
        _this.sessions = new Array();
        return _this;
    }
    TrackData.prototype.addToSession = function (sessionId, event) {
        var session;
        // check if a session with this id was already included
        this.sessions.forEach(function (existing) {
            if (existing.sessionId == sessionId) {
                session = existing;
            }
        });
        // if not, generate a new session
        if (!session) {
            session = new SessionData_1.SessionData();
            session.sessionId = sessionId;
            session.events = [];
            this.sessions.push(session);
        }
        // push the event in the session
        session.events.push(event);
    };
    return TrackData;
}(TrackData_1.TrackData));
var Manager = /** @class */ (function () {
    function Manager() {
        this.logger = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.LOGGER).log();
        this.connInfoProvider = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.CONNECTIVITY_INFO_PROVIDER);
        this.startupRecords = new Array();
        this.playerEventRecords = new Array();
        this.techEventRecords = new Array();
        this.initStepEventRecords = new Array();
    }
    Manager.prototype.initClient = function (client) {
        this.client = client;
    };
    Manager.prototype.init = function (guid, techInfo) {
        this.myId = guid;
        this.updateTechInfo(techInfo);
        this.logger.debug(loggerId + 'INIT Reporting ID: ' + guid);
    };
    /**
     * If no userAgent is passed, the track snapshot will use the
     * navigator one.
     *
     * @param techInfo TechInfo
     */
    Manager.prototype.updateTechInfo = function (techInfo) {
        this.techInfo = techInfo;
    };
    Manager.prototype.updateIntegrationInfo = function (info) {
        this.integrationInfo = info;
    };
    Manager.prototype.ticketRequested = function (ticket) {
        var trackRecord = new TrackEventRecord(ticket, this);
        this.startupRecords.push(trackRecord);
        this.activeEvent = null;
        this.client.scheduleSend(true);
    };
    Manager.prototype.manifestRequested = function (sessionId, url, respCode) {
        if (!this.activeEvent) {
            for (var i = 0; i < this.startupRecords.length; i++) {
                var record = this.startupRecords[i];
                if (record.ticket.sessionId === sessionId) {
                    this.logger.debug(loggerId + 'Activating Track for session ' + sessionId);
                    this.activeEvent = record;
                    break;
                }
            }
        }
        if (!this.activeEvent) {
            return;
        }
        if (this.activeEvent.ticket.sessionId != sessionId) {
            this.logger.warn(loggerId + 'ignoring manifest not matching event ' + this.activeEvent.ticket.sessionId + ' != ' + sessionId);
            return;
        }
        if (this.activeEvent.isSent) {
            return;
        }
        var manifestRequest = new ManifestRequested(sessionId, url, respCode);
        this.activeEvent.addManifest(manifestRequest);
        if (this.integrationInfo) {
            this.activeEvent.eventName = this.integrationInfo.eventName;
        }
        this.client.scheduleSend();
    };
    Manager.prototype.handlePlayerStats = function (playingPoint, playerBuffer, totBufferingTime) {
        if (this.activeEvent == null) {
            return;
        }
        if (!this.activeEvent.isSent) {
            this.activeEvent.playerFeedbacks.push(new PlayerFeedback(playingPoint, playerBuffer, totBufferingTime));
        }
    };
    Manager.prototype.handlePlayerEvent = function (sessionId, event, eventObj) {
        this.playerEventRecords.push(new PlayerEventRecord(sessionId, event, eventObj));
        this.client.scheduleSend();
    };
    Manager.prototype.handleTechEvent = function (sessionId, event, eventObj) {
        this.techEventRecords.push(new TechEventRecord(sessionId, event, eventObj));
        this.client.scheduleSend();
    };
    Manager.prototype.handleTechEvents = function (techEvents) {
        var _this = this;
        if (techEvents) {
            techEvents.forEach(function (el) {
                _this.techEventRecords.push(el);
            });
        }
    };
    Manager.prototype.handleInitStepEvents = function (events, sessionId) {
        var _this = this;
        events.forEach(function (event) {
            var initStep = event.initStep;
            var eventObj = {
                initEventType: InitStepTypeMap[initStep],
                initStepDuration: event.duration
            };
            _this.initStepEventRecords.push(new InitStepEventRecord(sessionId, initStep, eventObj, event.ts));
        });
        this.client.scheduleSend();
    };
    Manager.prototype.getPeerInfo = function () {
        var peerInfo = new PeerInfo_1.PeerInfo();
        if (ClientConfigs_1.HiveConfig.ClientInfo.PartnerId && ClientConfigs_1.HiveConfig.ClientInfo.CustomerId) {
            peerInfo.partnerId = ClientConfigs_1.HiveConfig.ClientInfo.PartnerId;
            peerInfo.customerId = ClientConfigs_1.HiveConfig.ClientInfo.CustomerId;
        }
        else if (this.activeEvent) {
            peerInfo.partnerId = this.activeEvent.ticket.getPartnerId();
            peerInfo.customerId = this.activeEvent.ticket.getCustomerId();
        }
        peerInfo.clientType = this.techInfo.name;
        var parser = new ua_parser_js_1.UAParser();
        parser.setUA(navigator.userAgent);
        peerInfo.os = parser.getOS().name + ' ' + parser.getOS().version;
        if (this.integrationInfo) {
            peerInfo.consumptionApp = this.integrationInfo.consumptionApp;
            peerInfo.integrationInfo = new IntegrationData_1.IntegrationData();
            peerInfo.integrationInfo.playerName = this.integrationInfo.playerName;
            peerInfo.integrationInfo.playerVersion = this.integrationInfo.playerVersion;
            peerInfo.integrationInfo.playerTech = this.integrationInfo.playerTech;
            peerInfo.integrationInfo.pluginName = this.integrationInfo.pluginName;
            peerInfo.integrationInfo.pluginVersion = this.integrationInfo.pluginVersion;
            peerInfo.integrationInfo.coreVersion = this.integrationInfo.coreVersion;
            if (this.integrationInfo.webRTCVersion) {
                peerInfo.integrationInfo.webRTCVersion = this.integrationInfo.webRTCVersion;
            }
            if (this.integrationInfo.telemetryId) {
                peerInfo.telemetryId = this.integrationInfo.telemetryId;
            }
        }
        return peerInfo;
    };
    Manager.prototype.getPotentialEvent = function () {
        if (this.activeEvent) {
            return this.activeEvent;
        }
        if (this.startupRecords && this.startupRecords.length > 0) {
            return this.startupRecords[this.startupRecords.length - 1];
        }
    };
    /**
     * create a track snapshot thrift object with the current data. It can be synchronous or asynchronous.
     * In the synchronous mode, the data collected is the last known. If some is not available it will be set as null.
     * In the asynchronous mode, instead, if some data is not available, it will try to gather them directly before forwarding.
     *
     * @param  {boolean=true} async
     * @returns {Q.Promise<TrackContainer>} if async
     * @returns {TrackContainer} if sync
     */
    Manager.prototype.getSnapshotContainer = function (async) {
        var _this = this;
        if (async === void 0) { async = true; }
        // check if we have content to send
        if (this.startupRecords.length == 0 && this.playerEventRecords.length == 0) {
            if (async) {
                return Q.reject('nothing to send');
            }
            else {
                this.logger.debug(loggerId + " NOTHING TO SEND");
                return null;
            }
        }
        // initialize the track snapshot with [app, createdAt, guid, name]
        var trackContainer = new TrackContainer_1.TrackContainer();
        trackContainer.app = Track.TRACK_APP;
        trackContainer.createdAt = Framework_1.Framework.time();
        trackContainer.guid = this.myId;
        trackContainer.name = Track.TRACK_NAME;
        var potentialEvent = this.getPotentialEvent();
        if (potentialEvent) {
            var strippedEventInfo = potentialEvent.ticket.getEventInfo().replace(/[\[\]]/g, '');
            trackContainer.tags = [strippedEventInfo];
            trackContainer.tags.push(potentialEvent.ticket.getPartnerId());
            trackContainer.tags.push(potentialEvent.ticket.getCustomerId());
        }
        else {
            trackContainer.tags = new Array();
        }
        var trackData = new TrackData();
        trackData.peer = this.getPeerInfo();
        // add startup records
        this.startupRecords.forEach(function (record) {
            if (!record.isSent) {
                trackData.addToSession(record.ticket.sessionId, record);
            }
        });
        // add player event records
        this.playerEventRecords.forEach(function (record) {
            trackData.addToSession(record.sessionId, record);
        });
        // add tech event records
        this.techEventRecords.forEach(function (record) {
            trackData.addToSession(record.sessionId, record);
        });
        // add init steps times records
        this.initStepEventRecords.forEach(function (record) {
            trackData.addToSession(record.sessionId, record);
        });
        trackContainer.data = trackData;
        if (async) {
            return this.connInfoProvider.getConnectivityInfo().then(function (ci) {
                var ncEvent = _this.getNetworkChangedEvent(ci);
                trackData.addToSession('null', ncEvent);
                return trackContainer;
            }).fail(function (error) {
                // in this case we return anyway the track container, but without the conn Info
                // this.logger.warn(loggerId + "Get connectivity info failed with error " + error);
                return trackContainer;
            });
        }
        else {
            var ncEvent = this.getNetworkChangedEvent(this.connInfoProvider.getSyncConnectivityInfo());
            trackData.addToSession('null', ncEvent);
            return trackContainer;
        }
    };
    Manager.prototype.getNetworkChangedEvent = function (ci) {
        var ncEvent = new NetworkChangedEvent();
        ncEvent.ts = Framework_1.Framework.time();
        var nc = ci.getNetworkInfo();
        if (nc.getPublicIp()) {
            ncEvent.pubIp = nc.getPublicIp();
        }
        if (nc.getPrivateIp()) {
            ncEvent.privIp = SensitiveInfoUtils_1.SensitiveInfoUtils.getPrivateIp(nc);
        }
        if (ci.getHostName()) {
            ncEvent.hostname = SensitiveInfoUtils_1.SensitiveInfoUtils.getHostname(ci);
        }
        if (nc.getCidr()) {
            ncEvent.netmask = nc.getCidr();
        }
        if (nc.getNic()) {
            ncEvent.nic = nc.getNic();
        }
        if (nc.getNicName()) {
            ncEvent.nicName = nc.getNicName();
        }
        if (nc.getMacAddress()) {
            ncEvent.mac = nc.getMacAddress();
        }
        return ncEvent;
    };
    Manager.prototype.getUserAgent = function () {
        return navigator.userAgent;
    };
    Manager.prototype.reset = function () {
        this.startupRecords = new Array();
        this.playerEventRecords = new Array();
        this.techEventRecords = new Array();
        this.initStepEventRecords = new Array();
    };
    Manager.prototype.serverConnected = function (guid) {
    };
    return Manager;
}());
exports.Manager = Manager;
var Client = /** @class */ (function () {
    function Client(trackManager) {
        this.trackSnapshotLog = isNaN(ClientConfigs_1.HiveConfig.DebugLogs.TrackSnapshotLogs) ? 0 : ClientConfigs_1.HiveConfig.DebugLogs.TrackSnapshotLogs;
        this.trackManager = trackManager;
        this.logger = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.LOGGER).log();
        this.client = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.SERVICES_CLIENT);
        this.trackManager.initClient(this);
    }
    /**
     * only schedule a track send if there isn't already a pending one
     * or the new track send should be sent in shorter time than the pending one
     * @param expedit
     */
    Client.prototype.scheduleSend = function (expedit) {
        if (expedit === void 0) { expedit = false; }
        var delay = expedit ? Constants_1.Constants.FIRST_TRACK_INTERVAL : Constants_1.Constants.TRACK_INTERVAL;
        if (!this.nextSendId) {
            this.scheduleWithTime(delay);
        }
        else {
            // check if the pending is scheduled fast enough
            var remainingMs = this.nextSendTime - new Date().getTime();
            if (remainingMs > delay) {
                Framework_1.Framework.clearTimeout(this.nextSendId);
                this.nextSendTime = null;
                this.scheduleWithTime(delay);
            }
        }
    };
    Client.prototype.clearScheduledSend = function () {
        if (this.nextSendId) {
            Framework_1.Framework.clearTimeout(this.nextSendId);
            this.nextSendTime = this.nextSendId = null;
        }
    };
    Client.prototype.scheduleWithTime = function (delay, persistClearAll) {
        var _this = this;
        if (persistClearAll === void 0) { persistClearAll = false; }
        this.nextSendId = Framework_1.Framework.setTimeout(function () {
            _this.trackSnapshot();
        }, delay, persistClearAll);
        this.nextSendTime = new Date().getTime() + delay;
    };
    /**
     * This method generates the track and then forwards it.
     * It can call the snapshot generation in asynchronous or synchronous mode, basing on the needs.
     * Right now sync mode is called when flushing the last partial snapshot
     * @param  {boolean=true} async
     */
    Client.prototype.trackSnapshot = function (async) {
        var _this = this;
        if (async === void 0) { async = true; }
        this.nextSendId = null;
        this.nextSendTime = null;
        var snap = this.trackManager.getSnapshotContainer(async);
        if (async) {
            this.logger.debug(loggerId + 'TAKING A TRACK SNAPSHOT');
            snap.then(function (track) { return _this.forward(track); })
                .fail(function (error) {
                _this.logger.debug(loggerId + " ERROR GENERATING/SENDING THE TRACK SNAPSHOT: ", error);
            })
                .finally(function () { return _this.trackManager.reset(); }).done();
        }
        else {
            this.logger.debug(loggerId + 'FLUSHING TRACK SNAPSHOT');
            this.forward(snap);
            this.trackManager.reset();
        }
    };
    Client.prototype.forward = function (snap) {
        if (this.filter) {
            var _a = this.filter.shouldSend(), playingTime = _a.playingTime, threshold = _a.threshold, shouldSend = _a.shouldSend;
            if (!shouldSend) {
                this.logger.debug(loggerId + "SKIPPING SNAPSHOT DUE TO REPORTING THRESHOLD: " + playingTime + " < " + threshold);
                return;
            }
        }
        // we send the snapshot if there is a connection and if snap is defined, since with the sync version of the snapshot creation,
        // if there is no data, the result will be an empty snapshot
        if (this.client && this.client.getConnection() && snap) {
            var jsonized = JSON.stringify(snap);
            switch (this.trackSnapshotLog) {
                case 0:
                default:
                    this.logger.debug(loggerId + 'TRACK EVENT');
                    break;
                case 1:
                    this.logger.debug(loggerId + 'TRACK EVENT:' + jsonized);
                    break;
            }
            var msg = new HiveServices_1.Message(HiveStreamingServices.HIVEJS_SNAPSHOTS, 2, jsonized);
            this.client.getConnection().send(msg);
        }
    };
    /**
     * This method is only called when we want to close the session.
     */
    Client.prototype.flushLastTrackSnapshot = function () {
        this.trackSnapshot(false);
    };
    Client.prototype.setFilter = function (filter) {
        this.filter = filter;
    };
    return Client;
}());
exports.Client = Client;
var TrackEventRecord = /** @class */ (function () {
    function TrackEventRecord(ticket, trackManager) {
        this.createdAt = new Date().getTime();
        this.isSent = false;
        this.ticket = ticket;
        this.manifests = new Array();
        this.playerFeedbacks = new Array();
        this.trackManager = trackManager;
    }
    TrackEventRecord.prototype.addManifest = function (manifestRequest) {
        this.manifests.push(manifestRequest);
    };
    /**
     * override of the default JSON.stringify method
     */
    TrackEventRecord.prototype.toJSON = function () {
        var obj = {};
        obj.type = 0 /* STARTUP */;
        // ticket
        obj.ticket = {};
        obj.ticket.url = this.ticket.getTicketUrl();
        obj.ticket.reqTs = this.ticket.requestTs;
        obj.ticket.respTs = this.ticket.responseTs;
        obj.ticket.userAgent = this.trackManager.getUserAgent();
        if (this.ticket.testId != null) {
            obj.ticket.testId = this.ticket.testId;
        }
        // manifests
        obj.manifests = [];
        this.manifests.forEach(function (manifest) {
            var mObj = {};
            mObj.url = manifest.url;
            mObj.respTs = manifest.responseTs;
            mObj.respCode = manifest.respCode;
            obj.manifests.push(mObj);
        });
        // add player stats
        var playTs = -1;
        var initialBufferTime = -1;
        var buffTime = -1;
        /*
         * find the first playerFeedback with totalBufferingTime > 0
         * and use it's timestamp as initial playback time (playTs).
         *
         * Plugin now will immediately forward a player feedback once measured
         * the initial buffering!
         */
        this.playerFeedbacks.forEach(function (pf) {
            if (pf.totBufferingTime > 0) {
                if (playTs == -1) {
                    playTs = pf.ts;
                    initialBufferTime = pf.totBufferingTime;
                }
                buffTime = pf.totBufferingTime;
            }
        });
        if (playTs != -1) {
            obj.playTs = playTs;
        }
        if (buffTime != -1) {
            obj.buffTime = buffTime;
        }
        if (initialBufferTime != -1) {
            obj.initBuffTime = initialBufferTime;
        }
        obj.eventName = this.eventName;
        return obj;
    };
    return TrackEventRecord;
}());
exports.TrackEventRecord = TrackEventRecord;
var ManifestRequested = /** @class */ (function () {
    function ManifestRequested(eventId, url, respCode) {
        this.eventId = eventId;
        this.url = url;
        this.responseTs = new Date().getTime();
        this.respCode = respCode;
    }
    return ManifestRequested;
}());
var AbstractEventRecord = /** @class */ (function () {
    function AbstractEventRecord(sessionId, event, eventObj, ts) {
        this.ts = new Date().getTime();
        this.sessionId = sessionId;
        if (!this.sessionId) {
            this.sessionId = 'null';
        }
        this.event = event;
        this.eventObj = eventObj;
        if (ts) {
            this.ts = ts;
        }
    }
    AbstractEventRecord.prototype.toJSON = function () {
        var obj = {};
        obj.type = (this.baseStartCode + this.event);
        obj.ts = this.ts;
        if (this.eventObj) {
            obj.parameters = this.eventObj;
        }
        return obj;
    };
    return AbstractEventRecord;
}());
var PlayerEventRecord = /** @class */ (function (_super) {
    __extends(PlayerEventRecord, _super);
    function PlayerEventRecord(sessionId, event, eventObj, ts) {
        var _this = _super.call(this, sessionId, event, eventObj, ts) || this;
        _this.baseStartCode = 100 /* PLAYER_EVENT */;
        return _this;
    }
    return PlayerEventRecord;
}(AbstractEventRecord));
var TechEventRecord = /** @class */ (function (_super) {
    __extends(TechEventRecord, _super);
    function TechEventRecord(sessionId, event, eventObj, ts) {
        var _this = _super.call(this, sessionId, event, eventObj, ts) || this;
        _this.baseStartCode = 200 /* TECH_EVENT */;
        return _this;
    }
    return TechEventRecord;
}(AbstractEventRecord));
exports.TechEventRecord = TechEventRecord;
var InitStepEventRecord = /** @class */ (function (_super) {
    __extends(InitStepEventRecord, _super);
    function InitStepEventRecord(sessionId, event, eventObj, ts) {
        var _this = _super.call(this, sessionId, event, eventObj, ts) || this;
        _this.baseStartCode = 3 /* TIMING_EVENT */;
        return _this;
    }
    InitStepEventRecord.prototype.toJSON = function () {
        return {
            type: this.baseStartCode,
            ts: this.ts,
            initStep: this.event,
            initStepDuration: this.eventObj.initStepDuration,
            initEventType: this.eventObj.initEventType
        };
    };
    return InitStepEventRecord;
}(AbstractEventRecord));
var PlayerFeedback = /** @class */ (function () {
    function PlayerFeedback(playingPoint, playerBuffer, totBufferingTime) {
        this.ts = new Date().getTime();
        this.playingPoint = playingPoint;
        this.playerBuffer = playerBuffer;
        this.totBufferingTime = totBufferingTime;
    }
    return PlayerFeedback;
}());
//# sourceMappingURL=Track.js.map

/***/ }),

/***/ "../../../core/build/core/src/stats/context/ContextManager.js":
/*!*************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/stats/context/ContextManager.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.VideoContextManager = void 0;
var Framework_1 = __webpack_require__(/*! ../../core/Framework */ "../../../core/build/core/src/core/Framework.js");
var DashContext_1 = __webpack_require__(/*! ./dash/DashContext */ "../../../core/build/core/src/stats/context/dash/DashContext.js");
var HlsContext_1 = __webpack_require__(/*! ./hls/HlsContext */ "../../../core/build/core/src/stats/context/hls/HlsContext.js");
var ContextManager_1 = __webpack_require__(/*! ../../core/context/ContextManager */ "../../../core/build/core/src/core/context/ContextManager.js");
var VideoContextManager = /** @class */ (function (_super) {
    __extends(VideoContextManager, _super);
    function VideoContextManager() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    VideoContextManager.prototype.init = function (reportingInstance, sessionId) {
        this.reportingInstance = reportingInstance;
        this.logger = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.LOGGER).log(sessionId);
    };
    VideoContextManager.prototype.createHlsContext = function (ticket) {
        return new HlsContext_1.HlsContext(this.reportingInstance, this.hiveTechOptions);
    };
    VideoContextManager.prototype.createDashContext = function (ticket) {
        return new DashContext_1.DashContext(this.reportingInstance, this.hiveTechOptions);
    };
    return VideoContextManager;
}(ContextManager_1.ContextManager));
exports.VideoContextManager = VideoContextManager;
//# sourceMappingURL=ContextManager.js.map

/***/ }),

/***/ "../../../core/build/core/src/stats/context/VideoContextBase.js":
/*!***************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/stats/context/VideoContextBase.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.VideoContextBase = void 0;
var SnapshotAccountingManager_1 = __webpack_require__(/*! ../SnapshotAccountingManager */ "../../../core/build/core/src/stats/SnapshotAccountingManager.js");
var EntityType_1 = __webpack_require__(/*! ../../core/entity/EntityType */ "../../../core/build/core/src/core/entity/EntityType.js");
var VideoContextBase = /** @class */ (function () {
    function VideoContextBase(reportingInstance) {
        this.reportingInstance = reportingInstance;
        this.snapshotAccountingManager = new SnapshotAccountingManager_1.SnapshotAccountingManager();
        this.fragmentMetadataProvider = reportingInstance.statsStore.fragmentMetadataProvider;
        this.fragmentDownloadProvider = reportingInstance.statsStore.fragmentDownloadProvider;
        this.manifestUrl = reportingInstance.ticket.getManifestUrlWithQuery();
        this.snapshotAccountingManager.init(reportingInstance);
    }
    VideoContextBase.prototype.requestReceived = function (request) {
        var _this = this;
        return this.metadata.requestReceived(request).then(function (value) {
            var entityType = _this.metadata.getEntityType(request.getRequestUrl());
            if (entityType === EntityType_1.EntityType.METADATA) {
                _this.metadataReceived(request);
            }
            return value;
        });
    };
    VideoContextBase.prototype.metadataReceived = function (request) {
        this.metadata.parse(request.getResponseUrl(), request.getResponseAsString(), false);
    };
    VideoContextBase.prototype.fragmentReceived = function (request) {
    };
    VideoContextBase.prototype.updateFragmentMetadata = function (request) {
        var segment = this.metadata.getSegmentInfo(request.getRequestUrl());
        if (segment) {
            this.fragmentMetadataProvider.add(segment, request.getResponseSize());
        }
    };
    VideoContextBase.prototype.updateFragmentDownload = function (request) {
        this.fragmentDownloadProvider.add(request, hive.snapshots.RequestType.PLAYER, hive.snapshots.OriginType.CDN);
    };
    VideoContextBase.prototype.updateBandwidth = function (request) {
        this.reportingInstance.nodeInfo.getSourceThroughput().smooth(request.getBandwidth());
    };
    VideoContextBase.prototype.updateQualityLevel = function (request) {
        var characteristics = request.getEntityCharacteristics();
        var previousQualityLevel = this.reportingInstance.nodeInfo.getWatchingQualityLevel();
        var currentQualityLevel = characteristics.getQualityLevel();
        if (!previousQualityLevel) {
            this.snapshotAccountingManager.accountQualityLevelSwitch(true);
        }
        else {
            if (currentQualityLevel.compareTo(previousQualityLevel) > 0) {
                this.snapshotAccountingManager.accountQualityLevelSwitch(true);
            }
            else if (currentQualityLevel.compareTo(previousQualityLevel) < 0) {
                this.snapshotAccountingManager.accountQualityLevelSwitch(false);
            }
        }
        this.reportingInstance.nodeInfo.setWatchingQualityLevel(currentQualityLevel);
    };
    VideoContextBase.prototype.getMetadata = function () {
        return this.metadata;
    };
    VideoContextBase.prototype.getStreamProtocol = function () {
        return this.metadata.getStreamProtocol();
    };
    VideoContextBase.prototype.hasBeenLive = function () {
        return this.wasLive;
    };
    VideoContextBase.prototype.getMetadataInfo = function () {
        return this.metadata.getMetadataInfo();
    };
    VideoContextBase.prototype.setAuthenticationToken = function (token) {
        this.metadata.setAuthenticationToken(token);
    };
    VideoContextBase.prototype.getQualityLevelTracker = function () {
        return this.metadata.getQualityLevelTracker();
    };
    return VideoContextBase;
}());
exports.VideoContextBase = VideoContextBase;
//# sourceMappingURL=VideoContextBase.js.map

/***/ }),

/***/ "../../../core/build/core/src/stats/context/dash/DashContext.js":
/*!***************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/stats/context/dash/DashContext.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.DashContext = void 0;
var VideoContextBase_1 = __webpack_require__(/*! ../VideoContextBase */ "../../../core/build/core/src/stats/context/VideoContextBase.js");
var Dash_1 = __webpack_require__(/*! ../../../core/metadata/dash/Dash */ "../../../core/build/core/src/core/metadata/dash/Dash.js");
var DashContext = /** @class */ (function (_super) {
    __extends(DashContext, _super);
    function DashContext(reportingInstance, statsJsOptions) {
        var _this = _super.call(this, reportingInstance) || this;
        _this.metadata = Dash_1.Dash.createMetadata(_this.manifestUrl, { regenerate: false }, null, statsJsOptions);
        _this.fragmentMetadataProvider.setMetadata(_this.metadata);
        return _this;
    }
    DashContext.prototype.metadataReceived = function (request) {
        _super.prototype.metadataReceived.call(this, request);
        if (this.wasLive === undefined) {
            this.wasLive = this.metadata.isLive();
        }
    };
    return DashContext;
}(VideoContextBase_1.VideoContextBase));
exports.DashContext = DashContext;
//# sourceMappingURL=DashContext.js.map

/***/ }),

/***/ "../../../core/build/core/src/stats/context/hls/HlsContext.js":
/*!*************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/stats/context/hls/HlsContext.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.HlsContext = void 0;
var VideoContextBase_1 = __webpack_require__(/*! ../VideoContextBase */ "../../../core/build/core/src/stats/context/VideoContextBase.js");
var Hls_1 = __webpack_require__(/*! ../../../core/metadata/hls/Hls */ "../../../core/build/core/src/core/metadata/hls/Hls.js");
var HlsContext = /** @class */ (function (_super) {
    __extends(HlsContext, _super);
    function HlsContext(reportingInstance, statsJsOptions) {
        var _this = _super.call(this, reportingInstance) || this;
        _this.metadata = Hls_1.Hls.createMetadata({ regenerate: false }, null, statsJsOptions);
        return _this;
    }
    HlsContext.prototype.metadataReceived = function (request) {
        _super.prototype.metadataReceived.call(this, request);
        if (this.metadata.hasPlaylist(request.getRequestUrl())) {
            if (this.wasLive === undefined) {
                this.wasLive = this.metadata.isLive();
            }
        }
    };
    return HlsContext;
}(VideoContextBase_1.VideoContextBase));
exports.HlsContext = HlsContext;
//# sourceMappingURL=HlsContext.js.map

/***/ }),

/***/ "../../../core/build/core/src/stats/index.js":
/*!********************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/stats/index.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Tech_1 = __webpack_require__(/*! ../core/Tech */ "../../../core/build/core/src/core/Tech.js");
var Framework_1 = __webpack_require__(/*! ../core/Framework */ "../../../core/build/core/src/core/Framework.js");
var techs_hive_1 = __webpack_require__(/*! ../common/techs/techs.hive */ "../../../core/build/core/src/common/techs/techs.hive.js");
var Stats = /** @class */ (function (_super) {
    __extends(Stats, _super);
    function Stats() {
        return _super.call(this, techs_hive_1.TechName.StatsJS, Framework_1.Framework.Definitions.REPORTING) || this;
    }
    return Stats;
}(Tech_1.default));
exports.default = new Stats();
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../../core/build/core/src/stats/node-info/DefaultStatsNodeInfo.js":
/*!*********************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/stats/node-info/DefaultStatsNodeInfo.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.DefaultStatsNodeInfo = void 0;
var Utils_1 = __webpack_require__(/*! ../../core/Utils */ "../../../core/build/core/src/core/Utils.js");
var DefaultStatsNodeInfo = /** @class */ (function () {
    function DefaultStatsNodeInfo() {
        this.sourceThroughput = new Utils_1.Bandwidth();
    }
    DefaultStatsNodeInfo.prototype.setWatchingQualityLevel = function (qualityLevel) {
        this.watchingQualityLevel = qualityLevel;
    };
    DefaultStatsNodeInfo.prototype.getWatchingQualityLevel = function () {
        return this.watchingQualityLevel;
    };
    DefaultStatsNodeInfo.prototype.getSourceThroughput = function () {
        return this.sourceThroughput;
    };
    return DefaultStatsNodeInfo;
}());
exports.DefaultStatsNodeInfo = DefaultStatsNodeInfo;
//# sourceMappingURL=DefaultStatsNodeInfo.js.map

/***/ }),

/***/ "../../../core/build/core/src/stats/requests/PlayerManifestRequest.js":
/*!*********************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/stats/requests/PlayerManifestRequest.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.PlayerManifestRequest = void 0;
var PlayerRequest_1 = __webpack_require__(/*! ./PlayerRequest */ "../../../core/build/core/src/stats/requests/PlayerRequest.js");
var logger_hive_1 = __webpack_require__(/*! ../../common/logger.hive */ "../../../core/build/core/src/common/logger.hive.js");
var SessionRegistry_1 = __webpack_require__(/*! ../../common/session/SessionRegistry */ "../../../core/build/core/src/common/session/SessionRegistry.js");
var SessionActivator_1 = __webpack_require__(/*! ../../common/session/SessionActivator */ "../../../core/build/core/src/common/session/SessionActivator.js");
var stats_hive_1 = __webpack_require__(/*! ../../common/techs/statsjs/stats.hive */ "../../../core/build/core/src/common/techs/statsjs/stats.hive.js");
var PlayerManifestRequest = /** @class */ (function (_super) {
    __extends(PlayerManifestRequest, _super);
    function PlayerManifestRequest(xhr, pluginId) {
        var _this = _super.call(this, xhr, null) || this;
        _this.pluginId = pluginId;
        if (!_this.pluginId) {
            _this.pluginId = SessionRegistry_1.SessionRegistry.getInstance().getDefaultPluginId();
        }
        // Override the send() function to activate the session before the player receives the manifest
        var _send = xhr.send;
        xhr.send = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var initialized = SessionActivator_1.SessionActivator.getInstance().activate(_this.pluginId, _this.url, function (session) {
                if (session.tech instanceof stats_hive_1.StatsJS)
                    session.tech.setManifestIntercepted();
            });
            if (!initialized) {
                logger_hive_1.ErrorMonitor.getInstance().logError('Failed to initialize session on player request');
            }
            // Call the original send() implementation
            _send.apply(xhr, args);
        };
        return _this;
    }
    return PlayerManifestRequest;
}(PlayerRequest_1.PlayerRequest));
exports.PlayerManifestRequest = PlayerManifestRequest;
//# sourceMappingURL=PlayerManifestRequest.js.map

/***/ }),

/***/ "../../../core/build/core/src/stats/requests/PlayerRequest.js":
/*!*************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/stats/requests/PlayerRequest.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.PlayerRequest = void 0;
var EntityRequest_1 = __webpack_require__(/*! ../../core/entity/EntityRequest */ "../../../core/build/core/src/core/entity/EntityRequest.js");
var EntityType_1 = __webpack_require__(/*! ../../core/entity/EntityType */ "../../../core/build/core/src/core/entity/EntityType.js");
var VideoEntityCharacteristics_1 = __webpack_require__(/*! ../../core/entity/video/VideoEntityCharacteristics */ "../../../core/build/core/src/core/entity/video/VideoEntityCharacteristics.js");
var Framework_1 = __webpack_require__(/*! ../../core/Framework */ "../../../core/build/core/src/core/Framework.js");
var Utils_1 = __webpack_require__(/*! ../../core/Utils */ "../../../core/build/core/src/core/Utils.js");
var Utils = __webpack_require__(/*! ../../core/Utils */ "../../../core/build/core/src/core/Utils.js");
var PlayerRequest = /** @class */ (function () {
    function PlayerRequest(xhr, provider) {
        var _this = this;
        this.xhr = xhr;
        this.provider = provider;
        this.status = EntityRequest_1.EntityRequestStatus.CREATED;
        // Override the open() function to snatch the request url
        var _open = xhr.open;
        xhr.open = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var method = args[0], url = args[1];
            _this.url = url;
            // Call the original open() implementation
            _open.apply(xhr, args);
        };
        this.registerListeners();
    }
    Object.defineProperty(PlayerRequest.prototype, "startedTime", {
        get: function () {
            return this._startedTime;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(PlayerRequest.prototype, "finishedTime", {
        get: function () {
            return this._finishedTime;
        },
        enumerable: false,
        configurable: true
    });
    PlayerRequest.prototype.loadstart = function (event) {
        this.status = EntityRequest_1.EntityRequestStatus.STARTED;
        this._startedTime = Framework_1.Framework.time();
    };
    PlayerRequest.prototype.onload = function (event) {
        this.status = EntityRequest_1.EntityRequestStatus.SUCCEEDED;
    };
    PlayerRequest.prototype.onerror = function (event) {
        this.status = EntityRequest_1.EntityRequestStatus.FAILED;
    };
    PlayerRequest.prototype.onloadend = function (event) {
        this.removeListeners();
        this.size = event.loaded;
        this._finishedTime = Framework_1.Framework.time();
        this.entityCharacteristics = this.createEntityCharacteristics();
        this.onready && this.onready(this.status, this.url);
    };
    PlayerRequest.prototype.ontimeout = function (event) {
        this.status = EntityRequest_1.EntityRequestStatus.TIMEDOUT;
    };
    PlayerRequest.prototype.createEntityCharacteristics = function () {
        if (!this.provider)
            return null;
        var entityType = this.provider.getEntityType(this.url);
        if (entityType === EntityType_1.EntityType.VIDEO || entityType === EntityType_1.EntityType.AUDIO || entityType === EntityType_1.EntityType.SUBTITLES) {
            var segment = this.provider.getSegmentInfo(this.url);
            return VideoEntityCharacteristics_1.VideoEntityCharacteristics.fromSegment(segment);
        }
        return null;
    };
    PlayerRequest.prototype.registerListeners = function () {
        this.xhr.addEventListener('loadstart', this.loadstart.bind(this));
        this.xhr.addEventListener('load', this.onload.bind(this));
        this.xhr.addEventListener('error', this.onerror.bind(this));
        this.xhr.addEventListener('loadend', this.onloadend.bind(this));
        this.xhr.addEventListener('timeout', this.ontimeout.bind(this));
    };
    PlayerRequest.prototype.removeListeners = function () {
        this.xhr.removeEventListener('loadstart', this.loadstart);
        this.xhr.removeEventListener('load', this.onload);
        this.xhr.removeEventListener('error', this.onerror);
        this.xhr.removeEventListener('loadend', this.onloadend);
        this.xhr.removeEventListener('timeout', this.ontimeout);
    };
    PlayerRequest.prototype.getRequestUrl = function () {
        return this.url;
    };
    PlayerRequest.prototype.getResponseUrl = function () {
        return this.xhr && this.xhr.responseURL || this.url;
    };
    PlayerRequest.prototype.getStatus = function () {
        return this.status;
    };
    PlayerRequest.prototype.getResponseSize = function () {
        return this.size;
    };
    PlayerRequest.prototype.getBandwidth = function () {
        return new Utils_1.Bandwidth(this._finishedTime - this._startedTime, this.size);
    };
    PlayerRequest.prototype.getResponse = function () {
        return this.xhr.response;
    };
    PlayerRequest.prototype.getResponseAsString = function () {
        return this.xhr.responseType === 'arraybuffer' ?
            Utils.arrayBufferToString(this.xhr.response) : this.xhr.response;
    };
    PlayerRequest.prototype.getEntityType = function () {
        return this.entityCharacteristics ? this.entityCharacteristics.getEntityType() : EntityType_1.EntityType.OTHER;
    };
    PlayerRequest.prototype.getEntityCharacteristics = function () {
        return this.entityCharacteristics;
    };
    PlayerRequest.prototype.getXhrStatus = function () {
        return this.xhr.status;
    };
    return PlayerRequest;
}());
exports.PlayerRequest = PlayerRequest;
//# sourceMappingURL=PlayerRequest.js.map

/***/ }),

/***/ "../../../core/build/core/src/webrtc/Bindings.js":
/*!************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/webrtc/Bindings.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.WebRTCBindings = void 0;
var inversify = __webpack_require__(/*! inversify */ "../../../node_modules/inversify/dist/inversify.js");
var Bindings_1 = __webpack_require__(/*! ../core/Bindings */ "../../../core/build/core/src/core/Bindings.js");
var Reporting_1 = __webpack_require__(/*! ../stats/Reporting */ "../../../core/build/core/src/stats/Reporting.js");
var StatsServiceClient_1 = __webpack_require__(/*! ../stats/StatsServiceClient */ "../../../core/build/core/src/stats/StatsServiceClient.js");
var DefaultTicketResolver_1 = __webpack_require__(/*! ../core/ticket/DefaultTicketResolver */ "../../../core/build/core/src/core/ticket/DefaultTicketResolver.js");
var PersistentIdentityProvider_1 = __webpack_require__(/*! ../core/identity/PersistentIdentityProvider */ "../../../core/build/core/src/core/identity/PersistentIdentityProvider.js");
var Stats_1 = __webpack_require__(/*! ../stats/Stats */ "../../../core/build/core/src/stats/Stats.js");
var Track_1 = __webpack_require__(/*! ../stats/Track */ "../../../core/build/core/src/stats/Track.js");
var Peer_1 = __webpack_require__(/*! ./Peer */ "../../../core/build/core/src/webrtc/Peer.js");
var HiveCache_1 = __webpack_require__(/*! ./HiveCache */ "../../../core/build/core/src/webrtc/HiveCache.js");
var ContextManager_1 = __webpack_require__(/*! ./context/ContextManager */ "../../../core/build/core/src/webrtc/context/ContextManager.js");
var LiveCache_1 = __webpack_require__(/*! ./cache/LiveCache */ "../../../core/build/core/src/webrtc/cache/LiveCache.js");
var Cache_1 = __webpack_require__(/*! ./cache/Cache */ "../../../core/build/core/src/webrtc/cache/Cache.js");
var FallbackRequester_1 = __webpack_require__(/*! ./FallbackRequester */ "../../../core/build/core/src/webrtc/FallbackRequester.js");
var TrackerClient_1 = __webpack_require__(/*! ./discovery/tracker/TrackerClient */ "../../../core/build/core/src/webrtc/discovery/tracker/TrackerClient.js");
var ObjectIndex_1 = __webpack_require__(/*! ./ObjectIndex */ "../../../core/build/core/src/webrtc/ObjectIndex.js");
var Membership_1 = __webpack_require__(/*! ./membership/Membership */ "../../../core/build/core/src/webrtc/membership/Membership.js");
var Partnership_1 = __webpack_require__(/*! ./partnership/Partnership */ "../../../core/build/core/src/webrtc/partnership/Partnership.js");
var P2PRequester_1 = __webpack_require__(/*! ./p2ptransfer/P2PRequester */ "../../../core/build/core/src/webrtc/p2ptransfer/P2PRequester.js");
var P2PResponder_1 = __webpack_require__(/*! ./p2ptransfer/P2PResponder */ "../../../core/build/core/src/webrtc/p2ptransfer/P2PResponder.js");
var ScoreUpdaterStreaming_1 = __webpack_require__(/*! ./ScoreUpdaterStreaming */ "../../../core/build/core/src/webrtc/ScoreUpdaterStreaming.js");
var Prefetcher_1 = __webpack_require__(/*! ./prefetch/Prefetcher */ "../../../core/build/core/src/webrtc/prefetch/Prefetcher.js");
var P2PTransport_1 = __webpack_require__(/*! ./transport/P2PTransport */ "../../../core/build/core/src/webrtc/transport/P2PTransport.js");
var HiveNetworkManager_1 = __webpack_require__(/*! ./network/HiveNetworkManager */ "../../../core/build/core/src/webrtc/network/HiveNetworkManager.js");
var ServerManagerScala_1 = __webpack_require__(/*! ./network/ServerManagerScala */ "../../../core/build/core/src/webrtc/network/ServerManagerScala.js");
var RequestTracker_1 = __webpack_require__(/*! ./RequestTracker */ "../../../core/build/core/src/webrtc/RequestTracker.js");
var DefaultPeerNodeInfo_1 = __webpack_require__(/*! ./node-info/DefaultPeerNodeInfo */ "../../../core/build/core/src/webrtc/node-info/DefaultPeerNodeInfo.js");
var PickerExt_1 = __webpack_require__(/*! ./p2ptransfer/picker/PickerExt */ "../../../core/build/core/src/webrtc/p2ptransfer/picker/PickerExt.js");
var PrefetcherManager_1 = __webpack_require__(/*! ./prefetch/PrefetcherManager */ "../../../core/build/core/src/webrtc/prefetch/PrefetcherManager.js");
var TrackerClientManager_1 = __webpack_require__(/*! ./discovery/tracker/TrackerClientManager */ "../../../core/build/core/src/webrtc/discovery/tracker/TrackerClientManager.js");
var ChunkHandler_1 = __webpack_require__(/*! ./cache/ChunkHandler */ "../../../core/build/core/src/webrtc/cache/ChunkHandler.js");
var NodeConnectivityInfo_1 = __webpack_require__(/*! ../core/connectivity/NodeConnectivityInfo */ "../../../core/build/core/src/core/connectivity/NodeConnectivityInfo.js");
var IpSpoofing_1 = __webpack_require__(/*! ./partnership/IpSpoofing */ "../../../core/build/core/src/webrtc/partnership/IpSpoofing.js");
var ScorePartnerSelection_1 = __webpack_require__(/*! ./partnership/policies/ScorePartnerSelection */ "../../../core/build/core/src/webrtc/partnership/policies/ScorePartnerSelection.js");
var PrefetcherPartnerSelection_1 = __webpack_require__(/*! ./partnership/policies/PrefetcherPartnerSelection */ "../../../core/build/core/src/webrtc/partnership/policies/PrefetcherPartnerSelection.js");
var build_defaults_1 = __webpack_require__(/*! ../common/build.defaults */ "../../../core/build/core/src/common/build.defaults.js");
var SnapshotAccountingManager_1 = __webpack_require__(/*! ./SnapshotAccountingManager */ "../../../core/build/core/src/webrtc/SnapshotAccountingManager.js");
var LocalityPartnerSelection_1 = __webpack_require__(/*! ./partnership/policies/LocalityPartnerSelection */ "../../../core/build/core/src/webrtc/partnership/policies/LocalityPartnerSelection.js");
var NetworkRangeLocalityScore_1 = __webpack_require__(/*! ./partnership/locality/NetworkRangeLocalityScore */ "../../../core/build/core/src/webrtc/partnership/locality/NetworkRangeLocalityScore.js");
var LocalityServiceClient_1 = __webpack_require__(/*! ./locality/LocalityServiceClient */ "../../../core/build/core/src/webrtc/locality/LocalityServiceClient.js");
var StatsJSConnectivityProvider_1 = __webpack_require__(/*! ../stats/StatsJSConnectivityProvider */ "../../../core/build/core/src/stats/StatsJSConnectivityProvider.js");
var DefaultQualityLevelTracker_1 = __webpack_require__(/*! ../core/quality-level/DefaultQualityLevelTracker */ "../../../core/build/core/src/core/quality-level/DefaultQualityLevelTracker.js");
var DefaultQualityLevelMetricsProvider_1 = __webpack_require__(/*! ../core/metrics/DefaultQualityLevelMetricsProvider */ "../../../core/build/core/src/core/metrics/DefaultQualityLevelMetricsProvider.js");
var DefaultStatsNodeInfo_1 = __webpack_require__(/*! ../stats/node-info/DefaultStatsNodeInfo */ "../../../core/build/core/src/stats/node-info/DefaultStatsNodeInfo.js");
var DefaultFragmentMetadataMetricsProvider_1 = __webpack_require__(/*! ../core/metrics/DefaultFragmentMetadataMetricsProvider */ "../../../core/build/core/src/core/metrics/DefaultFragmentMetadataMetricsProvider.js");
var DefaultStreamInfoMetricsProvider_1 = __webpack_require__(/*! ../core/metrics/DefaultStreamInfoMetricsProvider */ "../../../core/build/core/src/core/metrics/DefaultStreamInfoMetricsProvider.js");
var DefaultRemoteConfigManager_1 = __webpack_require__(/*! ./remote-config/DefaultRemoteConfigManager */ "../../../core/build/core/src/webrtc/remote-config/DefaultRemoteConfigManager.js");
var DefaultConfigStore_1 = __webpack_require__(/*! ./config-store/DefaultConfigStore */ "../../../core/build/core/src/webrtc/config-store/DefaultConfigStore.js");
var DefaultBoosterClient_1 = __webpack_require__(/*! ../webrtc/booster/DefaultBoosterClient */ "../../../core/build/core/src/webrtc/booster/DefaultBoosterClient.js");
var Logger_1 = __webpack_require__(/*! ../core/Logger */ "../../../core/build/core/src/core/Logger.js");
var ExternalCandidates_1 = __webpack_require__(/*! ../stats/ExternalCandidates */ "../../../core/build/core/src/stats/ExternalCandidates.js");
var TICKETLESS_PLUGIN = build_defaults_1.BuildParameters.TICKETLESS_PLUGIN;
/**
* assign the bindings for Hive browser distribution to a context.
* If initialized on the constructor with isUpgradeFromStats = true it means that
* the context was already initialized by Stats.js bindings, therefore we only need
* to add the missing ones to upgrade
*/
var WebRTCBindings = /** @class */ (function () {
    /**
     * create bindings for HiveJs
     * @param isUpgradeFromStats true if the context was already initialized with Stats.js bindings
     */
    function WebRTCBindings(isUpgradeFromStats) {
        this.isUpgradeFromStats = false;
        if (isUpgradeFromStats)
            this.isUpgradeFromStats = isUpgradeFromStats;
    }
    WebRTCBindings.prototype.apply = function (kernel) {
        // check if we need to SKIP the Bindings already set up by Stats pack
        if (!this.isUpgradeFromStats) {
            // Bindings for ticket resolution
            kernel.bind(new inversify.TypeBinding(Bindings_1.Definitions.REPORTING, Reporting_1.Reporting, inversify.TypeBindingScopeEnum.Singleton));
            kernel.bind(new inversify.TypeBinding(Bindings_1.Definitions.SERVICES_CLIENT, StatsServiceClient_1.StatsServiceClient, inversify.TypeBindingScopeEnum.Singleton));
            kernel.bind(new inversify.TypeBinding(Bindings_1.Definitions.TICKET_RESOLVER, DefaultTicketResolver_1.DefaultTicketResolver, inversify.TypeBindingScopeEnum.Singleton));
            kernel.bind(new inversify.TypeBinding(Bindings_1.Definitions.IDENTITY_PROVIDER, PersistentIdentityProvider_1.PersistentReportingIdentityProvider, inversify.TypeBindingScopeEnum.Singleton));
            kernel.bind(new inversify.TypeBinding(Bindings_1.Definitions.LOGGER, Logger_1.Logger, inversify.TypeBindingScopeEnum.Singleton));
            kernel.bind(new inversify.TypeBinding(Bindings_1.Definitions.CONFIG_STORE, DefaultConfigStore_1.DefaultConfigStore, inversify.TypeBindingScopeEnum.Singleton));
            kernel.bind(new inversify.TypeBinding(Bindings_1.Definitions.PEER_NODE_INFO, DefaultPeerNodeInfo_1.DefaultPeerNodeInfo, inversify.TypeBindingScopeEnum.Transient));
            // Bindings for Stats Metrics and Track Snapshots
            kernel.bind(new inversify.TypeBinding(Bindings_1.Definitions.STATS_CLIENT, Stats_1.Client, inversify.TypeBindingScopeEnum.Transient));
            kernel.bind(new inversify.TypeBinding(Bindings_1.Definitions.TRACK_MANAGER, Track_1.Manager, inversify.TypeBindingScopeEnum.Transient));
            kernel.bind(new inversify.TypeBinding(Bindings_1.Definitions.TRACK_CLIENT, Track_1.Client, inversify.TypeBindingScopeEnum.Transient));
            kernel.bind(new inversify.TypeBinding(Bindings_1.Definitions.QUALITY_LEVEL_TRACKER, DefaultQualityLevelTracker_1.DefaultQualityLevelTracker, inversify.TypeBindingScopeEnum.Transient));
            kernel.bind(new inversify.TypeBinding(Bindings_1.Definitions.QUALITY_LEVEL_METRICS_PROVIDER, DefaultQualityLevelMetricsProvider_1.DefaultQualityLevelMetricsProvider, inversify.TypeBindingScopeEnum.Transient));
            kernel.bind(new inversify.TypeBinding(Bindings_1.Definitions.STATS_NODE_INFO, DefaultStatsNodeInfo_1.DefaultStatsNodeInfo, inversify.TypeBindingScopeEnum.Transient));
            kernel.bind(new inversify.TypeBinding(Bindings_1.Definitions.STREAM_INFO_METRICS_PROVIDER, DefaultStreamInfoMetricsProvider_1.DefaultStreamInfoMetricsProvider, inversify.TypeBindingScopeEnum.Transient));
            kernel.bind(new inversify.TypeBinding(Bindings_1.Definitions.FRAGMENT_METADATA_METRICS_PROVIDER, DefaultFragmentMetadataMetricsProvider_1.DefaultFragmentMetadataMetricsProvider, inversify.TypeBindingScopeEnum.Transient));
            kernel.bind(new inversify.TypeBinding(Bindings_1.Definitions.CONNECTIVITY_INFO_PROVIDER, StatsJSConnectivityProvider_1.StatsJSConnectivityProvider, inversify.TypeBindingScopeEnum.Singleton));
            kernel.bind(new inversify.TypeBinding(Bindings_1.Definitions.EXTERNAL_CANDIDATES, ExternalCandidates_1.ExternalCandidates, inversify.TypeBindingScopeEnum.Singleton));
            kernel.bind(new inversify.TypeBinding(Bindings_1.Definitions.REMOTE_CONFIG_MANAGER, DefaultRemoteConfigManager_1.DefaultRemoteConfigManager, inversify.TypeBindingScopeEnum.Singleton));
            kernel.bind(new inversify.TypeBinding(Bindings_1.Definitions.BOOSTER_CLIENT, DefaultBoosterClient_1.DefaultBoosterClient, inversify.TypeBindingScopeEnum.Singleton));
        }
        kernel.bind(new inversify.TypeBinding(Bindings_1.Definitions.LOCALITY_CLIENT, LocalityServiceClient_1.LocalityServiceClient, inversify.TypeBindingScopeEnum.Transient));
        kernel.bind(new inversify.TypeBinding(Bindings_1.Definitions.SNAP_STATS_MANAGER, SnapshotAccountingManager_1.SnapshotAccountingManager, inversify.TypeBindingScopeEnum.Transient));
        kernel.bind(new inversify.TypeBinding(Bindings_1.Definitions.PEER_CONNECTIVITY_INFO, NodeConnectivityInfo_1.NodeConnectivityInfo, inversify.TypeBindingScopeEnum.Singleton));
        // Bindings for Peer Distributed cache
        kernel.bind(new inversify.TypeBinding(Bindings_1.Definitions.PEER, Peer_1.Peer, inversify.TypeBindingScopeEnum.Singleton));
        kernel.bind(new inversify.TypeBinding(Bindings_1.Definitions.DCACHE, HiveCache_1.HiveCache, inversify.TypeBindingScopeEnum.Transient));
        kernel.bind(new inversify.TypeBinding(Bindings_1.Definitions.CONTEXT_RESOLVER, ContextManager_1.VideoContextManager, inversify.TypeBindingScopeEnum.Transient));
        kernel.bind(new inversify.TypeBinding(Bindings_1.Definitions.CACHE, Cache_1.Cache, inversify.TypeBindingScopeEnum.Transient));
        kernel.bind(new inversify.TypeBinding(Bindings_1.Definitions.LIVE_CACHE, LiveCache_1.LiveCache, inversify.TypeBindingScopeEnum.Transient));
        // Bindings for Fallback Requests
        kernel.bind(new inversify.TypeBinding(Bindings_1.Definitions.FALLBACK_REQUESTER, FallbackRequester_1.FallbackRequester, inversify.TypeBindingScopeEnum.Transient));
        if (typeof HiveOriginalXMLHttpRequest !== 'undefined')
            kernel.bind(new inversify.TypeBinding(Bindings_1.Definitions.HTTP_REQUEST, HiveOriginalXMLHttpRequest));
        else
            kernel.bind(new inversify.TypeBinding(Bindings_1.Definitions.HTTP_REQUEST, XMLHttpRequest));
        // Bindings for Tracker
        kernel.bind(new inversify.TypeBinding(Bindings_1.Definitions.TRACKER_MANAGER, TrackerClientManager_1.TrackerClientManager, inversify.TypeBindingScopeEnum.Singleton));
        kernel.bind(new inversify.TypeBinding(Bindings_1.Definitions.TRACKER_CLIENT, TrackerClient_1.TrackerClient, inversify.TypeBindingScopeEnum.Transient));
        // Bindings for P2P components
        kernel.bind(new inversify.TypeBinding(Bindings_1.Definitions.RTC_MANAGER, HiveNetworkManager_1.HiveNetworkManager, inversify.TypeBindingScopeEnum.Singleton));
        kernel.bind(new inversify.TypeBinding(Bindings_1.Definitions.SERVER_MANAGER, ServerManagerScala_1.ServerManagerScala, inversify.TypeBindingScopeEnum.Singleton));
        kernel.bind(new inversify.TypeBinding(Bindings_1.Definitions.CENTRAL_FRAGMENT, ChunkHandler_1.ChunkHandler, inversify.TypeBindingScopeEnum.Transient));
        kernel.bind(new inversify.TypeBinding(Bindings_1.Definitions.OBJECT_INDEX, ObjectIndex_1.ObjectIndex, inversify.TypeBindingScopeEnum.Transient));
        kernel.bind(new inversify.TypeBinding(Bindings_1.Definitions.MEMBERSHIP, Membership_1.Membership, inversify.TypeBindingScopeEnum.Transient));
        kernel.bind(new inversify.TypeBinding(Bindings_1.Definitions.PARTNERSHIP, Partnership_1.Partnership, inversify.TypeBindingScopeEnum.Transient));
        kernel.bind(new inversify.TypeBinding(Bindings_1.Definitions.IN_PARTNERSHIP, LocalityPartnerSelection_1.LocalityInPartnerSelection, inversify.TypeBindingScopeEnum.Transient));
        kernel.bind(new inversify.TypeBinding(Bindings_1.Definitions.OUT_PARTNERSHIP, ScorePartnerSelection_1.ScoreOutPartnerSelection, inversify.TypeBindingScopeEnum.Transient));
        kernel.bind(new inversify.TypeBinding(Bindings_1.Definitions.IN_PREFETCHER_PARTNERSHIP, PrefetcherPartnerSelection_1.DeltaPartnerSelection, inversify.TypeBindingScopeEnum.Transient));
        kernel.bind(new inversify.TypeBinding(Bindings_1.Definitions.OUT_PREFETCHER_PARTNERSHIP, PrefetcherPartnerSelection_1.ThroughputPartnerSelection, inversify.TypeBindingScopeEnum.Transient));
        kernel.bind(new inversify.TypeBinding(Bindings_1.Definitions.IP_SPOOFING, IpSpoofing_1.IpSpoofing, inversify.TypeBindingScopeEnum.Transient));
        kernel.bind(new inversify.TypeBinding(Bindings_1.Definitions.P2P_REQUESTER, P2PRequester_1.P2PRequester, inversify.TypeBindingScopeEnum.Transient));
        kernel.bind(new inversify.TypeBinding(Bindings_1.Definitions.RESPONDER, P2PResponder_1.P2PResponder, inversify.TypeBindingScopeEnum.Transient));
        kernel.bind(new inversify.TypeBinding(Bindings_1.Definitions.SCORE_UPDATER, ScoreUpdaterStreaming_1.ScoreUpdaterStreaming, inversify.TypeBindingScopeEnum.Transient));
        // kernel.bind(new inversify.TypeBinding<Picker>(Definitions.PICKER, PickerTRSingle, inversify.TypeBindingScopeEnum.Transient))
        kernel.bind(new inversify.TypeBinding(Bindings_1.Definitions.PICKER, PickerExt_1.PickerExt, inversify.TypeBindingScopeEnum.Transient));
        kernel.bind(new inversify.TypeBinding(Bindings_1.Definitions.P2P_VIDEO_PREFETCHER, Prefetcher_1.VideoPrefetcher, inversify.TypeBindingScopeEnum.Transient));
        kernel.bind(new inversify.TypeBinding(Bindings_1.Definitions.PREFETCH_MANAGER, PrefetcherManager_1.PrefetcherManager, inversify.TypeBindingScopeEnum.Transient));
        kernel.bind(new inversify.TypeBinding(Bindings_1.Definitions.TRANSPORT, P2PTransport_1.P2PTransport, inversify.TypeBindingScopeEnum.Transient));
        kernel.bind(new inversify.TypeBinding(Bindings_1.Definitions.REQUEST_TRACKER, RequestTracker_1.RequestTracker, inversify.TypeBindingScopeEnum.Transient));
        kernel.bind(new inversify.TypeBinding(Bindings_1.Definitions.LOCALITY_SCORE, NetworkRangeLocalityScore_1.NetworkRangeLocalityScore, inversify.TypeBindingScopeEnum.Transient));
    };
    return WebRTCBindings;
}());
exports.WebRTCBindings = WebRTCBindings;
//# sourceMappingURL=Bindings.js.map

/***/ }),

/***/ "../../../core/build/core/src/webrtc/ClientConfigs.js":
/*!*****************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/webrtc/ClientConfigs.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.HiveConfig = void 0;
var HiveConfig_1 = __webpack_require__(/*! ../core/HiveConfig */ "../../../core/build/core/src/core/HiveConfig.js");
var build_defaults_1 = __webpack_require__(/*! ../common/build.defaults */ "../../../core/build/core/src/common/build.defaults.js");
/**
 * Dash related configurable fields
 */
var Dash = /** @class */ (function () {
    function Dash() {
    }
    /**
     * Index of the bitrates to keep in the video manifest. It can either be represented as a comma separated value string,
     * or directly as an array of numbers. For example both "0,1,2" or [0, 1, 2] means that the client will
     * keep in the manifest returned to the player the 3 lowest bitrates, excluding all the remaining.
     * @type string | Array<number>
     */
    Dash.DashFilterBitrates = null;
    /**
     * remove the width and height minimum player size for every bitrate from the manifest
     * for allowing silent test to go to the highest bitrate even with small rendering window
     * @type {boolean}
     */
    Dash.DashRemoveBitrateSize = false;
    return Dash;
}());
/**
 * Stats related configurable fields
 */
var Stats = /** @class */ (function () {
    function Stats() {
    }
    /**
     * We always account the audio fragments that are downloaded either by the fallback or the p2p.
     * When we set this value to false we stop accounting the audio fragments and we have a much clearer
     * radial graph.
     * @type {boolean}
     */
    Stats.AudioAccounting = true;
    return Stats;
}());
/**
 * Debugging logs of big thrift objects.
 * By default these logs should be false in order not to create huge logs
 * on the client
 */
var DebugLogs = /** @class */ (function (_super) {
    __extends(DebugLogs, _super);
    function DebugLogs() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Tracker request/response
     * 0 => off
     * 1 => json
     * 2 => object
     * 3 => json + object
     * @type {number}
     */
    DebugLogs.TrackerLogs = 0;
    return DebugLogs;
}(HiveConfig_1.HiveConfig.DebugLogs));
var CustomSnapshotProperties = /** @class */ (function () {
    function CustomSnapshotProperties() {
    }
    /**
     * Custom snapshot permission
     */
    CustomSnapshotProperties.enabled = false;
    return CustomSnapshotProperties;
}());
var SensitiveInfo = /** @class */ (function () {
    function SensitiveInfo() {
    }
    /**
     * if true this option will not send hostname info and will omit the last octet of the private IP address
     * @type {boolean}
     * @default false
     */
    SensitiveInfo.restrictedConnectivityInfo = build_defaults_1.BuildParameters.RESTRICTED_CONN_INFO;
    /**
     * This is the default string used as hostname if the {@link restrictedConnectivityInfo} is true
     * @type {string}
     * @default '[Hidden]'
     */
    SensitiveInfo.hiddenHostnameValue = '[Hidden]';
    return SensitiveInfo;
}());
var ClientInfo = /** @class */ (function () {
    function ClientInfo() {
    }
    ClientInfo.PartnerId = null;
    ClientInfo.CustomerId = null;
    return ClientInfo;
}());
var ConnInfo = /** @class */ (function () {
    function ConnInfo() {
    }
    /**
     * This propery bypasses the usage of webRTC for gathering the connectivity info, since was causing a crash of the test tab
     * @type {boolean}
     * @default DETECT_PRIVATEIP
     */
    ConnInfo.detectPrivateIP = build_defaults_1.BuildParameters.DETECT_PRIVATEIP;
    return ConnInfo;
}());
var HiveConfig = /** @class */ (function () {
    function HiveConfig() {
    }
    HiveConfig.Dash = Dash;
    HiveConfig.Stats = Stats;
    HiveConfig.DebugLogs = DebugLogs;
    HiveConfig.SensitiveInfo = SensitiveInfo;
    HiveConfig.ClientInfo = ClientInfo;
    HiveConfig.ConnInfo = ConnInfo;
    HiveConfig.CustomSnapshotProperties = CustomSnapshotProperties;
    return HiveConfig;
}());
exports.HiveConfig = HiveConfig;
if (typeof window != 'undefined') {
    if (typeof window['HiveConfig'] == 'undefined') {
        window['HiveConfig'] = {};
    }
    window['HiveConfig']['Dash'] = HiveConfig.Dash;
    window['HiveConfig']['Stats'] = HiveConfig.Stats;
    window['HiveConfig']['DebugLogs'] = HiveConfig.DebugLogs;
    window['HiveConfig']['SensitiveInfo'] = HiveConfig.SensitiveInfo;
    window['HiveConfig']['ClientInfo'] = HiveConfig.ClientInfo;
    window['HiveConfig']['ConnInfo'] = HiveConfig.ConnInfo;
    window['HiveConfig']['CustomSnapshotProperties'] = HiveConfig.CustomSnapshotProperties;
}
//# sourceMappingURL=ClientConfigs.js.map

/***/ }),

/***/ "../../../core/build/core/src/webrtc/FallbackRequester.js":
/*!*********************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/webrtc/FallbackRequester.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.FallbackRequester = void 0;
var HashMap = __webpack_require__(/*! @hivestreaming/collections/map */ "../../../node_modules/@hivestreaming/collections/map.js");
var HiveInternalRequest_1 = __webpack_require__(/*! ./HiveInternalRequest */ "../../../core/build/core/src/webrtc/HiveInternalRequest.js");
var Utils_1 = __webpack_require__(/*! ../core/Utils */ "../../../core/build/core/src/core/Utils.js");
var Utils = __webpack_require__(/*! ../core/Utils */ "../../../core/build/core/src/core/Utils.js");
var PeerConstants_1 = __webpack_require__(/*! ./PeerConstants */ "../../../core/build/core/src/webrtc/PeerConstants.js");
var Framework_1 = __webpack_require__(/*! ../core/Framework */ "../../../core/build/core/src/core/Framework.js");
var EntityType_1 = __webpack_require__(/*! ../core/entity/EntityType */ "../../../core/build/core/src/core/entity/EntityType.js");
var logger_hive_1 = __webpack_require__(/*! ../common/logger.hive */ "../../../core/build/core/src/common/logger.hive.js");
var ErrorCodes = __webpack_require__(/*! ../common/error.hive */ "../../../core/build/core/src/common/error.hive.js");
var Utils_2 = __webpack_require__(/*! ../core/Utils */ "../../../core/build/core/src/core/Utils.js");
var FallbackRequester = /** @class */ (function () {
    function FallbackRequester() {
        this.loggerId = '[FallbackRequester] ';
        this.pendingRequests = new HashMap();
        this.bandwidth = new Utils_1.Bandwidth();
        this.accumulator = new Utils_2.StatsAccumulator();
    }
    FallbackRequester.prototype.init = function (swarm) {
        this.logger = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.LOGGER).log(swarm.sessionId);
        this.cache = swarm.hiveCache;
        this.nodeInfo = swarm.nodeInfo;
        if (this.nodeInfo)
            this.bandwidth = this.nodeInfo.getSourceThroughput();
        this.statsStore = swarm.reportingInstance.statsStore;
        this.statsStore.updateFallbackAccumulator(this.accumulator);
    };
    FallbackRequester.prototype.request = function (internalRequest) {
        var _this = this;
        var req = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.HTTP_REQUEST);
        var loaded = false;
        var requestId = internalRequest.getRequestId();
        var originalRequest = internalRequest.originalRequest;
        var requestUrl = internalRequest.originalRequest.url;
        internalRequest.xhr = req;
        internalRequest.requestStats.fallbackRequestStarted = Framework_1.Framework.time();
        this.logger.debug('REQ FOR FRAGMENT ' + internalRequest.entityCharacteristics.toString() + '-' +
            internalRequest.requestStats.totalFromP2P + ' [' + EntityType_1.EntityType[internalRequest.getEntityType()] + '] TO CDN ');
        // Map properties from HiveRequest -> XHR
        if (internalRequest.entityCharacteristics.isBinary())
            req.responseType = 'arraybuffer';
        if (this.isNormalRequest(internalRequest.type) && originalRequest.range && internalRequest.getEntityType() != EntityType_1.EntityType.METADATA) {
            req.setRequestHeader('Range', 'bytes=' + originalRequest.range);
        }
        if (PeerConstants_1.PeerConstants.HTTP.UseRangeRequest && this.isCompensation(internalRequest.type) && internalRequest.requestStats.totalFromP2P != 0) {
            this.logger.info('SET RANGE ' + ('bytes=' + internalRequest.requestStats.totalFromP2P + '-'));
            req.setRequestHeader('Range', 'bytes=' + internalRequest.requestStats.totalFromP2P + '-');
        }
        // Copy headers and attributes from original request to new XHR
        originalRequest.copyTo(req);
        req.onloadstart = function (event) {
            var loadStartEvent = Utils.createEvent(Event, 'loadstart', event, originalRequest);
            originalRequest.dispatchEvent(loadStartEvent);
        };
        req.onabort = function (event) {
            if (loaded)
                return;
            var abortEvent = Utils.createEvent(Event, 'abort', event, originalRequest);
            originalRequest.dispatchEvent(abortEvent);
        };
        req.ontimeout = function (event) {
            if (loaded)
                return;
            originalRequest.status = req.status;
            // In case the request has timedout and we have a status 0, we force the error to
            // use the error code 10. Error Code 10 is defined in the metrics.thrift object
            // for CDN timeouts https://github.com/hivestreaming/hive-services-protocol/blob/master/src/main/thrift/snapshots/metrics.thrift#L291
            _this.error(internalRequest, requestId, 10);
            var timeoutEvent = Utils.createEvent(ProgressEvent, 'timeout', event, originalRequest);
            originalRequest.dispatchEvent(timeoutEvent);
            logger_hive_1.ErrorMonitor.getInstance().logError('Error on fallback request because of timeout', _this.loggerId, ErrorCodes.FALLBACK_REQUESTER_CODES.REQUEST_TIMEOUT);
        };
        // Add handlers to map properties from XHR -> HiveRequest
        req.onreadystatechange = function (event) {
            if (originalRequest) {
                if (req.readyState === XMLHttpRequest.HEADERS_RECEIVED) {
                    originalRequest.respHeaders = req.getAllResponseHeaders();
                    originalRequest.status = req.status;
                    originalRequest.statusText = req.statusText;
                }
                // The handling of readystatechange -> DONE is handled by onload/HiveCache.respondToRequest
                // But, if the xhr has been aborted, that onload is not called and we want to trigger the
                // readystatechange anyway
                if (req.readyState < XMLHttpRequest.DONE || (req.readyState === XMLHttpRequest.DONE && req.status === 0)) {
                    /*
                     * On abort, the status can change from 200 (set during
                     * HEADERS_RECEIVED) to 0 (after abort), so we need to
                     * re-set it.
                     */
                    if (req.status === 0) {
                        originalRequest.status = req.status;
                        originalRequest.statusText = req.statusText;
                    }
                    originalRequest.readyState = req.readyState;
                    var readyStateChangeEvent = Utils.createEvent(Event, 'readystatechange', event, originalRequest);
                    originalRequest.dispatchEvent(readyStateChangeEvent);
                }
            }
        };
        req.onprogress = function (event) {
            if (!_this.isCompensation(internalRequest.type)) {
                var progressEvent = Utils.createEvent(ProgressEvent, 'progress', event, originalRequest);
                originalRequest.dispatchEvent(progressEvent);
                req.total = event.total;
            }
            internalRequest.requestStats.totalFromFallback = event.total;
            internalRequest.size = event.total;
        };
        req.onload = function (event) {
            loaded = true;
            originalRequest.status = req.status;
            originalRequest.responseURL = req.responseURL;
            if (event && event.total != 0) {
                internalRequest.requestStats.totalFromFallback = event.total;
            }
            internalRequest.respHeaders = req.getAllResponseHeaders();
            if (req.status < 200 || req.status > 299) {
                _this.logger.debug('SERVER RETURNED ERROR CODE ' + req.status);
                _this.error(internalRequest, requestId);
                var eventInit = {
                    bubbles: false,
                    cancelable: false,
                    lengthComputable: false,
                    loaded: req.loaded,
                    total: req.total,
                    currentTarget: originalRequest
                };
                originalRequest.readyState = XMLHttpRequest.DONE;
                originalRequest.dispatchEvent(Utils.createEvent(Event, 'readystatechange', eventInit));
                originalRequest.dispatchEvent(Utils.createEvent(ProgressEvent, 'load', eventInit));
                originalRequest.dispatchEvent(Utils.createEvent(ProgressEvent, 'loadend', eventInit));
                return;
            }
            if (internalRequest.entityCharacteristics.isBinary()) {
                if (_this.isNormalRequest(internalRequest.type)) {
                    internalRequest.binaryData = req.response;
                }
                else if (_this.isCompensation(internalRequest.type)) {
                    if (!PeerConstants_1.PeerConstants.HTTP.UseRangeRequest)
                        internalRequest.binaryData = req.response;
                    else
                        internalRequest.binaryData = Framework_1.Framework.isSimulated() ? null : Utils.appendBuffer(internalRequest.binaryData, req.response);
                }
            }
            else {
                internalRequest.responseText = req.responseText;
            }
            _this.pendingRequests.delete(requestId);
            internalRequest.requestStats.fragmentDownloadedTs = Framework_1.Framework.time();
            _this.updateBandwidthMeasurement(internalRequest);
            _this.accountSuccess(internalRequest);
            _this.cache.fallbackRequestSuccessful(internalRequest);
            req = null;
        };
        req.onerror = function (event) {
            if (loaded)
                return;
            originalRequest.status = req.status;
            _this.error(internalRequest, requestId);
            var errorEvent = Utils.createEvent(ProgressEvent, 'error', event, originalRequest);
            originalRequest.dispatchEvent(errorEvent);
        };
        this.pendingRequests.set(requestId, internalRequest);
        req.open('GET', requestUrl, originalRequest.async, originalRequest.username, originalRequest.password);
        req.send();
    };
    /**
     * called both in case of network error, or http error code
     * updates the metrics ("Detailed source errors" on Insights),
     * clears the pending requests and notifies the cache.
     *
     * Detailed source errors are only tracked for non-Prefetch requests.
     */
    FallbackRequester.prototype.error = function (internalRequest, requestId, forceStatus) {
        if (this.statsStore && !this.isPrefetchRequest(internalRequest.type)) {
            if (forceStatus && forceStatus > 0) {
                this.statsStore.addNewResponseInfo(forceStatus);
            }
            else {
                if (internalRequest.xhr.status && internalRequest.xhr.status > 0) {
                    this.statsStore.addNewResponseInfo(internalRequest.xhr.status);
                }
                else {
                    this.statsStore.addNewResponseInfo(404);
                }
            }
        }
        var loggingError = 'COULD NOT DOWNLOAD ' + internalRequest.getRequestUrl() + ' status: ' + internalRequest.xhr.status;
        if (internalRequest.type == HiveInternalRequest_1.RequestType.CDN_PREFETCH)
            this.logger.debug(loggingError);
        else
            this.logger.warn(loggingError);
        this.accountFailure(internalRequest);
        this.pendingRequests.delete(requestId);
        this.cache.fallbackRequestFailed(internalRequest);
    };
    FallbackRequester.prototype.isPending = function (requestId) {
        return this.pendingRequests.has(requestId);
    };
    FallbackRequester.prototype.isPrefetchRequest = function (type) {
        return (type == HiveInternalRequest_1.RequestType.CDN_PREFETCH || type == HiveInternalRequest_1.RequestType.P2P_PREFETCH);
    };
    FallbackRequester.prototype.isNormalRequest = function (type) {
        return (type == HiveInternalRequest_1.RequestType.CDN_PREFETCH || type == HiveInternalRequest_1.RequestType.CDN || type == HiveInternalRequest_1.RequestType.UPPER_LAYER);
    };
    FallbackRequester.prototype.isCompensation = function (type) {
        return type == HiveInternalRequest_1.RequestType.CDN_COMPENSATION;
    };
    FallbackRequester.prototype.cancelRequest = function (requestId) {
        var req = this.pendingRequests.get(requestId);
        this.pendingRequests.delete(requestId);
        if (req) {
            if (req.xhr)
                req.xhr.abort();
        }
    };
    FallbackRequester.prototype.accountSuccess = function (request) {
        if (request.entityCharacteristics.getEntityType() == EntityType_1.EntityType.VIDEO) {
            this.accumulator.add(request.getFallbackElapsed());
        }
        this.logger.info('SUCCESS FROM CDN REQUEST FOR ' + request.getRequestUrl() + ' [' + HiveInternalRequest_1.RequestType[request.type] + '][' + request.requestStats.totalFromFallback + '] AFTER ' +
            request.getFallbackElapsed() + ' [curr:' + request.getBandwidth().toHumanReadable() + ' avg:' + this.bandwidth.toHumanReadable() + ']');
    };
    FallbackRequester.prototype.accountFailure = function (request) {
    };
    FallbackRequester.prototype.getMeasuredBandwidth = function () {
        return this.bandwidth;
    };
    /**
     * updated the general Fallback Requester average bandwidth
     * currently we use only video fragments to update it since
     * metadata and audio are way too small to get an accurate bandwidth estimation
     */
    FallbackRequester.prototype.updateBandwidthMeasurement = function (request) {
        if (request.getEntityType() === EntityType_1.EntityType.VIDEO)
            this.bandwidth.smooth(request.getBandwidth());
    };
    return FallbackRequester;
}());
exports.FallbackRequester = FallbackRequester;
//# sourceMappingURL=FallbackRequester.js.map

/***/ }),

/***/ "../../../core/build/core/src/webrtc/HiveCache.js":
/*!*************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/webrtc/HiveCache.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.HiveCache = void 0;
var HashMap = __webpack_require__(/*! @hivestreaming/collections/map */ "../../../node_modules/@hivestreaming/collections/map.js");
var Q = __webpack_require__(/*! @hivestreaming/q */ "../../../node_modules/@hivestreaming/q/q.js");
var HiveInternalRequest_1 = __webpack_require__(/*! ./HiveInternalRequest */ "../../../core/build/core/src/webrtc/HiveInternalRequest.js");
var Utils = __webpack_require__(/*! ../core/Utils */ "../../../core/build/core/src/core/Utils.js");
var PeerConstants_1 = __webpack_require__(/*! ./PeerConstants */ "../../../core/build/core/src/webrtc/PeerConstants.js");
var Framework_1 = __webpack_require__(/*! ../core/Framework */ "../../../core/build/core/src/core/Framework.js");
var EntityType_1 = __webpack_require__(/*! ../core/entity/EntityType */ "../../../core/build/core/src/core/entity/EntityType.js");
var RenderStats_1 = __webpack_require__(/*! ./RenderStats */ "../../../core/build/core/src/webrtc/RenderStats.js");
var Utils_1 = __webpack_require__(/*! ../core/Utils */ "../../../core/build/core/src/core/Utils.js");
var logger_hive_1 = __webpack_require__(/*! ../common/logger.hive */ "../../../core/build/core/src/common/logger.hive.js");
var ErrorCodes = __webpack_require__(/*! ../common/error.hive */ "../../../core/build/core/src/common/error.hive.js");
var OriginType = hive.snapshots.OriginType;
var SnapshotRequestType = hive.snapshots.RequestType;
var HiveCache = /** @class */ (function () {
    function HiveCache() {
        this.hiveCacheRequests = new HashMap();
        this.changedQualityLevel = false;
        this.newQualityLevelCount = 0;
        this.loggerId = '[HiveCache] ';
        this.NUMBER_OF_FRAGMENTS_QUALITY_LEVEL_ANNOUNCE = 5;
        this.clientBufferAccumulator = new Utils_1.StatsAccumulator();
    }
    HiveCache.prototype.init = function (swarm) {
        this.logger = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.LOGGER).log(swarm.sessionId);
        this.objectIndex = swarm.objectIndex;
        this.cache = swarm.cache;
        this.membership = swarm.membership;
        this.partnership = swarm.partnership;
        this.statsStore = swarm.reportingInstance.statsStore;
        this.sessionId = swarm.reportingInstance.ticket.sessionId;
        this.fallbackRequester = swarm.fallbackRequester;
        this.p2pRequester = swarm.p2pRequester;
        this.contextResolver = swarm.contextManager;
        this.nodeInfo = swarm.nodeInfo;
        this.chunkHandler = swarm.chunkHandler;
        this.snapAccountingManager = swarm.snapAccountingManager;
        this.prefetcherManager = swarm.prefetchManager;
        this.renderStats = new RenderStats_1.RenderStats(swarm.reportingInstance);
        this.statsStore.updateStatsAccumulator(this.clientBufferAccumulator);
    };
    /**
     * This function initiates a HIVE REQUEST called immediately from the player
     * @param request
     */
    HiveCache.prototype.request = function (request) {
        try {
            var url = request.url;
            this.logger.info('HIVE REQ ' + url);
            request.playerRequestTs = Framework_1.Framework.time();
            var context_1 = this.contextResolver.resolveContext(request);
            var entityCharacteristics = context_1.getEntityCharacteristics(request.url);
            this.snapAccountingManager.accountPlayerRequest(entityCharacteristics);
            this.retrieve(request, entityCharacteristics, context_1, HiveInternalRequest_1.RequestType.UPPER_LAYER);
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error on player request', this.loggerId, ErrorCodes.HIVE_CACHE_CODES.PLAYER_REQUEST_ERROR, error);
        }
    };
    /**
     * This functions retrieves the requests both from the player and the Prefetcher.
     * If it is a Prefetcher request we may not proceed. This is based on the requestDirective that the VideoContext returns.
     * For audio and metadata requests we always proceed.
     * @param original
     * @param entityCharacteristics
     * @param context
     * @param type
     * @returns {Promise<HiveInternalRequest>}
     */
    HiveCache.prototype.retrieve = function (original, entityCharacteristics, context, type) {
        var _this = this;
        // Check If the entity is video/audio or metadata (We do not cache metadata)
        if (entityCharacteristics.isCacheable()) {
            // We check to proceed or ignore only for the video fragments. We do not prefetch audio fragments
            if (entityCharacteristics.getEntityType() == EntityType_1.EntityType.VIDEO) {
                // Retrieve the requestDirective which contains the information regarding a previous request
                // and if we need to proceed with this request or not.
                var requestDirective = context.requestReceived(entityCharacteristics, type);
                // Check if the requestDirective allows us to proceed.
                // More information regarding the cases that we proceed or ignore the request on the comments in VideoContextBase.ts (ignoreOrProceed)
                if (requestDirective.doNotContinue) {
                    this.logger.debug('DO NOT CONTINUE WITH THE REQUEST ' + entityCharacteristics.getEntityId() + '. ALREADY REQUESTED  ' + requestDirective.alreadyRequested + ' PENDING REQUEST ' + requestDirective.pendingRequest);
                    return null;
                }
                else {
                    // The preconditions to check for prefetch upgrade is i) to already know that we have an already pending request for the same fragment
                    // and the new request to be initiated from the player
                    if (requestDirective.pendingRequest && type == HiveInternalRequest_1.RequestType.UPPER_LAYER) {
                        /*
                         * We check if we can prefetch or not. We may not need to upgrade the prefetch iff
                         * we have received the fragment from the prefetcher and there is no current pending request.
                         * Otherwise, on upgrade, we remove all the previous Prefetch-HiveRequests references
                         * and create a new reference from the actual player request to the internal one
                         */
                        var previousRequests = this.prefetchUpgraded(original, entityCharacteristics, context, type);
                        if (previousRequests.length > 0) {
                            previousRequests.forEach(function (id) {
                                var previousInternal = _this.hiveCacheRequests.get(id);
                                _this.hiveCacheRequests.set(original.id, previousInternal);
                                _this.hiveCacheRequests.delete(id);
                            });
                            return null;
                        }
                        else {
                            // This should not happen since the above code is synchronous but I suggest
                            // to keep it in case of change in the future.
                            // If the prefetch upgrade failed, we proceed normally with the request
                            this.logger.info('PREFETCH UPGRADE FAILED. THIS SHOULD NOT HAPPEN. CHECK FOR MULTIPLE PLAYER REQUESTS FOR THE SAME FRAGMENT');
                            return this.proceedForEntity(original, entityCharacteristics, context, type);
                        }
                    }
                    else {
                        return this.proceedForEntity(original, entityCharacteristics, context, type);
                    }
                }
            }
            else {
                // The requested fragment is not video.
                return this.proceedForEntity(original, entityCharacteristics, context, type);
            }
        }
        else {
            var requestNumber = Utils.FragmentCounter.increment();
            var request = new HiveInternalRequest_1.HiveInternalRequest(original, requestNumber, type, entityCharacteristics, context);
            this.hiveCacheRequests.set(original.id, request);
            request.type = HiveInternalRequest_1.RequestType.CDN;
            this.fallbackRequest(request);
            return request;
        }
    };
    /**
     * This function does the following:
     * 1) Checks if the requested fragment is already included in the cache
     * 2) Proceed with the P2P/Fallback if 1st step fails.
     *
     * We do not need to return a promise since we initiate the HiveInternalRequest from the early beginning. Once the HiveInternalRequest is created
     * we do not care about the ending of this request. We only care about the request object in order to modify it in case of upgradePrefetch.
     * @param original
     * @param entityCharacteristics
     * @param context
     * @param type
     * @returns {HiveInternalRequest}
     */
    HiveCache.prototype.proceedForEntity = function (original, entityCharacteristics, context, type) {
        var _this = this;
        var requestNumber = Utils.FragmentCounter.increment();
        var request = new HiveInternalRequest_1.HiveInternalRequest(original, requestNumber, type, entityCharacteristics, context);
        this.hiveCacheRequests.set(original.id, request);
        // Inform the RequestTracker that you will perform a check for this entity and will end up in a new request
        if (entityCharacteristics.getEntityType() == EntityType_1.EntityType.VIDEO) {
            context.createPendingRequest(request);
            // if the request is not a prefetch one, we update the watching quality level
            if (type !== HiveInternalRequest_1.RequestType.CDN_PREFETCH && type !== HiveInternalRequest_1.RequestType.P2P_PREFETCH) {
                var currentQualityLevel = entityCharacteristics.getQualityLevel();
                var previousQualityLevel = this.nodeInfo.getWatchingQualityLevel();
                if (currentQualityLevel) {
                    this.nodeInfo.setWatchingQualityLevel(currentQualityLevel);
                    this.prefetcherManager.prefetchAsLeader(this.nodeInfo.amISiteLeader() || this.nodeInfo.isLanLeader());
                    if (!previousQualityLevel || currentQualityLevel.id !== previousQualityLevel.id) {
                        this.changedQualityLevel = true;
                        this.newQualityLevelCount = 0;
                        // inform the membership that local info have been updated
                        this.membership.updatedLocalMemberInfo();
                    }
                    if (this.changedQualityLevel) {
                        this.newQualityLevelCount++;
                    }
                }
            }
        }
        // Check in the cache if the fragment is already downloaded and stored.
        this.checkInCache(entityCharacteristics.getEntityId()).then(function (rangeContent) {
            // We need to calculate the successful responses that we had from either the p2p or CDN
            _this.snapAccountingManager.accountFragmentAlreadyCached(request, rangeContent);
            // The fragment is in cache and we need to deliver it to the player
            _this.scheduleDeliverAlreadyCached(request, rangeContent);
            // We remove the pending request from the RequestTracker
            context.removePendingRequest(request.getEntityId(), request.getRequestId());
            // We initiate an attempt Prefetch. This does not mean that we will eventually prefetch the next fragment.
            context.attemptPrefetch(entityCharacteristics.getQualityLevel());
        }).catch(function () {
            // We do not have the fragment stored in the cache. We proceed with either a P2P request or a Fallback request
            _this.checkP2POrFallback(entityCharacteristics, request);
            if (request.getEntityType() == EntityType_1.EntityType.VIDEO) {
                // If the request is a video we track the final request to the RequestTracker
                context.addAlreadyRequest(request);
                // if the request is from the player, and we don't have it already in cache (and it's video)
                // means that the internal client buffer reached 0
                if (request.type == HiveInternalRequest_1.RequestType.UPPER_LAYER) {
                    _this.clientBufferAccumulator.add(0);
                }
            }
        });
        return request;
    };
    /**
     * This function initiates the prefetch upgrade procedure to the context. It returns a boolean to inform if the upgrade is succeeded or failed.
     * @param original
     * @param entityCharacteristics
     * @param context
     * @param type
     * @returns {boolean}
     */
    HiveCache.prototype.prefetchUpgraded = function (original, entityCharacteristics, context, type) {
        return context.attemptToUpgradePrefetch(original, entityCharacteristics, type);
    };
    /**
     * This function checks in the cache for the requested fragment.
     * If the fragment is found it returns the rangeContent. Otherwise it returns null.
     * @param entityId
     * @returns {Promise<RangeContent>}
     */
    HiveCache.prototype.checkInCache = function (entityId) {
        return this.cache.get(entityId);
    };
    /**
     * This function checks the ObjectIndex and decides if we need to proceed with a P2P request or a Fallback Request
     * @param entityCharacteristics
     * @param request
     */
    HiveCache.prototype.checkP2POrFallback = function (entityCharacteristics, request) {
        if (this.objectIndex.contains(entityCharacteristics.getEntityId())) {
            this.logger.debug('OBJ IDX CONTAINS ' + request.getEntityId() + ' PROCEED WITH P2P REQUEST');
            // if a request arrived here scheduled by the CDN prefetcher,
            // we can just prefetching from P2P, so we change it for P2P_PREFETCH
            if (request.getRequestType() == HiveInternalRequest_1.RequestType.CDN_PREFETCH) {
                request.type = HiveInternalRequest_1.RequestType.P2P_PREFETCH;
            }
            this.p2pRequest(request);
        }
        else {
            if (request.getRequestType() != HiveInternalRequest_1.RequestType.P2P_PREFETCH) {
                this.fallbackRequest(request);
            }
            else {
                logger_hive_1.ErrorMonitor.getInstance().logError('P2P prefetch failed because object index does not contain request entity', this.loggerId, { entityId: request.getEntityId() });
                request.entityContext.removePendingRequest(request.getEntityId(), request.getRequestId());
            }
        }
    };
    HiveCache.prototype.abortAll = function () {
        var _this = this;
        this.hiveCacheRequests.forEach(function (value) { return _this.abort(value.originalRequest); });
    };
    HiveCache.prototype.abort = function (request) {
        if (this.hiveCacheRequests.has(request.id)) {
            var internalRequest = this.hiveCacheRequests.get(request.id);
            try {
                var requestId = internalRequest.getRequestId();
                this.logger.debug('REQUEST ' + requestId + ' ABORTED ');
                if (this.p2pRequester.isPending(requestId)) {
                    this.p2pRequester.cancelRequest(requestId);
                }
                else if (this.fallbackRequester.isPending(requestId)) {
                    this.fallbackRequester.cancelRequest(requestId);
                }
                this.hiveCacheRequests.delete(request.id);
            }
            catch (error) {
                logger_hive_1.ErrorMonitor.getInstance().logError('Error occurred while aborting the request', this.loggerId, ErrorCodes.HIVE_CACHE_CODES.PLAYER_ABORT_ERROR, error);
            }
        }
    };
    HiveCache.prototype.p2pRequest = function (request) {
        if (request.type == HiveInternalRequest_1.RequestType.UPPER_LAYER) {
            request.type = HiveInternalRequest_1.RequestType.P2P;
        }
        if (request.type == HiveInternalRequest_1.RequestType.P2P_PREFETCH) {
            request.p2pPrefetchGenerated = true;
        }
        this.p2pRequester.request(request);
    };
    /**
     * We received a p2p request failed. This can happen because:
     * 1. We timed-out
     * 2. We received a do not have
     * 3. We received a not a partner message.
     *
     *
     * In all occasions we need to check
     * 1. If the request type is from the player then we automatically compensate.
     * 2. If the request type is p2p prefetch then we clear the request tracker from the previous request and we
     *    trigger the prefetch again.
     * @param request
     */
    HiveCache.prototype.p2pRequestFailed = function (request) {
        if (request.rcvMesgLength != 0) {
            request.requestStats.totalFromP2P = request.rcvMesgLength;
            this.logger.info('ALREADY DOWNLOADED ' + request.requestStats.totalFromP2P + ' BYTES');
            request.requestStats.p2pBeforeCompensation = request.rcvMesgLength;
        }
        if (!PeerConstants_1.PeerConstants.HTTP.UseRangeRequest && request.rcvMesgLength) {
            request.requestStats.totalFromP2P = 0;
        }
        this.snapAccountingManager.accountP2PResponseFailure(request);
        if (request.type != HiveInternalRequest_1.RequestType.P2P_PREFETCH) {
            // We explicitly define the requestType here to the CDN_COMPENSATION
            request.type = HiveInternalRequest_1.RequestType.CDN_COMPENSATION;
            this.fallbackRequest(request);
        }
        else {
            if (request.getEntityType() == EntityType_1.EntityType.VIDEO) {
                request.entityContext.removeAlreadyRequested(request.getEntityId());
                request.entityContext.removePendingRequest(request.getEntityId(), request.getRequestId());
                var videoE = request.entityCharacteristics;
                if (videoE.getQualityLevel()) {
                    request.entityContext.attemptPrefetch(videoE.getQualityLevel());
                }
            }
        }
    };
    /**
     * This function handles a successful response from a previous P2P request.
     * It caches the retrieved fragment to the cache, handles the statistics,
     * checks if the fragment needs to be delivered to the player and informs the context that the
     * fragment is retrieved.
     * @param request
     * @returns {Promise<void>}
     */
    HiveCache.prototype.p2pRequestSuccessful = function (request) {
        var _this = this;
        this.logger.info('SUCCESS FROM P2P FOR ' + request.getRequestUrl() + ' [REQ ' + request.requestNumber + '] [' +
            HiveInternalRequest_1.RequestType[request.type] + '] AFTER ' + request.getP2PElapsed() + ' [bw:' + request.getBandwidth().toHumanReadable() + ']');
        this.calculateRequestStats(request);
        this.handleResponse(request, this.isNotPrefetch(request.type));
        this.chunkHandler.addFragment(request);
        // We need to calculate the bit per second even for the p2p request successful beacuse if we have
        // only p2p for a long time, then the sourceThroughput on the insights will be 0.
        var cdnBitps = this.fallbackRequester.getMeasuredBandwidth().toBitPerSecond();
        this.snapAccountingManager.accountP2PRequestSuccessful(request, cdnBitps);
        this.cacheAndAdvertise(request).then(function () {
            request.entityContext.fragmentReceived(request);
            _this.renderLocalStats();
        }).finally(function () {
            if (_this.isNotPrefetch(request.type)) {
                _this.respondToRequest(request, OriginType.P2P);
            }
            _this.hiveCacheRequests.delete(request.originalRequest.id);
        });
    };
    /**
     * We tried to fetch the fragment through P2P but the connection was really slow and
     * we decided to abort without even trying.
     * If the P2P request was triggered because of a Player request then we trigger immediately the
     * fallback request.
     * Otherwise, we delete the pending request from the request tracker and we trigger the prefetch again.
     * @param {HiveInternalRequest} request
     */
    HiveCache.prototype.p2pRequestAborted = function (request) {
        if (request.type != HiveInternalRequest_1.RequestType.P2P_PREFETCH) {
            // We explicitly define the requestType here to the CDN_COMPENSATION
            request.type = HiveInternalRequest_1.RequestType.UPPER_LAYER;
            this.fallbackRequest(request);
        }
        else {
            if (request.getEntityType() == EntityType_1.EntityType.VIDEO) {
                request.entityContext.removeAlreadyRequested(request.getEntityId());
                request.entityContext.removePendingRequest(request.getEntityId(), request.getRequestId());
                var videoE = request.entityCharacteristics;
                if (videoE.getQualityLevel()) {
                    request.entityContext.attemptPrefetch(videoE.getQualityLevel());
                }
            }
        }
    };
    HiveCache.prototype.fallbackRequest = function (request) {
        request.entityContext.getRequestContext().attachParams(request.originalRequest);
        this.snapAccountingManager.accountFallbackRequest(request);
        this.fallbackRequester.request(request);
    };
    HiveCache.prototype.fallbackRequestFailed = function (request) {
        this.renderLocalStats();
        var cdnBitps = this.fallbackRequester.getMeasuredBandwidth().toBitPerSecond();
        this.snapAccountingManager.accountFallbackRequestFailure(request, cdnBitps);
        if (request.getEntityType() == EntityType_1.EntityType.VIDEO) {
            request.entityContext.removeAlreadyRequested(request.getEntityId());
            request.entityContext.removePendingRequest(request.getEntityId(), request.getRequestId());
        }
        this.hiveCacheRequests.delete(request.originalRequest.id);
    };
    /**
     * This function handles a successful response from a previous Fallback request.
     * It caches the retrieved fragment to the cache, handles the statistics,
     * checks if the fragment needs to be delivered to the player and informs the context that the
     * fragment is retrieved.
     * @param request
     * @returns {Promise<void>}
     */
    HiveCache.prototype.fallbackRequestSuccessful = function (request) {
        var _this = this;
        this.calculateRequestStats(request);
        this.handleResponse(request, this.isNotPrefetch(request.type));
        if (request.type == HiveInternalRequest_1.RequestType.CDN_COMPENSATION) {
            this.logger.debug('CDN COMPENSATION TIME ' + (request.requestStats.fragmentDownloadedTs - request.originalRequest.playerRequestTs) + ' / '
                + (request.requestStats.fragmentDownloadedTs - request.requestStats.initialRequestTs) +
                ' P2P TIME ' + (request.requestStats.fallbackRequestStarted - request.requestStats.p2pRequestStartedTs));
        }
        // if it's a fragment, let's prepare the chunks
        if ([EntityType_1.EntityType.METADATA, EntityType_1.EntityType.OTHER].indexOf(request.getEntityType()) == -1) {
            this.chunkHandler.addFragment(request);
        }
        var cdnBitps = this.fallbackRequester.getMeasuredBandwidth().toBitPerSecond();
        this.snapAccountingManager.accountFallbackRequestSuccessful(request, cdnBitps);
        this.cacheAndAdvertise(request).then(function () {
            if (request.getEntityType() == EntityType_1.EntityType.METADATA) {
                request.entityContext.metadataReceived(request);
            }
            if ([EntityType_1.EntityType.METADATA, EntityType_1.EntityType.OTHER].indexOf(request.getEntityType()) == -1) {
                request.entityContext.fragmentReceived(request);
            }
            _this.renderLocalStats();
        }).catch(function (e) {
            _this.logger.error(e);
        }).finally(function () {
            if (_this.isNotPrefetch(request.type)) {
                _this.respondToRequest(request, OriginType.CDN);
            }
            _this.hiveCacheRequests.delete(request.originalRequest.id);
        });
    };
    /**
     * In this function we calculate the quantity of the bytes that we downloaded.
     * Since we pass to the SnapAccountingManager just the HiveInternalRequest,
     * the request should contain all the statistics in order to do the maths
     * @param {HiveInternalRequest} request
     */
    HiveCache.prototype.calculateRequestStats = function (request) {
        if (request.type == HiveInternalRequest_1.RequestType.P2P_PREFETCH) {
            request.requestStats.p2pAgenTrafficSuccessQt = request.requestStats.totalFromP2P;
        }
        if (request.type == HiveInternalRequest_1.RequestType.CDN_PREFETCH) {
            request.requestStats.cdnAgenTrafficSuccessQt = request.requestStats.totalFromFallback;
            if (request.generatedByLeader) {
                request.requestStats.srcOtherRespQt = request.requestStats.totalFromFallback;
            }
        }
        request.requestStats.totalDownloaded = request.requestStats.totalFromFallback + request.requestStats.totalFromP2P;
        request.originalRequest.total = request.requestStats.totalDownloaded;
    };
    /**
     * This function handles the response from the original request.
     *
     * If it is a request from the player, then the onProgress event should be triggered and we need to
     * assign the response on the originalRequest.
     * Otherwise, we just need to fix the headers in order to be properly stored in the cache.
     * @param {HiveInternalRequest} request
     * @param {boolean} onProgress
     */
    HiveCache.prototype.handleResponse = function (request, onProgress) {
        this.fixHeaders(request);
        request.originalRequest.total = request.size;
        if (onProgress) {
            var hpe = Utils.createEvent(ProgressEvent, 'progress', {
                lengthComputable: true,
                total: request.requestStats.totalDownloaded,
                loaded: request.requestStats.totalDownloaded,
                currentTarget: request.originalRequest
            });
            request.originalRequest.dispatchEvent(hpe);
            if (!request.entityCharacteristics.isBinary()) 
            // we return a copy of our downloaded buffer to the player
            // since some player may detach this buffer for transmuxing or other
            // stuff, and that will prevent us from doing operations on our cached fragment
            {
                request.originalRequest.response = request.getResponseAsString();
                request.originalRequest.responseText = request.getResponseAsString();
            }
        }
    };
    /**
     * In this function we generate the originalRequest that we are going to give back to the player
     * @param {HiveInternalRequest} request
     */
    HiveCache.prototype.respondToRequest = function (request, origin) {
        var originalRequest = request.originalRequest;
        var responseSize = (Framework_1.Framework.isSimulated() ? originalRequest.total : (request.binaryData ? request.binaryData.byteLength : 0));
        if (request.getEntityType() === EntityType_1.EntityType.VIDEO) {
            this.statsStore.fragmentDownloadProvider.add(request, SnapshotRequestType.PLAYER, origin);
        }
        this.logger.info('RESPOND TO THE PLAYER ' + request.getEntityId() + ' SIZE ' + responseSize);
        originalRequest.status = 200;
        originalRequest.statusText = 'OK';
        originalRequest.readyState = 4;
        /*
         * fix to make sure that we return the right expected response type to the player (i.e. Viblast requests
         * playlists as arraybuffer and complains too)
         */
        if (typeof originalRequest.response === 'string' && originalRequest.responseType === 'arraybuffer') {
            originalRequest.response = Utils.stringToArrayBuffer(originalRequest.response);
        }
        /*
         * to comply with https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/responseText
         * if a player request indicated a non-text responseType, the responseText should not
         * be set, only the response
         */
        if (originalRequest.responseType != 'text' && originalRequest.responseType != '') {
            delete originalRequest.responseText;
        }
        /*
         * whenever we return a buffer to the player, we create a copy of it, since the player might consume and
         * unbind it
         */
        if (request.entityCharacteristics.isBinary()) {
            //     this.logger.warn(`${this.loggerId}no response found in the original response but in the binary request ${request.binaryData}`);
            originalRequest.response = Framework_1.Framework.isSimulated() ? null : Utils.copyBuffer(request.binaryData);
        }
        /*
         * prepare and trigger the 3 main events on the player requests
         */
        var readyStateChangeEvent = Utils.createEvent(Event, 'readystatechange', {
            currentTarget: originalRequest
        });
        var loadEvent = Utils.createEvent(ProgressEvent, 'load', {
            bubbles: false,
            cancelable: false,
            lengthComputable: false,
            total: responseSize,
            currentTarget: originalRequest,
            loaded: responseSize
        });
        // some player like hls.js only listen to onLoadEnd
        var loadendEvent = Utils.createEvent(ProgressEvent, 'loadend', {
            bubbles: false,
            cancelable: false,
            lengthComputable: false,
            loaded: responseSize,
            total: 0,
            currentTarget: originalRequest
        });
        originalRequest.dispatchEvent(readyStateChangeEvent);
        originalRequest.dispatchEvent(loadEvent);
        originalRequest.dispatchEvent(loadendEvent);
    };
    /**
     * This function stores the retrieved fragment to the cache and send Haves to the partners
     * We only send haves to the partners if the store procedure is successful.
     * @param request
     * @returns {Promise<void>}
     */
    HiveCache.prototype.cacheAndAdvertise = function (request) {
        var _this = this;
        if (request.entityCharacteristics.isCacheable()) {
            return this.cache.put(request).then(function () {
                return _this.partnership.sendHaves(request.entityCharacteristics, request.requestStats.totalDownloaded, request.partner);
            }).catch(function (error) {
                Q.resolve(true);
            });
        }
        else {
            return Q.resolve(true);
        }
    };
    HiveCache.prototype.scheduleDeliverAlreadyCached = function (request, rangeContent) {
        var _this = this;
        request.binaryData = rangeContent.data;
        request.respHeaders = rangeContent.headers;
        request.partnerInfo = rangeContent.partnerInfo;
        request.requestStats = rangeContent.requestStats;
        request.size = rangeContent.length;
        var delay = request.entityContext.getTimerHandler().getDeliverDelay(rangeContent.length);
        this.logger.info('SCHEDULE DELIVERY OF ' + request.getEntityId() + ' SIZE ' + (Framework_1.Framework.isSimulated() ? rangeContent.length : request.binaryData.byteLength) + ' BYTES' + ' IN ' + delay + ' MS');
        Framework_1.Framework.setTimeout(function () {
            _this.deliverAlreadyCached(request);
        }, delay);
    };
    HiveCache.prototype.deliverAlreadyCached = function (request) {
        this.logger.debug('DELIVERY OF ' + request.getEntityId());
        this.handleResponse(request, true);
        this.hiveCacheRequests.delete(request.originalRequest.id);
        // FIXME:
        var prefetchedTime = request.originalRequest.playerRequestTs - request.requestStats.fragmentDownloadedTs;
        if (prefetchedTime > 0 && request.getEntityType() == EntityType_1.EntityType.VIDEO) {
            this.clientBufferAccumulator.add(prefetchedTime);
        }
        var totalTime = 0;
        if (request.requestStats.p2pRequestStartedTs > 0) {
            totalTime = request.originalRequest.playerRequestTs - request.requestStats.p2pRequestStartedTs;
        }
        else {
            totalTime = request.originalRequest.playerRequestTs - request.requestStats.fallbackRequestStarted;
        }
        this.logger.debug('FRAGMENT PREFETCHED ' + prefetchedTime + ' MS BEFORE PLAYER REQUEST AND REQUESTED ' + (totalTime) + ' MS BEFORE PLAYER REQUEST');
        this.respondToRequest(request, OriginType.CACHE);
    };
    HiveCache.prototype.isNotPrefetch = function (type) {
        return type != HiveInternalRequest_1.RequestType.P2P_PREFETCH && type != HiveInternalRequest_1.RequestType.CDN_PREFETCH;
    };
    HiveCache.prototype.fixHeaders = function (request) {
        if (request.type !== HiveInternalRequest_1.RequestType.CDN_COMPENSATION) {
            request.respHeaders = request.originalRequest.respHeaders = request.respHeaders;
        }
        else {
            var contentRangeHeader = '\nContent-Range: bytes=0-' + (request.size - 1) + '/' + request.size + '\n';
            contentRangeHeader += 'Content-Length: ' + request.size + '\n';
            request.respHeaders = request.originalRequest.respHeaders = contentRangeHeader;
        }
        if (request.respHeaders == null) {
            request.respHeaders = 'access-control-allow-origin: *';
        }
        else if (request.respHeaders.toLowerCase().indexOf('access-control-allow-origin') == -1) {
            request.respHeaders = request.respHeaders.trim() + '\naccess-control-allow-origin: *\n';
        }
    };
    HiveCache.prototype.renderLocalStats = function () {
        if (!Framework_1.Framework.isSimulated() && this.renderStats) {
            this.renderStats.render();
        }
    };
    HiveCache.prototype.removeFromCache = function (request) {
        this.cache.remove(request);
    };
    return HiveCache;
}());
exports.HiveCache = HiveCache;
//# sourceMappingURL=HiveCache.js.map

/***/ }),

/***/ "../../../core/build/core/src/webrtc/HiveInternalRequest.js":
/*!***********************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/webrtc/HiveInternalRequest.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.HiveInternalRequest = exports.RequestStats = exports.RequestType = void 0;
var Q = __webpack_require__(/*! @hivestreaming/q */ "../../../node_modules/@hivestreaming/q/q.js");
var Framework_1 = __webpack_require__(/*! ../core/Framework */ "../../../core/build/core/src/core/Framework.js");
var Utils_1 = __webpack_require__(/*! ../core/Utils */ "../../../core/build/core/src/core/Utils.js");
var FragmentAuthenticator_1 = __webpack_require__(/*! ./p2ptransfer/authentication/FragmentAuthenticator */ "../../../core/build/core/src/webrtc/p2ptransfer/authentication/FragmentAuthenticator.js");
var PeerConstants_1 = __webpack_require__(/*! ./PeerConstants */ "../../../core/build/core/src/webrtc/PeerConstants.js");
var RequestType;
(function (RequestType) {
    RequestType[RequestType["UPPER_LAYER"] = 0] = "UPPER_LAYER";
    RequestType[RequestType["CDN"] = 1] = "CDN";
    RequestType[RequestType["CDN_PREFETCH"] = 2] = "CDN_PREFETCH";
    RequestType[RequestType["CDN_COMPENSATION"] = 3] = "CDN_COMPENSATION";
    RequestType[RequestType["P2P"] = 4] = "P2P";
    RequestType[RequestType["P2P_PREFETCH"] = 5] = "P2P_PREFETCH";
})(RequestType = exports.RequestType || (exports.RequestType = {}));
var RequestStats = /** @class */ (function () {
    function RequestStats() {
        this.p2pRequest = false;
        this.totalDownloaded = 0;
        this.totalFromP2P = 0;
        this.p2pBeforeCompensation = 0;
        this.totalFromDisk = 0;
        this.totalFromFallback = 0;
        this.p2pAgenTrafficSuccessQt = 0;
        this.cdnAgenTrafficSuccessQt = 0;
        this.srcOtherRespQt = 0;
        // This is the request timestamp which is set immediately when the request is created
        this.initialRequestTs = 0;
        // Those timestamps are set during the fragment download either by the P2P or the fallback
        this.p2pRequestStartedTs = 0;
        this.fallbackRequestStarted = 0;
        this.fragmentDownloadedTs = 0;
    }
    return RequestStats;
}());
exports.RequestStats = RequestStats;
var HiveInternalRequest = /** @class */ (function () {
    function HiveInternalRequest(upperLayerRequest, requestNumber, type, entityCharacteristics, context) {
        this.setTimer = false;
        this.type = undefined;
        this.requestStats = new RequestStats();
        this.generatedByLeader = false;
        this.p2pPrefetchGenerated = false;
        this.respHeaders = '';
        this.binaryData = new ArrayBuffer(0);
        this.rcvMesgLength = 0;
        this.type = type;
        this.originalRequest = upperLayerRequest;
        this.requestNumber = requestNumber;
        this.entityContext = context;
        this.entityCharacteristics = entityCharacteristics;
        this.requestStats.initialRequestTs = Framework_1.Framework.time();
        this.fragmentAuthenticator = new FragmentAuthenticator_1.FragmentAuthenticator(this.originalRequest);
    }
    Object.defineProperty(HiveInternalRequest.prototype, "startedTime", {
        get: function () {
            return this.requestStats.p2pRequest ? this.requestStats.p2pRequestStartedTs : this.requestStats.fallbackRequestStarted;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(HiveInternalRequest.prototype, "finishedTime", {
        get: function () {
            return this.requestStats.fragmentDownloadedTs;
        },
        enumerable: false,
        configurable: true
    });
    HiveInternalRequest.prototype.getRequestType = function () {
        return this.type;
    };
    HiveInternalRequest.prototype.getEntityType = function () {
        return this.entityCharacteristics.getEntityType();
    };
    HiveInternalRequest.prototype.getEntityId = function () {
        return this.entityCharacteristics.getEntityId();
    };
    HiveInternalRequest.prototype.getRequestId = function () {
        return this.getEntityId() + '-' + this.requestNumber;
    };
    HiveInternalRequest.prototype.getRequestUrl = function () {
        return this.entityCharacteristics.getUrl();
    };
    HiveInternalRequest.prototype.getCacheable = function () {
        return this.entityCharacteristics.isCacheable();
    };
    HiveInternalRequest.prototype.getFallbackElapsed = function () {
        return Math.max(1, this.requestStats.fragmentDownloadedTs - this.requestStats.fallbackRequestStarted);
    };
    HiveInternalRequest.prototype.getP2PElapsed = function () {
        return Math.max(1, this.requestStats.fragmentDownloadedTs - this.requestStats.p2pRequestStartedTs);
    };
    HiveInternalRequest.prototype.getBandwidth = function () {
        if (this.requestStats.totalFromFallback != 0)
            return new Utils_1.Bandwidth(this.getFallbackElapsed(), this.requestStats.totalFromFallback);
        else
            return new Utils_1.Bandwidth(this.getP2PElapsed(), this.requestStats.totalFromP2P);
    };
    HiveInternalRequest.prototype.getResponse = function () {
        return this.xhr ? this.xhr.response : this.binaryData;
    };
    HiveInternalRequest.prototype.getResponseAsString = function () {
        return this.responseText;
    };
    HiveInternalRequest.prototype.getResponseSize = function () {
        return this.requestStats.totalDownloaded;
    };
    HiveInternalRequest.prototype.getStatus = function () {
        throw new Error('Not implemented');
    };
    HiveInternalRequest.prototype.getEntityCharacteristics = function () {
        return this.entityCharacteristics;
    };
    HiveInternalRequest.prototype.getResponseUrl = function () {
        if (this.xhr && this.xhr.responseURL) {
            return this.xhr.responseURL;
        }
        return this.getRequestUrl();
    };
    /**
     * Authenticates a p2p response. Returns the first promise to resolve from:
     * 1. Forcing authentication. If we receive a second player request for a fragment we will force the authentication
     * and return true instantly so the player doesn't wait
     *
     * 2. Fragment Authentication. If this resolves before the authentication is forced will return the result of the authentication
     *
     * 3. timeToWait - Audio fragments are fetched very fast from p2p and they might be fetched faster than the 32 bytes from the CDN.
     * In that case we wait for (150ms - p2pElapsed) before forcing authentication. Based on tests we ran and data we collected it is
     * enough time to authenticate almost all audio fragments.
     *
     * @returns Whether authentication was successful or not
     */
    HiveInternalRequest.prototype.authenticateResponse = function () {
        return __awaiter(this, void 0, void 0, function () {
            var timeToWait;
            return __generator(this, function (_a) {
                this.forceAuthentication = Q.defer();
                timeToWait = PeerConstants_1.PeerConstants.FragmentAuthenticator.CDN_RANGE_TIMEOUT_MS - this.getP2PElapsed();
                return [2 /*return*/, Q.race([
                        this.fragmentAuthenticator.authenticate(this.binaryData),
                        this.forceAuthentication.promise,
                        this.waitFor(timeToWait)
                    ])];
            });
        });
    };
    HiveInternalRequest.prototype.waitFor = function (ms) {
        return new Promise(function (resolve) {
            if (ms >= 0) {
                Framework_1.Framework.setTimeout(function () {
                    resolve(true);
                }, ms);
            }
        });
    };
    HiveInternalRequest.prototype.startAuthentication = function () {
        this.fragmentAuthenticator.request();
    };
    HiveInternalRequest.prototype.cancelValidation = function () {
        this.fragmentAuthenticator.cancel();
    };
    HiveInternalRequest.prototype.upgradedRequest = function () {
        if (this.forceAuthentication) {
            this.forceAuthentication.resolve(true);
        }
    };
    return HiveInternalRequest;
}());
exports.HiveInternalRequest = HiveInternalRequest;
//# sourceMappingURL=HiveInternalRequest.js.map

/***/ }),

/***/ "../../../core/build/core/src/webrtc/HiveXHR.js":
/*!***********************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/webrtc/HiveXHR.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.HiveXHR = void 0;
var Utils = __webpack_require__(/*! ../core/Utils */ "../../../core/build/core/src/core/Utils.js");
var logger_hive_1 = __webpack_require__(/*! ../common/logger.hive */ "../../../core/build/core/src/common/logger.hive.js");
var HiveXHR = /** @class */ (function () {
    /**
     * default constructor, depending on the player (AMP 1.8.0+) it may already
     * pass the pluginId associated to this player request. Other players
     * instead will initialize without pluginId, so the integration must register
     * the playerId -> pluginId association, and resolve it at every request using
     * {@link setPlayerId}
     * @param pluginId
     */
    function HiveXHR(pluginId) {
        this.loggerId = '[HiveXHR] ';
        this.DONE = 4;
        this.LOADING = 3;
        this.HEADERS_RECEIVED = 2;
        this.OPENED = 1;
        this.UNSENT = 0;
        this.username = null;
        this.password = null;
        this.requestHeaders = [];
        this.responseType = '';
        this.readyState = this.UNSENT;
        this.status = 0;
        this.async = true;
        this.timeout = 0;
        this.events = {};
        if (pluginId) {
            this.pluginId = pluginId;
        }
    }
    /**
     * Add an event handler to the stored events object.
     * @param type Event type
     * @param listener Callback
     * @param useCapture
     */
    HiveXHR.prototype.addEventListener = function (type, listener, useCapture) {
        this.events[type] = this.events[type] || [];
        this.events[type].push(listener);
    };
    /**
     * Remove a previously added event handler.
     * @param type Event type
     * @param listener Callback
     * @param options Options (unused)
     */
    HiveXHR.prototype.removeEventListener = function (type, listener, options) {
        if (this.events[type])
            this.events[type] = this.events[type].filter(function (_listener) { return _listener !== listener; });
    };
    /**
     * Sends an event to registered handlers. Will first go through events bound via addEventListener(),
     * and then check for the existence of any on* attribute handlers.
     * @param evt Event to dispatch
     */
    HiveXHR.prototype.dispatchEvent = function (evt) {
        var _this = this;
        // Check if part of event handlers created via addEventListener
        if (this.events[evt.type]) {
            this.events[evt.type].forEach(function (handler) {
                try {
                    if (typeof handler === 'function') {
                        handler.call(_this, evt);
                    }
                    else if (typeof handler.handleEvent === 'function') {
                        handler.handleEvent(evt);
                    }
                }
                catch (error) {
                    logger_hive_1.ErrorMonitor.getInstance().logError('Error in callback handler', { handler: evt.type, error: error });
                }
            });
        }
        // Check for on* properties
        var handler = this['on' + evt.type];
        if (typeof handler === 'function') {
            try {
                handler.call(this, evt);
            }
            catch (error) {
                logger_hive_1.ErrorMonitor.getInstance().logError('Error in callback handler', { handler: evt.type, error: error });
            }
        }
        return false;
    };
    HiveXHR.prototype.msCachingEnabled = function () {
        return typeof this.msCaching !== 'undefined';
    };
    HiveXHR.prototype.overrideMimeType = function (mimeType) {
        this.mimeType = mimeType;
    };
    /**
     * when initializing a player in the window, use register to statically
     * associate a video element id to the initialized pluginId and then
     * {@link setPlayerId} to resolve the association on every request
     * @param playerId
     * @param pluginId
     */
    HiveXHR.register = function (playerId, pluginId) {
        HiveXHR.playerPluginMap[playerId] = pluginId;
    };
    /**
     * Use the originating playerId of this request
     * to associate the correct pluginId to it
     * @param playerId
     */
    HiveXHR.prototype.setPlayerId = function (playerId) {
        if (!this.pluginId) {
            this.pluginId = HiveXHR.playerPluginMap[playerId];
        }
    };
    /**
     *
     * @param method Method
     * @param url URL
     * @param async Set to 'false' if this call is synchronous
     * @param username Username
     * @param password Password
     */
    HiveXHR.prototype.open = function (method, url, async, username, password) {
        if (async === void 0) { async = true; }
        if (username === void 0) { username = null; }
        if (password === void 0) { password = null; }
        this.url = url.trim();
        this.method = method;
        this.username = username;
        this.password = password;
        this.async = async;
        this.readyState = this.OPENED;
        var readystatechangeEvent = Utils.createEvent(Event, 'readystatechange', { currentTarget: this });
        this.dispatchEvent(readystatechangeEvent);
    };
    /**
     * Adds a request header to the queued list of headers. These headers are utilized
     * in the individual send() implementation.
     * @param header Header
     * @param value Value
     */
    HiveXHR.prototype.setRequestHeader = function (header, value) {
        if (this.readyState !== this.OPENED)
            throw new Error("The object's state must be OPENED.");
        this.requestHeaders.push({ key: header, value: value });
    };
    /**
     * Retrieves a response header.
     * @param header Header
     * @returns Value of response header, or `null` if header is not found.
     */
    HiveXHR.prototype.getResponseHeader = function (header) {
        var headers = this.getAllResponseHeaders();
        if (headers) {
            var responseHeaders_1 = {};
            var lines = headers.split(/[\r\n]+/);
            lines.forEach(function (line) {
                var keyValue = line.match(/^([^:]+): ?(.+)$/);
                if (!keyValue)
                    return;
                responseHeaders_1[keyValue[1]] = keyValue[2];
            });
            return responseHeaders_1[header.toLowerCase()];
        }
        else {
            return null;
        }
    };
    /**
     * Retrieve all response headers.
     * @returns All response headers, separated by new-lines.
     */
    HiveXHR.prototype.getAllResponseHeaders = function () {
        return this.respHeaders;
    };
    HiveXHR.prototype.onload = function (event) {
    };
    HiveXHR.prototype.onloadend = function (event) {
    };
    HiveXHR.prototype.onerror = function (event) {
    };
    HiveXHR.prototype.onprogress = function (event) {
    };
    HiveXHR.prototype.onreadystatechange = function (event) {
    };
    HiveXHR.prototype.onabort = function (event) {
    };
    HiveXHR.prototype.onloadstart = function (event) {
    };
    HiveXHR.prototype.ontimeout = function (event) {
    };
    HiveXHR.playerPluginMap = {};
    HiveXHR.counter = 0;
    return HiveXHR;
}());
exports.HiveXHR = HiveXHR;
//# sourceMappingURL=HiveXHR.js.map

/***/ }),

/***/ "../../../core/build/core/src/webrtc/ObjectIndex.js":
/*!***************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/webrtc/ObjectIndex.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ObjectIndex = exports.Element = void 0;
var HashMap = __webpack_require__(/*! @hivestreaming/collections/map */ "../../../node_modules/@hivestreaming/collections/map.js");
var Framework_1 = __webpack_require__(/*! ../core/Framework */ "../../../core/build/core/src/core/Framework.js");
var Utils = __webpack_require__(/*! ../core/Utils */ "../../../core/build/core/src/core/Utils.js");
var logger_hive_1 = __webpack_require__(/*! ../common/logger.hive */ "../../../core/build/core/src/common/logger.hive.js");
var ErrorCodes = __webpack_require__(/*! ../common/error.hive */ "../../../core/build/core/src/common/error.hive.js");
var Element = /** @class */ (function () {
    function Element(id, size) {
        this.id = id;
        this.size = size;
    }
    return Element;
}());
exports.Element = Element;
var ObjectIndex = /** @class */ (function () {
    function ObjectIndex() {
        this.loggerId = '[ObjectIndex] ';
        this.idToObj = new HashMap();
        this.idToPartners = new HashMap();
        this.logger = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.LOGGER).log();
    }
    ObjectIndex.prototype.put = function (have, peer) {
        try {
            var fragmentId = have.fragmentId;
            var size = have.size;
            if (!this.idToObj.has(fragmentId)) {
                this.idToObj.set(fragmentId, new Element(fragmentId, size));
                this.idToPartners.set(fragmentId, new Array());
            }
            this.idToPartners.get(fragmentId).push(peer);
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error adding new have in object index', this.loggerId, ErrorCodes.OBJECT_INDEX_CODES.ADD_HAVE, error);
            throw new Error(error);
        }
    };
    ObjectIndex.prototype.contains = function (fragmentId) {
        return this.idToPartners.has(fragmentId);
    };
    ObjectIndex.prototype.getPartners = function (fragmentId) {
        return this.idToPartners.get(fragmentId);
    };
    ObjectIndex.prototype.getElement = function (fragmentId) {
        return this.idToObj.get(fragmentId);
    };
    ObjectIndex.prototype.removePeer = function (peer) {
        var _this = this;
        try {
            this.idToPartners.forEach(function (prts, fragmentId) {
                Utils.removeArrayItem(prts, peer, false);
                if (prts.length === 0) {
                    _this.idToPartners.delete(fragmentId);
                    _this.idToObj.delete(fragmentId);
                }
            });
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error removing haves send from a specific peer', this.loggerId, ErrorCodes.OBJECT_INDEX_CODES.REMOVE_PEER, error);
        }
    };
    ObjectIndex.prototype.printContent = function () {
        var _this = this;
        this.idToPartners.forEach(function (prts, fragmentId) {
            _this.logger.debug('OBJIDX FR ' + fragmentId + ' PS ' + prts.map(function (prt) {
                return prt.dispatcher.transport.otherGuid;
            }).reduce(function (previous, current) {
                return previous + ',' + current;
            }));
        });
    };
    return ObjectIndex;
}());
exports.ObjectIndex = ObjectIndex;
//# sourceMappingURL=ObjectIndex.js.map

/***/ }),

/***/ "../../../core/build/core/src/webrtc/Peer.js":
/*!********************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/webrtc/Peer.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Peer = exports.Swarm = void 0;
var Q = __webpack_require__(/*! @hivestreaming/q */ "../../../node_modules/@hivestreaming/q/q.js");
var jsrsasign_1 = __webpack_require__(/*! @hivestreaming/jsrsasign */ "../../../node_modules/@hivestreaming/jsrsasign/lib/jsrsasign.js");
var Framework_1 = __webpack_require__(/*! ../core/Framework */ "../../../core/build/core/src/core/Framework.js");
var PeerConstants_1 = __webpack_require__(/*! ./PeerConstants */ "../../../core/build/core/src/webrtc/PeerConstants.js");
var Reporting_1 = __webpack_require__(/*! ../stats/Reporting */ "../../../core/build/core/src/stats/Reporting.js");
var HashMap = __webpack_require__(/*! @hivestreaming/collections/map */ "../../../node_modules/@hivestreaming/collections/map.js");
var CustomSnapshotProvider_1 = __webpack_require__(/*! ../stats/CustomSnapshotProvider */ "../../../core/build/core/src/stats/CustomSnapshotProvider.js");
var build_defaults_1 = __webpack_require__(/*! ../common/build.defaults */ "../../../core/build/core/src/common/build.defaults.js");
var logger_hive_1 = __webpack_require__(/*! ../common/logger.hive */ "../../../core/build/core/src/common/logger.hive.js");
var ErrorCodes = __webpack_require__(/*! ../common/error.hive */ "../../../core/build/core/src/common/error.hive.js");
var SCORE_EQUALITY = build_defaults_1.BuildParameters.SCORE_EQUALITY;
var Swarm = /** @class */ (function () {
    function Swarm(reportingInstance, hivejsOptions) {
        this.state = Reporting_1.ClientState.PLAY;
        this.requestTimeout = -1;
        try {
            this.logger = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.LOGGER).log(reportingInstance.ticket.sessionId);
            this.loggerId = '[SWARM] ';
            this.networkManager = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.RTC_MANAGER);
            this.sessionId = reportingInstance.ticket.sessionId;
            this.reportingInstance = reportingInstance;
            this.hiveCache = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.DCACHE);
            this.cache = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.CACHE);
            this.membership = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.MEMBERSHIP);
            this.fallbackRequester = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.FALLBACK_REQUESTER);
            this.objectIndex = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.OBJECT_INDEX);
            this.partnership = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.PARTNERSHIP);
            this.uploadScore = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.SCORE_UPDATER);
            this.responder = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.RESPONDER);
            this.trackerClient = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.TRACKER_CLIENT);
            this.p2pRequester = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.P2P_REQUESTER);
            this.contextManager = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.CONTEXT_RESOLVER);
            this.requestTracker = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.REQUEST_TRACKER);
            this.nodeInfo = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.PEER_NODE_INFO);
            this.prefetcher = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.P2P_VIDEO_PREFETCHER);
            this.prefetchManager = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.PREFETCH_MANAGER);
            this.chunkHandler = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.CENTRAL_FRAGMENT);
            this.ipSpoofing = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.IP_SPOOFING);
            this.snapAccountingManager = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.SNAP_STATS_MANAGER);
            this.localityScore = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.LOCALITY_SCORE);
            this.localityClient = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.LOCALITY_CLIENT);
            this.hivejsOptions = hivejsOptions;
            this.swarmId = this.getHash(reportingInstance.ticket.getEventInfo());
            this.snapAccountingManager.init(this);
            this.fallbackRequester.init(this);
            this.chunkHandler.init(this);
            this.ipSpoofing.init(this);
            this.partnership.init(this);
            this.responder.init(this);
            this.trackerClient.init(this);
            this.p2pRequester.init(this);
            this.contextManager.init(this);
            this.hiveCache.init(this);
            this.membership.init(this);
            this.prefetcher.init(this);
            this.prefetchManager.init(this);
            this.requestTracker.init(this);
            this.localityScore.init(this);
            this.localityClient.init(this);
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error constructing swarm object', this.loggerId, ErrorCodes.PEER_CODES.CONSTRUCT_SWARM, error);
            throw new Error(error);
        }
    }
    Swarm.prototype.init = function (ticket, android) {
        try {
            if (!SCORE_EQUALITY) {
                // If we have the android parameter equals true, then we force the
                // peer to report 1 CPU cores to the tracker.
                // Otherwise we let the navigator collect the CPU cores.
                if (android) {
                    this.updateLeaderScore(false);
                }
                else {
                    this.updateLeaderScore(true);
                }
            }
            else {
                this.updateLeaderScore(false);
            }
            this.nodeInfo.setTicket(ticket);
            this.nodeInfo.setReportingGuid(this.reportingInstance.identity.getReportingId());
            this.nodeInfo.setAndroidDeviceFlag(android);
            this.cache.init(PeerConstants_1.PeerConstants.Cache.Occupancy, PeerConstants_1.PeerConstants.Cache.PurgeTime);
            var context_1 = this.contextManager.initContext(ticket, this.hivejsOptions);
            this.nodeInfo.setContextId(this.contextManager.currentContext.getContextId());
            // initialize stream info provider
            this.reportingInstance.statsStore.streamInfoProvider.init(ticket, context_1);
            // set the quality level tracker
            this.reportingInstance.statsStore.streamInfoProvider.setQualityLevelTracker(context_1.getQualityLevelTracker());
            // start discovery
            this.trackerClient.start(this.contextManager, this.membership);
            var networkListeners = [this.localityClient, this.membership, this.partnership, this.trackerClient, this.reportingInstance.statsStore, this.reportingInstance.trackManager, this.ipSpoofing];
            this.networkManager.start(this.swarmId, networkListeners);
            this.reportingInstance.statsStore.setP2PInfoProvider(this.partnership);
            this.reportingInstance.statsStore.updateNodeInfo(this.nodeInfo);
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error initializing swarm object', this.loggerId, ErrorCodes.PEER_CODES.INIT_SWARM, error);
            throw new Error(error);
        }
    };
    Swarm.prototype.updateLeaderScore = function (activeScore) {
        if (activeScore && typeof navigator != 'undefined' && navigator.hardwareConcurrency) {
            this.nodeInfo.setCurrentScore(navigator.hardwareConcurrency);
        }
        else {
            this.nodeInfo.setCurrentScore(1);
        }
        this.logger.debug(this.loggerId + 'My score ' + this.nodeInfo.getCurrentScore());
    };
    Swarm.prototype.getHash = function (eventInfo) {
        return jsrsasign_1.CryptoJS.SHA1(eventInfo).toString(jsrsasign_1.CryptoJS.enc.Hex);
    };
    Swarm.prototype.request = function (request) {
        this.resetRequestTimeout();
        this.hiveCache.request(request);
    };
    Swarm.prototype.toIdle = function () {
        // no need to stop again all services if it was already stopped the session
        if (this.state === Reporting_1.ClientState.STOP) {
            this.logger.debug('Ignoring changing state from Stop to Idle');
            return;
        }
        // stop partnership / prefetching
        this.membership.stop();
        this.partnership.stop();
        this.prefetchManager.stopPeriodicPrefetchEval();
        this.prefetchManager.stopScheduledPrefetches();
        // stop discovery
        this.trackerClient.stopPeriodicAnnounce();
        // stop reporting
        this.reportingInstance.onStateChange(Reporting_1.ClientState.IDLE);
        // We release the already reserved memory since we are on IDLE state
        // remove the already cached fragments from the liveCache
        this.cache.flushCache();
        // remove the already stored chunks from the storage
        this.chunkHandler.flushChunkStore();
        this.hiveCache.abortAll();
        this.snapAccountingManager.stopPeriodicConnInfoAnnouncement();
        // clearing the request timeout for the Idle check
        Framework_1.Framework.clearTimeout(this.requestTimeout);
    };
    Swarm.prototype.onStateChange = function (newState, swarmId) {
        try {
            if (this.state != newState) {
                this.logger.info("Switching state " + Reporting_1.ClientState[this.state] + " -> " + Reporting_1.ClientState[newState]);
                switch (newState) {
                    case Reporting_1.ClientState.STOP:
                        this.toIdle();
                        this.networkManager.stop(swarmId);
                        break;
                    case Reporting_1.ClientState.IDLE:
                        this.toIdle();
                        break;
                    case Reporting_1.ClientState.PLAY:
                        // Start Tracker announcements, membership, partnership, and prefetch
                        // only if P2P is enabled
                        if (PeerConstants_1.PeerConstants.P2P.P2P_ENABLED) {
                            this.trackerClient.startPeriodicAnnounce();
                            this.membership.start();
                            this.partnership.start(this.contextManager.currentContext);
                            this.prefetchManager.startPeriodicPrefetchEval();
                        }
                        this.reportingInstance.onStateChange(Reporting_1.ClientState.PLAY);
                        break;
                }
                this.state = newState;
            }
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error changing peer status', this.loggerId, ErrorCodes.PEER_CODES.SWITCH_STATE, error);
        }
    };
    /**
     * on every player request reset and restart a timer
     * when the timer expires, enter idle state
     */
    Swarm.prototype.resetRequestTimeout = function () {
        var _this = this;
        try {
            Framework_1.Framework.clearTimeout(this.requestTimeout);
            this.onStateChange(Reporting_1.ClientState.PLAY);
            this.requestTimeout = Framework_1.Framework.setTimeout(function () {
                _this.onStateChange(Reporting_1.ClientState.IDLE);
            }, PeerConstants_1.PeerConstants.Peer.DEFAULT_IDLE_TIME_PERIOD);
        }
        catch (e) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error requesting timeout', this.loggerId, ErrorCodes.PEER_CODES.REQUEST_TIMEOUT, e);
        }
    };
    return Swarm;
}());
exports.Swarm = Swarm;
var Peer = /** @class */ (function () {
    function Peer() {
        this.pluginToSwarmMap = new HashMap();
        this.swarmToPluginMap = new HashMap();
        this.reInitializeTrackerManager = false;
        this.trackerManager = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.TRACKER_MANAGER);
        this.connInfoProvider = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.CONNECTIVITY_INFO_PROVIDER);
        this.androidDevice = false;
    }
    Peer.prototype.start = function (reportingInstance, hivejsOptions) {
        this.logger = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.LOGGER).log(reportingInstance.ticket.sessionId);
        var ticket = reportingInstance.ticket;
        var pluginId = ticket.pluginId;
        if (!this.pluginToSwarmMap.has(pluginId)) {
            CustomSnapshotProvider_1.CustomSnapshotProvider.initClient(reportingInstance.trackClient.client, ticket.getEventInfoArray(), reportingInstance.identity.getReportingId());
            var swarm = new Swarm(reportingInstance, hivejsOptions);
            swarm.init(ticket, this.androidDevice);
            this.logger.info('PEER CONTEXT STARTED');
            this.pluginToSwarmMap.set(pluginId, swarm);
            this.swarmToPluginMap.set(swarm.swarmId, pluginId);
        }
        else {
            this.logger.warn('SESSION ALREADY ACTIVE ' + pluginId);
        }
        if ((this.pluginToSwarmMap.length == 1 || this.reInitializeTrackerManager) && !Framework_1.Framework.isSimulated()) {
            this.trackerManager.init();
            this.reInitializeTrackerManager = false;
        }
        return Q.resolve(ticket.getManifestUrl());
    };
    Peer.prototype.serviceClientDisconnected = function () {
        this.reInitializeTrackerManager = true;
    };
    Peer.prototype.getSwarm = function (swarmId) {
        if (this.swarmToPluginMap.has(swarmId)) {
            var pluginId = this.swarmToPluginMap.get(swarmId);
            return this.pluginToSwarmMap.get(pluginId);
        }
        return null;
    };
    Peer.prototype.getSwarmFromPluginId = function (pluginId) {
        return this.pluginToSwarmMap.get(pluginId);
    };
    Peer.prototype.getHiveCache = function (pluginId) {
        if (this.pluginToSwarmMap.has(pluginId)) {
            return this.pluginToSwarmMap.get(pluginId).hiveCache;
        }
        return null;
    };
    Peer.prototype.request = function (request, pluginId) {
        this.getSwarmFromPluginId(pluginId).request(request);
    };
    Peer.prototype.onStateChange = function (pluginId, state) {
        var swarm = this.getSwarmFromPluginId(pluginId);
        if (swarm) {
            swarm.onStateChange(state, swarm.swarmId);
            if (state === Reporting_1.ClientState.STOP)
                this.pluginToSwarmMap.delete(pluginId);
        }
    };
    Peer.prototype.abort = function (request, pluginId) {
        var cache = this.getHiveCache(pluginId);
        if (cache)
            cache.abort(request);
    };
    Peer.prototype.setUpAndroidDevice = function (androidDevice) {
        this.androidDevice = androidDevice;
    };
    return Peer;
}());
exports.Peer = Peer;
//# sourceMappingURL=Peer.js.map

/***/ }),

/***/ "../../../core/build/core/src/webrtc/PeerConstants.js":
/*!*****************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/webrtc/PeerConstants.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.PeerConstants = void 0;
var build_defaults_1 = __webpack_require__(/*! ../common/build.defaults */ "../../../core/build/core/src/common/build.defaults.js");
var Overlay = /** @class */ (function () {
    function Overlay() {
    }
    Overlay.PartnershipOutReqTimeout = 5000;
    Overlay.MaxInPartners = 6;
    Overlay.InPartnerChoiceInterval = 10000;
    Overlay.InPartnerReplacementRatio = 0.2;
    Overlay.MaxOutPartner = 10;
    return Overlay;
}());
var PartnershipConstants = /** @class */ (function () {
    function PartnershipConstants() {
    }
    PartnershipConstants.P2P_PROTOCOL_VERSION = '0.0.1';
    PartnershipConstants.PEER_INFO_ANNOUNCE_INTERVAL = 30000;
    PartnershipConstants.STREAM_POINT_BIASED_MEMBERSIP_TOLERANCE = 4 * 10000000;
    PartnershipConstants.CLOSEST_RATIO = 1.0;
    PartnershipConstants.PARTNER_SHIP_SAME_AS_PROBABILITY = 0.8;
    PartnershipConstants.CHOKING_PREFETCH_USE_BW = false;
    PartnershipConstants.CHOCKING_RANGE = 20000;
    PartnershipConstants.MAX_HANDSHAKE_DELAY = 10000;
    PartnershipConstants.PARTNERSHIP_QUARANTINE_TIME_MS = 300000;
    return PartnershipConstants;
}());
var IpSpoofing = /** @class */ (function () {
    function IpSpoofing() {
    }
    IpSpoofing.ENABLED = build_defaults_1.BuildParameters.IP_SPOOFING_ENABLED;
    IpSpoofing.MAX_NUMBER_OF_PARTNERS = 3;
    IpSpoofing.IP_SPOOFING_VIOLATION_INTERVAL = 10000;
    return IpSpoofing;
}());
var P2P = /** @class */ (function () {
    function P2P() {
    }
    P2P.P2P_ENABLED = true;
    return P2P;
}());
var P2PTimer = /** @class */ (function () {
    function P2PTimer() {
    }
    P2PTimer.FALLBACK_TRANSMISSION_TIME_MULTIPLIER = 1.2;
    P2PTimer.P2P_PREFETCH_MULTIPLIER = 1.5;
    P2PTimer.PARTNER_RATE_MULTIPLIER = 1.2;
    P2PTimer.LOCAL_P2P_TIMER_MULTIPLIER = 0.5;
    return P2PTimer;
}());
var P2PServices = /** @class */ (function () {
    function P2PServices() {
    }
    P2PServices.Discovery = build_defaults_1.BuildParameters.DISCOVERY;
    P2PServices.TrackerRequestInterval = 20000;
    P2PServices.ConnServerReconnectTimer = 5000;
    return P2PServices;
}());
// 412 is the error code for Azure Media Services
// 404 is the error code for West Studio
var CDNErrorCode = /** @class */ (function () {
    function CDNErrorCode() {
    }
    CDNErrorCode.PREFETCH_ERROR_CODES = [412, 404];
    return CDNErrorCode;
}());
var Prefetching = /** @class */ (function () {
    function Prefetching() {
    }
    Prefetching.PREFETCH_ENABLED = true;
    Prefetching.AGGRESSIVE_RANDOM_VALUE = 2000;
    Prefetching.ELECTION_ENABLED = true;
    Prefetching.ELECTION_FORCED = false;
    /**
     * when active stops a site leader prefetching only after two
     * consecutive tracker with non-leader reports
     */
    Prefetching.SMOOTH_LEADER_SWITCH = true;
    Prefetching.MINIMUM_PARTNERS_HAVES = 1;
    Prefetching.PERCENTAGE_OF_PREFETCHERS = 0.04;
    Prefetching.MIN_PREFETCHERS = 2;
    Prefetching.SECOND_TIER_AGENT_ENABLED = true;
    Prefetching.FORCE_FALL_AGENT = false;
    Prefetching.FORCED_FALL_AGENT_IS_FIRST = false;
    Prefetching.FALL_AGENT_RE_EVALUATION_TIMER = 10000;
    Prefetching.QUALITY_LEVEL_ANNOUNCE_INTERVAL = 40000;
    Prefetching.FALL_AGENT_RETRY_DELAY_RND_MAX = 3700;
    Prefetching.FIRST_TIER_MAX_DISTANCE = 20000;
    /**
     * If true, if we have partners from the same ex AS,
     * wait for haves from them for prefetching
     */
    Prefetching.EXTERNAL_AS_PREFERENCE = true;
    /**
     * config the minimum locality level for which the
     * prefetcher should verify that the partner can send
     * the fragment in its own duration time.
     *
     * This is to avoid getting stuck prefetching from somebody
     * with very low throughput.
     *
     * 0 -> check always
     * 1 -> check with at least same SITE prefetch
     * 2 -> check with at least same AS prefetch
     * 3 -> check for all other prefetch
     * 4 -> never check
     */
    Prefetching.PREFETCH_DOWNLOAD_CHECK_MIN_LOCALITY = 2;
    /**
     * the download check verifies that we can download
     * from at least one partner with a speed such as we
     * would retrieve the fragment in less then
     * fragment duration *times* this multiplier
     */
    Prefetching.PREFETCH_DOWNLOAD_CHECK_DURATION_MULTIPLIER = 1.5;
    return Prefetching;
}());
var RequestTracker = /** @class */ (function () {
    function RequestTracker() {
    }
    RequestTracker.ALREADY_REQUESTED_GC = 30;
    RequestTracker.PERIODIC_CHECK_FOR_PENDING_REQUESTS = 20000;
    RequestTracker.EXCEEDED_PENDING_REQUESTS_THRESHOLD = 30000;
    return RequestTracker;
}());
var Cache = /** @class */ (function () {
    function Cache() {
    }
    Cache.Occupancy = 30000000;
    Cache.PurgeTime = 30000;
    Cache.MAXIMUM_CHUNK_STORED_IN_L1 = 10;
    return Cache;
}());
var PerfMetrics = /** @class */ (function () {
    function PerfMetrics() {
    }
    PerfMetrics.NUM_HISTORIC_UPDATES = 3;
    PerfMetrics.USE_PARTIAL_THROUGHPUT_RATE = false;
    PerfMetrics.SCORE_UPDATER_TIME_WINDOW = 30000;
    PerfMetrics.SCORE_FAILURE_MULTIPLIER = 3;
    PerfMetrics.PARTIAL_WEIGHT_SUCCESS = 1 / 5;
    PerfMetrics.PARTIAL_WEIGHT_FAILURE = 1 / 5;
    PerfMetrics.TRANSFER_OBSERVATION_WINDOW = 10000;
    return PerfMetrics;
}());
var HTTP = /** @class */ (function () {
    function HTTP() {
    }
    HTTP.UseRangeRequest = false;
    HTTP.RANGE_REQUEST_RESPONSE_CODE = 206;
    return HTTP;
}());
var Transport = /** @class */ (function () {
    function Transport() {
    }
    Transport.ChunkSize = 64000;
    Transport.TimeOut = 5000;
    Transport.PICKER_ERR_ALPHA = 1;
    Transport.PICKER_ERR_BETA = 1;
    /**
     * use chunk/ack vs webrtc channel buffereAmount to
     * control the sending rate. Use chunk/ack in simulation
     */
    Transport.USE_ACK = false;
    /**
     * switch for giving preference to haves from external AS
     */
    Transport.PICKER_EX_AS_PREFERENCE = true;
    return Transport;
}());
var Membership = /** @class */ (function () {
    function Membership() {
    }
    Membership.RND_VIEW_MAX = 100;
    return Membership;
}());
var Tracker = /** @class */ (function () {
    function Tracker() {
    }
    Tracker.RANDOM_PEERS = 20;
    Tracker.EXTERNAL_PEERS = 20;
    Tracker.SITE_PEERS = 20;
    Tracker.SITE_LEADERS = 5;
    Tracker.TIMEOUT = 60000;
    return Tracker;
}());
var NetworkStats = /** @class */ (function () {
    function NetworkStats() {
    }
    NetworkStats.SITE_TAG = 'site';
    NetworkStats.EXTERNAL_AS_TAG = 'externalAs';
    NetworkStats.SEND_RATE_TAG = 'availableSendRate';
    NetworkStats.REMOTE_ADDRESS_TAG = 'remoteAddress';
    NetworkStats.LOCAL_ADDRESS_TAG = 'localAddress';
    NetworkStats.PERIODIC_UPDATE_INTERVAL = 20000;
    return NetworkStats;
}());
var Peer = /** @class */ (function () {
    function Peer() {
    }
    Peer.DEFAULT_IDLE_TIME_PERIOD = 30000;
    return Peer;
}());
// Instead of sending one message per ICE candidate that we can have,
// we are waiting 300 msec in order to collect all the available ice candidates
// and we send them as using one message. We do this operation in order to offload
// the signaling server
var WebRTC = /** @class */ (function () {
    function WebRTC() {
    }
    WebRTC.COLLECT_ICE_TIMEOUT = 300;
    return WebRTC;
}());
// Constants controlling the custom snapshots behavior
var CustomSnaps = /** @class */ (function () {
    function CustomSnaps() {
    }
    CustomSnaps.P2P_TIMER = false;
    CustomSnaps.LOCAL_SCORE = false;
    return CustomSnaps;
}());
var LocalityScores = /** @class */ (function () {
    function LocalityScores() {
    }
    LocalityScores.SAME_AS = 1;
    LocalityScores.SAME_SITE = 6;
    LocalityScores.SAME_AS_SIMILAR_PR_IP = 12;
    LocalityScores.SAME_QUALITY_LEVEL = 4;
    LocalityScores.MAX_SCORE = 27;
    LocalityScores.UDP_BROADCAST_CLASS = 1 / 2;
    LocalityScores.SAME_SITE_SAME_LAN_MASK_24_CLASS = 1 / 4;
    LocalityScores.SAME_SITE_SAME_LAN_MASK_16_CLASS = 1 / 8;
    LocalityScores.SAME_SITE_CLASS = 1 / 16;
    LocalityScores.SAME_PUBLIC_IP_CLASS = 1 / 32;
    LocalityScores.SAME_AS_CLASS = 1 / 64;
    LocalityScores.RANDOM_CLASS = 1 / 128;
    return LocalityScores;
}());
var FragmentAuthenticator = /** @class */ (function () {
    function FragmentAuthenticator() {
    }
    FragmentAuthenticator.RANGE = 32;
    FragmentAuthenticator.CDN_RANGE_TIMEOUT_MS = 150;
    return FragmentAuthenticator;
}());
var Booster = /** @class */ (function () {
    function Booster() {
    }
    Booster.ACTIVE_DISCOVERY = true;
    Booster.INTERVAL_LAN_VIEWERS_FETCHING = 20000;
    return Booster;
}());
var PeerConstants = /** @class */ (function () {
    function PeerConstants() {
    }
    PeerConstants.Overlay = Overlay;
    PeerConstants.PartnershipConstants = PartnershipConstants;
    PeerConstants.IpSpoofing = IpSpoofing;
    PeerConstants.P2P = P2P;
    PeerConstants.P2PTimer = P2PTimer;
    PeerConstants.P2PServices = P2PServices;
    PeerConstants.CDNErrorCode = CDNErrorCode;
    PeerConstants.Prefetching = Prefetching;
    PeerConstants.RequestTracker = RequestTracker;
    PeerConstants.Cache = Cache;
    PeerConstants.PerfMetrics = PerfMetrics;
    PeerConstants.HTTP = HTTP;
    PeerConstants.Transport = Transport;
    PeerConstants.Membership = Membership;
    PeerConstants.Tracker = Tracker;
    PeerConstants.NetworkStats = NetworkStats;
    PeerConstants.Peer = Peer;
    PeerConstants.WebRTC = WebRTC;
    PeerConstants.CustomSnaps = CustomSnaps;
    PeerConstants.LocalityScores = LocalityScores;
    PeerConstants.Booster = Booster;
    PeerConstants.FragmentAuthenticator = FragmentAuthenticator;
    return PeerConstants;
}());
exports.PeerConstants = PeerConstants;
//# sourceMappingURL=PeerConstants.js.map

/***/ }),

/***/ "../../../core/build/core/src/webrtc/RangeUtils.js":
/*!**************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/webrtc/RangeUtils.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.RangeUtils = exports.HTTPRange = void 0;
var logger_hive_1 = __webpack_require__(/*! ../common/logger.hive */ "../../../core/build/core/src/common/logger.hive.js");
var HTTPRange = /** @class */ (function () {
    function HTTPRange(start, end, total) {
        this.start = start;
        this.end = end;
        this.total = total;
    }
    HTTPRange.prototype.size = function () {
        var gap = this.end - this.start + 1;
        if (!Number.isInteger(gap)) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Segment Size is a Float', { 'size': gap });
            gap = Math.round(gap);
        }
        return (this.end == 0 && this.start == 0) ? 0 : gap;
    };
    HTTPRange.prototype.isComplete = function () {
        return (this.start == 0 && (this.end == this.total - 1 || this.end == this.total && this.total == 0));
    };
    HTTPRange.prototype.isLast = function () {
        return (this.end == this.total - 1 || this.end == this.total && this.total == 0);
    };
    HTTPRange.prototype.overlapping = function (other) {
        return other.start <= this.start && this.start <= other.end;
    };
    HTTPRange.prototype.toString = function () {
        return 'R[S=' + this.start + ',E=' + this.end + ',T=' + this.total + ']';
    };
    return HTTPRange;
}());
exports.HTTPRange = HTTPRange;
var RangeUtils = /** @class */ (function () {
    function RangeUtils() {
    }
    RangeUtils.toBoundaries = function (rangeStr) {
        return rangeStr.split('-');
    };
    RangeUtils.toHTTPRange = function (rangeStr) {
        var splitted = rangeStr.split('=', 4);
        var split1 = splitted[1].substr(0, splitted[1].indexOf(','));
        var split2 = splitted[2].substr(0, splitted[2].indexOf(','));
        var split3 = splitted[3].substr(0, splitted[3].indexOf(']'));
        var start = +(split1);
        var end = +(split2);
        var total = +(split3);
        return new HTTPRange(start, end, total);
    };
    return RangeUtils;
}());
exports.RangeUtils = RangeUtils;
//# sourceMappingURL=RangeUtils.js.map

/***/ }),

/***/ "../../../core/build/core/src/webrtc/RenderStats.js":
/*!***************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/webrtc/RenderStats.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.RenderStats = void 0;
var common_hive_1 = __webpack_require__(/*! ../common/common.hive */ "../../../core/build/core/src/common/common.hive.js");
/**
 * Aggregated the current client statistics into a simple stats object that is exposed
 * to the global defined method 'renderHiveStats'
 */
var RenderStats = /** @class */ (function () {
    function RenderStats(reportingInstance) {
        this.reportingInstance = reportingInstance;
    }
    RenderStats.prototype.updateSummary = function (currentStats) {
        currentStats.uuid = this.reportingInstance.statsStore.myId;
        var traffic = this.reportingInstance.statsStore.totalSnapshot.totalTraffic;
        var p2pReceivedBytes = this.getIFDefined(traffic.p2pSubRespQt);
        var cdnReceivedBytes = this.getIFDefined(traffic.srcRespQt);
        currentStats.cdnRequests += this.getIFDefined(traffic.srcReqN);
        currentStats.cdnResponses += this.getIFDefined(traffic.srcRespN);
        currentStats.cdnResponseErrors += this.getIFDefined(traffic.srcRespErrN);
        currentStats.cdnResponseBytes += this.getIFDefined(traffic.srcRespQt);
        currentStats.p2pRequests += this.getIFDefined(traffic.p2pSubReqN);
        currentStats.p2pResponses += this.getIFDefined(traffic.p2pSubRespN);
        currentStats.p2pResponseErrors += this.getIFDefined(traffic.p2pSubRespErrN);
        currentStats.p2pResponseBytes += this.getIFDefined(traffic.p2pSubRespQt);
        currentStats.savings = this.getIFDefined((p2pReceivedBytes / (cdnReceivedBytes + p2pReceivedBytes)) * 100);
    };
    RenderStats.prototype.getIFDefined = function (num) {
        if (num)
            return num;
        return 0;
    };
    RenderStats.prototype.updatePartners = function (currentStats) {
        var _this = this;
        currentStats.uuid = this.reportingInstance.statsStore.myId;
        var partners = this.reportingInstance.statsStore.totalSnapshot.partnerTraffic;
        var metrics = this.reportingInstance.statsStore.totalSnapshot.partnerMetrics;
        partners.forEach(function (v, k) {
            if (!currentStats.partners[k]) {
                currentStats.partners[k] = new common_hive_1.HivePartnerStats();
            }
            var partner = currentStats.partners[k];
            partner.uuid = k;
            var p2pSuccSent = _this.getIFDefined(v.p2pSuccSent);
            partner.sentBytes += p2pSuccSent;
            currentStats.p2pPartnerTotalSentBytes += p2pSuccSent;
            var p2pSuccReceived = _this.getIFDefined(v.p2pSuccReceived);
            partner.receivedBytes += p2pSuccReceived;
            partner.successTransfers += _this.getIFDefined(v.p2pSuccReq);
            partner.failedTransfers += _this.getIFDefined(v.p2pFailReq);
            if (metrics.has(k))
                partner.rateReceived = metrics.get(k).rateReceived;
            partner.lastUpdated = Date.now();
        });
    };
    RenderStats.prototype.render = function () {
        var renderStatsCallback = this.reportingInstance.renderStatsCallback;
        if (renderStatsCallback) {
            var currentStats = new common_hive_1.HiveClientStats();
            this.updateSummary(currentStats);
            this.updatePartners(currentStats);
            try {
                renderStatsCallback(currentStats);
            }
            catch (e) {
                console.warn('error in rendering local stats', e);
            }
        }
    };
    return RenderStats;
}());
exports.RenderStats = RenderStats;
//# sourceMappingURL=RenderStats.js.map

/***/ }),

/***/ "../../../core/build/core/src/webrtc/RequestDirective.js":
/*!********************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/webrtc/RequestDirective.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.RequestDirective = void 0;
var RequestDirective = /** @class */ (function () {
    function RequestDirective() {
        this.alreadyRequested = false;
        this.pendingRequest = false;
        this.doNotContinue = false;
    }
    return RequestDirective;
}());
exports.RequestDirective = RequestDirective;
//# sourceMappingURL=RequestDirective.js.map

/***/ }),

/***/ "../../../core/build/core/src/webrtc/RequestTracker.js":
/*!******************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/webrtc/RequestTracker.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.RequestTracker = void 0;
var HashMap = __webpack_require__(/*! @hivestreaming/collections/map */ "../../../node_modules/@hivestreaming/collections/map.js");
var PeerConstants_1 = __webpack_require__(/*! ./PeerConstants */ "../../../core/build/core/src/webrtc/PeerConstants.js");
var Framework_1 = __webpack_require__(/*! ../core/Framework */ "../../../core/build/core/src/core/Framework.js");
/**
 * This class maintains all the last 30 requests performed from either the player or the Prefetcher
 * The number 30 is defined in PeerConstants.Prefetching.ALREADY_REQUESTED_GC
 */
var RequestTracker = /** @class */ (function () {
    function RequestTracker() {
        this.alreadyRequested = new HashMap();
        // This list contains all the entityIds of the requests that exist in the alreadyRequested HashMap.
        // We use it in order to create an LRU of the requests and remove the oldest when the garbage collection is performed
        this.alreadyRequestedList = [];
        // There is a connection between pendingRequests and objectsToRequests.
        // The key of the pendingRequests is the requestID which is one of the values of objectsToRequests
        // We initiate the pendingRequests iff the request is ready to be send
        this.pendingRequests = new HashMap();
        // The objectsToRequests start when we initially proceed working with this request (check in cache, etc).
        // Since for the same entity we may have multiple requests, the objectsToRequests format is <entityId, requestId>
        this.objectsToRequests = new HashMap();
    }
    RequestTracker.prototype.init = function (swarm) {
        this.logger = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.LOGGER).log(swarm.sessionId);
        this.hiveCache = swarm.hiveCache;
        this.startPeriodicCheckForPendingRequests();
    };
    RequestTracker.prototype.startPeriodicCheckForPendingRequests = function () {
        var _this = this;
        Framework_1.Framework.setInterval(function () {
            _this.removeExceededPendingRequests();
        }, PeerConstants_1.PeerConstants.RequestTracker.PERIODIC_CHECK_FOR_PENDING_REQUESTS);
    };
    RequestTracker.prototype.removeExceededPendingRequests = function () {
        var _this = this;
        var pendingRequestValues = this.pendingRequests.values();
        var exceededPendingRequests = pendingRequestValues.filter(function (request) {
            return ((Framework_1.Framework.time() - request.requestStats.initialRequestTs) > PeerConstants_1.PeerConstants.RequestTracker.EXCEEDED_PENDING_REQUESTS_THRESHOLD);
        });
        exceededPendingRequests.forEach(function (exceedPendingRequest) {
            _this.hiveCache.abort(exceedPendingRequest.originalRequest);
            // In case of something is broken and the abort never removed the pending request. In theory if we do removed the
            // pending request using the abort function, we should see a warning that we tried to remove an object that does not exist
            _this.removePendingRequest(exceedPendingRequest.getEntityId(), exceedPendingRequest.getRequestId());
        });
    };
    /**
     * This function adds the request to the objectsToRequests HashMap and
     * creates a new pending Request
     * @param request
     */
    RequestTracker.prototype.createPendingRequest = function (request) {
        this.addObjectsToRequests(request.getEntityId(), request.getRequestId());
        this.pendingRequests.set(request.getRequestId(), request);
    };
    /**
     * This function removes a pending request from both the pendingRequests and the objectsToRequests hashMaps
     * @param entityId
     * @param requestId
     */
    RequestTracker.prototype.removePendingRequest = function (entityId, requestId) {
        this.pendingRequests.delete(requestId);
        this.removeObjectsToRequests(entityId, requestId);
    };
    /**
     * This function adds the request to the alreadyRequested hashMap.
     * This happens only when the request is completed and submited
     * @param request
     */
    RequestTracker.prototype.trackRequest = function (request) {
        this.addAlreadyRequested(request);
    };
    /**
     * This function removes the request from the alreadyRequested hashMap.
     * This means that something went wrong with this request
     * @param entityId
     */
    RequestTracker.prototype.removeAlreadyRequested = function (entityId) {
        this.alreadyRequested.delete(entityId);
    };
    /**
     * This function adds a request to the alreadyRequestedHashMap.
     * We have a GarbageCollection in order to limit the size of the HashMap
     * @param request
     */
    RequestTracker.prototype.addAlreadyRequested = function (request) {
        this.alreadyRequested.set(request.getEntityId(), request.getRequestType());
        this.alreadyRequestedList.push(request.getEntityId());
        if (this.alreadyRequested.length > PeerConstants_1.PeerConstants.RequestTracker.ALREADY_REQUESTED_GC) {
            // Retrieve the oldest entityId
            var requestToRemove = this.alreadyRequestedList[0];
            this.alreadyRequested.delete(requestToRemove);
            this.alreadyRequestedList.splice(0, 1);
        }
    };
    /**
     * We check if we have already requested this entityId
     * @param id
     * @returns {boolean}
     */
    RequestTracker.prototype.isAlreadyRequested = function (id) {
        return this.alreadyRequested.has(id);
    };
    /**
     * We return the type of the alreadyRequested request
     * @param id
     * @returns {RequestType}
     */
    RequestTracker.prototype.getAlreadyRequestedType = function (id) {
        return this.alreadyRequested.get(id);
    };
    /**
     * In this function we add a new request to the objectsToRequests hashMap.
     * An entityId can have multiple requests. If this phenomenon keeps going,
     * this means that the upgradePrefetch didn't work and we have a bug :(
     * @param entityId
     * @param requestId
     */
    RequestTracker.prototype.addObjectsToRequests = function (entityId, requestId) {
        if (this.objectsToRequests.has(entityId)) {
            this.objectsToRequests.get(entityId).push(requestId);
        }
        else {
            var newRequestList = [];
            newRequestList.push(requestId);
            this.objectsToRequests.set(entityId, newRequestList);
        }
    };
    /**
     * We remove the specific requestId from the entityId. In general this should remove the complete
     * entityId from the HashMap
     * @param entityId
     * @param requestId
     */
    RequestTracker.prototype.removeObjectsToRequests = function (entityId, requestId) {
        if (!this.objectsToRequests.has(entityId)) {
            this.logger.warn('TRIED TO REMOVE AN OBJECT THAT DOES NOT EXIST');
        }
        else {
            var requestList = this.objectsToRequests.get(entityId);
            var index = requestList.indexOf(requestId);
            if (index == -1) {
                this.logger.warn('I CANNOT FIND THE REQUEST ID ' + requestId);
            }
            else {
                requestList.splice(index, 1);
            }
            if (requestList.length == 0) {
                this.objectsToRequests.delete(entityId);
            }
        }
    };
    /**
     * This function returns all the pending requests for the referred entityId
     * @param entityId
     * @returns {Array}
     */
    RequestTracker.prototype.getPendingRequestsByObject = function (entityId) {
        var request = [];
        if (this.isObjectsToRequests(entityId)) {
            var requestList = this.objectsToRequests.get(entityId);
            for (var i = 0; i < requestList.length; i++) {
                if (this.pendingRequests.has(requestList[i])) {
                    request.push(this.pendingRequests.get(requestList[i]));
                }
            }
        }
        return request;
    };
    /**
     * This function checks if we have pending request(s) for this entityId
     * @param entityId
     * @returns {boolean}
     */
    RequestTracker.prototype.isObjectsToRequests = function (entityId) {
        return this.objectsToRequests.has(entityId);
    };
    /**
     * This function checks if there are pending requests in general.
     * This should not always return true
     * @returns {boolean}
     */
    RequestTracker.prototype.hasPendingRequests = function () {
        return (this.pendingRequests.length == 0) ? false : true;
    };
    /**
     * This function checks if we have pending request(s) for this entityId
     * @param entityId
     * @returns {boolean}
     */
    RequestTracker.prototype.hasPendingRequest = function (entityId) {
        return this.objectsToRequests.has(entityId);
    };
    return RequestTracker;
}());
exports.RequestTracker = RequestTracker;
//# sourceMappingURL=RequestTracker.js.map

/***/ }),

/***/ "../../../core/build/core/src/webrtc/ScoreUpdaterStreaming.js":
/*!*************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/webrtc/ScoreUpdaterStreaming.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ScoreUpdaterStreaming = exports.R = exports.ET = void 0;
var SortedMap = __webpack_require__(/*! @hivestreaming/collections/sorted-map */ "../../../node_modules/@hivestreaming/collections/sorted-map.js");
var Framework_1 = __webpack_require__(/*! ../core/Framework */ "../../../core/build/core/src/core/Framework.js");
var PeerConstants_1 = __webpack_require__(/*! ./PeerConstants */ "../../../core/build/core/src/webrtc/PeerConstants.js");
var ET;
(function (ET) {
    ET[ET["S"] = 0] = "S";
    ET[ET["F"] = 1] = "F";
    ET[ET["PF"] = 2] = "PF";
})(ET = exports.ET || (exports.ET = {}));
var CacheEvent = /** @class */ (function () {
    function CacheEvent(ts) {
        this.ts = ts;
    }
    return CacheEvent;
}());
var R = /** @class */ (function () {
    function R() {
        this.amountTransfered = 0;
        this.successes = 0;
        this.failures = 0;
        this.pFailures = 0;
        this.pFailuresSuccRatio = 0;
        this.pFailuresFailureRatio = 0;
    }
    return R;
}());
exports.R = R;
var ScoreUpdaterStreaming = /** @class */ (function () {
    function ScoreUpdaterStreaming() {
        this.cacheEvents = new SortedMap();
    }
    ScoreUpdaterStreaming.prototype.success = function (receivedAmount) {
        this.event(ET.S, receivedAmount, receivedAmount);
    };
    ScoreUpdaterStreaming.prototype.failed = function () {
        this.event(ET.F, 0, 0);
    };
    ScoreUpdaterStreaming.prototype.partial = function (receivedAmount, totalAmount) {
        this.event(ET.PF, receivedAmount, totalAmount);
    };
    ScoreUpdaterStreaming.prototype.event = function (et, receivedAmount, totalAmount) {
        var cacheEvent = new CacheEvent(Framework_1.Framework.time());
        cacheEvent.t = et;
        cacheEvent.amount = receivedAmount;
        cacheEvent.successRatio = receivedAmount / totalAmount;
        cacheEvent.failureRatio = (totalAmount - receivedAmount) / totalAmount;
        this.cacheEvents.set(cacheEvent.ts, cacheEvent);
        this.GC();
    };
    ScoreUpdaterStreaming.prototype.GC = function () {
        var _this = this;
        var now = Framework_1.Framework.time();
        var minimumTime = now - (PeerConstants_1.PeerConstants.PerfMetrics.SCORE_UPDATER_TIME_WINDOW * 2);
        if (minimumTime > 0) {
            var keysToRemove_1 = [];
            this.cacheEvents.forEach(function (cacheEvent, eventTime) {
                if (eventTime < minimumTime) {
                    keysToRemove_1.push(eventTime);
                }
            });
            keysToRemove_1.forEach(function (key) {
                _this.cacheEvents.delete(key);
            });
        }
    };
    /**
     * Scoring function that returns a value of how good is this partner
     * to send me fragments.
     * In this version the score goes from [-1, 1] and is heavily penalized
     * in case of partial or total failures
     */
    ScoreUpdaterStreaming.prototype.getSuccessScore = function (exact) {
        var ret = 0;
        var r = this.calculateR(exact, PeerConstants_1.PeerConstants.PerfMetrics.SCORE_UPDATER_TIME_WINDOW);
        if (r != null) {
            var all = r.successes + r.failures + r.pFailures;
            ret = all == 0 ? 0 : (r.successes - PeerConstants_1.PeerConstants.PerfMetrics.SCORE_FAILURE_MULTIPLIER * (r.pFailures + r.failures)) /
                (r.successes + PeerConstants_1.PeerConstants.PerfMetrics.SCORE_FAILURE_MULTIPLIER * (r.pFailures + r.failures));
        }
        return ret;
    };
    // TODO WE SHOULD CHANGE THIS. EXACT IS NEVER USED.
    ScoreUpdaterStreaming.prototype.getFailureScore = function (exact) {
        var ret = 0;
        var r = this.calculateR(exact, PeerConstants_1.PeerConstants.PerfMetrics.SCORE_UPDATER_TIME_WINDOW);
        if (r != null) {
            var all = r.successes + r.failures + r.pFailures;
            ret = all == 0 ? 0 : (r.failures + (r.pFailures * PeerConstants_1.PeerConstants.PerfMetrics.PARTIAL_WEIGHT_FAILURE)) / all;
        }
        return ret;
    };
    // getAmountTransfered():number {
    //     var r = this.calculateR(false, PeerConstants.PerfMetrics.SCORE_UPDATER_TIME_WINDOW);
    //     if (r != null) {
    //         return r.amountTransfered;
    //     }
    //     return 0;
    //
    // }
    ScoreUpdaterStreaming.prototype.getAmountTransfered = function (period) {
        var r = this.calculateR(false, period);
        if (r != null) {
            return r.amountTransfered;
        }
        return 0;
    };
    // TODO DO WE NEED TO EXCLUDE RESET?? CACHE EVENTS ALWAYS CONTAINS EVENTS OVER THE LAST SCORE_UPDATER_TIME_WINDOW TIME
    ScoreUpdaterStreaming.prototype.calculateR = function (reset, period) {
        if (this.cacheEvents.keys().length != 0) {
            var r_1 = new R();
            // var now = Framework.time() < PeerConstants.PerfMetrics.SCORE_UPDATER_TIME_WINDOW * 2 ? 2 * PeerConstants.PerfMetrics.SCORE_UPDATER_TIME_WINDOW : Framework.time();
            var now = Framework_1.Framework.time();
            var until_1 = now - period;
            if (until_1 < 0) {
                until_1 = 0;
            }
            var inWindow_1 = new SortedMap();
            this.cacheEvents.forEach(function (v, k) {
                if (k >= until_1)
                    inWindow_1.set(k, v);
            });
            // this.cacheEvents.forEach((v, k) => {
            inWindow_1.forEach(function (v, k) {
                r_1.amountTransfered += v.amount;
                switch (v.t) {
                    case ET.S:
                        r_1.successes++;
                        break;
                    case ET.F:
                        r_1.failures++;
                        break;
                    default:
                        r_1.pFailures++;
                        r_1.pFailuresSuccRatio += v.successRatio;
                        r_1.pFailuresFailureRatio += v.failureRatio;
                        break;
                }
            });
            // if (reset)
            //     this.cacheEvents = inWindow
            return r_1;
        }
        return null;
    };
    ScoreUpdaterStreaming.PARTIAL_WEIGHT_FAILURE = (1 / 5);
    ScoreUpdaterStreaming.PARTIAL_WEIGHT_SUCCESS = (1 / 5);
    return ScoreUpdaterStreaming;
}());
exports.ScoreUpdaterStreaming = ScoreUpdaterStreaming;
//# sourceMappingURL=ScoreUpdaterStreaming.js.map

/***/ }),

/***/ "../../../core/build/core/src/webrtc/SnapshotAccountingManager.js":
/*!*****************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/webrtc/SnapshotAccountingManager.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.SnapshotAccountingManager = void 0;
__webpack_require__(/*! hivejs-protocol/services/metrics_types */ "../../../protocol/services/metrics_types.js");
var Framework_1 = __webpack_require__(/*! ../core/Framework */ "../../../core/build/core/src/core/Framework.js");
var EntityType_1 = __webpack_require__(/*! ../core/entity/EntityType */ "../../../core/build/core/src/core/entity/EntityType.js");
var VideoEntityCharacteristics_1 = __webpack_require__(/*! ../core/entity/video/VideoEntityCharacteristics */ "../../../core/build/core/src/core/entity/video/VideoEntityCharacteristics.js");
var HiveInternalRequest_1 = __webpack_require__(/*! ./HiveInternalRequest */ "../../../core/build/core/src/webrtc/HiveInternalRequest.js");
var DiscoveryInfo_1 = __webpack_require__(/*! ./discovery/DiscoveryInfo */ "../../../core/build/core/src/webrtc/discovery/DiscoveryInfo.js");
var ClientConfigs_1 = __webpack_require__(/*! ./ClientConfigs */ "../../../core/build/core/src/webrtc/ClientConfigs.js");
var PeerConstants_1 = __webpack_require__(/*! ./PeerConstants */ "../../../core/build/core/src/webrtc/PeerConstants.js");
var SnapshotAccountingManager = /** @class */ (function () {
    function SnapshotAccountingManager() {
        this.allowAudioMetricAccounting = ClientConfigs_1.HiveConfig.Stats.AudioAccounting === true;
        this.connInfoInterval = null;
    }
    SnapshotAccountingManager.prototype.init = function (swarm) {
        this.logger = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.LOGGER).log(swarm.sessionId);
        this.connectivityInfo = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.PEER_CONNECTIVITY_INFO);
        this.loggerId = "S[" + swarm.sessionId + "]";
        this.statsStore = swarm.reportingInstance.statsStore;
        this.nodeInfo = swarm.nodeInfo;
    };
    /** ---------- Membership / Partnership ----------- */
    /**
     * Metric snapshot contains the information about how many members
     * the peer currently contains in it's membership.
     * We need to update both the currentSnapshot and the totalSnapshot
     */
    SnapshotAccountingManager.prototype.accountMembershipStats = function (totalNumberOfMembers) {
        this.statsStore.currentSnapshot.metrics.memN = totalNumberOfMembers;
        this.statsStore.totalSnapshot.metrics.memN = totalNumberOfMembers;
    };
    /**
     * Metric snapshots contain the information about the lookup functionality.
     * We always calculate the number of lookup requests that we did.
     * If we never managed to establish a P2PTransport then we assume that we
     * tried to contact a peer that currently does not exist.
     * On the other hand, if we have a P2PTransport but we cannot establish partnership,
     * then we consider it as a failed lookup.
     * Finally, if we manage to establish a partnership we increase the lookupReqEstablished property.
     * @param {boolean} notFound
     * @param {boolean} failed
     */
    SnapshotAccountingManager.prototype.accountInPartnerLookupStats = function (notFound, failed) {
        this.statsStore.currentSnapshot.metrics.lookupTotal++;
        this.statsStore.totalSnapshot.metrics.lookupTotal++;
        if (notFound) {
            this.statsStore.currentSnapshot.metrics.lookupNotFound++;
            this.statsStore.totalSnapshot.metrics.lookupNotFound++;
            this.statsStore.currentSnapshot.metrics.lookupFailed++;
            this.statsStore.totalSnapshot.metrics.lookupFailed++;
        }
        else if (failed) {
            this.statsStore.currentSnapshot.metrics.lookupFailed++;
            this.statsStore.totalSnapshot.metrics.lookupFailed++;
        }
        else {
            this.statsStore.currentSnapshot.metrics.lookupReqEstablished++;
            this.statsStore.totalSnapshot.metrics.lookupReqEstablished++;
        }
    };
    /**
     * Metric snapshots contain the information about the lookup functionality.
     * If someone requested to become our outPartner and we accept it then we increase the number
     * of lookupReqAccept.
     * Otherwise we don't calculate something
     * (TODO We need to know if we rejected someone, especially if it is for IPSpoofing reasons)
     */
    SnapshotAccountingManager.prototype.accountOutPartnerLookupStats = function () {
        // Account the lookup request metrics
        this.statsStore.currentSnapshot.metrics.lookupReqAccept++;
        this.statsStore.totalSnapshot.metrics.lookupReqAccept++;
    };
    /**
     * We calculate the traffic that we had with this partner but we take into account only the
     * requests that we did to him (either direct or prefetch).
     *
     * Moreover, we can exclude the audio metrics from this accounting process (for research purposes only)
     * @param {string} guid
     * @param {number} receivedAmount
     * @param {boolean} isVideo
     * @param {RequestType} requestType
     */
    SnapshotAccountingManager.prototype.accountPartnerRequestCompleted = function (guid, receivedAmount, receivedAmountLow, isVideo, requestType) {
        if (this.allowAudioMetricAccounting || isVideo) {
            var prefetch = requestType == HiveInternalRequest_1.RequestType.P2P_PREFETCH;
            var permanentPartnerTraffic = this.statsStore.getPartnerTrafficStorePermanent(guid);
            var currentPartnerTraffic = this.statsStore.getPartnerTrafficStoreCurrent(guid);
            permanentPartnerTraffic.p2pSuccReq++;
            permanentPartnerTraffic.p2pSuccReceived += receivedAmount;
            currentPartnerTraffic.p2pSuccReq++;
            currentPartnerTraffic.p2pSuccReceived += receivedAmount;
            if (prefetch) {
                permanentPartnerTraffic.p2pSuccReceivedLow += receivedAmount;
                currentPartnerTraffic.p2pSuccReceivedLow += receivedAmount;
            }
            // The receivedAmountLow contains the amount of data we managed to transfer as a prefetch request.
            // Then the upgrade request arrived and changed the ReqType to P2P and not P2P_PREFETCH.
            // In the Prefetcher.upgradePrefetch we calculate the amount of data currently retrieved and store it
            // to request.requestStats.p2pAgenTrafficSuccessQt. Then when we finally manage to retrieve the whole fragment,
            // we calculate how much did we download as a low prio
            if (receivedAmountLow > 0 && !prefetch) {
                permanentPartnerTraffic.p2pSuccReceivedLow += receivedAmount;
                currentPartnerTraffic.p2pSuccReceivedLow += receivedAmount;
            }
        }
    };
    /**
     * We calculate the traffic that we had with this partner and we partially managed to retrieve the fragment.
     *
     * Moreover, we can exclude the audio metrics from this accounting process (for research purposes only)
     * @param {string} guid
     * @param {number} receivedAmount
     * @param {number} totalAmount
     * @param {boolean} isVideo
     * @param {RequestType} requestType
     */
    SnapshotAccountingManager.prototype.accountPartnerRequestPartiallyCompleted = function (guid, receivedAmount, receivedLowAmount, totalAmount, isVideo, requestType) {
        if (this.allowAudioMetricAccounting || isVideo) {
            var prefetch = requestType == HiveInternalRequest_1.RequestType.P2P_PREFETCH;
            var permanentPartnerTraffic = this.statsStore.getPartnerTrafficStorePermanent(guid);
            var currentPartnerTraffic = this.statsStore.getPartnerTrafficStoreCurrent(guid);
            permanentPartnerTraffic.p2pFailReq++;
            permanentPartnerTraffic.p2pSuccReceived += receivedAmount;
            permanentPartnerTraffic.p2pFailReceived += (totalAmount - receivedAmount);
            currentPartnerTraffic.p2pSuccReq++;
            currentPartnerTraffic.p2pSuccReceived += receivedAmount;
            currentPartnerTraffic.p2pFailReceived += (totalAmount - receivedAmount);
            if (prefetch) {
                permanentPartnerTraffic.p2pSuccReceivedLow += receivedAmount;
                currentPartnerTraffic.p2pSuccReceivedLow += receivedAmount;
            }
            // The receivedAmountLow contains the amount of data we managed to transfer as a prefetch request.
            // Then the upgrade request arrived and changed the ReqType to P2P and not P2P_PREFETCH.
            // In the Prefetcher.upgradePrefetch we calculate the amount of data currently retrieved and store it
            // to request.requestStats.p2pAgenTrafficSuccessQt. Then when we finally manage to retrieve the whole fragment,
            // we calculate how much did we download as a low prio
            if (receivedLowAmount > 0 && !prefetch) {
                permanentPartnerTraffic.p2pSuccReceivedLow += receivedAmount;
                currentPartnerTraffic.p2pSuccReceivedLow += receivedAmount;
            }
        }
    };
    /**
     * We calculate the failed requests that we had with this partner but we take into account only the requests
     * that we did. Not the requests that he did to us.
     * @param {string} guid
     * @param {number} total
     * @param {boolean} accountAudioMetrics
     */
    SnapshotAccountingManager.prototype.accountPartnerRequestFailed = function (guid, total, isVideo) {
        if (this.allowAudioMetricAccounting || isVideo) {
            var permanentPartnerTraffic = this.statsStore.getPartnerTrafficStorePermanent(guid);
            var currentPartnerTraffic = this.statsStore.getPartnerTrafficStoreCurrent(guid);
            permanentPartnerTraffic.p2pFailReq++;
            permanentPartnerTraffic.p2pFailReceived += total;
            currentPartnerTraffic.p2pFailReq++;
            currentPartnerTraffic.p2pFailReceived += total;
        }
    };
    /**
     * We calculate the number of responses that we successfully accomplished to the partner partnerGuid.
     * We also calculate the number of bytes that we send
     * @param {number} amountSent
     * @param {string} partnerGuid
     * @param {boolean} accountAudioMetrics
     */
    SnapshotAccountingManager.prototype.accountPartnerResponseCompleted = function (amountSent, partnerGuid, isVideo) {
        if (this.allowAudioMetricAccounting || isVideo) {
            var permanentPartnerTraffic = this.statsStore.getPartnerTrafficStorePermanent(partnerGuid);
            var currentPartnerTraffic = this.statsStore.getPartnerTrafficStoreCurrent(partnerGuid);
            permanentPartnerTraffic.p2pSuccResp++;
            permanentPartnerTraffic.p2pSuccSent += amountSent;
            currentPartnerTraffic.p2pSuccResp++;
            currentPartnerTraffic.p2pSuccSent += amountSent;
        }
    };
    /**
     * We calculate the number of partial responses that we had to this specific partnerGuid
     * @param {number} amountSent
     * @param {number} total
     * @param {string} partnerGuid
     * @param {boolean} accountAudioMetrics
     */
    SnapshotAccountingManager.prototype.accountPartnerResponsePartiallyCompleted = function (amountSent, total, partnerGuid, isVideo) {
        if (this.allowAudioMetricAccounting || isVideo) {
            var permanentPartnerTraffic = this.statsStore.getPartnerTrafficStorePermanent(partnerGuid);
            var currentPartnerTraffic = this.statsStore.getPartnerTrafficStoreCurrent(partnerGuid);
            permanentPartnerTraffic.p2pPartResp++;
            permanentPartnerTraffic.p2pSuccSent += amountSent;
            permanentPartnerTraffic.p2pFailSent += (total - amountSent);
            currentPartnerTraffic.p2pPartResp++;
            currentPartnerTraffic.p2pSuccSent += amountSent;
            currentPartnerTraffic.p2pFailSent += (total - amountSent);
        }
    };
    /**
     * We calculate the number of failed responses to this specific partnerGuid.
     * We account this only when the other partner sends us a cancel request to the transfer of this fragment
     * @param {number} total
     * @param {string} partnerGuid
     * @param {boolean} accountAudioMetrics
     */
    SnapshotAccountingManager.prototype.accountPartnerResponseFailed = function (total, partnerGuid, isVideo) {
        if (this.allowAudioMetricAccounting || isVideo) {
            var permanentPartnerTraffic = this.statsStore.getPartnerTrafficStorePermanent(partnerGuid);
            var currentPartnerTraffic = this.statsStore.getPartnerTrafficStoreCurrent(partnerGuid);
            permanentPartnerTraffic.p2pFailResp++;
            permanentPartnerTraffic.p2pFailSent += total;
            currentPartnerTraffic.p2pFailResp++;
            currentPartnerTraffic.p2pFailSent += total;
        }
    };
    /** ---------- Traffic ----------- */
    SnapshotAccountingManager.prototype.accountQualityLevelSwitch = function (qualityLevelUp) {
        if (qualityLevelUp) {
            this.statsStore.currentSnapshot.metrics.bitrateUpN++;
        }
        else {
            this.statsStore.currentSnapshot.metrics.bitrateDwnN++;
        }
    };
    /**
     * In this function we account only the number of requests that the player performed.
     * We distinguish the playlist requests from the actual fragment requests in order to increase
     * the proper counters.
     *
     * WE INCREASE THE REQN ONLY FOR FRAGMENT REQUESTS FROM THE PLAYER
     * for the respective quality level.
     * @param {EntityCharacteristics} entityCharacteristics
     */
    SnapshotAccountingManager.prototype.accountPlayerRequest = function (entityCharacteristics) {
        var _a = this.allowAccounting(entityCharacteristics), isMetadata = _a.isMetadata, isVideo = _a.isVideo, allowAccounting = _a.allowAccounting;
        if (isMetadata) {
            this.statsStore.getTotalTrafficStorePermanent().reqOtherN++;
            this.statsStore.getTotalTrafficStoreCurrent().reqOtherN++;
        }
        else if (allowAccounting) {
            this.statsStore.getTotalTrafficStorePermanent().reqN++;
            this.statsStore.getTotalTrafficStoreCurrent().reqN++;
            if (isVideo) {
                var videoE = entityCharacteristics;
                if (videoE.getQualityLevel()) {
                    var qualityLevel = videoE.getQualityLevel();
                    this.statsStore.getPermanentTrafficStoreQualityLevel(qualityLevel).reqN++;
                    this.statsStore.getCurrentTrafficStoreQualityLevel(qualityLevel).reqN++;
                }
            }
        }
    };
    SnapshotAccountingManager.prototype.allowAccounting = function (entity) {
        var isMetadata = [EntityType_1.EntityType.METADATA, EntityType_1.EntityType.OTHER].indexOf(entity.getEntityType()) !== -1;
        var isVideo = entity.getEntityType() === EntityType_1.EntityType.VIDEO;
        var isAudio = entity.getEntityType() === EntityType_1.EntityType.AUDIO;
        // We calculate ONLY the video/audio fragment requests that we do to the CDN.
        // This includes both requests from the player and prefetch requests
        var allowAccounting = isVideo || this.allowAudioMetricAccounting && isAudio;
        return { allowAccounting: allowAccounting, isMetadata: isMetadata, isVideo: isVideo };
    };
    /**
     * In this function we account ONLY the video/audio requests that we perform to the CDN.
     * This means that we need to distinquish the actual player requests and the CDN prefetch requests
     * @param {HiveInternalRequest} request
     */
    SnapshotAccountingManager.prototype.accountFallbackRequest = function (request) {
        var _a = this.allowAccounting(request), isVideo = _a.isVideo, allowAccounting = _a.allowAccounting;
        if (allowAccounting) {
            var totalStorePermanent = this.statsStore.getTotalTrafficStorePermanent();
            var totalStoreCurrent = this.statsStore.getTotalTrafficStoreCurrent();
            var totalStorePermanentQualityLevel = null;
            var totalStoreCurrentQualityLevel = null;
            totalStorePermanent.srcReqN++;
            totalStoreCurrent.srcReqN++;
            if (isVideo) {
                var qualityLevel = this.getStreamQualityLevel(request);
                if (qualityLevel) {
                    totalStorePermanentQualityLevel = this.statsStore.getPermanentTrafficStoreQualityLevel(qualityLevel);
                    totalStoreCurrentQualityLevel = this.statsStore.getCurrentTrafficStoreQualityLevel(qualityLevel);
                    totalStorePermanentQualityLevel.srcReqN++;
                    totalStoreCurrentQualityLevel.srcReqN++;
                }
            }
            // If we request a fragment as a CDN_PREFETCH then we need to increase the
            // srcOtherReqN
            if (request.getRequestType() === HiveInternalRequest_1.RequestType.CDN_PREFETCH) {
                totalStorePermanent.srcOtherReqN++;
                totalStoreCurrent.srcOtherReqN++;
                if (isVideo) {
                    var qualityLevel = this.getStreamQualityLevel(request);
                    if (qualityLevel) {
                        totalStorePermanentQualityLevel.srcOtherReqN++;
                        totalStoreCurrentQualityLevel.srcOtherReqN++;
                    }
                }
            }
        }
    };
    /**
     * In this function we caclulate the p2p requests that we perform. It is only the requests.
     * We don't calculate the responses.
     * @param {HiveInternalRequest} request
     */
    SnapshotAccountingManager.prototype.accountP2PRequest = function (request) {
        // In theory this should be a partial P2P request, something that we do not support on Hive Web.
        // As such, we increase the p2pSubReqN by 1.
        this.statsStore.getTotalTrafficStorePermanent().p2pSubReqN++;
        this.statsStore.getTotalTrafficStoreCurrent().p2pSubReqN++;
        var isVideo = request.getEntityType() == EntityType_1.EntityType.VIDEO;
        if (isVideo) {
            var qualityLevel = this.getStreamQualityLevel(request);
            if (qualityLevel) {
                this.statsStore.getPermanentTrafficStoreQualityLevel(qualityLevel).p2pSubReqN++;
                this.statsStore.getCurrentTrafficStoreQualityLevel(qualityLevel).p2pSubReqN++;
            }
        }
    };
    /**
     * Whenever we have a response for video/audio fragments (NO METADATA), we need to
     * calculate all the traffic that we had.
     *
     * @param {HiveInternalRequest} request
     * @param {number} cdnBitps
     */
    SnapshotAccountingManager.prototype.accountTrafficResponse = function (request, cdnBitps) {
        this.accountTrafficStats(request, this.statsStore.getTotalTrafficStoreCurrent());
        this.accountTrafficStats(request, this.statsStore.getTotalTrafficStorePermanent());
        //
        var qualityLevel = this.getStreamQualityLevel(request);
        if (qualityLevel && request.getEntityType() === EntityType_1.EntityType.VIDEO && this.nodeInfo.getWatchingQualityLevel().id === qualityLevel.id) {
            this.accountTrafficStats(request, this.statsStore.getPermanentTrafficStoreQualityLevel(qualityLevel));
            this.accountTrafficStats(request, this.statsStore.getCurrentTrafficStoreQualityLevel(qualityLevel));
        }
        if (!isNaN(cdnBitps)) {
            this.statsStore.currentSnapshot.metrics.srcThroughput = cdnBitps;
        }
    };
    /**
     * When we have a successful response from the CDN, we
     * check if it is for a metadata request and we increase the respFallbackOtherN.
     * Otherwise, if it is for video,audio fragments we let the accountTrafficResponse to increase the proper counters.
     * @param {HiveInternalRequest} request
     * @param {number} cdnBitps
     */
    SnapshotAccountingManager.prototype.accountFallbackRequestSuccessful = function (request, cdnBitps) {
        var _a = this.allowAccounting(request), isMetadata = _a.isMetadata, allowAccounting = _a.allowAccounting;
        if (isMetadata) {
            this.statsStore.getTotalTrafficStorePermanent().respFallbackOtherN++;
            this.statsStore.getTotalTrafficStoreCurrent().respFallbackOtherN++;
        }
        else if (allowAccounting) {
            this.accountTrafficResponse(request, cdnBitps);
        }
    };
    /**
     * In this function we calculate all the failed requests that we did to the CDN.
     * This also includes 412.
     * @param {HiveInternalRequest} request
     * @param {number} cdnBitps
     */
    SnapshotAccountingManager.prototype.accountFallbackRequestFailure = function (request, cdnBitps) {
        // account for metadata/other failure
        var _a = this.allowAccounting(request), isMetadata = _a.isMetadata, isVideo = _a.isVideo, allowAccounting = _a.allowAccounting;
        if (isMetadata) {
            this.statsStore.getTotalTrafficStorePermanent().respFallbackOthertErrN++;
            this.statsStore.getTotalTrafficStoreCurrent().respFallbackOthertErrN++;
        }
        else if (allowAccounting) {
            if (this.isNotPrefetch(request.type)) {
                this.accountNonPrefetchFallbackRequestFailure(request, cdnBitps, isVideo);
            }
            else {
                // If we receive a 412, then we need to increse the fallAgentFailedRespN.
                // Moreover, we need to reduce the number of requests in order not to create insights confusion.
                // Again fro insights reasons, we do not do any traffic accounting
                this.accountPrefetchFallbackRequestFailure(request, cdnBitps, isVideo);
            }
        }
    };
    SnapshotAccountingManager.prototype.accountPrefetchFallbackRequestFailure = function (request, cdnBitps, isVideo) {
        // We cannot have 412 on non CDN_PREFETCH requests
        if (request.type == HiveInternalRequest_1.RequestType.CDN_PREFETCH && PeerConstants_1.PeerConstants.CDNErrorCode.PREFETCH_ERROR_CODES.indexOf(request.originalRequest.status) != -1) {
            this.statsStore.getTotalTrafficStorePermanent().fallAgentFailedRespN++;
            this.statsStore.getTotalTrafficStoreCurrent().fallAgentFailedRespN++;
            this.statsStore.getTotalTrafficStorePermanent().reqN--;
            this.statsStore.getTotalTrafficStoreCurrent().reqN--;
        }
        else {
            // If we fail to download a fragment from the CDN and we didn't receive anything, then the accountTrafficStats
            // will be in a situation where totalCDN == 0 and we will never enter the if statement.
            // Therefore, we will never increase the srcOtherRespErrN.
            if (request.requestStats.totalFromFallback == 0) {
                this.statsStore.getTotalTrafficStorePermanent().srcOtherRespErrN++;
                this.statsStore.getTotalTrafficStoreCurrent().srcOtherRespErrN++;
            }
            if (isVideo) {
                var qualityLevel = this.getStreamQualityLevel(request);
                if (qualityLevel && request.getEntityType() === EntityType_1.EntityType.VIDEO) {
                    this.statsStore.getPermanentTrafficStoreQualityLevel(qualityLevel).srcOtherRespErrN++;
                    this.statsStore.getCurrentTrafficStoreQualityLevel(qualityLevel).srcOtherRespErrN++;
                }
            }
            this.accountTrafficResponse(request, cdnBitps);
        }
    };
    SnapshotAccountingManager.prototype.accountNonPrefetchFallbackRequestFailure = function (request, cdnBitps, isVideo) {
        this.statsStore.getTotalTrafficStoreCurrent().respFallbackErrN++;
        this.statsStore.getTotalTrafficStorePermanent().respFallbackErrN++;
        if (isVideo) {
            var qualityLevel = this.getStreamQualityLevel(request);
            if (qualityLevel) {
                this.statsStore.getPermanentTrafficStoreQualityLevel(qualityLevel).respFallbackErrN++;
                this.statsStore.getCurrentTrafficStoreQualityLevel(qualityLevel).respFallbackErrN++;
            }
        }
        // If we fail to download a fragment from the CDN and we didn't receive anything, then the accountTrafficStats
        // will be in a situation where totalCDN == 0 and we will never enter the if statement.
        // Therefore, we will never increase the srcRespErrN.
        if (request.requestStats.totalFromFallback == 0) {
            this.statsStore.getTotalTrafficStoreCurrent().srcRespErrN++;
            this.statsStore.getTotalTrafficStorePermanent().srcRespErrN++;
            if (isVideo) {
                var qualityLevel = this.getStreamQualityLevel(request);
                if (qualityLevel && request.getEntityType() === EntityType_1.EntityType.VIDEO) {
                    this.statsStore.getPermanentTrafficStoreQualityLevel(qualityLevel).srcRespErrN++;
                    this.statsStore.getCurrentTrafficStoreQualityLevel(qualityLevel).srcRespErrN++;
                }
            }
        }
        this.accountTrafficResponse(request, cdnBitps);
    };
    /**
     * In this function we need to calculate all the requests that the player did and we have them already in our cache.
     * When we retrieve the rangeContent from our cache, we know how we downloaded this fragment (ReqType)
     * @param {HiveInternalRequest} request
     * @param {RangeContent} rangeContent
     */
    SnapshotAccountingManager.prototype.accountFragmentAlreadyCached = function (request, rangeContent) {
        var isVideo = request.getEntityType() == EntityType_1.EntityType.VIDEO;
        var qualityLevel = this.getStreamQualityLevel(request);
        if (rangeContent.requestType == HiveInternalRequest_1.RequestType.P2P_PREFETCH) {
            this.statsStore.getTotalTrafficStoreCurrent().respP2pN++;
            this.statsStore.getTotalTrafficStorePermanent().respP2pN++;
            if (isVideo && qualityLevel) {
                this.statsStore.getPermanentTrafficStoreQualityLevel(qualityLevel).respP2pN++;
                this.statsStore.getCurrentTrafficStoreQualityLevel(qualityLevel).respP2pN++;
            }
        }
        else if (rangeContent.requestType == HiveInternalRequest_1.RequestType.CDN_PREFETCH) {
            this.statsStore.getTotalTrafficStoreCurrent().respFallbackN++;
            this.statsStore.getTotalTrafficStorePermanent().respFallbackN++;
            if (isVideo && qualityLevel) {
                this.statsStore.getPermanentTrafficStoreQualityLevel(qualityLevel).respFallbackN++;
                this.statsStore.getCurrentTrafficStoreQualityLevel(qualityLevel).respFallbackN++;
            }
            // We have seen players re-requesting the same exact fragment.
            // In case the player, requested a fragment as an UPPER_LAYER request and we have it in cache,
            // we need to increase the lCacheRespN and lCacheRespQt in order to analyze it further.
        }
        else if (rangeContent.requestType == HiveInternalRequest_1.RequestType.UPPER_LAYER) {
            this.statsStore.getTotalTrafficStoreCurrent().lCacheRespN++;
            this.statsStore.getTotalTrafficStorePermanent().lCacheRespN++;
            var rangeContentSize = (Framework_1.Framework.isSimulated() ? rangeContent.length : request.binaryData.byteLength);
            this.statsStore.getTotalTrafficStoreCurrent().lCacheRespQt += rangeContentSize;
            this.statsStore.getTotalTrafficStorePermanent().lCacheRespQt += rangeContentSize;
            if (isVideo && qualityLevel) {
                this.statsStore.getPermanentTrafficStoreQualityLevel(qualityLevel).lCacheRespN++;
                this.statsStore.getCurrentTrafficStoreQualityLevel(qualityLevel).lCacheRespN++;
                this.statsStore.getPermanentTrafficStoreQualityLevel(qualityLevel).lCacheRespQt += rangeContentSize;
                this.statsStore.getCurrentTrafficStoreQualityLevel(qualityLevel).lCacheRespQt += rangeContentSize;
            }
        }
    };
    SnapshotAccountingManager.prototype.accountP2PRequestSuccessful = function (request, cdnBitps) {
        var notAudio = request.getEntityType() != EntityType_1.EntityType.AUDIO;
        if ((this.allowAudioMetricAccounting || notAudio)) {
            this.accountTrafficResponse(request, cdnBitps);
        }
        // account the rate in the persistent metrics for renderStats
        var metrics = new hive.snapshots.PartnerMetrics();
        metrics.rateReceived = request.partner.getRcvRatesAvg();
        this.statsStore.totalSnapshot.partnerMetrics.set(request.partner.reportingGuid, metrics);
    };
    SnapshotAccountingManager.prototype.accountP2PResponseFailure = function (request) {
        // We need to increase the p2pSubRespErrN only if we have partial downloads.
        if (request.rcvMesgLength != 0) {
            this.statsStore.getTotalTrafficStorePermanent().p2pSubRespErrN++;
            this.statsStore.getTotalTrafficStoreCurrent().p2pSubRespErrN++;
            var isVideo = request.getEntityType() == EntityType_1.EntityType.VIDEO;
            if (isVideo) {
                var qualityLevel = this.getStreamQualityLevel(request);
                if (qualityLevel) {
                    this.statsStore.getPermanentTrafficStoreQualityLevel(qualityLevel).p2pSubRespErrN++;
                    this.statsStore.getCurrentTrafficStoreQualityLevel(qualityLevel).p2pSubRespErrN++;
                }
            }
        }
    };
    SnapshotAccountingManager.prototype.accountP2PRequestExpired = function (request) {
        this.statsStore.getTotalTrafficStorePermanent().p2pSubRespExpN++;
        this.statsStore.getTotalTrafficStoreCurrent().p2pSubRespExpN++;
        var isVideo = request.getEntityType() == EntityType_1.EntityType.VIDEO;
        if (isVideo) {
            var qualityLevel = this.getStreamQualityLevel(request);
            if (qualityLevel) {
                this.statsStore.getPermanentTrafficStoreQualityLevel(qualityLevel).p2pSubRespExpN++;
                this.statsStore.getCurrentTrafficStoreQualityLevel(qualityLevel).p2pSubRespExpN++;
            }
        }
    };
    SnapshotAccountingManager.prototype.accountTrafficStats = function (request, traffic) {
        var total = request.requestStats.totalDownloaded;
        var totalCDN = request.requestStats.totalFromFallback;
        var totalP2P = request.requestStats.totalFromP2P;
        var p2pBeforeCompensation = request.requestStats.p2pBeforeCompensation;
        var totalDisk = request.requestStats.totalFromDisk;
        if (request.getEntityType() != EntityType_1.EntityType.METADATA) {
            // if it started as p2p request and it didn't get everything,
            // account it as failure.
            if (request.requestStats.p2pRequest && p2pBeforeCompensation && p2pBeforeCompensation < total) {
                var downloadedRatio = p2pBeforeCompensation / total;
                traffic.p2pSubRespPartN += downloadedRatio;
                if (!this.isNotPrefetch(request.type)) {
                    traffic.p2pAgenTrafficFailureQt += (total - totalP2P);
                }
            }
            if (totalDisk != 0) {
                if (totalDisk == total) {
                    traffic.lCacheRespN++;
                }
                traffic.lCacheRespQt += request.requestStats.totalFromDisk;
            }
            if (totalP2P != 0) {
                if (totalP2P == total) {
                    // We calculate the respP2pN here only for the upper layer requests.
                    // When we download a fragment as a prefetch, we calculate the succesful p2p request
                    // only when the player requests it
                    if (this.isNotPrefetch(request.type)) {
                        traffic.respP2pN++;
                    }
                    traffic.p2pSubRespN++;
                }
                traffic.p2pSubReqQt += total;
                traffic.p2pSubRespQt += totalP2P;
                traffic.p2pAgenTrafficSuccessQt += request.requestStats.p2pAgenTrafficSuccessQt;
                traffic.p2pDirectQt += totalP2P;
                // we are in the same UDP range, we increment UDP traffic and SITE traffic
                if (request.partner.member.peerInfo.type == DiscoveryInfo_1.DiscoveryType.UDP) {
                    traffic.p2pUdpbQt += totalP2P;
                    traffic.p2pNatQt += totalP2P;
                }
                else {
                    // check if we are in the same site
                    var mySite = this.connectivityInfo.getNetworkInfo().getSiteId();
                    if (mySite && mySite > 0) {
                        if (request.partnerInfo != null) {
                            var partIAs = request.partnerInfo.internalAs;
                            if (mySite === partIAs) {
                                traffic.p2pNatQt += totalP2P;
                            }
                        }
                        else {
                            this.logger.warn('Missing partner info');
                        }
                    }
                }
            }
        }
        if (totalCDN != 0) {
            if (this.isPrefetch(request.type)) {
                traffic.srcOtherReqQt += request.requestStats.totalFromFallback;
            }
            if (totalCDN == total) {
                if (this.isPrefetch(request.type)) {
                    traffic.srcOtherRespN++;
                    traffic.srcOtherRespQt += request.requestStats.totalFromFallback;
                    traffic.srcOtherOverQt += request.requestStats.totalFromFallback;
                    traffic.fallAgentRespN++;
                }
                else {
                    // We calculate the respFallbackN here only for the upper layer requests.
                    // When we download a fragment as a prefetch, we calculate the succesful fallback request
                    // only when the player requests it
                    traffic.respFallbackN++;
                }
                traffic.srcRespN++;
            }
            else {
                traffic.srcRespErrN++;
                var cdnPerc = totalCDN / (totalP2P + totalCDN);
                traffic.respFallbackN = cdnPerc;
                traffic.respP2pN = 1 - cdnPerc;
                if (this.isPrefetch(request.type)) {
                    traffic.srcOtherRespErrN++;
                    traffic.srcOtherRespQt += request.requestStats.totalFromFallback;
                    traffic.srcOtherOverQt += request.requestStats.totalFromFallback;
                    traffic.fallAgenTrafficFailureQt += request.requestStats.totalFromFallback;
                }
            }
            traffic.srcReqQt += request.requestStats.totalFromFallback;
            traffic.srcRespQt += request.requestStats.totalFromFallback;
            traffic.srcOverQt += request.requestStats.totalFromFallback;
            if (this.isPrefetch(request.type)) {
                traffic.fallAgenTrafficSuccessQt += request.requestStats.cdnAgenTrafficSuccessQt;
            }
        }
    };
    SnapshotAccountingManager.prototype.getStreamQualityLevel = function (request) {
        var qualityLevel = null;
        if (request.entityCharacteristics instanceof VideoEntityCharacteristics_1.VideoEntityCharacteristics) {
            var videoE = request.entityCharacteristics;
            if (videoE.getQualityLevel()) {
                qualityLevel = videoE.getQualityLevel();
            }
        }
        return qualityLevel;
    };
    SnapshotAccountingManager.prototype.isNotPrefetch = function (type) {
        return type != HiveInternalRequest_1.RequestType.P2P_PREFETCH && type != HiveInternalRequest_1.RequestType.CDN_PREFETCH;
    };
    SnapshotAccountingManager.prototype.isPrefetch = function (type) {
        return !this.isNotPrefetch(type);
    };
    SnapshotAccountingManager.prototype.stopPeriodicConnInfoAnnouncement = function () {
        Framework_1.Framework.clearInterval(this.connInfoInterval);
        this.connInfoInterval = null;
    };
    return SnapshotAccountingManager;
}());
exports.SnapshotAccountingManager = SnapshotAccountingManager;
//# sourceMappingURL=SnapshotAccountingManager.js.map

/***/ }),

/***/ "../../../core/build/core/src/webrtc/StreamHealthChecker.js":
/*!***********************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/webrtc/StreamHealthChecker.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.StreamHealthChecker = void 0;
var error_hive_1 = __webpack_require__(/*! ../common/error.hive */ "../../../core/build/core/src/common/error.hive.js");
var ErrorCodes = __webpack_require__(/*! ../common/error.hive */ "../../../core/build/core/src/common/error.hive.js");
var Framework_1 = __webpack_require__(/*! ../core/Framework */ "../../../core/build/core/src/core/Framework.js");
var basicutils_hive_1 = __webpack_require__(/*! ../common/basicutils.hive */ "../../../core/build/core/src/common/basicutils.hive.js");
var logger_hive_1 = __webpack_require__(/*! ../common/logger.hive */ "../../../core/build/core/src/common/logger.hive.js");
var HIVE_STREAM_CHECKER_CODES = ErrorCodes.HIVE_STREAM_CHECKER_CODES;
var EntityType_1 = __webpack_require__(/*! ../core/entity/EntityType */ "../../../core/build/core/src/core/entity/EntityType.js");
var LOG_LEVEL;
(function (LOG_LEVEL) {
    LOG_LEVEL[LOG_LEVEL["INFO"] = 0] = "INFO";
    LOG_LEVEL[LOG_LEVEL["WARN"] = 1] = "WARN";
    LOG_LEVEL[LOG_LEVEL["ERROR"] = 2] = "ERROR";
})(LOG_LEVEL || (LOG_LEVEL = {}));
var StreamHealthChecker = /** @class */ (function () {
    function StreamHealthChecker(metadata) {
        this.alerts = [];
        this.metadata = metadata;
        this.logger = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.LOGGER).log();
    }
    /** Called when the metadata object has been updated by the HLS|DashContext */
    StreamHealthChecker.prototype.metadataUpdated = function () {
        var qualityLevels = this.metadata.availableQualityLevels(EntityType_1.EntityType.VIDEO);
        var qualityLevelCount = qualityLevels.length;
        var isLive = this.metadata.isLive();
        /**
         * The metadata update happens multiple times for HLS: once for master (with isLive being undefined),
         * and again for each chunklist. We will use the `isLive` property to determine if we've analyzed the
         * stream already.
         * However, `isLive` would never be set if no chunklist was downloaded (eg. no available bitrates).
         * We need an explicit check for that as well
         */
        if (qualityLevelCount === 0 || typeof isLive !== 'undefined') {
            for (var i = 0; i < StreamHealthChecker.NUM_BITRATE_STEPS.length; i++) {
                var _a = StreamHealthChecker.NUM_BITRATE_STEPS[i], numQualityLevelCheck = _a[0], errorCode = _a[1], logLevel = _a[2];
                // Check the number of quality levels
                if (qualityLevelCount <= numQualityLevelCheck) {
                    // only alert if haven't alerted already
                    if (this.alerts.indexOf(errorCode) === -1) {
                        // Generate log message
                        var bitrateList = qualityLevels.map(function (qualityLevel) { return basicutils_hive_1.toHumanReadable(qualityLevel.bitrate) + '/s'; }).join(', ');
                        var message = StreamHealthChecker.LOGGER_ID + basicutils_hive_1.stringFormat(error_hive_1.ErrorMessages[errorCode], isLive ? 'Live' : 'VOD', qualityLevelCount, bitrateList);
                        switch (logLevel) {
                            case LOG_LEVEL.INFO:
                                this.logger.info(message);
                                break;
                            case LOG_LEVEL.WARN:
                                this.logger.warn(message);
                                break;
                            default:
                                this.logger.error(message);
                                // Generate atatus error message
                                var atatusErrorCode = qualityLevelCount === 0 ? HIVE_STREAM_CHECKER_CODES.NUM_BITRATES_ATATUS_ERROR_NONE : HIVE_STREAM_CHECKER_CODES.NUM_BITRATES_ATATUS_ERROR_HIGH;
                                logger_hive_1.ErrorMonitor.getInstance().logError(error_hive_1.ErrorMessages[atatusErrorCode], StreamHealthChecker.LOGGER_ID, atatusErrorCode, { isLive: isLive, qualityLevels: qualityLevels });
                        }
                        this.alerts.push(errorCode);
                    }
                    break;
                }
            }
        }
        // Check for too high bitrates
        if (this.alerts.indexOf(HIVE_STREAM_CHECKER_CODES.BITRATE_TOO_HIGH) === -1) {
            var hasTooHighBitrate = false;
            for (var i = 0; i < qualityLevels.length; i++) {
                var qualityLevel = qualityLevels[i];
                if (qualityLevel.bitrate > StreamHealthChecker.WARNING_OVER_BITRATE) {
                    hasTooHighBitrate = true;
                    var message = StreamHealthChecker.LOGGER_ID + basicutils_hive_1.stringFormat(error_hive_1.ErrorMessages[ErrorCodes.HIVE_STREAM_CHECKER_CODES.BITRATE_TOO_HIGH], basicutils_hive_1.toHumanReadable(qualityLevel.bitrate), basicutils_hive_1.toHumanReadable(StreamHealthChecker.WARNING_OVER_BITRATE));
                    this.logger.warn(message);
                    break;
                }
            }
            if (hasTooHighBitrate) {
                this.alerts.push(HIVE_STREAM_CHECKER_CODES.BITRATE_TOO_HIGH);
            }
        }
    };
    StreamHealthChecker.prototype.reset = function () {
        this.alerts.length = 0;
    };
    StreamHealthChecker.LOGGER_ID = '[StreamHealthChecker] ';
    StreamHealthChecker.WARNING_OVER_BITRATE = 3500000;
    /**
     * Corresponds to HIVE_STREAM_CHECKER_CODES.NUM_BITRATE_xxx error enums.
     * If number of bitrates is...
     *      <= NUM_BITRATE_STEPS[0]: NUM_BITRATES_NONE [error]
     *      <= NUM_BITRATE_STEPS[1]: NUM_BITRATES_OK [info]
     *      <= NUM_BITRATE_STEPS[2]: NUM_BITRATES_WARNING [warning]
     *      else: NUM_BITRATES_ERROR [error]
     */
    StreamHealthChecker.NUM_BITRATE_STEPS = [
        [0, HIVE_STREAM_CHECKER_CODES.NUM_BITRATES_NONE, LOG_LEVEL.ERROR],
        [4, HIVE_STREAM_CHECKER_CODES.NUM_BITRATES_OK, LOG_LEVEL.INFO],
        [7, HIVE_STREAM_CHECKER_CODES.NUM_BITRATES_WARNING, LOG_LEVEL.WARN],
        [Infinity, HIVE_STREAM_CHECKER_CODES.NUM_BITRATES_ERROR, LOG_LEVEL.ERROR]
    ];
    return StreamHealthChecker;
}());
exports.StreamHealthChecker = StreamHealthChecker;
//# sourceMappingURL=StreamHealthChecker.js.map

/***/ }),

/***/ "../../../core/build/core/src/webrtc/booster/BoosterClient.js":
/*!*************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/webrtc/booster/BoosterClient.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.BoosterEvents = exports.BoosterState = exports.LanBroadcastingState = void 0;
var LanBroadcastingState;
(function (LanBroadcastingState) {
    // LA is not yet broadcasting our peer info
    LanBroadcastingState[LanBroadcastingState["STOPPED"] = 0] = "STOPPED";
    // peer info are being broadcasted
    LanBroadcastingState[LanBroadcastingState["ACTIVE"] = 1] = "ACTIVE";
})(LanBroadcastingState = exports.LanBroadcastingState || (exports.LanBroadcastingState = {}));
var BoosterState;
(function (BoosterState) {
    // the agent is not available, or doesn't support LA
    BoosterState[BoosterState["DISCONNECTED"] = 0] = "DISCONNECTED";
    // agent is found and supports LA
    BoosterState[BoosterState["CONNECTED"] = 1] = "CONNECTED";
})(BoosterState = exports.BoosterState || (exports.BoosterState = {}));
var BoosterEvents;
(function (BoosterEvents) {
    BoosterEvents["INITIALIZED"] = "initialized";
    BoosterEvents["CONNECTED"] = "connected";
    BoosterEvents["DISCONNECTED"] = "disconnected";
    BoosterEvents["NETWORK_INFO_UPDATE"] = "network-info-update";
    BoosterEvents["LAN_MEMBERS_UPDATE"] = "lan-members-update";
})(BoosterEvents = exports.BoosterEvents || (exports.BoosterEvents = {}));
//# sourceMappingURL=BoosterClient.js.map

/***/ }),

/***/ "../../../core/build/core/src/webrtc/booster/BoosterLogger.js":
/*!*************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/webrtc/booster/BoosterLogger.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __spreadArray = (this && this.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BoosterLogger = void 0;
var basicutils_hive_1 = __webpack_require__(/*! ../../common/basicutils.hive */ "../../../core/build/core/src/common/basicutils.hive.js");
var BoosterLogger = /** @class */ (function () {
    function BoosterLogger() {
        this._url = undefined;
        this.authorization = undefined;
        this.removedLines = 0;
        this.MAX_BUFFER_SIZE = 200;
        this.SEND_LOGS_INTERVAL_MS = 5000;
        this.buffer = [];
    }
    BoosterLogger.prototype.start = function (url, authorization) {
        var _this = this;
        this._url = url.endsWith('/') ? url : url + "/";
        this.authorization = authorization;
        setInterval(function () {
            _this.flush();
        }, this.SEND_LOGS_INTERVAL_MS);
    };
    BoosterLogger.prototype.addToBuffer = function (level) {
        var message = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            message[_i - 1] = arguments[_i];
        }
        // For safety reasons we will limit the buffer to 200 log messages
        if (this.buffer.length >= this.MAX_BUFFER_SIZE) {
            // get the last MAX_BUFFER_SIZE - 1 objects. The next one will be added afterwards so the
            // size is MAX_BUFFER_SIZE in the end
            this.removedLines += this.buffer.length - this.MAX_BUFFER_SIZE + 1;
            this.buffer = this.buffer.slice(-(this.MAX_BUFFER_SIZE - 1));
        }
        this.buffer.push({ level: level, message: message.toString() });
    };
    BoosterLogger.prototype.flush = function () {
        var _this = this;
        if (!this._url || !this.authorization) {
            return;
        }
        if (this.removedLines > 0) {
            this.buffer.unshift({
                level: 'info',
                message: "Removed " + this.removedLines + " lines before they were flushed down"
            });
        }
        var copy = __spreadArray([], this.buffer);
        this.buffer = [];
        basicutils_hive_1.ajaxPostPromise(this._url + "logs", JSON.stringify(copy), 'application/json', this.authorization)
            .then(function () { return _this.removedLines = 0; })
            .catch(function (error) {
            console.log('Failed to send logs to Booster', error);
            _this.buffer = __spreadArray(__spreadArray([], copy), _this.buffer);
        });
    };
    return BoosterLogger;
}());
exports.BoosterLogger = BoosterLogger;
//# sourceMappingURL=BoosterLogger.js.map

/***/ }),

/***/ "../../../core/build/core/src/webrtc/booster/DefaultBoosterClient.js":
/*!********************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/webrtc/booster/DefaultBoosterClient.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.DefaultBoosterClient = void 0;
var BoosterClient_1 = __webpack_require__(/*! ./BoosterClient */ "../../../core/build/core/src/webrtc/booster/BoosterClient.js");
var Framework_1 = __webpack_require__(/*! ../../core/Framework */ "../../../core/build/core/src/core/Framework.js");
var basicutils_hive_1 = __webpack_require__(/*! ../../common/basicutils.hive */ "../../../core/build/core/src/common/basicutils.hive.js");
var build_defaults_1 = __webpack_require__(/*! ../../common/build.defaults */ "../../../core/build/core/src/common/build.defaults.js");
var Q = __webpack_require__(/*! @hivestreaming/q */ "../../../node_modules/@hivestreaming/q/q.js");
var Utils_1 = __webpack_require__(/*! ../../core/Utils */ "../../../core/build/core/src/core/Utils.js");
var validator_1 = __webpack_require__(/*! ./validation/validator */ "../../../core/build/core/src/webrtc/booster/validation/validator.js");
var constants_hivejs_hive_1 = __webpack_require__(/*! ../../common/techs/hivejs/constants.hivejs.hive */ "../../../core/build/core/src/common/techs/hivejs/constants.hivejs.hive.js");
var PeerConstants_1 = __webpack_require__(/*! ../PeerConstants */ "../../../core/build/core/src/webrtc/PeerConstants.js");
var DefaultBoosterClient = /** @class */ (function (_super) {
    __extends(DefaultBoosterClient, _super);
    function DefaultBoosterClient() {
        var _this = _super.call(this) || this;
        _this.loggerId = '[DefaultBoosterClient] ';
        _this.API_VERSION = '/v1';
        _this.logger = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.LOGGER).log();
        _this.boosterState = BoosterClient_1.BoosterState.DISCONNECTED;
        _this.lanBroadcastingState = BoosterClient_1.LanBroadcastingState.STOPPED;
        return _this;
    }
    DefaultBoosterClient.prototype.init = function (ticket) {
        this.ticket = ticket;
        // inform other components that we are ready to attempts connections to the LA
        this.emit(BoosterClient_1.BoosterEvents.INITIALIZED);
    };
    /**
     * internal state machine keeping track of connectivity state
     * and triggering once state change events
     */
    DefaultBoosterClient.prototype.updateState = function (newState) {
        var _this = this;
        switch (newState) {
            case BoosterClient_1.BoosterState.CONNECTED:
                if (this.boosterState === BoosterClient_1.BoosterState.DISCONNECTED) {
                    this.boosterState = newState;
                    Q.nextTick(function () { return _this.emit(BoosterClient_1.BoosterEvents.CONNECTED); });
                }
                break;
            case BoosterClient_1.BoosterState.DISCONNECTED:
                if (this.boosterState === BoosterClient_1.BoosterState.CONNECTED) {
                    this.boosterState = newState;
                    Q.nextTick(function () { return _this.emit(BoosterClient_1.BoosterEvents.DISCONNECTED); });
                }
                break;
        }
    };
    /**
     * load the version.json to see if the agent is available and if it supports
     * the Booster (it will contain the LA port)
     */
    DefaultBoosterClient.prototype.checkBoosterPresence = function () {
        var _this = this;
        if (!this.ticket) {
            return Q.reject('Ticket is not yet initialized');
        }
        if (this.boosterState === BoosterClient_1.BoosterState.CONNECTED) {
            return Q.resolve();
        }
        var url = this.getUrl(this.getAgentMonitorPort());
        return basicutils_hive_1.ajaxGetPromise(url + 'version.json')
            .then(function (response) {
            var _a, _b;
            var agentVersion = JSON.parse(response);
            var boosterPort = (_b = (_a = agentVersion.services) === null || _a === void 0 ? void 0 : _a.booster) === null || _b === void 0 ? void 0 : _b.port;
            if (boosterPort) {
                _this.logger.debug(_this.loggerId + 'Booster detected on port ' + boosterPort);
                _this.url = _this.getUrl(boosterPort, _this.API_VERSION);
                _this.logger.bindBooster(_this.url, _this.getAuthorization());
                _this.updateState(BoosterClient_1.BoosterState.CONNECTED);
                return Q.resolve();
            }
            else {
                return Q.reject('Booster not detected');
            }
        })
            .catch(function (error) {
            _this.updateState(BoosterClient_1.BoosterState.DISCONNECTED);
            return Q.reject('Hive Agent not detected - status ' + error.status);
        });
    };
    /**
     * get extended network information from the LA. If it fails with network error, update the
     * connection state
     */
    DefaultBoosterClient.prototype.getExtendedNetworkInfo = function (address) {
        var _this = this;
        if (!this.ticket) {
            return Q.reject({ message: 'ticket not present' });
        }
        var request = {
            sessionId: this.ticket.sessionId,
            version: build_defaults_1.BuildParameters.PLUGIN_VERSION,
            interfaces: address.map(function (a) { return ({ address: { value: a.value, type: a.type } }); })
        };
        return basicutils_hive_1.ajaxPostPromise(this.url + '/network', JSON.stringify(request), 'application/json', this.getAuthorization()).then(function (response) {
            validator_1.validator('extended-network-info-schema', response);
            _this.extendedNetworkInfo = JSON.parse(response);
            Q.nextTick(function () { return _this.emit(BoosterClient_1.BoosterEvents.NETWORK_INFO_UPDATE); });
            return Q.resolve(_this.extendedNetworkInfo);
        }).fail(function (error) {
            if (error.status === -1) {
                _this.updateState(BoosterClient_1.BoosterState.DISCONNECTED);
            }
            return Q.reject(error);
        });
    };
    /**
     * starts the LAN discovery process by activating broadcasting of the peer info and asking periodically for updated LAN members.
     */
    DefaultBoosterClient.prototype.startLanDiscovery = function (peerId, rank) {
        this.peerInfo = {
            peerId: peerId,
            rank: rank,
            qualityId: null
        };
        if (PeerConstants_1.PeerConstants.Booster.ACTIVE_DISCOVERY) {
            this.activateBroadcast();
            this.getActivePeersPeriodically();
        }
    };
    /**
     * stop the LAN discovery and the local peer info broadcast
     */
    DefaultBoosterClient.prototype.stopLanDiscovery = function () {
        this.stopPeerBroadcasting();
        if (this.getActivePeersTaskId) {
            Framework_1.Framework.clearInterval(this.getActivePeersTaskId);
        }
        this.lanBroadcastingState = BoosterClient_1.LanBroadcastingState.STOPPED;
    };
    /**
     * update the internal reference of the local peer info, and if the broadcast is already active,
     * push the updated info down to the LA
     */
    DefaultBoosterClient.prototype.updateLanDiscovery = function (qualityId, rank) {
        var _this = this;
        this.peerInfo.qualityId = qualityId ? qualityId : this.peerInfo.qualityId;
        this.peerInfo.rank = rank ? rank : this.peerInfo.rank;
        if (this.lanBroadcastingState != BoosterClient_1.LanBroadcastingState.ACTIVE) {
            return;
        }
        var request = {
            peerInfo: this.peerInfo,
            interfaces: this.extendedNetworkInfo.interfaces.map(function (i) { return i.id; })
        };
        basicutils_hive_1.ajaxGenericPromise('PUT', this.url + '/broadcast', 'application/json', true, this.getAuthorization(), JSON.stringify(request)).then(function (response) {
            _this.logger.debug(_this.loggerId + 'Broadcasting updated: QL ' + request.peerInfo.qualityId + ' rank ' + request.peerInfo.rank + ' INTER ' + request.interfaces.map(function (i) { return i.substr(0, 8); }));
        }).fail(function (error) {
            _this.logger.error(_this.loggerId + 'Updating broadcasting failed', error);
        });
    };
    /**
     * the local peer discovery depends on fetching first the extended network info. If missing,
     * it waits for the next network info update event.
     */
    DefaultBoosterClient.prototype.activateBroadcast = function () {
        var _this = this;
        if (!this.ticket || !this.extendedNetworkInfo || this.extendedNetworkInfo.interfaces.length == 0) {
            this.once(BoosterClient_1.BoosterEvents.NETWORK_INFO_UPDATE, this.activateBroadcast.bind(this));
            return;
        }
        var request = {
            sessionId: this.ticket.sessionId,
            peerInfo: this.peerInfo,
            interfaces: this.extendedNetworkInfo.interfaces.map(function (i) { return i.id; })
        };
        basicutils_hive_1.ajaxPostPromise(this.url + '/broadcast', JSON.stringify(request), 'application/json', this.getAuthorization()).then(function (response) {
            _this.lanBroadcastingState = BoosterClient_1.LanBroadcastingState.ACTIVE;
            _this.logger.debug(_this.loggerId + 'Lan discovering started');
        }).fail(function (error) {
            _this.lanBroadcastingState = BoosterClient_1.LanBroadcastingState.STOPPED;
            _this.logger.error(_this.loggerId + 'Starting lan discovering failed with error: ', error);
        });
    };
    /**
     * trigger an immediate and a periodic fetch of all active LAN members. The request requires an active connection to the LA.
     * if it's missing, it will wait for the connected event
     */
    DefaultBoosterClient.prototype.getActivePeersPeriodically = function () {
        var _this = this;
        if (this.boosterState !== BoosterClient_1.BoosterState.CONNECTED) {
            this.once(BoosterClient_1.BoosterEvents.CONNECTED, this.getActivePeersPeriodically.bind(this));
            return;
        }
        if (this.getActivePeersTaskId) {
            Framework_1.Framework.clearInterval(this.getActivePeersTaskId);
        }
        this.getActivePeersTaskId = Framework_1.Framework.setInterval(function () { return _this.getActivePeers(); }, PeerConstants_1.PeerConstants.Booster.INTERVAL_LAN_VIEWERS_FETCHING);
        this.getActivePeers();
    };
    /**
     * fetch the latest LAN members list, check if it changed from last fetch and in case
     * trigger an update. If it fails with network error, update the agent connection state
     */
    DefaultBoosterClient.prototype.getActivePeers = function () {
        var _this = this;
        var path = this.peerInfo && this.peerInfo.peerId ? '/broadcast/' + this.peerInfo.peerId : '/broadcast';
        basicutils_hive_1.ajaxGetPromise(this.url + path, undefined, true, this.getAuthorization()).then(function (response) {
            validator_1.validator('lan-members-schema', response);
            // parse the response and trigger update if anything changed
            var lanMembers = JSON.parse(response);
            if (_this.isLanMembershipChanged(lanMembers)) {
                Q.nextTick(function () { return _this.emit(BoosterClient_1.BoosterEvents.LAN_MEMBERS_UPDATE, lanMembers); });
            }
            _this.lastLanMembers = lanMembers;
            _this.logger.debug(_this.loggerId + 'Lan viewers fetched ', lanMembers);
        }).fail(function (error) {
            if (error.status === -1) {
                _this.updateState(BoosterClient_1.BoosterState.DISCONNECTED);
            }
            _this.logger.error(_this.loggerId + 'Could not get lan viewers', error);
        });
    };
    DefaultBoosterClient.prototype.isLanMembershipChanged = function (lanMembers) {
        return ((!this.lastLanMembers && Utils_1.isSet(lanMembers)) || (lanMembers.latestUpdate > this.lastLanMembers.latestUpdate));
    };
    /**
     *  Browsers do not guarantee to send XHR requests if the page is about to unloaded. Beacon is asynchronous and guaranteed to be sent
     */
    DefaultBoosterClient.prototype.stopPeerBroadcasting = function () {
        if (this.lanBroadcastingState === BoosterClient_1.LanBroadcastingState.ACTIVE) {
            var blob = new Blob([JSON.stringify(this.getAuthorization())], { type: 'application/json' });
            navigator.sendBeacon(this.url + '/broadcast/' + this.peerInfo.peerId, blob);
            this.logger.debug(this.loggerId + 'Lan broadcasting stopped');
        }
    };
    DefaultBoosterClient.prototype.getUrl = function (port, apiVersion) {
        var suffix = apiVersion ? port + apiVersion : port;
        return new URL('https://' + constants_hivejs_hive_1.HiveJsConstants.BOOSTER_DOMAIN + ':' + suffix);
    };
    DefaultBoosterClient.prototype.getAuthorization = function () {
        return { authorization: 'TicketAuth ' + this.ticket.getTicketUrl() };
    };
    /**
     * the agent port might be configured differently during silent tests
     * so we want to replicate the plugin logic for using the right one
     */
    DefaultBoosterClient.prototype.getAgentMonitorPort = function () {
        var params = new Proxy(new URLSearchParams(window.location.search), {
            get: function (searchParams, prop) { return searchParams.get(prop); }
        });
        var monitorPort = params['hiveMonitorPort'];
        if (monitorPort) {
            try {
                return parseInt(monitorPort);
            }
            catch (e) {
                this.logger.warn('Exception parsing the agent monitor port');
            }
        }
        return constants_hivejs_hive_1.HiveJsConstants.AGENT_MONITOR_PORT;
    };
    return DefaultBoosterClient;
}(Utils_1.TypedEventEmitter));
exports.DefaultBoosterClient = DefaultBoosterClient;
//# sourceMappingURL=DefaultBoosterClient.js.map

/***/ }),

/***/ "../../../core/build/core/src/webrtc/booster/models/AgentVersion.js":
/*!*******************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/webrtc/booster/models/AgentVersion.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=AgentVersion.js.map

/***/ }),

/***/ "../../../core/build/core/src/webrtc/booster/models/ExtendedNetworkInfo.js":
/*!**************************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/webrtc/booster/models/ExtendedNetworkInfo.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.addressSchema = exports.extendedNetworkInfoSchema = exports.networkInterfaceSchema = exports.routeSchema = exports.publicInterfaceSchema = exports.nicSchema = exports.siteSchema = exports.AddressType = exports.ConnectionType = void 0;
var ConnectionType;
(function (ConnectionType) {
    ConnectionType["UNKNOWN"] = "UNKNOWN";
    ConnectionType["WIRELESS"] = "WIRELESS";
    ConnectionType["ETHERNET"] = "ETHERNET";
})(ConnectionType = exports.ConnectionType || (exports.ConnectionType = {}));
var AddressType;
(function (AddressType) {
    AddressType["NA"] = "NA";
    AddressType["IP"] = "IP";
    AddressType["MDNS"] = "MDNS";
})(AddressType = exports.AddressType || (exports.AddressType = {}));
exports.siteSchema = {
    $id: 'site-schema',
    type: 'object',
    properties: {
        id: { type: 'number' },
        vpn: { type: 'boolean' }
    },
    required: [
        'id',
        'vpn'
    ],
    additionalProperties: false
};
exports.nicSchema = {
    $id: 'nic-schema',
    type: 'object',
    properties: {
        name: { type: 'string' },
        vpn: { type: 'boolean' },
        connectionType: { enum: ['UNKNOWN', 'WIRELESS', 'ETHERNET'] }
    },
    required: [
        'name',
        'vpn',
        'connectionType'
    ],
    additionalProperties: false
};
exports.publicInterfaceSchema = {
    $id: 'public-interface-schema',
    type: 'object',
    properties: {
        address: { type: 'string' },
        as: { type: 'number' }
    },
    required: [
        'address',
        'as'
    ],
    additionalProperties: false
};
exports.routeSchema = {
    $id: 'route-schema',
    type: 'object',
    properties: {
        domain: { type: 'string' },
        interface: { type: 'string' }
    },
    required: [
        'domain',
        'interface'
    ],
    additionalProperties: false
};
exports.networkInterfaceSchema = {
    $id: 'network-interface-schema',
    type: 'object',
    properties: {
        id: { type: 'string' },
        address: { type: 'array', items: { $ref: 'address-schema' } },
        netMask: { type: 'string' },
        site: { $ref: 'site-schema' },
        nic: { $ref: 'nic-schema' }
    },
    required: [
        'id',
        'address',
        'netMask',
        'site',
        'nic'
    ],
    additionalProperties: false
};
exports.extendedNetworkInfoSchema = {
    $id: 'extended-network-info-schema',
    type: 'object',
    properties: {
        public: { $ref: 'public-interface-schema' },
        interfaces: { type: 'array', items: { $ref: 'network-interface-schema' } },
        routes: { type: 'array', items: { $ref: 'route-schema' } }
    },
    required: [
        'public',
        'interfaces',
        'routes'
    ],
    additionalProperties: false
};
exports.addressSchema = {
    $id: 'address-schema',
    type: 'object',
    properties: {
        value: { type: 'string' },
        type: { enum: ['NA', 'IP', 'MDNS'] }
    },
    required: [
        'value',
        'type'
    ],
    additionalProperties: false
};
//# sourceMappingURL=ExtendedNetworkInfo.js.map

/***/ }),

/***/ "../../../core/build/core/src/webrtc/booster/models/LanMembers.js":
/*!*****************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/webrtc/booster/models/LanMembers.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.peerInfoSchema = exports.lanMembersSchema = exports.peerSchema = void 0;
exports.peerSchema = {
    $id: 'peer-schema',
    type: 'object',
    properties: {
        peerInfo: { $ref: 'peer-info-schema' },
        nic: { $ref: 'nic-schema' },
        latestHeardFrom: { type: 'number' },
        joined: { type: 'number' }
    },
    required: [
        'peerInfo',
        'nic',
        'latestHeardFrom',
        'joined'
    ],
    additionalProperties: false
};
exports.lanMembersSchema = {
    $id: 'lan-members-schema',
    type: 'object',
    properties: {
        peers: { type: 'array', items: { $ref: 'peer-schema' } },
        latestUpdate: { type: 'number' }
    },
    required: [
        'latestUpdate'
    ],
    additionalProperties: false
};
exports.peerInfoSchema = {
    $id: 'peer-info-schema',
    type: 'object',
    properties: {
        peerId: { type: 'string' },
        rank: { type: 'number' },
        qualityId: { type: 'string' }
    },
    required: [
        'peerId',
        'rank',
        'qualityId'
    ],
    additionalProperties: false
};
//# sourceMappingURL=LanMembers.js.map

/***/ }),

/***/ "../../../core/build/core/src/webrtc/booster/models/index.js":
/*!************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/webrtc/booster/models/index.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(__webpack_require__(/*! ./ExtendedNetworkInfo */ "../../../core/build/core/src/webrtc/booster/models/ExtendedNetworkInfo.js"), exports);
__exportStar(__webpack_require__(/*! ./LanMembers */ "../../../core/build/core/src/webrtc/booster/models/LanMembers.js"), exports);
__exportStar(__webpack_require__(/*! ./AgentVersion */ "../../../core/build/core/src/webrtc/booster/models/AgentVersion.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../../core/build/core/src/webrtc/booster/validation/validator.js":
/*!********************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/webrtc/booster/validation/validator.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.validator = void 0;
// The validator should use `ajv`. Due to a issues with the old and new versions we postponed it for later
// to not block the work now
function validator(schema, data) {
    return;
}
exports.validator = validator;
//# sourceMappingURL=validator.js.map

/***/ }),

/***/ "../../../core/build/core/src/webrtc/cache/Cache.js":
/*!***************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/webrtc/cache/Cache.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Cache = void 0;
var Framework_1 = __webpack_require__(/*! ../../core/Framework */ "../../../core/build/core/src/core/Framework.js");
var Q = __webpack_require__(/*! @hivestreaming/q */ "../../../node_modules/@hivestreaming/q/q.js");
var ErrorCodes = __webpack_require__(/*! ../../common/error.hive */ "../../../core/build/core/src/common/error.hive.js");
var logger_hive_1 = __webpack_require__(/*! ../../common/logger.hive */ "../../../core/build/core/src/common/logger.hive.js");
var Cache = /** @class */ (function () {
    /**
     * The constructor initializes the LiveCache.
     */
    function Cache() {
        this.loggerId = '[CACHE] ';
        this.logger = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.LOGGER).log();
        this.liveCache = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.LIVE_CACHE);
    }
    /**
     * This function initializes the purging time and the maximum size of the
     * cache.
     * @param maxOccupancy
     * @param purgeTimer
     */
    Cache.prototype.init = function (maxOccupancy, purgeTimer) {
        try {
            this.liveCache.init(maxOccupancy, purgeTimer);
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error initializing cache', this.loggerId, ErrorCodes.CACHE_CODES.INIT_CACHE, error);
        }
    };
    /**
     * This function inserts the video fragment in the cache.
     * The video fragment is inserted in a cache that is in the memory.
     * @param request
     * @returns {Promise<boolean>}
     */
    Cache.prototype.put = function (request) {
        var _this = this;
        var defer = Q.defer();
        try {
            this.liveCache.put(request).then(function () {
                defer.resolve(true);
            }).catch(function (error) {
                if (error)
                    logger_hive_1.ErrorMonitor.getInstance().logError('Error adding new fragment in cache', _this.loggerId, ErrorCodes.CACHE_CODES.PUT_OPERATION, error);
                defer.reject(false);
            });
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error adding new fragment in cache', this.loggerId, ErrorCodes.CACHE_CODES.PUT_OPERATION, error);
            defer.reject(false);
        }
        return defer.promise;
    };
    /**
     * This function checks if an element is on the cache and tries to retrieve
     * its rangeContent. If it is LiveCache, it is retrieved from the memory.
     *
     * @param elementId
     * @returns {Promise<RangeContent>}
     */
    Cache.prototype.get = function (elementId) {
        var _this = this;
        var defer = Q.defer();
        try {
            this.contains(elementId).then(function (exists) {
                if (exists) {
                    _this.liveCache.get(elementId).then(function (rngCnt) {
                        defer.resolve(rngCnt);
                    }).catch(function (error) {
                        if (error)
                            logger_hive_1.ErrorMonitor.getInstance().logError('Error getting the fragment from cache', _this.loggerId, ErrorCodes.CACHE_CODES.GET_OPERATION, error);
                        defer.reject(false);
                    });
                }
                else
                    defer.reject(false);
            }).catch(function (error) {
                if (error)
                    logger_hive_1.ErrorMonitor.getInstance().logError('Error getting the fragment from cache', _this.loggerId, ErrorCodes.CACHE_CODES.GET_OPERATION, error);
                defer.reject(false);
            });
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error getting the fragment from cache', this.loggerId, ErrorCodes.CACHE_CODES.GET_OPERATION, error);
            defer.reject(false);
        }
        return defer.promise;
    };
    /**
     * This function first checks if there is the elementId included in the LiveCache.
     * @param elementId
     * @returns {Promise<boolean>}
     */
    Cache.prototype.contains = function (elementId) {
        var _this = this;
        var defer = Q.defer();
        var exists = false;
        try {
            this.liveCache.contains(elementId).then(function (exist) {
                exists = exist;
            }).fail(function (error) {
                _this.logger.error(error);
            }).finally(function () {
                defer.resolve(exists);
            });
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error checking if cache contains the fragment', this.loggerId, ErrorCodes.CACHE_CODES.CONTAINS_OPERATION, error);
            defer.resolve(false);
        }
        return defer.promise;
    };
    /**
     * Return all the entity ids from the cache
     * @returns {Array<string>}
     */
    Cache.prototype.getKeys = function () {
        try {
            return this.liveCache.getKeys();
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error getting the keys from cache', this.loggerId, ErrorCodes.CACHE_CODES.GET_KEYS_OPERATION, error);
            return [];
        }
    };
    /**
     * Returns all the DataItems from the Cache.
     * @returns {Promise<Array<DataItem>>}
     */
    Cache.prototype.getElements = function () {
        var _this = this;
        var defer = Q.defer();
        var elements = [];
        try {
            this.liveCache.getElements().then(function (elementList) {
                elements = elementList;
            }).fail(function (error) {
                _this.logger.error(error);
            }).finally(function () {
                defer.resolve(elements);
            });
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error getting the elements from cache ', this.loggerId, ErrorCodes.CACHE_CODES.GET_ELEMENTS_OPERATION, error);
            defer.resolve(elements);
        }
        return defer.promise;
    };
    Cache.prototype.flushCache = function () {
        this.liveCache.flushCache();
    };
    Cache.prototype.remove = function (request) {
        this.liveCache.remove(request);
    };
    return Cache;
}());
exports.Cache = Cache;
//# sourceMappingURL=Cache.js.map

/***/ }),

/***/ "../../../core/build/core/src/webrtc/cache/ChunkHandler.js":
/*!**********************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/webrtc/cache/ChunkHandler.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ChunkHandler = void 0;
var ByteBuffer = __webpack_require__(/*! bytebuffer */ "../../../core/node_modules/bytebuffer/dist/bytebuffer.js");
var HashMap = __webpack_require__(/*! @hivestreaming/collections/map */ "../../../node_modules/@hivestreaming/collections/map.js");
var Framework_1 = __webpack_require__(/*! ../../core/Framework */ "../../../core/build/core/src/core/Framework.js");
var PeerConstants_1 = __webpack_require__(/*! ../PeerConstants */ "../../../core/build/core/src/webrtc/PeerConstants.js");
var logger_hive_1 = __webpack_require__(/*! ../../common/logger.hive */ "../../../core/build/core/src/common/logger.hive.js");
var ErrorCodes = __webpack_require__(/*! ../../common/error.hive */ "../../../core/build/core/src/common/error.hive.js");
/**
 * utility class that takes a downloaded fragment and splits it
 * into chunks ready to be sent through p2p
 */
var ChunkHandler = /** @class */ (function () {
    function ChunkHandler() {
        this.loggerId = '[ChunkHandler] ';
        this.fragmentMap = new HashMap();
        this.fragmentListMap = new HashMap();
    }
    ChunkHandler.prototype.init = function (swarm) {
        this.logger = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.LOGGER).log(swarm.sessionId);
    };
    /**
     * called by the hive cache (p2p request success and fallback req success)
     */
    ChunkHandler.prototype.addFragment = function (request) {
        try {
            var elementId = request.getEntityId();
            var data = request.binaryData;
            var total = request.requestStats.totalDownloaded;
            var chunkNums = Math.ceil(total / PeerConstants_1.PeerConstants.Transport.ChunkSize);
            var qualityLevel = request.entityCharacteristics.getQualityLevel();
            var parsedAlready = 0;
            var till = Math.min(PeerConstants_1.PeerConstants.Transport.ChunkSize, total);
            this.generateArray(elementId, qualityLevel);
            var toSend = (till - parsedAlready);
            // fill up every entity id with the chunks
            while (chunkNums > 0) {
                var sl = null;
                try {
                    if (!Framework_1.Framework.isSimulated())
                        sl = ByteBuffer.wrap(data.slice(parsedAlready, till));
                    parsedAlready += toSend;
                }
                catch (error) {
                    logger_hive_1.ErrorMonitor.getInstance().logError('Error wrapping chunk', this.loggerId, ErrorCodes.CHUNK_HANDLER_CODES.WRAP_CHUNK, error);
                }
                this.fragmentMap.get(elementId).push(sl);
                chunkNums--;
                till = Math.min(parsedAlready + PeerConstants_1.PeerConstants.Transport.ChunkSize, total);
                toSend = (till - parsedAlready);
            }
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error adding fragment to the fragmentMap', this.loggerId, ErrorCodes.CHUNK_HANDLER_CODES.ADD_FRAGMENT_TO_MAP, error);
        }
    };
    /**
     * prepares the metadata for the chunks
     * @param elementId
     * @param qualityLevel
     */
    ChunkHandler.prototype.generateArray = function (elementId, qualityLevel) {
        try {
            // garbage collector, we keep the latest downloaded MAXIMUM_CHUNK_STORED_IN_L1 fragments per each
            if (this.fragmentListMap.has(qualityLevel.id) && this.fragmentListMap.get(qualityLevel.id).length > PeerConstants_1.PeerConstants.Cache.MAXIMUM_CHUNK_STORED_IN_L1) {
                var elementId_1 = this.fragmentListMap.get(qualityLevel.id)[0];
                this.fragmentMap.delete(elementId_1);
                this.fragmentListMap.get(qualityLevel.id).shift();
            }
            // generate the new lists
            if (!this.fragmentListMap.has(qualityLevel.id)) {
                var newArray = [elementId];
                this.fragmentListMap.set(qualityLevel.id, newArray);
                this.fragmentMap.set(elementId, []);
            }
            else {
                this.fragmentListMap.get(qualityLevel.id).push(elementId);
                this.fragmentMap.set(elementId, []);
            }
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error generating the chunk handler hashmaps', this.loggerId, ErrorCodes.CHUNK_HANDLER_CODES.GENERATE_HASHMAPS, error);
        }
    };
    ChunkHandler.prototype.getChunk = function (elementId, chunkNum) {
        if (this.fragmentMap.has(elementId))
            return this.fragmentMap.get(elementId)[chunkNum];
        return null;
    };
    ChunkHandler.prototype.flushChunkStore = function () {
        this.fragmentMap = new HashMap();
        this.fragmentListMap = new HashMap();
    };
    return ChunkHandler;
}());
exports.ChunkHandler = ChunkHandler;
//# sourceMappingURL=ChunkHandler.js.map

/***/ }),

/***/ "../../../core/build/core/src/webrtc/cache/DataItem.js":
/*!******************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/webrtc/cache/DataItem.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.DataItem = void 0;
var RangeUtils_1 = __webpack_require__(/*! ../RangeUtils */ "../../../core/build/core/src/webrtc/RangeUtils.js");
var HashMap = __webpack_require__(/*! @hivestreaming/collections/map */ "../../../node_modules/@hivestreaming/collections/map.js");
var DataItem = /** @class */ (function () {
    function DataItem(entityCharacteristics) {
        this.headers = null;
        this.partnerInfo = null;
        this.totalSize = 0;
        this.isFlushed = false;
        this.entityCharacteristics = entityCharacteristics;
        this.content = new HashMap();
    }
    DataItem.prototype.size = function () {
        var size = 0;
        this.content.forEach(function (rangeContent, rangeStr) {
            size += RangeUtils_1.RangeUtils.toHTTPRange(rangeStr).size();
        });
        return size;
    };
    return DataItem;
}());
exports.DataItem = DataItem;
//# sourceMappingURL=DataItem.js.map

/***/ }),

/***/ "../../../core/build/core/src/webrtc/cache/LiveCache.js":
/*!*******************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/webrtc/cache/LiveCache.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.LiveCache = void 0;
var HashMap = __webpack_require__(/*! @hivestreaming/collections/map */ "../../../node_modules/@hivestreaming/collections/map.js");
var Q = __webpack_require__(/*! @hivestreaming/q */ "../../../node_modules/@hivestreaming/q/q.js");
var Framework_1 = __webpack_require__(/*! ../../core/Framework */ "../../../core/build/core/src/core/Framework.js");
var RangeContent_1 = __webpack_require__(/*! ./RangeContent */ "../../../core/build/core/src/webrtc/cache/RangeContent.js");
var RangeUtils_1 = __webpack_require__(/*! ../RangeUtils */ "../../../core/build/core/src/webrtc/RangeUtils.js");
var DataItem_1 = __webpack_require__(/*! ./DataItem */ "../../../core/build/core/src/webrtc/cache/DataItem.js");
var logger_hive_1 = __webpack_require__(/*! ../../common/logger.hive */ "../../../core/build/core/src/common/logger.hive.js");
var ErrorCodes = __webpack_require__(/*! ../../common/error.hive */ "../../../core/build/core/src/common/error.hive.js");
var LiveCache = /** @class */ (function () {
    function LiveCache() {
        // protected loggedId = "CACHE";
        this.loggerId = '[LIVE CACHE] ';
        this.itemsStore = new HashMap();
        this.purgeTimer = -1;
        // Order of fragment
        this.contentOrder = [];
        this.logger = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.LOGGER).log();
    }
    LiveCache.prototype.init = function (maxOccupancy, purgePeriod) {
        this.maxOccupancy = maxOccupancy;
        this.purgePeriod = purgePeriod;
    };
    LiveCache.prototype.put = function (request) {
        var defer = Q.defer();
        try {
            var elementId = request.getEntityId();
            var headers = request.respHeaders;
            var data = request.binaryData;
            var start = 0;
            var end = request.requestStats.totalDownloaded - 1;
            var total = request.requestStats.totalDownloaded;
            if (this.purgeTimer == -1) {
                this.startPeriodicPurge();
            }
            var element = null;
            var added_1 = false;
            if (!this.itemsStore.has(elementId)) {
                var rangeStr = new RangeUtils_1.HTTPRange(start, end, total).toString();
                element = new DataItem_1.DataItem(request.entityCharacteristics);
                if (request.partner) {
                    element.partnerInfo = request.partner.member.peerInfo;
                }
                element.content.set(rangeStr, new RangeContent_1.RangeContent(total, data, request.requestStats, request.getRequestType()));
                this.itemsStore.set(elementId, element);
                // this.logger.info("PUT " + elementId + " RANGE " + rangeStr)
                added_1 = true;
                this.contentOrder.unshift(elementId);
            }
            else {
                element = this.itemsStore.get(elementId);
                var rangeO_1 = new RangeUtils_1.HTTPRange(start, end, total);
                added_1 = true;
                element.content.forEach(function (rangeContent, rangeStr) {
                    // this.logger.debug("RANGE IN C" + rangeStr)
                    var rangeOI = RangeUtils_1.RangeUtils.toHTTPRange(rangeStr);
                    if (rangeOI.overlapping(rangeO_1)) {
                        added_1 = false;
                        return;
                    }
                });
            }
            if (element.headers == null && headers != null) {
                element.headers = headers;
            }
            if (added_1)
                defer.resolve(true);
            else
                defer.reject(false);
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error adding fragment in LiveCache', this.loggerId, ErrorCodes.LIVE_CACHE_CODES.PUT_OPERATION, error);
            defer.reject('CACHE PUT ERROR ' + error);
        }
        return defer.promise;
    };
    LiveCache.prototype.get = function (elementId) {
        var defer = Q.defer();
        try {
            var el_1 = this.itemsStore.get(elementId);
            if (el_1 != null) {
                var ret_1 = null;
                el_1.content.forEach(function (rangeContent, rangeStr) {
                    // this.logger.debug("RANGE IN C" + rangeStr)
                    var rangeOI = RangeUtils_1.RangeUtils.toHTTPRange(rangeStr);
                    if (rangeOI.isComplete()) {
                        // this.logger.debug("RETURN ", rangeOI.toString(), rangeContent.length)
                        // this.logger.debug("RC ", rangeContent)
                        ret_1 = rangeContent;
                        ret_1.headers = el_1.headers;
                        ret_1.partnerInfo = el_1.partnerInfo;
                        return;
                    }
                });
                defer.resolve(ret_1);
            }
            else {
                defer.reject(false);
            }
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error getting fragment from LiveCache', this.loggerId, ErrorCodes.LIVE_CACHE_CODES.GET_OPERATION, error);
            defer.reject('CACHE GET ERROR ' + error);
        }
        return defer.promise;
    };
    LiveCache.prototype.getKeys = function () {
        try {
            return this.itemsStore.keys();
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error getting keys from LiveCache', this.loggerId, ErrorCodes.LIVE_CACHE_CODES.GET_KEYS_OPERATION, error);
            return [];
        }
    };
    LiveCache.prototype.getElements = function () {
        var defer = Q.defer();
        try {
            defer.resolve(this.itemsStore.values());
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error getting elements from LiveCache', this.loggerId, ErrorCodes.LIVE_CACHE_CODES.GET_ELEMENTS_OPERATION, error);
            defer.reject('CACHE GET ELEMENTS ERROR ' + error);
        }
        return defer.promise;
    };
    LiveCache.prototype.contains = function (elementId) {
        var defer = Q.defer();
        try {
            if (this.itemsStore.has(elementId)) {
                defer.resolve(true);
            }
            else {
                defer.resolve(false);
            }
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error checking if LiveCache contains the fragment', this.loggerId, ErrorCodes.LIVE_CACHE_CODES.CONTAINS_OPERATION, error);
            defer.reject('CACHE CONTAINS ERROR ' + error);
        }
        return defer.promise;
    };
    LiveCache.prototype.startPeriodicPurge = function () {
        var _this = this;
        this.stopPurgeTimer();
        this.logger.debug(this.loggerId + "Starting cache periodic purge");
        this.purgeTimer = Framework_1.Framework.setInterval(function () {
            _this.purge();
        }, this.purgePeriod);
    };
    LiveCache.prototype.stopPurgeTimer = function () {
        if (this.purgeTimer != -1) {
            this.logger.debug(this.loggerId + " Stopping cache periodic purge");
            Framework_1.Framework.clearInterval(this.purgeTimer);
            this.purgeTimer = -1;
        }
    };
    LiveCache.prototype.purge = function () {
        var _this = this;
        try {
            var total_1 = 0;
            var removeFromIndex_1 = 0;
            var exceeding = 0;
            this.logger.debug(this.loggerId + " RUNNING GC");
            /*
             * loop through every element in the ordered content accounting the total size
             * on the first element that exceedes the maximum, save its index and remove
             * every element after that (including)
             */
            if (!this.contentOrder.every(function (item, idx) {
                var itemSize = _this.itemsStore.get(item).size();
                if (total_1 + itemSize > _this.maxOccupancy) {
                    removeFromIndex_1 = idx;
                    return false;
                }
                else {
                    total_1 += itemSize;
                }
                return true;
            })) {
                exceeding = this.contentOrder.length - removeFromIndex_1;
                this.contentOrder.splice(removeFromIndex_1, this.contentOrder.length - 1).forEach(function (item) {
                    _this.itemsStore.delete(item);
                });
            }
            this.logger.debug(this.loggerId + " GC DONE - REMOVED: " + exceeding + " - CURRENT ITEMS: " + this.itemsStore.length + " SIZE: " + total_1 + " ");
            if (this.itemsStore.length === 0) {
                this.logger.debug(this.loggerId + " Cache contains no items, stopping purge timer");
                this.stopPurgeTimer();
            }
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error purging LiveCache', this.loggerId, ErrorCodes.LIVE_CACHE_CODES.PURGE_CACHE_OPERATION, error);
        }
    };
    LiveCache.prototype.flushCache = function () {
        this.itemsStore = new HashMap();
        this.contentOrder = [];
    };
    LiveCache.prototype.printContent = function () {
        var _this = this;
        this.itemsStore.forEach(function (element, elementId) {
            _this.logger.debug('EID=' + elementId);
            var hm = element.content;
            hm.forEach(function (frReq, rangeStr) {
                _this.logger.debug('\tRANGE ', rangeStr);
            });
        });
    };
    LiveCache.prototype.remove = function (request) {
        var entityId = request.getEntityId();
        try {
            if (this.itemsStore.has(entityId))
                this.itemsStore.delete(entityId);
        }
        catch (error) {
            this.logger.warn("Failed to remove element " + entityId + " from Cache. " + error);
        }
    };
    return LiveCache;
}());
exports.LiveCache = LiveCache;
//# sourceMappingURL=LiveCache.js.map

/***/ }),

/***/ "../../../core/build/core/src/webrtc/cache/RangeContent.js":
/*!**********************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/webrtc/cache/RangeContent.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.RangeContent = void 0;
var RangeContent = /** @class */ (function () {
    function RangeContent(length, data, requestStats, requestType) {
        // this.request = request;
        this.length = length;
        this.data = data;
        this.requestStats = requestStats;
        this.requestType = requestType;
    }
    return RangeContent;
}());
exports.RangeContent = RangeContent;
//# sourceMappingURL=RangeContent.js.map

/***/ }),

/***/ "../../../core/build/core/src/webrtc/config-store/ConfigStore.js":
/*!****************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/webrtc/config-store/ConfigStore.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.PeeringPolicy = void 0;
var PeeringPolicy;
(function (PeeringPolicy) {
    PeeringPolicy["UNRESTRICTED"] = "unrestricted";
    PeeringPolicy["EXCLUDE_VPN_SITES"] = "excludeVpnSites";
    PeeringPolicy["EXCLUDE_VPN_AND_UNKNOWN_SITES"] = "excludeVpnAndUnknownSites";
})(PeeringPolicy = exports.PeeringPolicy || (exports.PeeringPolicy = {}));
//# sourceMappingURL=ConfigStore.js.map

/***/ }),

/***/ "../../../core/build/core/src/webrtc/config-store/DefaultConfigStore.js":
/*!***********************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/webrtc/config-store/DefaultConfigStore.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DefaultConfigStore = void 0;
var config_values_1 = __webpack_require__(/*! @hivestreaming/remote-config-keys/dist/config-values */ "../../../node_modules/@hivestreaming/remote-config-keys/dist/config-values.js");
var Framework_1 = __webpack_require__(/*! ../../core/Framework */ "../../../core/build/core/src/core/Framework.js");
var Utils_1 = __webpack_require__(/*! ../../core/Utils */ "../../../core/build/core/src/core/Utils.js");
var DefaultConfigStore = /** @class */ (function (_super) {
    __extends(DefaultConfigStore, _super);
    function DefaultConfigStore() {
        var _this = _super.call(this) || this;
        _this.configs = config_values_1.ConfigValues;
        _this.loggerId = '[DefaultConfigStore] ';
        return _this;
    }
    DefaultConfigStore.prototype.init = function () {
        this.logger = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.LOGGER).log();
    };
    DefaultConfigStore.prototype.storeConfigs = function (configs) {
        if (!configs)
            return;
        if (Object.keys(configs).length === 0)
            return;
        var newConfigs = __assign(__assign({}, config_values_1.ConfigValues), configs);
        for (var key in newConfigs) {
            if (newConfigs[key] !== this.configs[key]) {
                this.emit(key, newConfigs[key]);
            }
        }
        this.configs = newConfigs;
    };
    DefaultConfigStore.prototype.getConfig = function (key) {
        var value = this.configs[key];
        if (value === undefined || value === null) {
            this.logger.error(this.loggerId + " Invalid config key '" + key + "'");
        }
        return value;
    };
    return DefaultConfigStore;
}(Utils_1.TypedEventEmitter));
exports.DefaultConfigStore = DefaultConfigStore;
//# sourceMappingURL=DefaultConfigStore.js.map

/***/ }),

/***/ "../../../core/build/core/src/webrtc/context/ContextManager.js":
/*!**************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/webrtc/context/ContextManager.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.VideoContextManager = void 0;
var DashContext_1 = __webpack_require__(/*! ./dash/DashContext */ "../../../core/build/core/src/webrtc/context/dash/DashContext.js");
var HlsContext_1 = __webpack_require__(/*! ./hls/HlsContext */ "../../../core/build/core/src/webrtc/context/hls/HlsContext.js");
var Framework_1 = __webpack_require__(/*! ../../core/Framework */ "../../../core/build/core/src/core/Framework.js");
var ContextManager_1 = __webpack_require__(/*! ../../core/context/ContextManager */ "../../../core/build/core/src/core/context/ContextManager.js");
var PeerConstants_1 = __webpack_require__(/*! ../PeerConstants */ "../../../core/build/core/src/webrtc/PeerConstants.js");
var VideoContextManager = /** @class */ (function (_super) {
    __extends(VideoContextManager, _super);
    function VideoContextManager() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.partnership = null;
        return _this;
    }
    VideoContextManager.prototype.init = function (swarm) {
        this.logger = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.LOGGER).log(swarm.sessionId);
        this.swarm = swarm;
        this.partnership = swarm.partnership;
    };
    VideoContextManager.prototype.createHlsContext = function (ticket) {
        return new HlsContext_1.HlsContext(ticket, this.swarm, this.hiveTechOptions);
    };
    VideoContextManager.prototype.createDashContext = function (ticket) {
        return new DashContext_1.DashContext(ticket, this.swarm, this.hiveTechOptions);
    };
    VideoContextManager.prototype.restartContext = function (context) {
        var _this = this;
        if (!PeerConstants_1.PeerConstants.P2P.P2P_ENABLED)
            return;
        if (this.partnership != null)
            this.partnership.stop().then(function (res) {
                _this.partnership.start(context);
            });
        else
            this.partnership.start(context);
    };
    VideoContextManager.prototype.resolveContext = function (request) {
        if (this.currentContext == null) {
            this.logger.warn('FIRST REQUEST, COULD NOT FIND RIGHT CONTEXT ' + request.url);
        }
        else {
            // EXISTING
            if (!this.currentContext.isCurrentContext(request)) {
                this.logger.warn('REQUEST DOES NOT BELONG TO THE CURRENT CONTEXT ' + request.url);
                return null;
            }
            this.currentContext.getRequestContext().cacheParams(request, this.hiveTechOptions);
        }
        return this.currentContext;
    };
    return VideoContextManager;
}(ContextManager_1.ContextManager));
exports.VideoContextManager = VideoContextManager;
//# sourceMappingURL=ContextManager.js.map

/***/ }),

/***/ "../../../core/build/core/src/webrtc/context/RequestContext.js":
/*!**************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/webrtc/context/RequestContext.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.RequestContext = void 0;
var HashMap = __webpack_require__(/*! @hivestreaming/collections/map */ "../../../node_modules/@hivestreaming/collections/map.js");
var URI = __webpack_require__(/*! urijs */ "../../../node_modules/urijs/src/URI.js");
var Utils = __webpack_require__(/*! ../../core/Utils */ "../../../core/build/core/src/core/Utils.js");
var Framework_1 = __webpack_require__(/*! ../../core/Framework */ "../../../core/build/core/src/core/Framework.js");
/**
 * this class keeps the context of the player requests' query parameters
 * and headers used in the current session. It allows to cache query parameters
 * and headers from player requests and append them to internal CDN prefetch request.
 * This for example can enable CDN authentication for CDN prefetch requests.
 */
var RequestContext = /** @class */ (function () {
    function RequestContext() {
        this.cachedQueryParameters = new HashMap();
        this.cachedHeaders = new HashMap();
        this.loggerId = '[RequestContext] ';
        this._logger = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.LOGGER).log();
    }
    RequestContext.prototype.cacheParams = function (request, options) {
        // we don't cache again values that comes from the prefetcher, since they have the cached params already
        if (request.internal)
            return;
        var params = Utils.getUrlQueryParams(request.url);
        this.cacheQueryParameters(params, options && options.requestCache && options.requestCache.queryParams || []);
        this.cacheHeaders(request.requestHeaders, options && options.requestCache && options.requestCache.headers || []);
    };
    RequestContext.prototype.attachParams = function (request) {
        // if internal false, it is a player request and should be used as is
        if (!request.internal)
            return;
        this.updateURL(request);
        request.requestHeaders = this.updateHeaders(request.requestHeaders);
    };
    RequestContext.prototype.resetRequestContext = function () {
        this.cachedQueryParameters = new HashMap();
        this.cachedHeaders = new HashMap();
    };
    RequestContext.prototype.updateURL = function (request) {
        var _this = this;
        // we update the request url if there is any cached QP
        if (this.cacheQueryParameters.length > 0) {
            // if there are params we append the cached params, otherwise we create the full search
            var newUri_1 = new URI(request.url);
            var search_1 = '';
            this.cachedQueryParameters.keys().forEach(function (key, index, array) {
                if (!newUri_1.hasQuery(key)) {
                    search_1 += key + "=" + _this.cachedQueryParameters.get(key);
                    if (index < array.length - 1)
                        search_1 += '&';
                }
                else
                    _this._logger.warn(_this.loggerId + "url param (" + key + ") already exists in the url, it will not be overridden");
            });
            // we avoid using URI.js in order not to encode reserved values that can create problem with the CDN
            // we want to use the params as is
            if (search_1.length > 0)
                request.url += "" + ((newUri_1.query().length > 0) ? '&' : '?') + search_1;
        }
    };
    RequestContext.prototype.cacheQueryParameters = function (params, allowedParams) {
        var _this = this;
        Object.keys(params).forEach(function (key) {
            if (allowedParams.includes(key) || allowedParams.includes('*')) {
                _this.cachedQueryParameters.set(key, params[key]);
            }
        });
    };
    RequestContext.prototype.updateHeaders = function (requestHeaders) {
        var _this = this;
        var result = [];
        Object.keys(requestHeaders).forEach(function (key) {
            result[key] = requestHeaders[key];
        });
        this.cachedHeaders.keys().forEach(function (key) {
            result[key] = _this.cachedHeaders.get(key);
        });
        return result;
    };
    RequestContext.prototype.cacheHeaders = function (requestHeaders, allowedHeaders) {
        var _this = this;
        Object.keys(requestHeaders).forEach(function (key) {
            if (allowedHeaders.includes(key) || allowedHeaders.includes('*')) {
                _this.cachedHeaders.set(key, requestHeaders[key]);
            }
        });
    };
    RequestContext.prototype.getCachedQueryParameters = function () {
        return this.cachedQueryParameters;
    };
    RequestContext.prototype.getCachedHeaders = function () {
        return this.cachedHeaders;
    };
    return RequestContext;
}());
exports.RequestContext = RequestContext;
//# sourceMappingURL=RequestContext.js.map

/***/ }),

/***/ "../../../core/build/core/src/webrtc/context/TimerHandlerBase.js":
/*!****************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/webrtc/context/TimerHandlerBase.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.TimerHandlerBase = void 0;
var Utils_1 = __webpack_require__(/*! ../../core/Utils */ "../../../core/build/core/src/core/Utils.js");
var HiveInternalRequest_1 = __webpack_require__(/*! ../HiveInternalRequest */ "../../../core/build/core/src/webrtc/HiveInternalRequest.js");
var EntityType_1 = __webpack_require__(/*! ../../core/entity/EntityType */ "../../../core/build/core/src/core/entity/EntityType.js");
var Framework_1 = __webpack_require__(/*! ../../core/Framework */ "../../../core/build/core/src/core/Framework.js");
var PeerConstants_1 = __webpack_require__(/*! ../PeerConstants */ "../../../core/build/core/src/webrtc/PeerConstants.js");
var ErrorCodes = __webpack_require__(/*! ../../common/error.hive */ "../../../core/build/core/src/common/error.hive.js");
var logger_hive_1 = __webpack_require__(/*! ../../common/logger.hive */ "../../../core/build/core/src/common/logger.hive.js");
var CustomSnapshotProvider_1 = __webpack_require__(/*! ../../stats/CustomSnapshotProvider */ "../../../core/build/core/src/stats/CustomSnapshotProvider.js");
var HashMap = __webpack_require__(/*! @hivestreaming/collections/map */ "../../../node_modules/@hivestreaming/collections/map.js");
/**
 * abstract implementation of the TimerHandler.
 * The implementation is the same for all, but every protocol can override the default min/max timers
 */
var TimerHandlerBase = /** @class */ (function () {
    function TimerHandlerBase(nodeInfo) {
        this.loggerId = '[TIMER HANDLER] ';
        this.fallbackAverageBw = new Utils_1.Bandwidth();
        this.p2pAverageBw = new Utils_1.Bandwidth();
        this.timerStatsMap = new HashMap();
        this.logger = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.LOGGER).log();
        this.nodeInfo = nodeInfo;
    }
    /**
     * Calculates the time to wait for a fragment from the P2P network keeping into account fragment duration,
     * estimated time to fetct it from the fallback or from the selected partner
     *
     * Since there is no compensation, we need to return a valid timeout ONLY if we are confident
     * that we can download the entire fragment in time from the chosen peer, otherwise better not risk it, return timer 0
     * and force going to the CDN directly.
     *
     * The general idea is that we will use as P2P timer the fragment duration - time to download it from the CDN.
     * In this way, if the p2p fails, we still have enough time to fetch the entire fragment from the CDN.
     *
     * If the CDN is too slow, but the P2P is very fast (possible local partner), then we will still attempt to fetch the
     * content from the P2P, with half a fragment as timer
     */
    TimerHandlerBase.prototype.getP2PTimeout = function (request, remainingBytes) {
        try {
            var timeout = void 0;
            var fragmentDuration = request.entityCharacteristics.getDuration();
            var totalBytes = request.size;
            var cdnTimeEstimate = -1;
            var remainingTimeForP2P = 0;
            var p2pTimeEstimate = -1;
            // first let's estimate how long it would take to fetch the entire fragment from the CDN
            // given the current average source throughput with a minimum of 10 millisecond of setting up XHR + RTT
            if (this.fallbackAverageBw.isValid())
                cdnTimeEstimate = Math.max(10, this.fallbackAverageBw.getTransmissionTime(totalBytes));
            // with a valid cdn estimate, calculate the remaining time for p2p as
            // fragment duration - a bit more than the cdn time
            if (cdnTimeEstimate > -1)
                remainingTimeForP2P = Math.max(0, fragmentDuration - (cdnTimeEstimate * PeerConstants_1.PeerConstants.P2PTimer.FALLBACK_TRANSMISSION_TIME_MULTIPLIER));
            else
                remainingTimeForP2P = fragmentDuration * 0.50;
            if (TimerHandlerBase.USE_NEW_ALG) {
                //  estimate the download time from the picked partner
                var partnerAvg = request.partner.getRcvRatesAvg();
                if (partnerAvg > 0) {
                    p2pTimeEstimate = (remainingBytes / partnerAvg) * PeerConstants_1.PeerConstants.P2PTimer.PARTNER_RATE_MULTIPLIER;
                }
                if (request.type === HiveInternalRequest_1.RequestType.P2P_PREFETCH) {
                    // in case of p2p prefetch request return the whole fragment duration times a multiplier
                    // TODO create special logic for P2P Prefetch
                    timeout = fragmentDuration * PeerConstants_1.PeerConstants.P2PTimer.P2P_PREFETCH_MULTIPLIER;
                }
                else if (p2pTimeEstimate > -1 && p2pTimeEstimate <= remainingTimeForP2P) {
                    // normal case, the p2p is faster then the remaining time to go to the P2P
                    timeout = remainingTimeForP2P;
                }
                else if (p2pTimeEstimate > -1 && p2pTimeEstimate <= fragmentDuration * PeerConstants_1.PeerConstants.P2PTimer.LOCAL_P2P_TIMER_MULTIPLIER) {
                    /*
                     * case in which the p2pTime Estimate is not less than the remaining Time
                     * because the CDN is probably too slow.
                     * If the P2P is anyhow fast enough to download the fragment in a small fraction
                     * of its duration, then let's go to P2P!
                     */
                    timeout = fragmentDuration * PeerConstants_1.PeerConstants.P2PTimer.LOCAL_P2P_TIMER_MULTIPLIER;
                }
                else
                    // we return 0 to force to fetch the entire fragment from CDN
                    timeout = 0;
            }
            else { // OLD ALGORITHM
                // in case of p2p prefetch request, as first version we just double the timer
                if (request.type == HiveInternalRequest_1.RequestType.P2P_PREFETCH)
                    remainingTimeForP2P *= 2;
                timeout = Math.max(this.getMinP2PTimeout(), remainingTimeForP2P);
            }
            if (PeerConstants_1.PeerConstants.CustomSnaps.P2P_TIMER) {
                var map = this.timerStatsMap.has(request.getEntityId()) ? this.timerStatsMap.get(request.getEntityId()) : this.initStatsMap(request);
                map.push([
                    Framework_1.Framework.time(),
                    remainingBytes,
                    cdnTimeEstimate,
                    remainingTimeForP2P,
                    p2pTimeEstimate,
                    request.type,
                    timeout // 6 gen timeout
                ]);
                this.timerStatsMap.set(request.getEntityId(), map);
            }
            this.logger.debug('TIMER DETAILS duration: ' + fragmentDuration + ' left/total: ' + remainingBytes + '/' + totalBytes
                + ' cdn: ' + cdnTimeEstimate + ' remaining: ' + remainingTimeForP2P + ' p2p: ' + p2pTimeEstimate + ' timeout: ' + timeout);
            return timeout;
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error calculating the p2p timeout', this.loggerId, ErrorCodes.TIMER_HANDLE_CODES.GET_P2P_TIMEOUT, error);
            // When we calculate the timeout in the P2PRequester we check if the timeout is 0. If we set this to 0, then we account this to failure(not the best option)
            // and we continue to CDN. The same think happens for the p2p upgrade prefetch.
            return 0;
        }
    };
    TimerHandlerBase.prototype.getCDNTimeout = function (request, left) {
        return 5000;
    };
    TimerHandlerBase.prototype.getDeliverDelay = function (size) {
        try {
            if (this.fallbackAverageBw.isValid())
                return Math.min(this.fallbackAverageBw.getTransmissionTime(size), this.getMaxDeliveryDelay());
            else
                return this.getInitDeliveryDelay();
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error calculating the delivery delay', this.loggerId, ErrorCodes.TIMER_HANDLE_CODES.DELIVER_DELAY, error);
            return this.getInitDeliveryDelay();
        }
    };
    TimerHandlerBase.prototype.updateTimers = function (request) {
        if (request.getEntityType() === EntityType_1.EntityType.VIDEO) {
            switch (request.getRequestType()) {
                case HiveInternalRequest_1.RequestType.CDN:
                case HiveInternalRequest_1.RequestType.UPPER_LAYER:
                case HiveInternalRequest_1.RequestType.CDN_PREFETCH:
                case HiveInternalRequest_1.RequestType.CDN_COMPENSATION:
                    this.fallbackAverageBw.smooth(request.getBandwidth());
                    break;
                case HiveInternalRequest_1.RequestType.P2P:
                case HiveInternalRequest_1.RequestType.P2P_PREFETCH:
                    this.p2pAverageBw.smooth(request.getBandwidth());
                    break;
            }
        }
        if (PeerConstants_1.PeerConstants.CustomSnaps.P2P_TIMER) {
            var map = this.timerStatsMap.has(request.getEntityId()) ? this.timerStatsMap.get(request.getEntityId()) : this.initStatsMap(request);
            map.push([
                Framework_1.Framework.time(),
                request.getRequestType()
            ]);
            CustomSnapshotProvider_1.CustomSnapshotProvider.appendAndFlush(null, null, 'p2p_timer', this.nodeInfo.getReportingGuid(), map, 10);
        }
    };
    /**
     * get minimum p2p timeout.
     * Each protocol can override this value
     * @return millisecond
     */
    TimerHandlerBase.prototype.getMinP2PTimeout = function () {
        return TimerHandlerBase.DEFAULT_MIN_P2P_TIMEOUT;
    };
    /**
     * get maximum delivery delay.
     * Each protocol can override this value
     * @return millisecond
     */
    TimerHandlerBase.prototype.getInitDeliveryDelay = function () {
        return TimerHandlerBase.DEFAULT_INIT_DELIVERY_DELAY;
    };
    /**
     * get initial delivery delay when there are no throughput info.
     * Each protocol can override this value.
     * @return millisecond
     */
    TimerHandlerBase.prototype.getMaxDeliveryDelay = function () {
        return TimerHandlerBase.DEFAULT_MAX_DELIVERY_DELAY;
    };
    TimerHandlerBase.prototype.initStatsMap = function (request) {
        return [[
                request.getEntityId(),
                request.entityCharacteristics.getDuration(),
                request.size
            ]];
    };
    // TODO: remove this, used only during evaluation
    TimerHandlerBase.USE_NEW_ALG = true;
    TimerHandlerBase.DEFAULT_MIN_P2P_TIMEOUT = 500;
    TimerHandlerBase.DEFAULT_MAX_DELIVERY_DELAY = 1500;
    TimerHandlerBase.DEFAULT_INIT_DELIVERY_DELAY = 500;
    return TimerHandlerBase;
}());
exports.TimerHandlerBase = TimerHandlerBase;
//# sourceMappingURL=TimerHandlerBase.js.map

/***/ }),

/***/ "../../../core/build/core/src/webrtc/context/VideoContextBase.js":
/*!****************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/webrtc/context/VideoContextBase.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.VideoContextBase = void 0;
var SortedMap = __webpack_require__(/*! @hivestreaming/collections/sorted-map */ "../../../node_modules/@hivestreaming/collections/sorted-map.js");
var VideoEntityCharacteristics_1 = __webpack_require__(/*! ../../core/entity/video/VideoEntityCharacteristics */ "../../../core/build/core/src/core/entity/video/VideoEntityCharacteristics.js");
var Framework_1 = __webpack_require__(/*! ../../core/Framework */ "../../../core/build/core/src/core/Framework.js");
var RequestDirective_1 = __webpack_require__(/*! ../RequestDirective */ "../../../core/build/core/src/webrtc/RequestDirective.js");
var EntityType_1 = __webpack_require__(/*! ../../core/entity/EntityType */ "../../../core/build/core/src/core/entity/EntityType.js");
var HiveInternalRequest_1 = __webpack_require__(/*! ../HiveInternalRequest */ "../../../core/build/core/src/webrtc/HiveInternalRequest.js");
var Prefetcher_1 = __webpack_require__(/*! ../prefetch/Prefetcher */ "../../../core/build/core/src/webrtc/prefetch/Prefetcher.js");
var PeerConstants_1 = __webpack_require__(/*! ../PeerConstants */ "../../../core/build/core/src/webrtc/PeerConstants.js");
var ErrorCodes = __webpack_require__(/*! ../../common/error.hive */ "../../../core/build/core/src/common/error.hive.js");
var logger_hive_1 = __webpack_require__(/*! ../../common/logger.hive */ "../../../core/build/core/src/common/logger.hive.js");
var QualityLevel_1 = __webpack_require__(/*! ../../core/quality-level/QualityLevel */ "../../../core/build/core/src/core/quality-level/QualityLevel.js");
var OriginType = hive.snapshots.OriginType;
var SnapshotRequestType = hive.snapshots.RequestType;
var RequestContext_1 = __webpack_require__(/*! ./RequestContext */ "../../../core/build/core/src/webrtc/context/RequestContext.js");
var VideoContextBase = /** @class */ (function () {
    function VideoContextBase(ticket, swarm) {
        this.baseLoggerId = '[VideoContext] ';
        this.playerRequests = new SortedMap();
        this.logger = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.LOGGER).log(swarm.sessionId);
        this.fragmentMetadataProvider = swarm.reportingInstance.statsStore.fragmentMetadataProvider;
        this.fragmentDownloadProvider = swarm.reportingInstance.statsStore.fragmentDownloadProvider;
        this.ticket = ticket;
        this.manifestUrl = ticket.getManifestUrlWithQuery();
        this.nodeInfo = swarm.nodeInfo;
        this.snapAccountManager = swarm.snapAccountingManager;
        this.requestTracker = swarm.requestTracker;
        this.videoPrefetcher = swarm.prefetcher;
        this.videoPrefetcher.initContext(this, this);
        this.requestContext = new RequestContext_1.RequestContext();
    }
    VideoContextBase.prototype.isPlayerBufferingBase = function (playerRequestDispersionTime, minimumFragmentsToInferBufferings) {
        try {
            var c = 0;
            var cBuffering = 0;
            if (this.playerRequests.length < minimumFragmentsToInferBufferings) {
                return true;
            }
            var timestamps = this.playerRequests.keys().reverse();
            var previousTimestamp = timestamps[0];
            var previousQualityLevel = this.playerRequests.get(previousTimestamp).getQualityLevel();
            var sliced = timestamps.slice(1);
            for (var i = 0; i < sliced.length; i++) {
                var ts = sliced[i];
                var playerRequest = this.playerRequests.get(ts);
                var requestedTimestamp = playerRequest.requestedTs;
                var requestedQualityLevel = playerRequest.getQualityLevel();
                var requestDelta = Math.abs(requestedTimestamp - previousTimestamp);
                if (requestedQualityLevel.id !== previousQualityLevel.id) {
                    return false;
                }
                else if (requestDelta < playerRequestDispersionTime) {
                    if (++cBuffering >= minimumFragmentsToInferBufferings) {
                        return false;
                    }
                }
                else {
                    if (++c > minimumFragmentsToInferBufferings) {
                        return true;
                    }
                    else {
                        cBuffering = Math.max(0, cBuffering - 1);
                    }
                    previousTimestamp = requestedTimestamp;
                    previousQualityLevel = requestedQualityLevel;
                }
            }
            return false;
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error calculating if the player is in buffering mode', this.baseLoggerId, ErrorCodes.VIDEO_CONTEXT_BASE_CODES.IS_PLAYER_BUFFERING_BASE, error);
            return false;
        }
    };
    /**
     *  Receive the videoEntityCharacteristics request from the HiveCache.
     *  The request can be either player's request or from the Prefetcher
     * @param entity
     * @param type
     * @returns {RequestDirective}
     */
    VideoContextBase.prototype.requestReceived = function (entity, type) {
        // account quality level switch
        if (this.isNotPrefetch(type)) {
            var previousRequest = this.lastPlayerRequest();
            if (previousRequest) {
                var currentQualityLevel = entity.getQualityLevel();
                var previousQualityLevel = previousRequest.getQualityLevel();
                if (currentQualityLevel.compareTo(previousQualityLevel) > 0) {
                    this.snapAccountManager.accountQualityLevelSwitch(true);
                }
                else if (currentQualityLevel.compareTo(previousQualityLevel) < 0) {
                    this.snapAccountManager.accountQualityLevelSwitch(false);
                }
            }
            else {
                this.snapAccountManager.accountQualityLevelSwitch(true);
            }
            // already requested garbage collection
            if (this.playerRequests.length > PeerConstants_1.PeerConstants.RequestTracker.ALREADY_REQUESTED_GC) {
                var firstPlayerRequest = this.playerRequests.keys()[0];
                this.playerRequests.delete(firstPlayerRequest);
            }
            // track the last video request
            this.playerRequests.set(Framework_1.Framework.time(), entity);
        }
        // Create a RequestDirective regardless it is a prefetch type or not
        return this.configureRequestDirective(entity, type);
    };
    /**
     * Initiate the request directive according to the Prefetcher wantedcontent and the RequestTracker information
     * @param entity
     * @param currentReqType
     * @returns {RequestDirective}
     */
    VideoContextBase.prototype.configureRequestDirective = function (entity, currentReqType) {
        var reqDir = new RequestDirective_1.RequestDirective();
        try {
            // Check if the quality level is assigned to the Prefetcher's wanted content
            if (!this.videoPrefetcher.hasQualityLevelAssigned(entity.getQualityLevel())) {
                var prefetchType = Prefetcher_1.PrefetchType.PLAYER;
                if (this.nodeInfo.isLanLeader()) {
                    prefetchType = Prefetcher_1.PrefetchType.LAN;
                }
                // If not assign the quality level and configure the prefetch variables
                this.videoPrefetcher.setPrefetchQualityLevel(entity.getQualityLevel(), prefetchType, prefetchType);
            }
            else {
                // Check if we already have requested for this entity before
                if (this.requestTracker.isAlreadyRequested(entity.getEntityId())) {
                    reqDir.alreadyRequested = true;
                    // Retrieve the already requested type
                    var alreadyReqType = this.requestTracker.getAlreadyRequestedType(entity.getEntityId());
                    // Check if we need to proceed with this request or ignore it.
                    this.ignoreOrProceed(currentReqType, alreadyReqType, reqDir);
                }
                // Check if there are any pending requests for the same entityId
                // NOTE: a pending request may be still in "initialization phase"
                if (this.requestTracker.hasPendingRequest(entity.getEntityId())) {
                    var requests = this.requestTracker.getPendingRequestsByObject(entity.getEntityId());
                    // For each pending request we check if we need to ignore this request
                    // or inform the HiveCache that this request need to proceed with upgradePrefetch
                    for (var _i = 0, requests_1 = requests; _i < requests_1.length; _i++) {
                        var request = requests_1[_i];
                        this.ignoreOrProceed(currentReqType, request.getRequestType(), reqDir);
                        reqDir.pendingRequest = true;
                    }
                }
            }
            return reqDir;
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error configuring the request directive', this.baseLoggerId, ErrorCodes.VIDEO_CONTEXT_BASE_CODES.CONFIGURE_REQUEST_DIRECTIVE, error);
            return new RequestDirective_1.RequestDirective();
        }
    };
    /**
     * We proceed with the request iff the current request is of type ReqType.UPPER_LAYER and the previous request is of any Prefetch type
     * Otherwise, if the current request is of any Prefetch Type and the previous request is of any type (UPPER_LAYER, PREFETCH_TYPE) we ignore the request
     * and we force the HiveCache not to continue with this request
     * @param cReqType
     * @param aReqType
     * @param reqDir
     */
    VideoContextBase.prototype.ignoreOrProceed = function (cReqType, aReqType, reqDir) {
        if ((cReqType == HiveInternalRequest_1.RequestType.CDN_PREFETCH || cReqType == HiveInternalRequest_1.RequestType.P2P_PREFETCH) &&
            (aReqType == HiveInternalRequest_1.RequestType.UPPER_LAYER ||
                aReqType == HiveInternalRequest_1.RequestType.P2P_PREFETCH ||
                aReqType == HiveInternalRequest_1.RequestType.CDN_PREFETCH)) {
            reqDir.doNotContinue = true;
        }
    };
    VideoContextBase.prototype.isNotPrefetch = function (type) {
        return type != HiveInternalRequest_1.RequestType.P2P_PREFETCH && type != HiveInternalRequest_1.RequestType.CDN_PREFETCH;
    };
    /**
     * This function will attempts to upgrade a prefetch. The upgrade prefetch is occurred iff the current ReqType is UPPER_LAYER
     * @param original
     * @param entityCharacteristics
     * @param type
     * @returns number[] all original prefetch Hive Requests that have been upgraded
     */
    VideoContextBase.prototype.attemptToUpgradePrefetch = function (original, entityCharacteristics, type) {
        var upgraded = [];
        try {
            var pendingRequests = this.requestTracker.getPendingRequestsByObject(entityCharacteristics.getEntityId());
            for (var _i = 0, pendingRequests_1 = pendingRequests; _i < pendingRequests_1.length; _i++) {
                var request = pendingRequests_1[_i];
                if (request.getRequestType() != HiveInternalRequest_1.RequestType.UPPER_LAYER) {
                    this.logger.debug('UPGRADING REQUEST. FORCING AUTHENTICATION IF NEEDED.');
                    request.upgradedRequest();
                    this.videoPrefetcher.upgradePrefetch(request, original);
                    upgraded.push(request.previousRequestId);
                }
            }
            return upgraded;
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error attempting to upgrade prefetch', this.baseLoggerId, ErrorCodes.VIDEO_CONTEXT_BASE_CODES.ATTEMPT_TO_UPGRADE_PREFETCH, error);
            return [];
        }
    };
    /**
     * This function will create a Pending request to the RequestTracker
     * @param request
     */
    VideoContextBase.prototype.createPendingRequest = function (request) {
        this.requestTracker.createPendingRequest(request);
    };
    /**
     * This function will remove a specific pending request from the RequestTracker
     * @param entityId
     * @param requestId
     */
    VideoContextBase.prototype.removePendingRequest = function (entityId, requestId) {
        this.requestTracker.removePendingRequest(entityId, requestId);
    };
    /**
     * This function removes a request that is already requested from the RequestTracker.
     * This can be happen iff we upgrade prefetch and iff we have a failure.
     * @param entityId
     */
    VideoContextBase.prototype.removeAlreadyRequested = function (entityId) {
        this.requestTracker.removeAlreadyRequested(entityId);
    };
    /**
     * This function tracks the request to the RequestTracker
     * @param request
     */
    VideoContextBase.prototype.addAlreadyRequest = function (request) {
        this.requestTracker.trackRequest(request);
    };
    /**
     * This function checks if there are any pending requests at the moment.
     * If not it initiates an attemptPrefetch
     * @param qualityLevel
     */
    VideoContextBase.prototype.attemptPrefetch = function (qualityLevel) {
        if (!this.requestTracker.hasPendingRequests()) {
            this.videoPrefetcher.initiateAttemptPrefetch(qualityLevel);
        }
    };
    VideoContextBase.prototype.lastPlayerRequest = function () {
        var tss = this.playerRequests.keys();
        if (tss.length > 0) {
            return this.playerRequests.get(tss[tss.length - 1]);
        }
        return null;
    };
    VideoContextBase.prototype.lastPlayerRequestTS = function () {
        var tss = this.playerRequests.keys();
        if (tss.length > 0) {
            return tss[tss.length - 1];
        }
    };
    /**
     * This function receives a have and tries to attempt a prefetch.
     * Since haves are received one by one, we attempt prefetch only for the first one.
     *
     * @param have
     */
    VideoContextBase.prototype.gotHave = function (have) {
        var qualityLevel = QualityLevel_1.QualityLevel.from(have.qualityLevel);
        this.attemptPrefetch(qualityLevel);
    };
    VideoContextBase.prototype.fragmentReceived = function (request) {
        switch (request.getEntityType()) {
            case EntityType_1.EntityType.AUDIO:
                {
                    this.updateFragmentMetadata(request);
                }
                break;
            case EntityType_1.EntityType.VIDEO:
                {
                    this.removePendingRequest(request.getEntityId(), request.getRequestId());
                    this.updateFragmentMetadata(request);
                    this.updateFragmentDownload(request);
                }
                break;
        }
    };
    VideoContextBase.prototype.updateFragmentMetadata = function (request) {
        var segment = this.metadata.getSegmentInfo(request.getRequestUrl());
        if (segment) {
            this.fragmentMetadataProvider.add(segment, request.getResponseSize());
        }
    };
    VideoContextBase.prototype.updateFragmentDownload = function (request) {
        if (!this.isNotPrefetch(request.type)) {
            this.fragmentDownloadProvider.add(request, SnapshotRequestType.PREFETCH, request.requestStats.p2pRequest ? OriginType.P2P : OriginType.CDN);
        }
    };
    VideoContextBase.prototype.getTicket = function () {
        return this.ticket;
    };
    VideoContextBase.prototype.getVideoPrefetcher = function () {
        return this.videoPrefetcher;
    };
    VideoContextBase.prototype.availableQualityLevels = function (type) {
        return this.metadata.availableQualityLevels(type);
    };
    VideoContextBase.prototype.hasBeenLive = function () {
        return this.wasLive;
    };
    VideoContextBase.prototype.getTimerHandler = function () {
        return this.timerHandler;
    };
    VideoContextBase.prototype.getMetadata = function () {
        return this.metadata;
    };
    VideoContextBase.prototype.getStreamProtocol = function () {
        return this.metadata.getStreamProtocol();
    };
    VideoContextBase.prototype.getEntityType = function (url) {
        return this.metadata.getEntityType(url);
    };
    VideoContextBase.prototype.getMetadataInfo = function () {
        return this.metadata.getMetadataInfo();
    };
    VideoContextBase.prototype.isCacheable = function (url) {
        var type = this.getEntityType(url);
        if (type == EntityType_1.EntityType.VIDEO || type == EntityType_1.EntityType.AUDIO)
            return true;
    };
    VideoContextBase.prototype.getEntity = function (segmentId, qualityLevel, type) {
        var segment = this.metadata.getSegment(segmentId, qualityLevel);
        if (segment != null) {
            return new VideoEntityCharacteristics_1.VideoEntityCharacteristics(segment.absoluteUrl, type, true, segmentId, segment.duration.ms(), qualityLevel, true, this.getContextId());
        }
        return null;
    };
    VideoContextBase.prototype.getNextEntity = function (entity) {
        try {
            var url = entity.getUrl();
            var nextSegment = this.metadata.getNextSegmentInfo(url);
            if (nextSegment != null) {
                return this.getEntityCharacteristics(nextSegment.absoluteUrl);
            }
            return null;
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error getting the next entity', this.baseLoggerId, ErrorCodes.VIDEO_CONTEXT_BASE_CODES.GET_NEXT_ENTITY, {
                detailedError: error,
                url: entity.getUrl()
            });
            return null;
        }
    };
    VideoContextBase.prototype.setAuthenticationToken = function (token) {
        this.metadata.setAuthenticationToken(token);
    };
    VideoContextBase.prototype.getQualityLevelTracker = function () {
        return this.metadata.getQualityLevelTracker();
    };
    VideoContextBase.prototype.getRequestContext = function () {
        return this.requestContext;
    };
    return VideoContextBase;
}());
exports.VideoContextBase = VideoContextBase;
//# sourceMappingURL=VideoContextBase.js.map

/***/ }),

/***/ "../../../core/build/core/src/webrtc/context/dash/DashContext.js":
/*!****************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/webrtc/context/dash/DashContext.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.DashContext = void 0;
var VideoContextBase_1 = __webpack_require__(/*! ../VideoContextBase */ "../../../core/build/core/src/webrtc/context/VideoContextBase.js");
var Dash_1 = __webpack_require__(/*! ../../../core/metadata/dash/Dash */ "../../../core/build/core/src/core/metadata/dash/Dash.js");
var DashTimerHandler_1 = __webpack_require__(/*! ./DashTimerHandler */ "../../../core/build/core/src/webrtc/context/dash/DashTimerHandler.js");
var EntityType_1 = __webpack_require__(/*! ../../../core/entity/EntityType */ "../../../core/build/core/src/core/entity/EntityType.js");
var VideoEntityCharacteristics_1 = __webpack_require__(/*! ../../../core/entity/video/VideoEntityCharacteristics */ "../../../core/build/core/src/core/entity/video/VideoEntityCharacteristics.js");
var Framework_1 = __webpack_require__(/*! ../../../core/Framework */ "../../../core/build/core/src/core/Framework.js");
var logger_hive_1 = __webpack_require__(/*! ../../../common/logger.hive */ "../../../core/build/core/src/common/logger.hive.js");
var ErrorCodes = __webpack_require__(/*! ../../../common/error.hive */ "../../../core/build/core/src/common/error.hive.js");
var Utils = __webpack_require__(/*! ../../../core/Utils */ "../../../core/build/core/src/core/Utils.js");
var StreamHealthChecker_1 = __webpack_require__(/*! ../../StreamHealthChecker */ "../../../core/build/core/src/webrtc/StreamHealthChecker.js");
var PrefetchRequest_1 = __webpack_require__(/*! ../../prefetch/PrefetchRequest */ "../../../core/build/core/src/webrtc/prefetch/PrefetchRequest.js");
var DashContext = /** @class */ (function (_super) {
    __extends(DashContext, _super);
    function DashContext(ticket, swarm, hiveJsOptions) {
        var _this = _super.call(this, ticket, swarm) || this;
        _this.loggerId = '[Dash Context] ';
        _this.metadataPrefetchActive = true;
        _this.timerHandler = new DashTimerHandler_1.DashTimerHandler(swarm.nodeInfo);
        _this.metadata = Dash_1.Dash.createMetadata(_this.manifestUrl, { regenerate: true }, swarm.sessionId, hiveJsOptions);
        _this.streamHealthChecker = new StreamHealthChecker_1.StreamHealthChecker(_this.metadata);
        _this.fragmentMetadataProvider.setMetadata(_this.metadata);
        return _this;
    }
    DashContext.prototype.getEntityCharacteristics = function (url) {
        var entityType = EntityType_1.EntityType.OTHER;
        var duration = 0;
        var qualityLevel = null;
        var segmentId = 0;
        var binary = true;
        var isCacheable = false;
        try {
            entityType = this.getEntityType(url);
            if (this.metadata.isInitialization(url)) {
                binary = true;
            }
            else if (entityType != EntityType_1.EntityType.METADATA) {
                var segment = this.metadata.getSegmentInfo(url);
                if (segment != null) {
                    duration = segment.duration.ms();
                    qualityLevel = segment.qualityLevel;
                    segmentId = segment.id;
                    isCacheable = this.isCacheable(url);
                }
                else {
                    this.requestMetadata();
                    this.logger.warn("could not extract segment info for " + url);
                    var rep = this.metadata.getRepresentation(url);
                    if (!rep) {
                        this.logger.warn("no representation found for " + url);
                    }
                    else {
                        this.logger.warn('representation is', rep);
                        this.logger.warn('representation segments', rep.idToSegment.map(function (a, b) { return b + " => " + a.absoluteUrl; }).join(', '));
                    }
                }
            }
            else {
                binary = false;
            }
            return new VideoEntityCharacteristics_1.VideoEntityCharacteristics(url, entityType, binary, segmentId, duration, qualityLevel, isCacheable, this.getContextId());
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error getting the entity characteristics based on a url', this.loggerId, ErrorCodes.DASH_CONTEXT_CODES.GET_ENTITY_CHARACTERISTICS, {
                detailedError: error,
                url: url
            });
            return new VideoEntityCharacteristics_1.VideoEntityCharacteristics(url, EntityType_1.EntityType.OTHER, false, 0, 0, null, false, this.getContextId());
        }
    };
    DashContext.prototype.canPrefetch = function () {
        return _super.prototype.isPlayerBufferingBase.call(this, Dash_1.Dash.DASH_REQUEST_DISPERSION, Dash_1.Dash.DASH_MINIMUM_FRAGMENTS_TO_INFER_BUFFERING);
    };
    DashContext.prototype.isCurrentContext = function (request) {
        try {
            var url = request.url;
            var urlNoParams = Utils.removeQueryParams(url);
            // check if it is our manifest
            if (urlNoParams === Utils.removeQueryParams(this.manifestUrl))
                return true;
            // ok if it is an initialization
            if (this.metadata != null && this.metadata.isInitialization(url))
                return true;
            // refuse if it is another manifest AND not a segment
            if (this.metadata.isManifest(url, this.logger) && (this.manifestUrl !== url) && !(Dash_1.Dash.isSegmentTemplate(this.manifestUrl, url)))
                return false;
            return true;
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error identifying if is current context', this.loggerId, ErrorCodes.DASH_CONTEXT_CODES.IS_CURRENT_CONTEXT, {
                detailedError: error,
                url: request.url
            });
            return false;
        }
    };
    DashContext.prototype.metadataReceived = function (request) {
        try {
            this.lastMetadataRequested = Framework_1.Framework.time();
            var text = request.getResponseAsString();
            var url = request.originalRequest.url;
            var trimmedManifest = this.metadata.parse(url, text, request.originalRequest.internal);
            this.streamHealthChecker.metadataUpdated();
            if (this.wasLive === undefined) {
                this.wasLive = this.metadata.isLive();
            }
            request.originalRequest.responseText = trimmedManifest;
            request.originalRequest.response = trimmedManifest;
            this.clearPendingRequestMetadata();
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error parsing received metadata', this.loggerId, ErrorCodes.DASH_CONTEXT_CODES.PARSED_METADATA, {
                detailedError: error,
                url: request.originalRequest.url
            });
            if (request.getResponseAsString()) {
                request.originalRequest.responseText = request.getResponseAsString();
                request.originalRequest.response = request.getResponseAsString();
            }
        }
        try {
            this.videoPrefetcher.metadataAvailable();
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error starting prefetcher after fetching metadata', this.loggerId, ErrorCodes.DASH_CONTEXT_CODES.PREFETCH_METADATA_RECEIVED, {
                detailedError: error,
                url: request.originalRequest.url
            });
        }
        // on every new manifest evaluate if there was an updated protection
        this.evaluateProtection();
    };
    DashContext.prototype.fragmentReceived = function (request) {
        var _this = this;
        try {
            _super.prototype.fragmentReceived.call(this, request);
            if (request.getEntityType() === EntityType_1.EntityType.VIDEO || request.getEntityType() === EntityType_1.EntityType.AUDIO) {
                // update timers
                if (request.getEntityType() === EntityType_1.EntityType.VIDEO)
                    this.timerHandler.updateTimers(request);
                // let the dash metadata process the fragment to calculate the next fragment
                // and then trigger the prefetcher
                this.metadata.requestReceived(request).then(function (error) {
                    // if there was an error in the decryption, re-evaluate the protection
                    // to, in case, enable the metadata prefetch
                    if (error)
                        _this.evaluateProtection();
                    if (request.getEntityType() == EntityType_1.EntityType.VIDEO) {
                        _this.videoPrefetcher.fragmentRetrieved(request.entityCharacteristics);
                    }
                }).done();
            }
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error when received a fragment', this.loggerId, ErrorCodes.DASH_CONTEXT_CODES.FRAGMENT_RECEIVED, error);
        }
    };
    /**
     * as context id use the format <manifestUrl>-[partner/customer/content]
     */
    DashContext.prototype.getContextId = function () {
        return this.ticket.getFullEventInfo();
    };
    DashContext.prototype.requestReceived = function (entity, reqType) {
        var videoEntity = entity;
        videoEntity.requestedTs = Framework_1.Framework.time();
        return _super.prototype.requestReceived.call(this, videoEntity, reqType);
    };
    DashContext.prototype.segmentDistance = function (previousSegmentId, previousSegmentQualityLevel, currentSegmentId, currentSegmentQualityLevel) {
        return this.metadata.segmentDistance(previousSegmentId, previousSegmentQualityLevel, currentSegmentId, currentSegmentQualityLevel);
    };
    /**
     * if the stream is protected, check if we can decrypt it, otherwise, if possible, activate the
     * metadata prefetch
     */
    DashContext.prototype.evaluateProtection = function () {
        var _this = this;
        try {
            if (this.metadata.protection)
                this.metadata.protection.canDecrypt().then(function (canDecrypt) {
                    if (canDecrypt) {
                        _this.metadataPrefetchActive = true;
                        _this.logger.debug('Protection evaluation: can decrypt');
                    }
                    else {
                        var logStr = 'Protection evaluation: cannot decrypt [' + (Dash_1.Dash.DASH_DECRYPT ? 'error' : 'disabled') + ']';
                        if (Dash_1.Dash.DASH_METADATA_PREFETCH) {
                            _this.metadataPrefetchActive = true;
                            _this.logger.debug(logStr + ', metadata prefetch enabled');
                        }
                        else
                            _this.logger.warn(logStr + ', metadata prefetch DISABLED');
                    }
                }).done();
            else
                this.logger.debug('Stream protection evaluation: not encrypted');
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error evaluating the protection', this.loggerId, ErrorCodes.DASH_CONTEXT_CODES.EVALUATE_PROTECTION, error);
            if (Dash_1.Dash.DASH_METADATA_PREFETCH) {
                var logStr = 'Protection evaluation: cannot decrypt [' + (Dash_1.Dash.DASH_DECRYPT ? 'error' : 'disabled') + ']';
                this.metadataPrefetchActive = true;
                this.logger.debug(logStr + ', metadata prefetch enabled');
            }
        }
    };
    /**
     * if the metadata prefetcher is enabled, schedule one metadata download at the time
     */
    DashContext.prototype.requestMetadata = function () {
        if (this.metadataPrefetchActive) {
            // if it's vod we don't re-download the manifest/bootstrapinfo
            if (this.metadataRequestTriggered == null && this.metadata.isLive()) {
                this.scheduleMetadataPrefetch();
            }
            else {
                this.logger.debug('DASH PRE-FETCHING METADATA ALREADY SCHEDULED OR NOT LIVE');
            }
        }
    };
    DashContext.prototype.clearPendingRequestMetadata = function () {
        if (this.metadataPrefetchActive) {
            if (this.metadataRequestTriggered != null) {
                Framework_1.Framework.clearTimeout(this.metadataRequestTriggered);
                this.metadataRequestTriggered = null;
            }
        }
    };
    /**
     * schedule one metadata download making sure to wait enough time from the previous download time
     * for a new fragment to be available
     */
    DashContext.prototype.scheduleMetadataPrefetch = function () {
        var _this = this;
        var lastMetadataRequest = this.lastMetadataRequested != undefined ? this.lastMetadataRequested : 0;
        var lastSegmentDuration = Dash_1.Dash.DASH_DEFAULT_FRAGMENT_DURATION;
        var postponeTo = lastMetadataRequest + lastSegmentDuration;
        var metadataReqDelay = Math.max(1, postponeTo - Framework_1.Framework.time() + Dash_1.Dash.DASH_METADATA_PREFETCH_ADJUST);
        this.logger.debug('DASH PREFETCHING METADATA ' + this.metadata.getManifestUrl() + ' IN ' + metadataReqDelay);
        this.metadataRequestTriggered = Framework_1.Framework.setTimeout(function () {
            _this.handleTimer(_this.metadata.getManifestUrl(), Framework_1.Framework.time());
        }, metadataReqDelay);
    };
    DashContext.prototype.handleTimer = function (url, scheduledAt) {
        var lastRequest = this.lastMetadataRequested;
        if (lastRequest == null) {
            lastRequest = 0;
        }
        if (lastRequest > scheduledAt) {
            this.scheduleMetadataPrefetch();
        }
        if (this.metadata && this.metadata.numericRepresentation) {
            // Number-based dynamic manifests don't need to be redownloaded.
            this.metadataRequestTriggered = null;
            this.lastMetadataRequested = Framework_1.Framework.time();
        }
        else {
            var request = new PrefetchRequest_1.PrefetchRequest(this.ticket.pluginId);
            request.open('GET', url);
            request.send();
            this.metadataRequestTriggered = null;
            this.lastMetadataRequested = Framework_1.Framework.time();
        }
    };
    DashContext.prototype.getDistanceDuration = function (currentSegmentId, currentSegmentQualityLevel) {
        try {
            var lastSegmentCharacteristics = this.lastPlayerRequest();
            var lastSegmentRequestTs = this.lastPlayerRequestTS();
            var lastId = lastSegmentCharacteristics.getSegmentId();
            var distanceMsec = this.metadata.segmentDistance(lastId, lastSegmentCharacteristics.getQualityLevel(), currentSegmentId, currentSegmentQualityLevel);
            var elapsedFromLastPlayerReq = Framework_1.Framework.time() - lastSegmentRequestTs;
            var distance = Math.max(0, distanceMsec - elapsedFromLastPlayerReq);
            return distance;
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error calculating the distance duration', this.loggerId, ErrorCodes.DASH_CONTEXT_CODES.GET_DISTANCE_DURATION, error);
            return 0;
        }
    };
    DashContext.prototype.getAvailability = function (segmentId, qualityLevel) {
        return this.metadata.getAvailability(segmentId, qualityLevel);
    };
    DashContext.prototype.getMinimumPrefetchDistance = function () {
        return Dash_1.Dash.DASH_MINIMUM_PREFETCH_DISTANCE;
    };
    DashContext.prototype.getMaximumPrefetchDistance = function () {
        return Dash_1.Dash.DASH_MAX_PREFETCH_DISTANCE;
    };
    return DashContext;
}(VideoContextBase_1.VideoContextBase));
exports.DashContext = DashContext;
//# sourceMappingURL=DashContext.js.map

/***/ }),

/***/ "../../../core/build/core/src/webrtc/context/dash/DashTimerHandler.js":
/*!*********************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/webrtc/context/dash/DashTimerHandler.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.DashTimerHandler = void 0;
var TimerHandlerBase_1 = __webpack_require__(/*! ../TimerHandlerBase */ "../../../core/build/core/src/webrtc/context/TimerHandlerBase.js");
var DashTimerHandler = /** @class */ (function (_super) {
    __extends(DashTimerHandler, _super);
    function DashTimerHandler() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return DashTimerHandler;
}(TimerHandlerBase_1.TimerHandlerBase));
exports.DashTimerHandler = DashTimerHandler;
//# sourceMappingURL=DashTimerHandler.js.map

/***/ }),

/***/ "../../../core/build/core/src/webrtc/context/hls/HlsContext.js":
/*!**************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/webrtc/context/hls/HlsContext.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.HlsContext = void 0;
var HashMap = __webpack_require__(/*! @hivestreaming/collections/map */ "../../../node_modules/@hivestreaming/collections/map.js");
var VideoContextBase_1 = __webpack_require__(/*! ../VideoContextBase */ "../../../core/build/core/src/webrtc/context/VideoContextBase.js");
var Hls_1 = __webpack_require__(/*! ../../../core/metadata/hls/Hls */ "../../../core/build/core/src/core/metadata/hls/Hls.js");
var HlsTimerHandler_1 = __webpack_require__(/*! ./HlsTimerHandler */ "../../../core/build/core/src/webrtc/context/hls/HlsTimerHandler.js");
var Framework_1 = __webpack_require__(/*! ../../../core/Framework */ "../../../core/build/core/src/core/Framework.js");
var EntityType_1 = __webpack_require__(/*! ../../../core/entity/EntityType */ "../../../core/build/core/src/core/entity/EntityType.js");
var VideoEntityCharacteristics_1 = __webpack_require__(/*! ../../../core/entity/video/VideoEntityCharacteristics */ "../../../core/build/core/src/core/entity/video/VideoEntityCharacteristics.js");
var URI = __webpack_require__(/*! urijs */ "../../../node_modules/urijs/src/URI.js");
var logger_hive_1 = __webpack_require__(/*! ../../../common/logger.hive */ "../../../core/build/core/src/common/logger.hive.js");
var ErrorCodes = __webpack_require__(/*! ../../../common/error.hive */ "../../../core/build/core/src/common/error.hive.js");
var StreamHealthChecker_1 = __webpack_require__(/*! ../../StreamHealthChecker */ "../../../core/build/core/src/webrtc/StreamHealthChecker.js");
var Utils = __webpack_require__(/*! ../../../core/Utils */ "../../../core/build/core/src/core/Utils.js");
var PrefetchRequest_1 = __webpack_require__(/*! ../../prefetch/PrefetchRequest */ "../../../core/build/core/src/webrtc/prefetch/PrefetchRequest.js");
var HlsContext = /** @class */ (function (_super) {
    __extends(HlsContext, _super);
    function HlsContext(ticket, swarm, hiveJsOptions) {
        var _this = _super.call(this, ticket, swarm) || this;
        _this.loggerId = '[HLS Context] ';
        _this.logContext = false;
        _this.lastMetadataRequested = new HashMap();
        _this.metadataRequestTriggered = new HashMap();
        _this.timerHandler = new HlsTimerHandler_1.HlsTimerHandler(swarm.nodeInfo);
        _this.metadata = Hls_1.Hls.createMetadata({ regenerate: true }, swarm.sessionId, hiveJsOptions);
        _this.streamHealthChecker = new StreamHealthChecker_1.StreamHealthChecker(_this.metadata);
        return _this;
    }
    HlsContext.prototype.getContextId = function () {
        return this.ticket.getFullEventInfo();
    };
    HlsContext.prototype.isCurrentContext = function (request) {
        try {
            var url = request.url = this.constructRealUrl(request.url);
            var urlNoQueryParams = Utils.removeQueryParams(url);
            if (urlNoQueryParams === this.ticket.getManifestUrl()) {
                if (this.logContext) {
                    this.logger.debug('SAME MANIFEST ' + url + ',' + this.ticket.getManifestUrl)();
                }
                return true;
            }
            if (this.metadata != null && this.metadata.hasPlaylist(url)) {
                if (this.logContext) {
                    this.logger.debug('CORRECT PLAYLIST ' + url + ',' + this.ticket.getManifestUrl);
                }
                return true;
            }
            if (this.metadata != null && this.metadata.getSegmentInfo(url) != null) {
                if (this.logContext) {
                    this.logger.debug('CORRECT SEGMENT ' + url + ',' + this.ticket.getManifestUrl);
                }
                return true;
            }
            if (this.metadata.isManifest(url, this.logger) && this.manifestUrl !== urlNoQueryParams) {
                if (this.logContext) {
                    this.logger.debug('FIRST REQUEST FOR MANIFEST ' + url + ',' + this.ticket.getManifestUrl);
                }
                return false;
            }
            return false;
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error getting the current context of the HiveRequest', this.loggerId, ErrorCodes.HLS_CONTEXT_CODES.IS_CURRENT_CONTEXT, {
                detailedError: error,
                url: request.url
            });
            return false;
        }
    };
    HlsContext.prototype.constructRealUrl = function (url) {
        return URI(url).normalizePathname().toString();
    };
    HlsContext.prototype.getEntityCharacteristics = function (url) {
        var duration = 0;
        var qualityLevel = null;
        var segmentId = 0;
        var binary = true;
        var isCacheable = false;
        try {
            var entityType = this.getEntityType(url);
            if (entityType != EntityType_1.EntityType.METADATA) {
                var segment = this.metadata.getSegmentInfo(url);
                if (segment != null) {
                    duration = segment.duration.ms();
                    qualityLevel = segment.qualityLevel;
                    segmentId = segment.id;
                    isCacheable = this.isCacheable(url);
                }
            }
            else {
                binary = false;
                if (this.metadata != null && this.metadata.hasPlaylist(url)) {
                    qualityLevel = this.metadata.getPlaylist(url).qualityLevel;
                    this.lastMetadataRequested.set(qualityLevel.id, Framework_1.Framework.time());
                }
            }
            return new VideoEntityCharacteristics_1.VideoEntityCharacteristics(url, entityType, binary, segmentId, duration, qualityLevel, isCacheable, this.getContextId());
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error getting the entityCharacteristics from the url', this.loggerId, ErrorCodes.HLS_CONTEXT_CODES.GET_ENTITY_CHARACTERISTICS, {
                detailedError: error,
                url: url
            });
            return new VideoEntityCharacteristics_1.VideoEntityCharacteristics(url, EntityType_1.EntityType.OTHER, false, 0, 0, null, false, this.getContextId());
        }
    };
    HlsContext.prototype.metadataReceived = function (request) {
        try {
            var text = request.getResponseAsString();
            var url = request.getResponseUrl();
            var trimmedManifest = this.metadata.parse(url, text);
            if (this.metadata.hasPlaylist(url)) {
                var playlist = this.metadata.getPlaylist(url);
                this.streamHealthChecker.metadataUpdated();
                if (this.wasLive === undefined) {
                    this.wasLive = !playlist.endList;
                }
                this.videoPrefetcher.metadataAvailable(playlist.qualityLevel);
            }
            // update the response buffer with the trimmed manifest
            request.originalRequest.response = trimmedManifest;
            request.originalRequest.responseText = trimmedManifest;
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error receiving the metadata', this.loggerId, ErrorCodes.HLS_CONTEXT_CODES.METADATA_RECEIVED, {
                detailedError: error,
                url: request.getRequestUrl()
            });
            if (request.getResponseAsString()) {
                request.originalRequest.responseText = request.getResponseAsString();
                request.originalRequest.response = request.getResponseAsString();
            }
        }
    };
    HlsContext.prototype.fragmentReceived = function (request) {
        _super.prototype.fragmentReceived.call(this, request);
        if (request.getEntityType() != EntityType_1.EntityType.METADATA && request.getEntityType() != EntityType_1.EntityType.OTHER) {
            this.timerHandler.updateTimers(request);
            if (request.getEntityType() == EntityType_1.EntityType.VIDEO) {
                this.videoPrefetcher.fragmentRetrieved(request.entityCharacteristics);
            }
        }
    };
    HlsContext.prototype.requestReceived = function (entity, reqType) {
        var videoEntity = entity;
        videoEntity.requestedTs = Framework_1.Framework.time();
        return _super.prototype.requestReceived.call(this, videoEntity, reqType);
    };
    HlsContext.prototype.requestMetadata = function (qualityLevel) {
        if (Hls_1.Hls.HLS_METADATA_PREFETCH) {
            var timerHandler = this.metadataRequestTriggered.get(qualityLevel.id);
            // if it's vod we don't re-download the manifest/bootstrapinfo
            if (timerHandler == null && this.metadata.isLive()) {
                this.scheduleMetadataPrefetch(qualityLevel);
            }
        }
    };
    HlsContext.prototype.scheduleMetadataPrefetch = function (qualityLevel) {
        var _this = this;
        try {
            var playlist_1 = this.metadata.getQualityLevelToPlaylist().get(qualityLevel.id);
            if (playlist_1 != null) {
                var hasQualityLevel = this.lastMetadataRequested.has(qualityLevel.id);
                var timestamp = this.lastMetadataRequested.get(qualityLevel.id);
                var lastMetadataRequest = hasQualityLevel ? timestamp : 0;
                var lastSegmentDuration = (playlist_1.segments != null ? playlist_1.segments[playlist_1.segments.length - 1].duration.ms() : Hls_1.Hls.HLS_DEFAULT_FRAGMENT_DURATION);
                var postponeTo = lastMetadataRequest + lastSegmentDuration;
                var metadataReqDelay = Math.max(1, postponeTo - Framework_1.Framework.time() + Hls_1.Hls.HLS_METADATA_PREFETCH_ADJUST);
                this.logger.debug('HLS PREFETCHING METADATA ' + playlist_1.absoluteUri + ' QUALITY LEVEL ' + qualityLevel.id + ' IN ' + metadataReqDelay + ' MS');
                var timerHandler = Framework_1.Framework.setTimeout(function () {
                    _this.handleTimer(qualityLevel, playlist_1.absoluteUri, Framework_1.Framework.time());
                }, metadataReqDelay);
                this.metadataRequestTriggered.set(qualityLevel.id, timerHandler);
            }
            else {
                this.logger.warn('NO STREAM WITH QL ' + qualityLevel.id);
            }
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error scheduling metadata prefetch', this.loggerId, ErrorCodes.HLS_CONTEXT_CODES.SCHEDULE_METADATA_PREFETCH, error);
        }
    };
    HlsContext.prototype.handleTimer = function (qualityLevel, url, scheduledAt) {
        var lastRequest = this.lastMetadataRequested.get(qualityLevel.id);
        if (lastRequest == null) {
            lastRequest = 0;
        }
        if (lastRequest > scheduledAt) {
            this.scheduleMetadataPrefetch(qualityLevel);
        }
        else {
            var request = new PrefetchRequest_1.PrefetchRequest(this.ticket.pluginId);
            request.open('GET', url);
            request.send();
            this.metadataRequestTriggered.delete(qualityLevel.id);
            this.lastMetadataRequested.set(qualityLevel.id, Framework_1.Framework.time());
        }
    };
    HlsContext.prototype.clearPendingRequestMetadata = function () {
        var _this = this;
        var metadataQualityLevels = this.metadataRequestTriggered.keys();
        metadataQualityLevels.forEach(function (qualityLevel) {
            var timeHandler = _this.metadataRequestTriggered.get(qualityLevel);
            Framework_1.Framework.clearTimeout(timeHandler);
            _this.metadataRequestTriggered.delete(qualityLevel);
        });
    };
    HlsContext.prototype.canPrefetch = function () {
        return _super.prototype.isPlayerBufferingBase.call(this, Hls_1.Hls.HLS_REQUEST_DISPERSION, Hls_1.Hls.HLS_MINIMUM_FRAGMENTS_TO_INFER_BUFFERING);
    };
    HlsContext.prototype.segmentDistance = function (previousSegmentId, previousSegmentQualityLevel, currentSegmentId, currentSegmentQualityLevel) {
        return currentSegmentId - previousSegmentId;
    };
    HlsContext.prototype.getMaximumPrefetchDistance = function () {
        return Hls_1.Hls.HLS_MAX_PREFETCH_DISTANCE;
    };
    HlsContext.prototype.getMinimumPrefetchDistance = function () {
        return Hls_1.Hls.HLS_MINIMUM_PREFETCH_DISTANCE;
    };
    HlsContext.prototype.getDistanceDuration = function (currentSegmentId, currentSegmentQualityLevel) {
        var distance = 0;
        try {
            var lastSegmentCharacteristics = this.lastPlayerRequest();
            var lastSegmentRequestTs = this.lastPlayerRequestTS();
            var lastId = lastSegmentCharacteristics.getSegmentId();
            var distanceMsec = 0;
            if (currentSegmentId > lastId) {
                var segment = this.metadata.getSegment(lastId, currentSegmentQualityLevel);
                while (segment && (segment.id < currentSegmentId)) {
                    distanceMsec += segment.duration.ms();
                    segment = segment.next;
                }
            }
            var elapsedFromLastPlayerReq = Framework_1.Framework.time() - lastSegmentRequestTs;
            distance = Math.max(0, distanceMsec - elapsedFromLastPlayerReq);
            return distance;
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error getting the distance duration', this.loggerId, ErrorCodes.HLS_CONTEXT_CODES.GET_DISTANCE_DURATION, error);
            return 0;
        }
    };
    HlsContext.prototype.getAvailability = function (segment, qualityLevel) {
        return 1;
    };
    return HlsContext;
}(VideoContextBase_1.VideoContextBase));
exports.HlsContext = HlsContext;
//# sourceMappingURL=HlsContext.js.map

/***/ }),

/***/ "../../../core/build/core/src/webrtc/context/hls/HlsTimerHandler.js":
/*!*******************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/webrtc/context/hls/HlsTimerHandler.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.HlsTimerHandler = void 0;
var TimerHandlerBase_1 = __webpack_require__(/*! ../TimerHandlerBase */ "../../../core/build/core/src/webrtc/context/TimerHandlerBase.js");
var HlsTimerHandler = /** @class */ (function (_super) {
    __extends(HlsTimerHandler, _super);
    function HlsTimerHandler() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return HlsTimerHandler;
}(TimerHandlerBase_1.TimerHandlerBase));
exports.HlsTimerHandler = HlsTimerHandler;
//# sourceMappingURL=HlsTimerHandler.js.map

/***/ }),

/***/ "../../../core/build/core/src/webrtc/discovery/DiscoveryInfo.js":
/*!***************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/webrtc/discovery/DiscoveryInfo.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.DiscoveredPeerInfo = exports.DiscoveryType = void 0;
__webpack_require__(/*! hivejs-protocol/services/new_tracker_types */ "../../../protocol/services/new_tracker_types.js");
var QualityLevel_1 = __webpack_require__(/*! ../../core/quality-level/QualityLevel */ "../../../core/build/core/src/core/quality-level/QualityLevel.js");
var ExtendedNetworkInfo_1 = __webpack_require__(/*! ../booster/models/ExtendedNetworkInfo */ "../../../core/build/core/src/webrtc/booster/models/ExtendedNetworkInfo.js");
var Utils_1 = __webpack_require__(/*! ../../core/Utils */ "../../../core/build/core/src/core/Utils.js");
var DiscoveryType;
(function (DiscoveryType) {
    DiscoveryType[DiscoveryType["TRACKER"] = 0] = "TRACKER";
    DiscoveryType[DiscoveryType["UDP"] = 1] = "UDP";
})(DiscoveryType = exports.DiscoveryType || (exports.DiscoveryType = {}));
var DiscoveredPeerInfo = /** @class */ (function () {
    function DiscoveredPeerInfo(type, guid, isLeader) {
        this.type = type;
        this.guid = guid;
        this.isVpn = false;
        this.isLeader = isLeader;
        this.connectionType = ExtendedNetworkInfo_1.ConnectionType.UNKNOWN;
    }
    DiscoveredPeerInfo.trackerDiscoveredPeerInfo = function (peerInfo, isLeader) {
        var trackerDiscoveryPeerInfo = new DiscoveredPeerInfo(DiscoveryType.TRACKER, peerInfo.guid, isLeader);
        trackerDiscoveryPeerInfo.internalAs = peerInfo.internalAs;
        trackerDiscoveryPeerInfo.externalAs = peerInfo.externalAs;
        trackerDiscoveryPeerInfo.nat = peerInfo.nat;
        trackerDiscoveryPeerInfo.bandwidth = peerInfo.bandwidth;
        trackerDiscoveryPeerInfo.watchingQualityLevel = new QualityLevel_1.QualityLevel(peerInfo.watchingQualityLevel, peerInfo.watchingBitrate);
        trackerDiscoveryPeerInfo.streams = peerInfo.streams;
        trackerDiscoveryPeerInfo.rankValue = peerInfo.rankValue;
        trackerDiscoveryPeerInfo.timestamp = peerInfo.timestamp;
        trackerDiscoveryPeerInfo.privateIpString = peerInfo.privateIpString;
        trackerDiscoveryPeerInfo.publicIpString = peerInfo.publicIpString;
        trackerDiscoveryPeerInfo.isVpn = peerInfo.isVpn;
        return trackerDiscoveryPeerInfo;
    };
    DiscoveredPeerInfo.UDPDiscoveredPeerInfo = function (peer) {
        var peerinfo = peer.peerInfo;
        var udpDiscoveredPeerInfo = new DiscoveredPeerInfo(DiscoveryType.UDP, peerinfo.peerId);
        udpDiscoveredPeerInfo.rankValue = peerinfo.rank;
        udpDiscoveredPeerInfo.watchingQualityLevel = new QualityLevel_1.QualityLevel(peerinfo.qualityId, 0);
        udpDiscoveredPeerInfo.timestamp = peer.latestHeardFrom;
        udpDiscoveredPeerInfo.joined = peer.joined;
        return udpDiscoveredPeerInfo;
    };
    /**
     * merges the new info into the current object
     */
    DiscoveredPeerInfo.prototype.updateInfo = function (update) {
        // always update the timestamp to the most recent one
        this.timestamp = this.checkVariable(this.timestamp, this.timestamp);
        if (update.type == DiscoveryType.UDP) {
            // update info is UDP, that means we can safely update the UDP related data and treat the member as UDP member
            this.type = DiscoveryType.UDP;
            this.joined = this.checkVariable(this.joined, update.joined);
            this.connectionType = this.checkVariable(this.connectionType, update.connectionType);
            this.watchingQualityLevel = this.checkVariable(this.watchingQualityLevel, update.watchingQualityLevel);
        }
        else {
            this.internalAs = this.checkVariable(this.internalAs, update.internalAs);
            this.isVpn = this.checkVariable(this.isVpn, update.isVpn);
            this.externalAs = this.checkVariable(this.externalAs, update.externalAs);
            this.nat = this.checkVariable(this.nat, update.nat);
            this.bandwidth = this.checkVariable(this.bandwidth, update.bandwidth);
            this.watchingQualityLevel = this.checkVariable(this.watchingQualityLevel, update.watchingQualityLevel);
            this.privateIpString = this.checkVariable(this.privateIpString, update.privateIpString);
            this.publicIpString = this.checkVariable(this.publicIpString, update.publicIpString);
            this.rankValue = this.checkVariable(this.rankValue, update.rankValue);
            if (update.isLeader) {
                this.isLeader = this.checkVariable(this.isLeader, update.isLeader);
            }
            if (update.streams) {
                this.streams = update.streams;
            }
        }
    };
    DiscoveredPeerInfo.prototype.checkVariable = function (oldVariable, newVariable) {
        return Utils_1.isSet(newVariable) ? newVariable : oldVariable;
    };
    return DiscoveredPeerInfo;
}());
exports.DiscoveredPeerInfo = DiscoveredPeerInfo;
//# sourceMappingURL=DiscoveryInfo.js.map

/***/ }),

/***/ "../../../core/build/core/src/webrtc/discovery/tracker/LocalityMode.js":
/*!**********************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/webrtc/discovery/tracker/LocalityMode.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.LocalityMode = void 0;
/**
 * directive from the prefetcher manager to the tracker
 * on which group to rank ourself if we are lan leader
 */
var LocalityMode;
(function (LocalityMode) {
    /**
     * rank me together with all other random nodes
     */
    LocalityMode[LocalityMode["ALL"] = 0] = "ALL";
    /**
     * rank me with all other leaders of the same AS (if site is unknown)
     */
    LocalityMode[LocalityMode["AS"] = 1] = "AS";
    /**
     * rank me with all other leaders of my same site
     */
    LocalityMode[LocalityMode["SITE"] = 2] = "SITE";
})(LocalityMode = exports.LocalityMode || (exports.LocalityMode = {}));
//# sourceMappingURL=LocalityMode.js.map

/***/ }),

/***/ "../../../core/build/core/src/webrtc/discovery/tracker/TrackerClient.js":
/*!***********************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/webrtc/discovery/tracker/TrackerClient.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.TrackerClient = void 0;
var Q = __webpack_require__(/*! @hivestreaming/q */ "../../../node_modules/@hivestreaming/q/q.js");
__webpack_require__(/*! hivejs-protocol/services/new_tracker_types */ "../../../protocol/services/new_tracker_types.js");
var Framework_1 = __webpack_require__(/*! ../../../core/Framework */ "../../../core/build/core/src/core/Framework.js");
var PeerConstants_1 = __webpack_require__(/*! ../../PeerConstants */ "../../../core/build/core/src/webrtc/PeerConstants.js");
var ConnectivityInfoProvider_1 = __webpack_require__(/*! ../../../core/connectivity/ConnectivityInfoProvider */ "../../../core/build/core/src/core/connectivity/ConnectivityInfoProvider.js");
var Prefetcher_1 = __webpack_require__(/*! ../../prefetch/Prefetcher */ "../../../core/build/core/src/webrtc/prefetch/Prefetcher.js");
var VideoContextBase_1 = __webpack_require__(/*! ../../context/VideoContextBase */ "../../../core/build/core/src/webrtc/context/VideoContextBase.js");
var DiscoveryInfo_1 = __webpack_require__(/*! ../DiscoveryInfo */ "../../../core/build/core/src/webrtc/discovery/DiscoveryInfo.js");
var LocalityMode_1 = __webpack_require__(/*! ./LocalityMode */ "../../../core/build/core/src/webrtc/discovery/tracker/LocalityMode.js");
var CustomerKey = hive.services.protocol.tracker.CustomerKey;
var ClientConfigs_1 = __webpack_require__(/*! ../../ClientConfigs */ "../../../core/build/core/src/webrtc/ClientConfigs.js");
var logger_hive_1 = __webpack_require__(/*! ../../../common/logger.hive */ "../../../core/build/core/src/common/logger.hive.js");
var ErrorCodes = __webpack_require__(/*! ../../../common/error.hive */ "../../../core/build/core/src/common/error.hive.js");
var Utils_1 = __webpack_require__(/*! ../../../core/Utils */ "../../../core/build/core/src/core/Utils.js");
var TrackerClient = /** @class */ (function () {
    function TrackerClient() {
        this.trackerLogs = isNaN(ClientConfigs_1.HiveConfig.DebugLogs.TrackerLogs) ? 0 : ClientConfigs_1.HiveConfig.DebugLogs.TrackerLogs;
        this.loggerId = '[TRACKER] ';
        this.localityGroupId = 0;
        this.ipRegex = /([0-9]{1,3}(\.[0-9]{1,3}){3}|[a-f0-9]{1,4}(:[a-f0-9]{0,4}){5})/;
        this.firstResponse = true;
        this.networkManager = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.RTC_MANAGER);
        this.connInfoProvider = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.CONNECTIVITY_INFO_PROVIDER);
        this.trackerManager = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.TRACKER_MANAGER);
        this.trackerAccumulator = new Utils_1.StatsAccumulator();
    }
    TrackerClient.prototype.init = function (swarm) {
        this.logger = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.LOGGER).log(swarm.sessionId);
        this.sessionId = swarm.sessionId;
        this.fallbackRequester = swarm.fallbackRequester;
        this.nodeInfo = swarm.nodeInfo;
        this.prefetcher = swarm.prefetcher;
        this.prefetcherManager = swarm.prefetchManager;
        this.trackerManager.newTrackerClient(swarm.sessionId, this);
        this.localityMode = LocalityMode_1.LocalityMode.ALL;
        this.statsStore = swarm.reportingInstance.statsStore;
        this.statsStore.updateTrackerStatsAccumulator(this.trackerAccumulator);
    };
    TrackerClient.prototype.start = function (context) {
        var listeners = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            listeners[_i - 1] = arguments[_i];
        }
        this.context = context;
        this.streamId = context.currentContext.getContextId();
        this.ticket = context.currentContext.getTicket();
        this.listeners = listeners;
    };
    TrackerClient.prototype.startPeriodicAnnounce = function () {
        var _this = this;
        this.stopPeriodicAnnounce();
        // register the periodic announce
        this.announceTimer = Framework_1.Framework.setInterval(function () {
            _this.announce();
        }, PeerConstants_1.PeerConstants.P2PServices.TrackerRequestInterval);
        // announce immediately
        this.announce();
    };
    TrackerClient.prototype.stopPeriodicAnnounce = function () {
        if (this.announceTimer) {
            Framework_1.Framework.clearInterval(this.announceTimer);
        }
    };
    TrackerClient.prototype.announce = function () {
        var _this = this;
        // Start timestamp for tracker latency calculation
        this.trackerRequestStartTime = Framework_1.Framework.time();
        this.prepareRequest().then(function (request) {
            var logString = _this.loggerId + 'SENDING TRACKER REQUEST [ privateIp:' +
                request.info.privateIpString + ' rank:' + request.info.rankValue + ']';
            switch (_this.trackerLogs) {
                case 0:
                default:
                    _this.logger.debug(logString);
                    break;
                case 1:
                    _this.logger.debug(logString + ' ' + JSON.stringify(request));
                    break;
                case 2:
                    _this.logger.debug(logString, request);
                    break;
                case 3:
                    _this.logger.debug(logString + ' ' + JSON.stringify(request), request);
                    break;
            }
            _this.trackerManager.sendRequest(request);
        }, function (err) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error preparing the tracker request', _this.loggerId, ErrorCodes.TRACKER_CLIENT_CODES.PREPARE_REQUEST, err);
        }).catch(function (err) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error sending tracker request', _this.loggerId, ErrorCodes.TRACKER_CLIENT_CODES.SEND_REQUEST, err);
        });
    };
    /**
     * generates the complete tracker request
     * @returns {Promise<hive.services.protocol.tracker.TrackerRequest>}
     */
    TrackerClient.prototype.prepareRequest = function () {
        var _this = this;
        var defer = Q.defer();
        var trackerRequest = new hive.services.protocol.tracker.TrackerRequest();
        var videoContext = this.context.currentContext;
        var streamType = videoContext.hasBeenLive() ? StreamType.LIVE : StreamType.VOD;
        // SESSION FOR MULTIPLEXING
        trackerRequest.sessionId = this.sessionId;
        var customerKey = new CustomerKey();
        if (ClientConfigs_1.HiveConfig.ClientInfo.PartnerId && ClientConfigs_1.HiveConfig.ClientInfo.CustomerId) {
            customerKey.partnerId = ClientConfigs_1.HiveConfig.ClientInfo.PartnerId;
            customerKey.customerId = ClientConfigs_1.HiveConfig.ClientInfo.CustomerId;
        }
        else {
            customerKey.partnerId = this.ticket.getPartnerId();
            customerKey.customerId = this.ticket.getCustomerId();
        }
        trackerRequest.customerKey = customerKey;
        trackerRequest.streamType = streamType;
        trackerRequest.contentId = this.nodeInfo.getContextId();
        var stats = new hive.snapshots.ConnectivityInfo();
        this.connInfoProvider.getConnectivityInfo().then(function (ci) {
            stats.privateIp = ci.getNetworkInfo().getPrivateIp();
            stats.publicIp = ci.getNetworkInfo().getPublicIp();
        }).fail(function () {
            // get previous network info stored
            stats.privateIp = _this.connInfoProvider.getSyncConnectivityInfo().getNetworkInfo().getPrivateIp();
            stats.publicIp = _this.connInfoProvider.getSyncConnectivityInfo().getNetworkInfo().getPublicIp();
        }).finally(function () {
            try {
                // Tracker Info
                trackerRequest.info = _this.prepareTrackerInfo(stats, videoContext);
                // Query
                trackerRequest.query = _this.prepareQuery(videoContext, trackerRequest.info);
                defer.resolve(trackerRequest);
            }
            catch (error) {
                logger_hive_1.ErrorMonitor.getInstance().logError('Error collecting the data for the tracker request', _this.loggerId, ErrorCodes.TRACKER_CLIENT_CODES.COLLECT_TRACKER_REQUEST_INFO, error);
                defer.reject('ERROR');
            }
        }).done();
        return defer.promise;
    };
    /**
     * specify on which group I should be ranked depending if I'm a leader and
     * my info about where I am
     * @returns {hive.services.protocol.tracker.TrackerRankType[]}
     */
    TrackerClient.prototype.getNeededRankings = function () {
        var rankings = new Array();
        if (this.localityMode == LocalityMode_1.LocalityMode.ALL) {
            rankings.push(hive.services.protocol.tracker.TrackerRankType.Global);
        }
        else if (this.localityMode == LocalityMode_1.LocalityMode.AS) {
            rankings.push(hive.services.protocol.tracker.TrackerRankType.ExternalAs);
        }
        else if (this.localityMode == LocalityMode_1.LocalityMode.SITE) {
            rankings.push(hive.services.protocol.tracker.TrackerRankType.InternalAs);
        }
        else {
            this.logger.warn('Wrong locality mode');
        }
        return rankings;
    };
    /**
     * prepare the query for specifying what we want back from the tracker
     * @param videoContext
     * @param trackerInfo
     * @returns {hive.services.protocol.tracker.TrackerQuery}
     */
    TrackerClient.prototype.prepareQuery = function (videoContext, trackerInfo) {
        var _this = this;
        var query = new hive.services.protocol.tracker.TrackerQuery();
        try {
            query.random = PeerConstants_1.PeerConstants.Tracker.RANDOM_PEERS;
            var networkInfo = this.connInfoProvider.getSyncConnectivityInfo().getNetworkInfo();
            var externalAs = networkInfo.getExternalAsId();
            if (trackerInfo.externalAs && !externalAs) {
                externalAs = trackerInfo.externalAs;
            }
            query.rankings = this.getNeededRankings();
            query.asns = [];
            // if we know about the AS, request bunch of peers from it
            if (externalAs > 0) {
                this.prepareTrackerAsQuery(query.asns, hive.services.protocol.tracker.TrackerAsType.External, externalAs, PeerConstants_1.PeerConstants.Tracker.EXTERNAL_PEERS);
            }
            var siteId_1 = networkInfo.getSiteId();
            // if we know about the site request a bunch of peers from it
            // and other special site requests
            if (siteId_1 > 0) {
                this.prepareTrackerAsQuery(query.asns, hive.services.protocol.tracker.TrackerAsType.Internal, siteId_1, PeerConstants_1.PeerConstants.Tracker.SITE_PEERS);
                // ask for one peer for each quality level
                query.watchersForQualityLevel = [];
                videoContext.availableQualityLevels().forEach(function (qualityLevel) {
                    var qualityLevelQuery = _this.prepareTrackerQualityLevelQuery(hive.services.protocol.tracker.TrackerAsType.Internal, siteId_1, qualityLevel, -1);
                    query.watchersForQualityLevel.push({
                        key: qualityLevelQuery,
                        value: 1
                    });
                });
                // ask for SITE_LEADERS number of peers for each quality level I'm prefetching already
                query.streamersForQualityLevel = [];
                this.nodeInfo.getPrefetchingQualityLevels().forEach(function (session, qualityLevel) {
                    var qualityLevelQuery = _this.prepareTrackerQualityLevelQuery(hive.services.protocol.tracker.TrackerAsType.Internal, siteId_1, session.qualityLevel, (session.type == Prefetcher_1.PrefetchType.SITE ? hive.services.protocol.tracker.TrackerPeerStreamState.PREFETCHER_FIRST_TIER : -1));
                    query.streamersForQualityLevel.push({
                        key: qualityLevelQuery,
                        value: PeerConstants_1.PeerConstants.Tracker.SITE_LEADERS
                    });
                });
            }
            return query;
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error preparing tracker query', this.loggerId, ErrorCodes.TRACKER_CLIENT_CODES.PREPARE_QUERY, error);
            throw new Error(error);
        }
    };
    TrackerClient.prototype.prepareTrackerQualityLevelQuery = function (asType, asn, qualityLevel, streamState) {
        var query = new hive.services.protocol.tracker.TrackerQualityLevelQuery();
        var trackerAsQuery = new hive.services.protocol.tracker.TrackerAsQuery();
        trackerAsQuery.asType = asType;
        trackerAsQuery.asn = asn;
        query.qualityLevel = qualityLevel.id;
        query.asn = trackerAsQuery;
        return query;
    };
    TrackerClient.prototype.prepareTrackerAsQuery = function (asns, asType, asn, num) {
        var query = new hive.services.protocol.tracker.TrackerAsQuery();
        query.asType = asType;
        query.asn = asn;
        asns.push({
            key: query,
            value: num
        });
    };
    /**
     * collect our info that the tracker will use to rank and index us
     * @param stats
     * @param videoContext
     * @returns {hive.services.protocol.tracker.TrackerPeerInfo}
     */
    TrackerClient.prototype.prepareTrackerInfo = function (stats, videoContext) {
        var trackerInfo = new hive.services.protocol.tracker.TrackerPeerInfo();
        try {
            if (!Framework_1.Framework.isSimulated()) {
                trackerInfo.guid = btoa(this.myId);
            }
            else {
                trackerInfo.guid = this.myId;
            }
            trackerInfo.timestamp = Framework_1.Framework.time();
            trackerInfo.nat = undefined;
            var networkInfo = this.connInfoProvider.getSyncConnectivityInfo().getNetworkInfo();
            trackerInfo.internalAs = networkInfo.getSiteId();
            if (networkInfo.getExternalAsId()) {
                trackerInfo.externalAs = networkInfo.getExternalAsId();
            }
            if (stats != null) {
                trackerInfo.publicIpString = stats.publicIp;
                var publicIp = new InetAddress();
                publicIp.address = stats.publicIp;
                trackerInfo.publicIp = publicIp;
                trackerInfo.privateIpString = stats.privateIp;
                var privateIp = new InetAddress();
                privateIp.address = stats.privateIp;
                trackerInfo.privateIp = privateIp;
            }
            // adding average source throughput
            var bandwidth = Math.round(this.nodeInfo.getSourceThroughput().toBitPerSecond() / 8);
            trackerInfo.bandwidth = isNaN(bandwidth) ? null : bandwidth;
            trackerInfo.rankValue = this.nodeInfo.getCurrentScore();
            if (this.context.currentContext instanceof VideoContextBase_1.VideoContextBase) {
                trackerInfo.streams = new Array();
                var videoEntityCharacteristics = videoContext.lastPlayerRequest();
                if (videoEntityCharacteristics != null) {
                    trackerInfo.watchingQualityLevel = videoEntityCharacteristics.getQualityLevel().id;
                }
                var videoPrefetcher_1 = videoContext.getVideoPrefetcher();
                this.nodeInfo.getPrefetchingQualityLevels().forEach(function (session, qualityLevel) {
                    if (session.entity) {
                        var trackerPeerStreamInfo = new hive.services.protocol.tracker.TrackerPeerStreamInfo();
                        trackerPeerStreamInfo.qualityLevel = session.qualityLevel.id;
                        switch (session.type) {
                            case Prefetcher_1.PrefetchType.PLAYER:
                                trackerPeerStreamInfo.state = hive.services.protocol.tracker.TrackerPeerStreamState.P2P_AGENT;
                                break;
                            case Prefetcher_1.PrefetchType.LAN:
                                trackerPeerStreamInfo.state = hive.services.protocol.tracker.TrackerPeerStreamState.PREFETCHER_SECOND_TIER;
                                break;
                            case Prefetcher_1.PrefetchType.SITE:
                                trackerPeerStreamInfo.state = hive.services.protocol.tracker.TrackerPeerStreamState.PREFETCHER_FIRST_TIER;
                                break;
                        }
                        trackerPeerStreamInfo.delta = videoPrefetcher_1.distanceFromPlayerNumber(session.entity.getSegmentId(), session.qualityLevel);
                        trackerInfo.streams.push(trackerPeerStreamInfo);
                    }
                });
            }
            return trackerInfo;
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error preparing tracker info', this.loggerId, ErrorCodes.TRACKER_CLIENT_CODES.PREPARE_TRACKER_INFO, error);
            throw new Error(error);
        }
    };
    TrackerClient.prototype.setTrackerElectionLocalityMode = function (localityMode) {
        this.localityMode = localityMode;
    };
    TrackerClient.prototype.calculateTrackerLatency = function () {
        // Calculate tracker latency based on trackerRequestStartTime and current timestamp
        var timeElapsed = Math.max(0, Framework_1.Framework.time() - this.trackerRequestStartTime);
        if (timeElapsed > 0 && timeElapsed < PeerConstants_1.PeerConstants.Tracker.TIMEOUT) {
            this.trackerAccumulator.add(timeElapsed);
        }
    };
    TrackerClient.prototype.handleResponse = function (response) {
        var _this = this;
        try {
            this.calculateTrackerLatency();
            switch (this.trackerLogs) {
                case 1:
                    this.logger.debug(this.loggerId + this.context.currentContext.getTicket() + ' Tracker Response: ' + JSON.stringify(response));
                    break;
                case 2:
                    this.logger.debug(this.loggerId + this.context.currentContext.getTicket() + ' Tracker Response: ', response);
                    break;
                case 3:
                    this.logger.debug(this.loggerId + this.context.currentContext.getTicket() + ' Tracker Response: ' + JSON.stringify(response), response);
                    break;
            }
            var privateIp = response.peerInfo.privateIpString;
            var externalAs = response.peerInfo.externalAs;
            var publicIp = response.peerInfo.publicIpString;
            var siteId = response.peerInfo.internalAs;
            var isVpn = response.peerInfo.isVpn;
            this.localityGroupId = response.peerInfo.localityGroupId;
            // update the connectivity info provider with the updated network info
            this.connInfoProvider.handleServiceResponse(ConnectivityInfoProvider_1.ServiceResponse.TRACKER, privateIp, siteId, isVpn, publicIp, externalAs);
            this.logger.debug(this.loggerId + "Reporting from tracker public IP: " + publicIp + " private IP: " + privateIp + " extAs:" + externalAs + " site:" + siteId + " vpn:" + isVpn + " localityGroupId:" + this.localityGroupId);
            this.prefetcherManager.manageElection(response.rankings, response.infos);
            var infos_1 = this.parseResponse(response);
            this.listeners.forEach(function (listener) { return listener.discoveredPeers(infos_1, _this.firstResponse); });
            this.firstResponse = false;
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error handling the response', this.loggerId, ErrorCodes.TRACKER_CLIENT_CODES.HANDLE_RESPONSE, error);
        }
    };
    TrackerClient.prototype.parseResponse = function (response) {
        var infos = [];
        for (var _i = 0, _a = response.infos; _i < _a.length; _i++) {
            var peerInfo = _a[_i];
            var tmpInfo = DiscoveryInfo_1.DiscoveredPeerInfo.trackerDiscoveredPeerInfo(peerInfo);
            infos.push(tmpInfo);
        }
        return infos;
    };
    TrackerClient.prototype.peerDisconnected = function (guid) {
    };
    TrackerClient.prototype.serverConnected = function (guid) {
        this.myId = guid;
        this.logger.info(this.loggerId + 'CONNECTED ' + this.myId);
        if (PeerConstants_1.PeerConstants.P2P.P2P_ENABLED) {
            this.prefetcherManager.initEvaluation();
            this.startPeriodicAnnounce();
        }
    };
    TrackerClient.prototype.serverDisconnected = function () {
    };
    return TrackerClient;
}());
exports.TrackerClient = TrackerClient;
//# sourceMappingURL=TrackerClient.js.map

/***/ }),

/***/ "../../../core/build/core/src/webrtc/discovery/tracker/TrackerClientManager.js":
/*!******************************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/webrtc/discovery/tracker/TrackerClientManager.js ***!
  \******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.TrackerClientManager = void 0;
var Framework_1 = __webpack_require__(/*! ../../../core/Framework */ "../../../core/build/core/src/core/Framework.js");
var HashMap = __webpack_require__(/*! @hivestreaming/collections/map */ "../../../node_modules/@hivestreaming/collections/map.js");
var HiveServices_1 = __webpack_require__(/*! ../../../core/HiveServices */ "../../../core/build/core/src/core/HiveServices.js");
var logger_hive_1 = __webpack_require__(/*! ../../../common/logger.hive */ "../../../core/build/core/src/common/logger.hive.js");
var ErrorCodes = __webpack_require__(/*! ../../../common/error.hive */ "../../../core/build/core/src/common/error.hive.js");
__webpack_require__(/*! hivejs-protocol/services/new_tracker_types */ "../../../protocol/services/new_tracker_types.js");
var Utils_1 = __webpack_require__(/*! ../../../core/Utils */ "../../../core/build/core/src/core/Utils.js");
/**
 * singleton tracker requests multiplexer between swarms
 * on a single services connection
 */
var TrackerClientManager = /** @class */ (function () {
    function TrackerClientManager() {
        this.trackerLog = false;
        this.loggerId = '[TRACKER] ';
        this.trackerClientRegistry = new HashMap();
        this.thriftSerializer = new Utils_1.ThriftSerializer();
        this.logger = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.LOGGER).log();
        if (!Framework_1.Framework.isSimulated()) {
            this.client = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.SERVICES_CLIENT);
        }
    }
    /**
     * called once per swarm
     */
    TrackerClientManager.prototype.newTrackerClient = function (sessionId, trackerClient) {
        try {
            this.logger.debug('TRACKER CLIENT REGISTERED ' + sessionId);
            if (!this.trackerClientRegistry.has(sessionId)) {
                this.trackerClientRegistry.set(sessionId, trackerClient);
            }
            return this.trackerClientRegistry.get(sessionId);
        }
        catch (error) {
            // TODO might not need this. Verify if we see logs like this in the future
            logger_hive_1.ErrorMonitor.getInstance().logError('Error adding new tracker client', this.loggerId, ErrorCodes.TRACKER_CLIENT_MANAGER_CODES.NEW_TRACKER_CLIENT, error);
        }
    };
    TrackerClientManager.prototype.removeDispatcher = function (sessionId) {
        this.trackerClientRegistry.delete(sessionId);
    };
    TrackerClientManager.prototype.getDispatcher = function (sessionId) {
        return this.trackerClientRegistry.get(sessionId);
    };
    TrackerClientManager.prototype.sendRequest = function (request) {
        var _this = this;
        // SEND THE REQUEST
        if (this.client && this.client.getConnection()) {
            var payload = void 0;
            try {
                payload = this.thriftSerializer.serialize(request, 'TRACKER_REQ', 0);
            }
            catch (error) {
                logger_hive_1.ErrorMonitor.getInstance().logError('Error serializing the new request', this.loggerId, ErrorCodes.TRACKER_CLIENT_MANAGER_CODES.SERIALIZE_REQUEST, error);
            }
            if (payload) {
                var msg = new HiveServices_1.Message(HiveStreamingServices.HIVEJS_TRACKER, 1, payload);
                var sendPromise = this.client.getConnection().send(msg);
                sendPromise.then(function () { return _this.logger.info('TRACKER REQUEST SENT'); });
                sendPromise.fail(function (error) {
                    logger_hive_1.ErrorMonitor.getInstance().logError('Error sending tracker request', _this.loggerId, ErrorCodes.TRACKER_CLIENT_MANAGER_CODES.SEND_REQUEST, error);
                });
            }
        }
        else {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error sending tracker request because of connection', this.loggerId, ErrorCodes.TRACKER_CLIENT_MANAGER_CODES.SERVICE_CONNECTION_DOWN);
        }
    };
    TrackerClientManager.prototype.cleanupTrackerResp = function (resp) {
        resp.infos.map(function (info) {
            info.guid = atob(info.guid);
            info.publicIp = new InetAddress();
            info.publicIp.address = info.publicIpString;
            info.privateIp = new InetAddress();
            info.privateIp.address = info.privateIpString;
        });
        resp.peerInfo.guid = atob(resp.peerInfo.guid);
        resp.peerInfo.publicIp = new InetAddress();
        resp.peerInfo.publicIp.address = resp.peerInfo.publicIpString;
        resp.peerInfo.privateIp = new InetAddress();
        resp.peerInfo.privateIp.address = resp.peerInfo.privateIpString;
    };
    /**
     * called once by Peer.ts to register the tracker response handler on the services
     */
    TrackerClientManager.prototype.init = function () {
        var _this = this;
        this.logger.debug('TRACKER MANAGER INIT');
        if (this.client && this.client.getConnection()) {
            // setup the response handler
            this.client.getConnection().on(HiveStreamingServices.HIVEJS_TRACKER, 10, function (msg) {
                try {
                    // console.log(this.loggerId + "TRACKER SENT AN UPDATE: ", msg.msg)
                    var resp = null;
                    try {
                        resp = _this.thriftSerializer.deserialize(msg.msg, 'TRACKER_RESP', 1, hive.services.protocol.tracker.TrackerResponse);
                        _this.cleanupTrackerResp(resp);
                    }
                    catch (error) {
                        logger_hive_1.ErrorMonitor.getInstance().logError('Error deserializing the tracker response', _this.loggerId, ErrorCodes.TRACKER_CLIENT_MANAGER_CODES.DESERIALIZE_RESPONSE, error);
                    }
                    if (_this.trackerLog) {
                        _this.logger.debug('RESP ' + JSON.stringify(resp));
                    }
                    if (resp && _this.trackerClientRegistry.has(resp.sessionId)) {
                        var trackerClient = _this.trackerClientRegistry.get(resp.sessionId);
                        trackerClient.handleResponse(resp);
                    }
                    else {
                        _this.logger.warn('SESSION ID NOT VALID OR NULL ' + resp.sessionId);
                    }
                }
                catch (error) {
                    logger_hive_1.ErrorMonitor.getInstance().logError('Error initializing the tracker manager', _this.loggerId, ErrorCodes.TRACKER_CLIENT_MANAGER_CODES.TRACKER_MANAGER_INIT, error);
                }
            });
        }
        else {
            if (!Framework_1.Framework.isSimulated()) {
                this.logger.warn(this.loggerId + ' CANNOT GET ACTIVE CONNECTION');
            }
        }
    };
    return TrackerClientManager;
}());
exports.TrackerClientManager = TrackerClientManager;
//# sourceMappingURL=TrackerClientManager.js.map

/***/ }),

/***/ "../../../core/build/core/src/webrtc/index.js":
/*!*********************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/webrtc/index.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Tech_1 = __webpack_require__(/*! ../core/Tech */ "../../../core/build/core/src/core/Tech.js");
var Framework_1 = __webpack_require__(/*! ../core/Framework */ "../../../core/build/core/src/core/Framework.js");
var techs_hive_1 = __webpack_require__(/*! ../common/techs/techs.hive */ "../../../core/build/core/src/common/techs/techs.hive.js");
var WebRTC = /** @class */ (function (_super) {
    __extends(WebRTC, _super);
    function WebRTC() {
        return _super.call(this, techs_hive_1.TechName.HiveJS, Framework_1.Framework.Definitions.PEER) || this;
    }
    return WebRTC;
}(Tech_1.default));
exports.default = new WebRTC();
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../../core/build/core/src/webrtc/locality/LocalityServiceClient.js":
/*!**********************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/webrtc/locality/LocalityServiceClient.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.LocalityServiceClient = void 0;
var Q = __webpack_require__(/*! @hivestreaming/q */ "../../../node_modules/@hivestreaming/q/q.js");
__webpack_require__(/*! hivejs-protocol/services/locality_types */ "../../../protocol/services/locality_types.js");
var Framework_1 = __webpack_require__(/*! ../../core/Framework */ "../../../core/build/core/src/core/Framework.js");
var logger_hive_1 = __webpack_require__(/*! ../../common/logger.hive */ "../../../core/build/core/src/common/logger.hive.js");
var ErrorCodes = __webpack_require__(/*! ../../common/error.hive */ "../../../core/build/core/src/common/error.hive.js");
var HiveServices_1 = __webpack_require__(/*! ../../core/HiveServices */ "../../../core/build/core/src/core/HiveServices.js");
var Utils_1 = __webpack_require__(/*! ../../core/Utils */ "../../../core/build/core/src/core/Utils.js");
var LocalityServiceClient = /** @class */ (function () {
    function LocalityServiceClient() {
        this.loggerId = '[LocalityServiceClient] ';
        this.connInfoProvider = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.CONNECTIVITY_INFO_PROVIDER);
        this.thriftSerializer = new Utils_1.ThriftSerializer();
        if (!Framework_1.Framework.isSimulated()) {
            this.client = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.SERVICES_CLIENT);
        }
    }
    LocalityServiceClient.prototype.init = function (swarm) {
        this.logger = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.LOGGER).log(swarm.sessionId);
        this.nodeInfo = swarm.nodeInfo;
    };
    LocalityServiceClient.prototype.announcePeerLocalityInfo = function () {
        var _this = this;
        if (this.client && this.client.getConnection()) {
            this.constructLocalityInfo().then(function (peerLocalityInfo) {
                _this.logger.debug(_this.loggerId + 'Peer Locality Info constructed with privateip ' + peerLocalityInfo.networkInfo.privateIp);
                var payload = null;
                try {
                    payload = _this.thriftSerializer.serialize(peerLocalityInfo, 'LOCALITY_INFO', 0);
                }
                catch (error) {
                    logger_hive_1.ErrorMonitor.getInstance().logError('Error serializing locality info update', _this.loggerId, ErrorCodes.LOCALITY_SERVICE_CODES.SERIALIZE_MESSAGE, error);
                }
                if (payload) {
                    var msg = new HiveServices_1.Message(HiveStreamingServices.LOCALITY_SERVICE, 0, payload);
                    var sendPromise = _this.client.getConnection().send(msg);
                    sendPromise.then(function () { return _this.logger.info('LOCALITY INFO UPDATE SENT'); });
                    sendPromise.fail(function (error) {
                        logger_hive_1.ErrorMonitor.getInstance().logError('Error sending locality update', _this.loggerId, ErrorCodes.LOCALITY_SERVICE_CODES.SEND_REQUEST, error);
                    });
                }
            });
        }
        else {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error sending locality update because of missing connection', this.loggerId, ErrorCodes.LOCALITY_SERVICE_CODES.SERVICE_CONNECTION_DOWN);
        }
    };
    LocalityServiceClient.prototype.constructLocalityInfo = function () {
        var defer = Q.defer();
        var peerLocalityInfo = new PeerLocalityInfo();
        peerLocalityInfo.agentId = this.nodeInfo.getReportingGuid();
        var customerInfo = new CustomerInfo();
        customerInfo.partnerId = this.nodeInfo.getTicket().getPartnerId();
        customerInfo.customerId = this.nodeInfo.getTicket().getCustomerId();
        peerLocalityInfo.customerInfo = customerInfo;
        var networkInfo = new NetworkInfo();
        this.connInfoProvider.getConnectivityInfo().then(function (ci) {
            if (ci.getNetworkInfo().getPublicIp() != '')
                networkInfo.publicIp = ci.getNetworkInfo().getPublicIp();
            if (ci.getNetworkInfo().getPrivateIp() != '')
                networkInfo.privateIp = ci.getNetworkInfo().getPrivateIp();
        }).fail(function (error) {
            // TODO FIXME WE SEND WRONG ERROR CODES
        }).finally(function () {
            peerLocalityInfo.networkInfo = networkInfo;
            defer.resolve(peerLocalityInfo);
        });
        return defer.promise;
    };
    LocalityServiceClient.prototype.serverConnected = function (guid) {
        this.announcePeerLocalityInfo();
    };
    return LocalityServiceClient;
}());
exports.LocalityServiceClient = LocalityServiceClient;
//# sourceMappingURL=LocalityServiceClient.js.map

/***/ }),

/***/ "../../../core/build/core/src/webrtc/math/Matrix.js":
/*!***************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/webrtc/math/Matrix.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Matrix = void 0;
var Matrix = /** @class */ (function () {
    function Matrix(matrix) {
        this.matrix = [];
        this.rows = 0;
        this.columns = 0;
        this.matrix = matrix;
        this.rows = this.matrix.length;
        this.columns = this.matrix[0].length;
    }
    // We do this only once per matrix and only on the first request.
    Matrix.prototype.getTranspose = function () {
        if (!this.matrixTranspose) {
            this.calculateTransposeMatrix();
        }
        return this.matrixTranspose;
    };
    Matrix.prototype.calculateTransposeMatrix = function () {
        var transposeMatrix = [];
        for (var i = 0; i < this.columns; i++) {
            var newRow = [];
            for (var j = 0; j < this.rows; j++) {
                newRow.push(this.matrix[j][i]);
            }
            transposeMatrix.push(newRow);
        }
        this.matrixTranspose = new Matrix(transposeMatrix);
    };
    // We request dotDivide only when we want to do
    // element-wise division between matrices
    Matrix.prototype.dotDivide = function (otherMatrix) {
        var otherMatrixArray = otherMatrix.getMatrix();
        var result = [];
        for (var i = 0; i < this.rows; i++) {
            var row = [];
            for (var j = 0; j < this.columns; j++) {
                var division = this.matrix[i][j] / otherMatrixArray[i][j];
                row.push(division ? division : 0);
            }
            result.push(row);
        }
        return new Matrix(result);
    };
    Matrix.prototype.multiply = function (otherMatrix) {
        var otherMatrixArray = otherMatrix.getMatrix();
        var otherRows = otherMatrix.getRows();
        var otherCols = otherMatrix.getColumns();
        var result = [];
        for (var i = 0; i < this.rows; i++) {
            var row = this.matrix[i];
            var resultRow = [];
            for (var j = 0; j < otherCols; j++) {
                var sum = 0;
                for (var k = 0; k < otherRows; k++) {
                    sum += row[k] * otherMatrixArray[k][j];
                }
                resultRow.push(sum);
            }
            result.push(resultRow);
        }
        return new Matrix(result);
    };
    Matrix.prototype.multiplyWithScalar = function (scalar) {
        var result = [];
        for (var i = 0; i < this.rows; i++) {
            var row = [];
            for (var j = 0; j < this.columns; j++) {
                row.push(this.matrix[i][j] * scalar);
            }
            result.push(row);
        }
        return new Matrix(result);
    };
    Matrix.prototype.additionWithScalar = function (scalar) {
        var result = [];
        for (var i = 0; i < this.rows; i++) {
            var row = [];
            for (var j = 0; j < this.columns; j++) {
                row.push(this.matrix[i][j] + scalar);
            }
            result.push(row);
        }
        return new Matrix(result);
    };
    Matrix.prototype.exponential = function () {
        var result = [];
        for (var i = 0; i < this.rows; i++) {
            var row = [];
            for (var j = 0; j < this.columns; j++) {
                row.push(Math.exp(this.matrix[i][j]));
            }
            result.push(row);
        }
        return new Matrix(result);
    };
    Matrix.prototype.prependColumnWithValue = function (scalar) {
        var result = [];
        for (var i = 0; i < this.rows; i++) {
            var row = this.matrix[i];
            result.push([scalar]);
            for (var j = 0; j < row.length; j++) {
                result[i].push(row[j]);
            }
        }
        return new Matrix(result);
    };
    Matrix.prototype.getMatrix = function () {
        return this.matrix;
    };
    Matrix.prototype.getRows = function () {
        return this.rows;
    };
    Matrix.prototype.getColumns = function () {
        return this.columns;
    };
    return Matrix;
}());
exports.Matrix = Matrix;
//# sourceMappingURL=Matrix.js.map

/***/ }),

/***/ "../../../core/build/core/src/webrtc/membership/Member.js":
/*!*********************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/webrtc/membership/Member.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Member = void 0;
var DiscoveryInfo_1 = __webpack_require__(/*! ../discovery/DiscoveryInfo */ "../../../core/build/core/src/webrtc/discovery/DiscoveryInfo.js");
var Matrix_1 = __webpack_require__(/*! ../math/Matrix */ "../../../core/build/core/src/webrtc/math/Matrix.js");
var LocalityScore_1 = __webpack_require__(/*! ../partnership/locality/LocalityScore */ "../../../core/build/core/src/webrtc/partnership/locality/LocalityScore.js");
var Member = /** @class */ (function () {
    function Member(discoveredPeerInfo) {
        this.localityScore = new LocalityScore_1.LocalityScore();
        this.peerInfo = discoveredPeerInfo;
    }
    Member.prototype.isInLan = function () {
        return this.peerInfo.type === DiscoveryInfo_1.DiscoveryType.UDP;
    };
    Member.prototype.setFeatureVector = function (featureVector) {
        this.featureVector = new Matrix_1.Matrix([featureVector]);
    };
    Member.prototype.getFeatureVector = function () {
        return this.featureVector;
    };
    Member.prototype.getLocalityScore = function () {
        return this.localityScore;
    };
    Member.prototype.setLocalityScore = function (score) {
        this.localityScore = score;
    };
    return Member;
}());
exports.Member = Member;
//# sourceMappingURL=Member.js.map

/***/ }),

/***/ "../../../core/build/core/src/webrtc/membership/Membership.js":
/*!*************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/webrtc/membership/Membership.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Membership = void 0;
var HashMap = __webpack_require__(/*! @hivestreaming/collections/map */ "../../../node_modules/@hivestreaming/collections/map.js");
var PeerConstants_1 = __webpack_require__(/*! ../PeerConstants */ "../../../core/build/core/src/webrtc/PeerConstants.js");
var Framework_1 = __webpack_require__(/*! ../../core/Framework */ "../../../core/build/core/src/core/Framework.js");
var Utils = __webpack_require__(/*! ../../core/Utils */ "../../../core/build/core/src/core/Utils.js");
var DiscoveryInfo_1 = __webpack_require__(/*! ../discovery/DiscoveryInfo */ "../../../core/build/core/src/webrtc/discovery/DiscoveryInfo.js");
var Member_1 = __webpack_require__(/*! ./Member */ "../../../core/build/core/src/webrtc/membership/Member.js");
var DiscoveryInfo_2 = __webpack_require__(/*! ../discovery/DiscoveryInfo */ "../../../core/build/core/src/webrtc/discovery/DiscoveryInfo.js");
var logger_hive_1 = __webpack_require__(/*! ../../common/logger.hive */ "../../../core/build/core/src/common/logger.hive.js");
var ErrorCodes = __webpack_require__(/*! ../../common/error.hive */ "../../../core/build/core/src/common/error.hive.js");
var ConfigStore_1 = __webpack_require__(/*! ../config-store/ConfigStore */ "../../../core/build/core/src/webrtc/config-store/ConfigStore.js");
var BoosterClient_1 = __webpack_require__(/*! ../booster/BoosterClient */ "../../../core/build/core/src/webrtc/booster/BoosterClient.js");
var Membership = /** @class */ (function () {
    function Membership() {
        this.loggerId = '[Membership] ';
        this.myId = null;
        this.membershipView = new HashMap();
        this.lastUdpUpdate = new Set();
    }
    Membership.prototype.init = function (swarm) {
        this.logger = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.LOGGER).log(swarm.sessionId);
        this.configStore = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.CONFIG_STORE);
        this.boosterClient = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.BOOSTER_CLIENT);
        this.connectivityInfo = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.PEER_CONNECTIVITY_INFO);
        this.partnership = swarm.partnership;
        this.nodeInfo = swarm.nodeInfo;
        this.localityScore = swarm.localityScore;
        this.snapshotManager = swarm.snapAccountingManager;
        if (PeerConstants_1.PeerConstants.P2P.P2P_ENABLED) {
            this.start();
        }
        this.configStore.on('p2p.siteToSiteEnabled', this.removeMembersFromOtherSites.bind(this));
        this.configStore.on('p2p.peeringPolicy', this.applyPeeringPolicy.bind(this));
        this.boosterClient.on(BoosterClient_1.BoosterEvents.LAN_MEMBERS_UPDATE, this.lanMembersUpdate.bind(this));
    };
    /**
     * called both on startup or after a idle state
     */
    Membership.prototype.start = function () {
        this.activeMembership = true;
        this.startLanDiscovery();
    };
    /**
     * called when tearing down the plugin or going to idle
     */
    Membership.prototype.stop = function () {
        this.activeMembership = false;
        this.boosterClient.stopLanDiscovery();
    };
    Membership.prototype.startLanDiscovery = function () {
        if (this.myId) {
            this.boosterClient.startLanDiscovery(this.myId, this.nodeInfo.getCurrentScore());
        }
    };
    Membership.prototype.updatedLocalMemberInfo = function () {
        // info of the local peer were updated so we update the LA info
        this.boosterClient.updateLanDiscovery(this.nodeInfo.getWatchingQualityLevel().id, this.nodeInfo.getCurrentScore());
    };
    Membership.prototype.hasMember = function (guid) {
        return this.membershipView.has(guid);
    };
    Membership.prototype.allMembers = function () {
        return this.membershipView.values();
    };
    Membership.prototype.membershipSize = function () {
        return this.membershipView.length;
    };
    /**
     * Reacts to the Booster event 'lan-members-update'
     * - Updates existing peers in the membership
     * - Removes members that are not in LAN any more
     * @param lanMebers
     */
    Membership.prototype.lanMembersUpdate = function (lanMembers) {
        this.logger.debug(this.loggerId + " lanMembers length " + lanMembers.peers.length);
        var infos = lanMembers.peers.map(function (peer) { return DiscoveryInfo_1.DiscoveredPeerInfo.UDPDiscoveredPeerInfo(peer); });
        this.lastUdpUpdate = new Set(lanMembers.peers.map(function (peer) { return peer.peerInfo.peerId; }));
        this.discoveredPeers(infos, false);
    };
    /**
     * called every time we discover new peers either from the tracker or from the Booster
     * @param infos
     */
    Membership.prototype.discoveredPeers = function (infos, firstTrackResponse) {
        var _this = this;
        try {
            if (this.activeMembership) {
                var newPeerList_1 = [];
                infos.forEach(function (info) {
                    var newMember = null;
                    if (_this.canConnectTo(info)) {
                        newMember = _this.addPeerToMembershipView(info);
                    }
                    if (newMember) {
                        newPeerList_1.push(newMember.peerInfo.guid);
                    }
                });
                //  garbage collect the views
                this.GCViews();
                this.handleStats();
                if (firstTrackResponse) {
                    this.partnership.partnerChoice(firstTrackResponse);
                }
                // we only log new peers discovered
                if (newPeerList_1.length > 0) {
                    this.logger.debug(this.loggerId + ' DISCOVERED/ADDED NEW PEERS' + infos.length + '/' + newPeerList_1.length + ': [' + newPeerList_1.map(function (p) { return p.substring(0, 8); }) + ']');
                }
            }
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error discovering peers', this.loggerId, ErrorCodes.MEMBERSHIP_CODES.DISCOVERED_PEERS, error);
        }
    };
    Membership.prototype.addPeerToMembershipView = function (peerInfo) {
        try {
            var member = this.membershipView.get(peerInfo.guid);
            if (member) {
                member.peerInfo.updateInfo(peerInfo);
                this.localityScore.computeMemberLocalityScore(member);
            }
            else {
                member = new Member_1.Member(peerInfo);
                this.membershipView.set(peerInfo.guid, member);
                this.localityScore.computeMemberLocalityScore(member);
                return member;
            }
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error adding peer to random view', this.loggerId, ErrorCodes.MEMBERSHIP_CODES.ADD_RANDOM_MEMBER, error);
            return null;
        }
    };
    Membership.prototype.canConnectTo = function (peer) {
        var peeringPolicy = this.configStore.getConfig('p2p.peeringPolicy');
        var siteToSiteEnabled = this.configStore.getConfig('p2p.siteToSiteEnabled');
        // don't connect if it's the same peer
        if (peer.guid === this.myId) {
            return false;
        }
        // don't connect if sites don't match. Ignore if peer is discovered via UDP since we might not have its siteId
        if (peer.type === DiscoveryInfo_2.DiscoveryType.TRACKER && !siteToSiteEnabled && peer.internalAs !== this.connectivityInfo.getNetworkInfo().getSiteId()) {
            return false;
        }
        // for any non-restricting peering policy, we don't connect if either local peer or other peer are on VPN
        if ((peeringPolicy === ConfigStore_1.PeeringPolicy.EXCLUDE_VPN_SITES || peeringPolicy === ConfigStore_1.PeeringPolicy.EXCLUDE_VPN_AND_UNKNOWN_SITES) &&
            (peer.isVpn || this.connectivityInfo.getNetworkInfo().isVpn())) {
            return false;
        }
        // if policy is strict, we don't connect if we are on unknown site, or the other peer is on unknown site.
        // If the other peer is discovered via UDP we won't have any siteId info for it, so we just check if discovered via Tracker
        if (peeringPolicy === ConfigStore_1.PeeringPolicy.EXCLUDE_VPN_AND_UNKNOWN_SITES) {
            if (!this.connectivityInfo.getNetworkInfo().getSiteId()) {
                return false;
            }
            if (peer.type === DiscoveryInfo_2.DiscoveryType.TRACKER && !peer.internalAs) {
                return false;
            }
        }
        return true;
    };
    Membership.prototype.onVpnSite = function (peer) {
        return peer.isVpn || this.connectivityInfo.getNetworkInfo().isVpn();
    };
    Membership.prototype.onUnknownSite = function (peer) {
        return !peer.internalAs || !this.connectivityInfo.getNetworkInfo().getSiteId();
    };
    Membership.prototype.removeMembersFromOtherSites = function (p2pSiteToSiteEnabled) {
        var _this = this;
        if (!p2pSiteToSiteEnabled) {
            this.membershipView.filter(function (member) { return member.peerInfo.type == DiscoveryInfo_2.DiscoveryType.TRACKER && member.peerInfo.internalAs !== _this.connectivityInfo.getNetworkInfo().getSiteId(); })
                .map(function (member) { return _this.removeFromMembership(member); });
            this.handleStats();
        }
    };
    Membership.prototype.removeFromMembership = function (member) {
        this.removeMemberFromGuid(member.peerInfo.guid);
    };
    Membership.prototype.applyPeeringPolicy = function (policy) {
        if ((policy === ConfigStore_1.PeeringPolicy.EXCLUDE_VPN_SITES || policy === ConfigStore_1.PeeringPolicy.EXCLUDE_VPN_AND_UNKNOWN_SITES) && this.connectivityInfo.getNetworkInfo().isVpn()) {
            this.removeAllMembers();
        }
        else if (policy === ConfigStore_1.PeeringPolicy.EXCLUDE_VPN_AND_UNKNOWN_SITES && !this.connectivityInfo.getNetworkInfo().getSiteId()) {
            this.removeAllMembers();
        }
        else if (policy === ConfigStore_1.PeeringPolicy.EXCLUDE_VPN_SITES) {
            this.removeVpnMembers();
        }
        else if (policy === ConfigStore_1.PeeringPolicy.EXCLUDE_VPN_AND_UNKNOWN_SITES) {
            this.removeVpnMembers();
            this.removeMembersUnknownSites();
        }
    };
    Membership.prototype.removeAllMembers = function () {
        this.membershipView.clear();
        this.handleStats();
    };
    Membership.prototype.removeVpnMembers = function () {
        var _this = this;
        this.membershipView.filter(function (member) { return member.peerInfo.isVpn; })
            .forEach(function (member) { return _this.removeFromMembership(member); });
        this.handleStats();
    };
    Membership.prototype.removeMembersUnknownSites = function () {
        var _this = this;
        this.membershipView.filter(function (member) { return member.peerInfo.type == DiscoveryInfo_2.DiscoveryType.TRACKER; })
            .filter(function (member) { return !(member.peerInfo).internalAs; })
            .forEach(function (member) { return _this.removeFromMembership(member); });
        this.handleStats();
    };
    /**
     * We update the number of members we currently know to the Stats.Store
     */
    Membership.prototype.handleStats = function () {
        this.snapshotManager.accountMembershipStats(this.membershipView.length);
    };
    /**
     * Keeps the membership views under the maximum size
     * Called once every tracker response or on every new lan peer discovered
     */
    Membership.prototype.GCViews = function () {
        var _this = this;
        try {
            if (this.membershipView.length > PeerConstants_1.PeerConstants.Membership.RND_VIEW_MAX) {
                var trackerMembersSorted = this.membershipView.filter(function (member) { return member.peerInfo.type == DiscoveryInfo_2.DiscoveryType.TRACKER; }).values().sort(function (a, b) { return a.peerInfo.timestamp - b.peerInfo.timestamp; });
                trackerMembersSorted.forEach(function (m) {
                    if (_this.membershipView.length > PeerConstants_1.PeerConstants.Membership.RND_VIEW_MAX && !_this.partnership.isInPartner(m)) {
                        _this.removeFromMembership(m);
                    }
                });
            }
            if (this.lastUdpUpdate.size > 0) {
                var allUdpMembers = this.allMembers().filter(function (member) { return member.peerInfo.type === DiscoveryInfo_2.DiscoveryType.UDP; }).map(function (m) { return m.peerInfo.guid; });
                allUdpMembers.filter(function (guid) { return !_this.lastUdpUpdate.has(guid); }).forEach(function (guid) { return _this.removeMemberFromGuid(guid); });
                this.lastUdpUpdate.clear();
            }
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error clearing membership views', this.loggerId, ErrorCodes.MEMBERSHIP_CODES.GC_MEMBERS, error);
        }
    };
    /**
     * This function samples the randomView to return the potential in-partners to the Partnership.
     * @param numberToSample
     * @returns {any}
     */
    Membership.prototype.sample = function (all, numberToSample) {
        var memberViews = [];
        try {
            if (this.activeMembership) {
                memberViews = Utils.shuffleArray(this.membershipView.values());
            }
            if (all) {
                return memberViews;
            }
            else if (numberToSample) {
                return memberViews.slice(0, numberToSample);
            }
            else {
                return memberViews.slice(0, PeerConstants_1.PeerConstants.Overlay.MaxInPartners * 2);
            }
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error sampling membership', this.loggerId, ErrorCodes.MEMBERSHIP_CODES.SAMPLE_MEMBERSHIP, error);
            return [];
        }
    };
    Membership.prototype.retrieveMember = function (guid) {
        return this.membershipView.get(guid);
    };
    Membership.prototype.serverConnected = function (guid) {
        this.logger.info(this.loggerId + 'MEMBERSHIP SERVER CONNECTED');
        this.myId = guid;
        this.nodeInfo.setId(this.myId);
        this.startLanDiscovery();
    };
    Membership.prototype.serverDisconnected = function () {
    };
    Membership.prototype.peerDisconnected = function (guid) {
        this.removeMemberFromGuid(guid);
        this.handleStats();
    };
    Membership.prototype.removeMemberFromGuid = function (guid) {
        if (this.membershipView.has(guid)) {
            this.logger.debug("REMOVING " + guid + " FROM MEMBERSHIP VIEW");
            this.membershipView.delete(guid);
        }
    };
    return Membership;
}());
exports.Membership = Membership;
//# sourceMappingURL=Membership.js.map

/***/ }),

/***/ "../../../core/build/core/src/webrtc/msgs/P2PMessage.js":
/*!*******************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/webrtc/msgs/P2PMessage.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.P2PMessage = void 0;
var P2PMessage = /** @class */ (function () {
    function P2PMessage() {
    }
    return P2PMessage;
}());
exports.P2PMessage = P2PMessage;
//# sourceMappingURL=P2PMessage.js.map

/***/ }),

/***/ "../../../core/build/core/src/webrtc/msgs/P2PResponse.js":
/*!********************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/webrtc/msgs/P2PResponse.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.P2PResponse = void 0;
var P2PResponse = /** @class */ (function () {
    function P2PResponse() {
        this.headers = null;
    }
    return P2PResponse;
}());
exports.P2PResponse = P2PResponse;
//# sourceMappingURL=P2PResponse.js.map

/***/ }),

/***/ "../../../core/build/core/src/webrtc/network/BaseNetworkManager.js":
/*!******************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/webrtc/network/BaseNetworkManager.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseNetworkManager = void 0;
var HashMap = __webpack_require__(/*! @hivestreaming/collections/map */ "../../../node_modules/@hivestreaming/collections/map.js");
var Framework_1 = __webpack_require__(/*! ../../core/Framework */ "../../../core/build/core/src/core/Framework.js");
var ErrorCodes = __webpack_require__(/*! ../../common/error.hive */ "../../../core/build/core/src/common/error.hive.js");
var logger_hive_1 = __webpack_require__(/*! ../../common/logger.hive */ "../../../core/build/core/src/common/logger.hive.js");
/**
 * generic network manager interface designed around easyrtc behavior
 */
var BaseNetworkManager = /** @class */ (function () {
    function BaseNetworkManager() {
        this.baseLoggerId = '[Base Network Manager] ';
        this.listeners = new HashMap();
        this.logger = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.LOGGER).log();
    }
    BaseNetworkManager.prototype.setListeners = function (swarmId, listeners) {
        if (listeners === void 0) { listeners = []; }
        this.listeners.set(swarmId, listeners);
    };
    BaseNetworkManager.prototype.removeListeners = function (swarmId) {
        this.listeners.delete(swarmId);
    };
    BaseNetworkManager.prototype.fireServerDisconnected = function () {
        if (this.listeners.length > 0)
            this.listeners.forEach(function (v, k) {
                v.forEach(function (l) {
                    if (l.serverDisconnected)
                        l.serverDisconnected();
                });
            });
    };
    BaseNetworkManager.prototype.fireServerConnected = function (myId, swarmId) {
        var _this = this;
        if (this.listeners.length > 0)
            if (swarmId) {
                this.listeners.get(swarmId).forEach(function (l) {
                    try {
                        if (l.serverConnected)
                            l.serverConnected(myId);
                    }
                    catch (error) {
                        logger_hive_1.ErrorMonitor.getInstance().logError('Error firing server connect when we have swarm', _this.baseLoggerId, ErrorCodes.NETWORK_MANAGER_CODES.FIRE_SERVER_CONNECTED_WITH_SWARM, error);
                        // this.logger.error("Cannot fire server connected on " + l);
                    }
                });
            }
            else {
                this.listeners.forEach(function (v, k) {
                    v.forEach(function (l) {
                        try {
                            if (l.serverConnected)
                                l.serverConnected(myId);
                        }
                        catch (error) {
                            logger_hive_1.ErrorMonitor.getInstance().logError('Error firing server connect when we do not have swarm', _this.baseLoggerId, ErrorCodes.NETWORK_MANAGER_CODES.FIRE_SERVER_CONNECTED_WITHOUT_SWARM, error);
                        }
                    });
                });
            }
    };
    BaseNetworkManager.prototype.firePeerDisconnected = function (peerId) {
        if (this.listeners.length > 0)
            this.listeners.forEach(function (v, k) {
                v.forEach(function (l) {
                    if (l.peerDisconnected)
                        l.peerDisconnected(peerId);
                });
            });
    };
    return BaseNetworkManager;
}());
exports.BaseNetworkManager = BaseNetworkManager;
//# sourceMappingURL=BaseNetworkManager.js.map

/***/ }),

/***/ "../../../core/build/core/src/webrtc/network/Channel.js":
/*!*******************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/webrtc/network/Channel.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Channel = void 0;
var PeerConstants_1 = __webpack_require__(/*! ../../webrtc/PeerConstants */ "../../../core/build/core/src/webrtc/PeerConstants.js");
var ErrorCodes = __webpack_require__(/*! ../../common/error.hive */ "../../../core/build/core/src/common/error.hive.js");
var Q = __webpack_require__(/*! @hivestreaming/q */ "../../../node_modules/@hivestreaming/q/q.js");
var Framework_1 = __webpack_require__(/*! ../../core/Framework */ "../../../core/build/core/src/core/Framework.js");
var logger_hive_1 = __webpack_require__(/*! ../../common/logger.hive */ "../../../core/build/core/src/common/logger.hive.js");
var Channel = /** @class */ (function () {
    // initialize a peer connection and the channel
    function Channel(channelManager, netManager, label, channelOptions, ice, remotePeer) {
        var _this = this;
        this.detailedLog = false;
        this.loggerId = '[Channel] ';
        this.collectICETimeout = -1;
        this.pc = null;
        this.channel = null;
        this.bufferedAmountHandler = null;
        this.connectTimer = null;
        this.connectRetries = 5;
        this.timeout = 5000;
        this.open = false;
        /**
         * flag to allow the forward of ICE candidate updates
         */
        this.readyToForwardICE = false;
        /**
         * list of local candidates ready to be sent
         */
        this.candidatesToSend = new Array();
        this.channelManager = channelManager;
        this.netManager = netManager;
        this.label = label;
        this.channelOptions = channelOptions;
        this.ice = ice;
        this.remotePeer = remotePeer;
        this.logger = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.LOGGER).log();
        this.p2pTransport = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.TRANSPORT);
        this.p2pTransport.init(this.netManager.myId, remotePeer);
        this.pc = new RTCPeerConnection(this.ice);
        this.connectivityInfo = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.PEER_CONNECTIVITY_INFO);
        this.externalCandidates = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.EXTERNAL_CANDIDATES);
        // setup callbacks for new ice candidates and changes
        this.pc.onicecandidate = function (evt) {
            if (evt && evt.candidate) {
                var candidates = _this.connectivityInfo.refineCandidate(evt.candidate);
                _this.candidatesToSend = _this.candidatesToSend.concat(candidates);
                _this.delayOrSendImmediatelyCandidates();
            }
        };
        this.pc.onnegotiationneeded = function () {
            // initiate the offer and return to the caller
            _this.createOffer()
                .then(function (rsd) {
                return _this.setLocal(rsd);
            })
                .then(function (offer) {
                if (_this.detailedLog) {
                    _this.logger.debug(_this.loggerId + 'Sending offer to ' + _this.remotePeer + ' [candidates: ' + _this.candidatesToSend.length + ']');
                }
                // sending offer message with candidates gathered so far
                var candidates = _this.candidatesToSend;
                _this.candidatesToSend = new Array();
                var offerPromise = _this.channelManager.serverManager.offer(_this.netManager.myId, _this.remotePeer, _this, candidates, offer);
                // allow next iceCandidates to be immediately forwarded
                _this.readyToForwardICE = true;
                return offerPromise;
            })
                .catch(function (err) {
                logger_hive_1.ErrorMonitor.getInstance().logError('Error negotiating with peer', _this.loggerId, ErrorCodes.CHANNEL_CODES.NEGOTIATION_FAILURE, {
                    detailedError: err,
                    otherGuid: _this.remotePeer
                });
                // this.logger.error(this.loggerId + " " + err);
                _this.close();
            });
        };
        this.pc.oniceconnectionstatechange = function (evt) {
            if (_this.pc && _this.pc.iceConnectionState === 'disconnected') {
                _this.close();
            }
            if (_this.pc && _this.pc.iceConnectionState === 'failed') {
                logger_hive_1.ErrorMonitor.getInstance().logError('Error establishing ICE connection', _this.loggerId, ErrorCodes.CHANNEL_CODES.NEGOTIATION_FAILURE, { otherGuid: _this.remotePeer });
                // this.logger.debug(this.loggerId + "Closing channel since it couldnt be established to " + this.remotePeer);
                _this.close();
            }
        };
        this.pc.onsignalingstatechange = function (ev) {
            if (ev.signalingState === 'closed') {
                _this.close();
            }
        };
    }
    Channel.prototype.checkConnection = function () {
        var _this = this;
        if (this.channel && this.channel.readyState != 'open') {
            if (this.detailedLog) {
                this.logger.debug(this.loggerId + 'Check connection ' + this.remotePeer);
            }
            if (this.connectRetries <= 0) {
                this.logger.debug(this.loggerId + 'Closing channel since it couldnt be established to ' + this.remotePeer);
                this.close();
                return;
            }
            else {
                // if we are still connecting, wait for a bit longer
                this.connectRetries -= 1;
                this.connectTimer = Framework_1.Framework.setTimeout(function () { return _this.checkConnection(); }, this.timeout);
            }
        }
    };
    Channel.prototype.close = function () {
        try {
            if (this.detailedLog) {
                this.logger.debug(this.loggerId + 'Closing connection to ' + this.remotePeer);
            }
            this.resetDelayedICE(true);
            this.channelManager.onCloseConnection(this);
            // shutdown this channel
            if (this.pc && this.pc.signalingState !== 'closed') {
                this.pc.close();
                this.pc = null;
                if (this.channel) {
                    this.channel.close();
                    this.channel = null;
                }
            }
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error closing the connection', this.loggerId, ErrorCodes.CHANNEL_CODES.CLOSE_CONNECTION, {
                detailedError: error,
                otherGuid: this.remotePeer
            });
        }
    };
    Channel.prototype.isConnecting = function () {
        if (this.channel) {
            return this.channel.readyState === 'connecting';
        }
        else {
            return false;
        }
    };
    // Returns a promise that resolves when the data channel is ready/open
    Channel.prototype.connect = function (remotePeer) {
        var _this = this;
        if (this.detailedLog) {
            this.logger.debug(this.loggerId + 'Connecting to ' + remotePeer);
        }
        this.remotePeer = remotePeer;
        // channel is set by the initiator
        this.channel = this.pc.createDataChannel(this.label);
        var openPromise = this.setupChannel(true, -1);
        // timer that closes the connection if it is not possible to setup
        this.connectTimer = Framework_1.Framework.setTimeout(function () { return _this.checkConnection(); }, this.timeout);
        return openPromise;
    };
    Channel.prototype.setRemote = function (sdp) {
        var _this = this;
        var p = Q.defer();
        this.pc.setRemoteDescription(sdp)
            .then(function () {
            p.resolve('OK');
        })
            .catch(function (err) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error setting remote description', _this.loggerId, ErrorCodes.CHANNEL_CODES.SIGNALING_STATE_CLOSED, {
                detailedError: err,
                otherGuid: _this.remotePeer
            });
            p.reject(err);
        });
        return p.promise;
    };
    Channel.prototype.setLocal = function (sdp) {
        var _this = this;
        var p = Q.defer();
        if (this.pc.signalingState !== 'closed') {
            /*
            this.pc.setLocalDescription(
                sdp,
                () => p.resolve(this.pc.localDescription),
                (err) => {
                    ErrorMonitor.getInstance().logError("Error setting local description", this.loggerId, ErrorCodes.CHANNEL_CODES.SET_LOCAL_DESCRIPTION_FAILED, {
                        detailedError: err,
                        otherGuid: this.remotePeer
                    });
                    p.reject(err);
                }
            )*/
            this.pc.setLocalDescription(sdp)
                .then(function () {
                p.resolve(_this.pc.localDescription);
            })
                .catch(function (err) {
                logger_hive_1.ErrorMonitor.getInstance().logError('Error setting local description', _this.loggerId, ErrorCodes.CHANNEL_CODES.SET_LOCAL_DESCRIPTION_FAILED, {
                    detailedError: err,
                    otherGuid: _this.remotePeer
                });
                p.reject(err);
            });
        }
        else {
            logger_hive_1.ErrorMonitor.getInstance().logError('Signaling state is closed', this.loggerId, ErrorCodes.CHANNEL_CODES.SIGNALING_STATE_CLOSED);
            p.reject('Signaling state is closed');
        }
        return p.promise;
    };
    Channel.prototype.createOffer = function () {
        var _this = this;
        var p = Q.defer();
        /*
            Create offer resolves without returning a value that's why we get a null error in webrtc-adapter

            Create offer and setlocaldescription use promises instead of passing callbacks

        this.pc.createOffer(() => { p.resolve(); }, (err) => {
            ErrorMonitor.getInstance().logError("Error creating offer", this.loggerId, ErrorCodes.CHANNEL_CODES.CREATE_OFFER, {
                detailedError: err,
                otherGuid: this.remotePeer
            });
            this.close()
        });*/
        this.pc.createOffer()
            .then(function (rtcSessionDescription) {
            p.resolve(new RTCSessionDescription(rtcSessionDescription));
        })
            .catch(function (err) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error creating offer', _this.loggerId, ErrorCodes.CHANNEL_CODES.CREATE_OFFER, {
                detailedError: err,
                otherGuid: _this.remotePeer
            });
            _this.close();
        });
        return p.promise;
    };
    Channel.prototype.createAnswer = function () {
        var _this = this;
        var p = Q.defer();
        this.pc.createAnswer()
            .then(function (rtcSessionDescriptionInit) {
            p.resolve(new RTCSessionDescription(rtcSessionDescriptionInit));
        })
            .catch(function (err) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error creating answer', _this.loggerId, ErrorCodes.CHANNEL_CODES.CREATE_ANSWER, {
                detailedError: err,
                otherGuid: _this.remotePeer
            });
            p.reject(err);
        });
        return p.promise;
    };
    /**
     * received an offer from the signaling server
     * sent by a remote peer
     * @param ev
     * @param timerHandle
     */
    Channel.prototype.offer = function (ev, timerHandle) {
        var _this = this;
        if (this.detailedLog) {
            this.logger.debug(this.loggerId + 'Received an offer from ' + this.remotePeer);
            this.logger.debug(this.loggerId + 'Offer:', ev);
        }
        // setup the datachannel listener
        this.pc.ondatachannel = function (ev) {
            _this.channel = ev.channel;
            _this.setupChannel(false, timerHandle);
        };
        // setup the session
        var session = new RTCSessionDescription(ev.channel.offer);
        this.remotePeer = ev.peer.guid;
        // set the remote descriptor, update the ice candidates
        // received with the offer, and create an answer
        this.setRemote(session)
            .then(function () {
            // in the meanwhile, the connection may have timed out
            if (_this.pc.signalingState !== 'closed') {
                _this.update_ice_candidates(ev);
                return _this.createAnswer();
            }
            else {
                return Q.reject('Connection closed while creating answer');
            }
        })
            .then(function (rsd) { return _this.setLocal(rsd); })
            .then(function (localSdp) {
            if (_this.detailedLog) {
                _this.logger.debug(_this.loggerId + 'Sending back an answer [candidates: ' + _this.candidatesToSend.length + ']');
            }
            // send an answer with all the ice candidates gathered so far
            var candidates = _this.candidatesToSend;
            _this.candidatesToSend = new Array();
            _this.channelManager.serverManager.answer(_this, localSdp, candidates, _this.remotePeer);
            // allow next ice candidates to be immediately forwarded
            _this.readyToForwardICE = true;
        })
            .catch(function (err) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error responding to offer', _this.loggerId, ErrorCodes.CHANNEL_CODES.OFFER_RECEIVED, {
                detailedError: err,
                otherGuid: _this.remotePeer
            });
            _this.close();
        });
    };
    /**
     *  answer received from the discovery service
     *  sent by the remote peer.
     * @param ev
     */
    Channel.prototype.answer = function (ev) {
        var _this = this;
        if (this.detailedLog) {
            this.logger.debug(this.loggerId + 'Answer: ', ev);
        }
        // initialize the session
        var sdp = new RTCSessionDescription(ev.answer);
        // set the remote descriptor
        this.setRemote(sdp).then(function () {
            // as soon as we set the remote descriptor we can
            // update the ice candidates arrived together with the answer
            if (_this.pc.signalingState !== 'closed') {
                _this.update_ice_candidates(ev);
            }
        }).catch(function (err) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error setting remote descriptor for the answer received', _this.logger, ErrorCodes.CHANNEL_CODES.ANSWER_RECEIVED, {
                detailedError: err,
                otherGuid: _this.remotePeer
            });
            _this.close();
            // this.logger.error(this.loggerId + " " + err)
        });
    };
    Channel.prototype.update_ice_candidates = function (ev) {
        var _this = this;
        var candidates = ev.channel.ice_candidates;
        candidates.forEach(function (candidate) {
            if (_this.detailedLog) {
                _this.logger.debug(_this.loggerId + 'got ICE cand: ', candidate);
            }
            var iceCandidate = new RTCIceCandidate(candidate);
            _this.pc.addIceCandidate(iceCandidate)
                .then(function () {
                // if (this.detailedLog)this.logger.debug(this.loggerId + "UPDATED ICE CANDIDATE")
            })
                .catch(function (err) {
                logger_hive_1.ErrorMonitor.getInstance().logError('Error updating ice candidates', _this.loggerId, ErrorCodes.CHANNEL_CODES.UPDATE_ICE_CANDIDATES, {
                    detailedError: err,
                    otherGuid: _this.remotePeer
                });
            });
        });
    };
    Channel.prototype.setupChannel = function (initiated, timerHandle) {
        var _this = this;
        var p = Q.defer();
        // promise is triggered when the channel is ready
        this.channel.onopen = function (ev) { return _this.onChannelOpen(p, initiated, timerHandle); };
        this.channel.onclose = function (ev) {
            _this.close();
            p.reject(_this);
        };
        this.channel.onmessage = function (event) { return _this.p2pTransport.receiveMessage(event.data); };
        this.channel.onerror = function (err) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error setting up channel', _this.loggerId, ErrorCodes.CHANNEL_CODES.SETUP_CHANNEL_ERROR, { otherGuid: _this.remotePeer, detailedError: err });
            // this.logger.error(this.loggerId + " -- WebRTC channel error", err);
            _this.close();
        };
        return p.promise;
    };
    Channel.prototype.onChannelOpen = function (p, initiated, timerHandle) {
        var _this = this;
        this.open = true;
        /*
         * configure the channel buffer low threshold
         * @see https://developer.mozilla.org/en-US/docs/Web/API/RTCDataChannel/bufferedAmountLowThreshold
         */
        this.channel['bufferedAmountLowThreshold'] = Math.min(this.pc.sctp.maxMessageSize, PeerConstants_1.PeerConstants.Transport.ChunkSize);
        this.channel.addEventListener('bufferedamountlow', function () {
            _this.p2pTransport.onBufferedAmountLow();
        });
        p.resolve(this);
        if (!initiated) {
            this.netManager.connectionReceived(this.remotePeer, this);
            if (timerHandle) {
                Framework_1.Framework.clearTimeout(timerHandle);
            }
        }
    };
    /**
     * Instead of sending one message per ice candidate that we collect,
     * we are waiting X milliseconds in order to get more ICE candidates
     * and we send them as one message
     */
    Channel.prototype.delayOrSendImmediatelyCandidates = function () {
        var _this = this;
        if (this.readyToForwardICE && (this.collectICETimeout == -1)) {
            this.collectICETimeout = Framework_1.Framework.setTimeout(function () {
                _this.sendCandidates();
                _this.resetDelayedICE(false);
            }, PeerConstants_1.PeerConstants.WebRTC.COLLECT_ICE_TIMEOUT);
        }
    };
    Channel.prototype.sendCandidates = function () {
        var _this = this;
        var candidates = this.candidatesToSend;
        this.candidatesToSend = new Array();
        if (candidates && candidates.length > 0) {
            var len_1 = candidates.length;
            this.channelManager.serverManager.updateICE(this.netManager.myId, this, candidates, this.remotePeer).then(function (resp) {
                if (_this.detailedLog) {
                    _this.logger.debug(_this.loggerId + 'sent ' + len_1 + ' more candidates', candidates);
                }
            }).catch(function (err) {
                logger_hive_1.ErrorMonitor.getInstance().logError('Error sending candidates', _this.loggerId, ErrorCodes.CHANNEL_CODES.SETUP_CHANNEL_ERROR, { detailedError: err, otherGuid: _this.remotePeer });
                // this.logger.error(this.loggerId + " " + err)
            });
        }
    };
    /**
     * We need to reset the collectICETimeout whenever we close a connection.
     * There is a race condition in which
     * 1. we establish a connection (to a local peer),
     * 2. we immediately send a partnership offer which is rejected (for various reasons)
     * 3. Timeout for collecting ICE candidates is triggered
     *
     * Although we set the timeout period for collecting ICE candidates to 300 msecs, it can still happen
     * for peers that are in the same LAN.
     * This is mostly for Hive WebRTC.
     */
    Channel.prototype.resetDelayedICE = function (clearTimeout) {
        if (clearTimeout && this.collectICETimeout != -1) {
            Framework_1.Framework.clearTimeout(this.collectICETimeout);
        }
        this.collectICETimeout = -1;
    };
    Channel.prototype.send = function (data) {
        var _this = this;
        if (this.bufferedAmountHandler !== null) {
            Framework_1.Framework.clearTimeout(this.bufferedAmountHandler);
            this.bufferedAmountHandler = null;
        }
        try {
            this.channel.send(data);
            // This is a workaround due to the bug that all browsers are incorrectly calculating the
            // amount of buffered data. Therefore, the 'bufferedamountlow' event would not fire.
            if (this.channel.bufferedAmount <= PeerConstants_1.PeerConstants.Transport.ChunkSize) {
                this.bufferedAmountHandler = Framework_1.Framework.setTimeout(function () { return _this.p2pTransport.onBufferedAmountLow(); }, 0);
            }
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error setting sending', this.loggerId, ErrorCodes.CHANNEL_CODES.SEND_DATA, { detailedError: error, otherGuid: this.remotePeer });
            this.close();
        }
    };
    return Channel;
}());
exports.Channel = Channel;
//# sourceMappingURL=Channel.js.map

/***/ }),

/***/ "../../../core/build/core/src/webrtc/network/ChannelManager.js":
/*!**************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/webrtc/network/ChannelManager.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ChannelManager = void 0;
var Q = __webpack_require__(/*! @hivestreaming/q */ "../../../node_modules/@hivestreaming/q/q.js");
var Framework_1 = __webpack_require__(/*! ../../core/Framework */ "../../../core/build/core/src/core/Framework.js");
var Channel_1 = __webpack_require__(/*! ./Channel */ "../../../core/build/core/src/webrtc/network/Channel.js");
var FrameworkNetworkConstants_1 = __webpack_require__(/*! ./FrameworkNetworkConstants */ "../../../core/build/core/src/webrtc/network/FrameworkNetworkConstants.js");
var ErrorCodes = __webpack_require__(/*! ../../common/error.hive */ "../../../core/build/core/src/common/error.hive.js");
var logger_hive_1 = __webpack_require__(/*! ../../common/logger.hive */ "../../../core/build/core/src/common/logger.hive.js");
var ChannelManager = /** @class */ (function () {
    function ChannelManager(logger, serverManager, netManager) {
        this.loggerId = '[ChannelManager] ';
        this.counter = 1;
        this.channelOptions = null;
        // channels created by the peer, that we offer connections to
        this.channels = {};
        // peers that the peer has connected with
        this.connections = {};
        this.logger = logger;
        this.serverManager = serverManager;
        this.netManager = netManager;
        this.configStore = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.CONFIG_STORE);
    }
    ChannelManager.prototype.initiateConnect = function (myId, otherId) {
        var promise = null;
        if (otherId in this.connections) {
            var deferred = Q.defer();
            deferred.reject('OTHER ALREADY TRYING TO CONNECT');
            promise = deferred.promise;
        }
        else {
            // create a connection with the given peer
            if (this.netManager.detailedLog)
                this.logger.info('Initiating connection to ' + otherId);
            // create a label, local peer + channel id
            var label = this.generateLabel(myId, otherId);
            var channel = this.makeChannel(label, otherId);
            // connect the channel to the remote peer
            promise = channel.connect(otherId);
        }
        return promise;
    };
    /**
     * the channel was closed from the network
     * @param channel
     */
    ChannelManager.prototype.onCloseConnection = function (channel) {
        var isConnected = channel.remotePeer in this.connections;
        if (isConnected) {
            delete this.channels[channel.label];
            delete this.connections[channel.remotePeer];
        }
        if (channel.open) {
            this.netManager.connectionClosed(channel.remotePeer);
            channel.open = false;
        }
    };
    ChannelManager.prototype.send = function (remotePeer, data) {
        if (this.netManager.detailedLog)
            this.logger.debug('DATA ' + data.byteLength + ' ' + data);
        var channel = this.connections[remotePeer];
        if (channel && channel.channel) {
            channel.send(data);
            return true;
        }
        else {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error sending message without channel established', this.loggerId, ErrorCodes.CHANNEL_MANAGER_CODES.SEND_MSG_WITHOUT_CHANNEL, { otherGuid: remotePeer });
            return false;
        }
    };
    ChannelManager.prototype.trigger = function (name, msg) {
        var chan = msg.channel;
        if (chan && chan.label && this.channels[chan.label]) {
            // get or create a new channel
            var c = this.channels[chan.label];
            // dispatch the message
            var func = c[name];
            func.call(c, msg);
        }
        else {
            // ErrorMonitor.getInstance().logError("Error received a message for a non existing channel", this.loggerId, ErrorCodes.CHANNEL_MANAGER_CODES.MSG_TRIGGER_ERROR);
            var funcName = 'handle_' + name;
            // this is not a channel signaling message, dispatch to peer
            var func = this[funcName];
            if (func) {
                func.call(this, msg);
            }
            else {
                logger_hive_1.ErrorMonitor.getInstance().logError('Error received a message for a non existing function', this.loggerId, ErrorCodes.CHANNEL_MANAGER_CODES.MSG_TRIGGER_ERROR, { functionName: funcName });
                // this.logger.warn("Handler " + funcName + " not found or channel " + chan.label + " not active")
            }
        }
    };
    /**
     * receive an offer from another peer
     */
    ChannelManager.prototype.handle_offer = function (ev) {
        if (this.netManager.detailedLog)
            this.logger.info('received an offer from ' + ev.peer.guid + ' on channel ' + ev.channel.label);
        var conn = this.connections[ev.peer.guid];
        // existing open connection
        // var rejectOpen = conn && !conn.isConnecting()
        // connecting (but our offer should be used)
        var rejectConnecting = conn &&
            // conn.isConnecting() &&
            ev.peer < this.netManager.myId;
        // reject if
        // 1) an open connection to the peer exists
        // 2) an ongoing offer from us exist and we have precedence
        var reject = 
        // _.size(self.connections) >= self.targetPeerCount ||
        // rejectOpen ||
        rejectConnecting;
        // no free connections or ongoing conn => reject
        if (reject) {
            // let the peer know that we cannot accept the offer
            this.serverManager.rejectOffer(this.netManager.myId, ev.peer.guid, ev.channel.label);
        }
        else {
            // setup a new connection
            var c = this.makeChannel(ev.channel.label, ev.peer.guid);
            // setup timer here
            var timerHandle = this.setChannelOfferTimer(c);
            c.offer(ev, timerHandle);
        }
    };
    ChannelManager.prototype.setChannelOfferTimer = function (c) {
        var _this = this;
        return Framework_1.Framework.setTimeout(function () {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error incoming connection timedout', _this.loggerId, ErrorCodes.CHANNEL_MANAGER_CODES.CONNECTION_TIMEOUT, { otherGuid: c.remotePeer });
            // this.logger.warn("INCOMING CONNECTION FROM " + c.remotePeer + " TIMED OUT");
            c.close();
        }, FrameworkNetworkConstants_1.NetworkConstants.IncomingConnectionEstablishmentTimeout);
    };
    ChannelManager.prototype.makeChannel = function (label, remoteGuid) {
        var c = new Channel_1.Channel(this, this.netManager, label, this.channelOptions, this.getIce(), remoteGuid);
        this.channels[label] = c;
        this.connections[remoteGuid] = c;
        return c;
    };
    /**
     * triggered when remote peer rejected our offer
     * @param ev
     */
    ChannelManager.prototype.handle_offer_rejected = function (ev) {
        if (this.netManager.detailedLog)
            this.logger.debug('remote peer rejected ', ev);
        var chan = this.connections[ev.rejected_by];
        if (chan) {
            chan.close();
        }
        delete this.connections[ev.rejected_by];
        delete this.channels[ev.channel];
    };
    ChannelManager.prototype.generateLabel = function (local, remote) {
        return local.substring(0, Math.max(8, local.length)) + ':' + remote.substring(0, Math.max(8, remote.length)) + ':' + this.counter++;
    };
    /**
     * the application wants to close the connection to guid if any
     * @param guid
     */
    ChannelManager.prototype.disconnect = function (guid) {
        var channel = this.connections[guid];
        if (channel) {
            channel.close();
        }
    };
    ChannelManager.prototype.getIce = function () {
        var result = { iceServers: [] };
        if (this.configStore.getConfig('webrtc.enableStun')) {
            this.logger.info('STUN is enabled');
            result.iceServers.push({ urls: 'stun:stun.hivestreaming.com:3478' });
        }
        else {
            this.logger.info('STUN is disabled');
        }
        return result;
    };
    return ChannelManager;
}());
exports.ChannelManager = ChannelManager;
//# sourceMappingURL=ChannelManager.js.map

/***/ }),

/***/ "../../../core/build/core/src/webrtc/network/FrameworkNetworkConstants.js":
/*!*************************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/webrtc/network/FrameworkNetworkConstants.js ***!
  \*************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.RtcNetworkStats = exports.NetworkConstants = void 0;
var NetworkConstants = /** @class */ (function () {
    function NetworkConstants() {
    }
    NetworkConstants.StaleConnectionCleanup = true;
    NetworkConstants.StaleConnectionCheckPeriod = 30000;
    NetworkConstants.StaleConnectionMaxElapsed = 60000;
    NetworkConstants.IncomingConnectionEstablishmentTimeout = 30000;
    return NetworkConstants;
}());
exports.NetworkConstants = NetworkConstants;
var RtcNetworkStats = /** @class */ (function () {
    function RtcNetworkStats() {
    }
    RtcNetworkStats.SITE_TAG = 'site';
    RtcNetworkStats.EXTERNAL_AS_TAG = 'externalAs';
    RtcNetworkStats.SEND_RATE_TAG = 'availableSendRate';
    RtcNetworkStats.REMOTE_ADDRESS_TAG = 'remoteAddress';
    RtcNetworkStats.LOCAL_ADDRESS_TAG = 'localAddress';
    return RtcNetworkStats;
}());
exports.RtcNetworkStats = RtcNetworkStats;
//# sourceMappingURL=FrameworkNetworkConstants.js.map

/***/ }),

/***/ "../../../core/build/core/src/webrtc/network/HiveNetworkManager.js":
/*!******************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/webrtc/network/HiveNetworkManager.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.HiveNetworkManager = void 0;
var HashMap = __webpack_require__(/*! @hivestreaming/collections/map */ "../../../node_modules/@hivestreaming/collections/map.js");
var Q = __webpack_require__(/*! @hivestreaming/q */ "../../../node_modules/@hivestreaming/q/q.js");
var Framework_1 = __webpack_require__(/*! ../../core/Framework */ "../../../core/build/core/src/core/Framework.js");
var ChannelManager_1 = __webpack_require__(/*! ./ChannelManager */ "../../../core/build/core/src/webrtc/network/ChannelManager.js");
var BaseNetworkManager_1 = __webpack_require__(/*! ./BaseNetworkManager */ "../../../core/build/core/src/webrtc/network/BaseNetworkManager.js");
var FrameworkNetworkConstants_1 = __webpack_require__(/*! ./FrameworkNetworkConstants */ "../../../core/build/core/src/webrtc/network/FrameworkNetworkConstants.js");
var ErrorCodes = __webpack_require__(/*! ../../common/error.hive */ "../../../core/build/core/src/common/error.hive.js");
var logger_hive_1 = __webpack_require__(/*! ../../common/logger.hive */ "../../../core/build/core/src/common/logger.hive.js");
var Constants_1 = __webpack_require__(/*! ../../core/Constants */ "../../../core/build/core/src/core/Constants.js");
var HiveNetworkManager = /** @class */ (function (_super) {
    __extends(HiveNetworkManager, _super);
    function HiveNetworkManager() {
        var _this = _super.call(this) || this;
        _this.loggerId = '[HiveNetworkManager] ';
        _this.detailedLog = false;
        _this.connectedPeers = new HashMap();
        _this.counter = 1;
        _this.identityProvider = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.IDENTITY_PROVIDER);
        _this.serverManager = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.SERVER_MANAGER);
        _this.channelManager = new ChannelManager_1.ChannelManager(_this.logger, _this.serverManager, _this);
        _this.serverManager.init(_this, _this.logger, _this.channelManager);
        _this.startPeriodicConnectionsCheck();
        return _this;
    }
    HiveNetworkManager.prototype.start = function (swarmId, listeners) {
        if (listeners === void 0) { listeners = []; }
        var logger = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.LOGGER).log(swarmId);
        var promise = null;
        if (this.listeners.keys().length == 0) {
            promise = this.connectToServer();
            this.setListeners(swarmId, listeners);
        }
        else {
            promise = this.identityProvider.getIdentity();
            this.setListeners(swarmId, listeners);
            if (this.serverManager.isConnected()) {
                // logger.debug("FIRE SRV CONNECT ")
                this.fireServerConnected(this.myId, swarmId);
            }
        }
        return promise;
    };
    HiveNetworkManager.prototype.connectToServer = function () {
        var _this = this;
        var serverAdd = Constants_1.Constants.NETWORK_DISCOVERY_SERVICE;
        if (serverAdd === 'localhost')
            serverAdd = '127.0.0.1:' + location.port;
        return this.identityProvider.getIdentity().then(function (identity) {
            var guid = identity.getPeerId();
            _this.logger.debug(_this.loggerId + 'MY PEER ID ', guid);
            _this.myId = guid;
            _this.serverManager.start(serverAdd, guid);
            return identity;
        });
    };
    HiveNetworkManager.prototype.getInfo = function () {
        return Q.resolve(new HashMap());
    };
    HiveNetworkManager.prototype.connect = function (otherId) {
        var _this = this;
        var deferred = Q.defer();
        if (this.connectedPeers.has(otherId)) {
            this.logger.debug(this.loggerId + 'Already connected to ' + otherId + ', ignoring');
            deferred.resolve(this.connectedPeers.get(otherId));
        }
        else {
            this.channelManager.initiateConnect(this.myId, otherId)
                .then(function (channel) { return _this.connected(otherId, channel); })
                .then(function (p2ptransport) {
                return deferred.resolve(p2ptransport);
            })
                .fail(function (err) {
                deferred.reject('CONN TO ' + otherId + ' CANNOT BE ESTABLISHED');
            });
        }
        return deferred.promise;
    };
    HiveNetworkManager.prototype.send = function (guid, data, length) {
        var succeeded = this.channelManager.send(guid, data);
        if (!succeeded) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error sending message without channel established', this.loggerId, ErrorCodes.NETWORK_MANAGER_CODES.SEND_MESSAGE_TO_NON_EXISTING_CHANNEL, { otherGuid: guid });
            this.connectionClosed(guid);
        }
        return succeeded;
    };
    HiveNetworkManager.prototype.msgReceived = function (who, msgType, content) {
        if (this.detailedLog)
            this.logger.debug(this.loggerId + 'REC BUF ' + content.byteLength + ' ' + content);
        if (this.connectedPeers.has(who)) {
            if (this.detailedLog)
                this.logger.debug(this.loggerId + 'PROC MSG FROM ' + who);
            var p2pTransport = this.connectedPeers.get(who);
            p2pTransport.receiveMessage(content);
        }
        else {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error receiving msg without having a connection established', this.loggerId, ErrorCodes.NETWORK_MANAGER_CODES.SEND_MESSAGE_TO_NON_EXISTING_CHANNEL, { otherGuid: who });
            // this.logger.warn("RECEIVED MSG FROM PEER " + who + " BUT IT IS NOT CONNECTED")
        }
    };
    HiveNetworkManager.prototype.connected = function (otherId, channel) {
        if (this.connectedPeers.has(otherId)) {
            this.logger.debug(this.loggerId + 'RECONNECTED TO ' + otherId + ', RESETTING STATE');
            this.connectedPeers.get(otherId).reset();
        }
        else {
            this.logger.debug(this.loggerId + 'CONNECTED TO ' + otherId);
            var transport = channel.p2pTransport;
            transport.init(this.myId, otherId);
            this.connectedPeers.set(otherId, transport);
        }
        return Q.resolve(this.connectedPeers.get(otherId));
    };
    HiveNetworkManager.prototype.connectionFailed = function (defer, easyrtcid) {
        this.logger.debug(this.loggerId + 'FAILED CONN TO ' + easyrtcid);
        defer.reject('CONN TO ' + easyrtcid + ' CANNOT BE ESTABLISHED ');
    };
    HiveNetworkManager.prototype.connectionReceived = function (easyrtcid, channel) {
        this.connected(easyrtcid, channel);
    };
    HiveNetworkManager.prototype.connectionClosed = function (easyrtcid) {
        if (this.connectedPeers.has(easyrtcid)) {
            this.logger.debug(this.loggerId + 'Connection closed to ' + easyrtcid);
            this.connectedPeers.delete(easyrtcid);
            this.firePeerDisconnected(easyrtcid);
        }
        else {
            this.logger.warn(this.loggerId + 'TRYING TO REMOVE A PEER THAT IS NOT THERE: ' + easyrtcid);
        }
    };
    /**
     * periodic evaluation of stale webrtc connections
     */
    HiveNetworkManager.prototype.startPeriodicConnectionsCheck = function () {
        var _this = this;
        if (FrameworkNetworkConstants_1.NetworkConstants.StaleConnectionCleanup) {
            // cleanup up unused connections!
            Framework_1.Framework.setInterval(function () {
                var now = Framework_1.Framework.time();
                _this.connectedPeers.forEach(function (t, guid) {
                    var lastUsed = now - t.getLastUsed();
                    if (lastUsed > FrameworkNetworkConstants_1.NetworkConstants.StaleConnectionMaxElapsed) {
                        _this.logger.debug(_this.loggerId + 'closing stale connection to ' + guid + ' [unused for: ' + lastUsed + 'ms]');
                        _this.disconnect(guid);
                    }
                });
            }, FrameworkNetworkConstants_1.NetworkConstants.StaleConnectionCheckPeriod);
        }
    };
    HiveNetworkManager.prototype.stop = function (swarmId) {
        var logger = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.LOGGER).log(swarmId);
        logger.debug(this.loggerId + 'STOPPING CONNECTIONS AND REMOVING LISTENERS');
        this.removeListeners(swarmId);
    };
    HiveNetworkManager.prototype.disconnectFromServer = function () {
    };
    /**
     * application entry point to close a connection to a peer if any.
     * When the channel is closed it will trigger the connectionClosed
     *
     * @param easyrtcid
     */
    HiveNetworkManager.prototype.disconnect = function (easyrtcid) {
        if (this.connectedPeers.has(easyrtcid)) {
            // this.connectedPeers.delete(easyrtcid)
            this.channelManager.disconnect(easyrtcid);
        }
    };
    HiveNetworkManager.SEND_RATE_TAG = 'availableSendRate';
    HiveNetworkManager.REMOTE_ADDRESS_TAG = 'remoteAddress';
    HiveNetworkManager.LOCAL_ADDRESS_TAG = 'localAddress';
    return HiveNetworkManager;
}(BaseNetworkManager_1.BaseNetworkManager));
exports.HiveNetworkManager = HiveNetworkManager;
//# sourceMappingURL=HiveNetworkManager.js.map

/***/ }),

/***/ "../../../core/build/core/src/webrtc/network/ServerManagerScala.js":
/*!******************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/webrtc/network/ServerManagerScala.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ServerManagerScala = void 0;
var Q = __webpack_require__(/*! @hivestreaming/q */ "../../../node_modules/@hivestreaming/q/q.js");
var Framework_1 = __webpack_require__(/*! ../../core/Framework */ "../../../core/build/core/src/core/Framework.js");
var HiveServices_1 = __webpack_require__(/*! ../../core/HiveServices */ "../../../core/build/core/src/core/HiveServices.js");
/**
 * Sends and receives the different messages of the signaling process, using the Hive Services as signaling server.
 */
var ServerManagerScala = /** @class */ (function () {
    function ServerManagerScala() {
        this.counter = 1;
        this.client = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.SERVICES_CLIENT);
    }
    ServerManagerScala.prototype.init = function (netManager, logger, channelManager) {
        this.netManager = netManager;
        this.logger = logger;
        this.channelManager = channelManager;
    };
    ServerManagerScala.prototype.isConnected = function () {
        return this.client.getConnection().isConnected();
    };
    ServerManagerScala.prototype.start = function (serverAdd, myId) {
        var _this = this;
        this.myId = myId;
        if (this.client && this.client.getConnection()) {
            // setup the response handler
            this.client.getConnection().on(HiveStreamingServices.HIVEJS_FORWARDING, 1, function (msg) {
                _this.serverMessageReceived(msg.msg);
            });
        }
        else {
            this.logger.error('error getting active services connection');
        }
        this.netManager.fireServerConnected(this.myId);
    };
    ServerManagerScala.prototype.serverMessageReceived = function (data) {
        var ev = JSON.parse(data);
        if (this.netManager.detailedLog)
            this.logger.debug('RCV MSG FROM SRV ', ev);
        this.channelManager.trigger(ev.msgName, ev.msg);
    };
    ServerManagerScala.prototype.triggerSend = function (msgName, ev, destination) {
        var wrapped = this.wrap(ev, msgName, destination);
        if (this.client && this.client.getConnection()) {
            var serialized = JSON.stringify(wrapped);
            if (this.netManager.detailedLog)
                this.logger.debug(' FORWARDING REQUEST : ' + serialized);
            var msg = new HiveServices_1.Message(HiveStreamingServices.HIVEJS_FORWARDING, 0, serialized);
            return this.client.getConnection().send(msg);
        }
        return Q.reject();
    };
    ServerManagerScala.prototype.wrap = function (ev, msgName, destination) {
        return {
            msgId: this.counter++,
            destination: destination,
            msg: ev,
            msgName: msgName
        };
    };
    ServerManagerScala.prototype.updateICE = function (localPeer, channel, candidates, remotePeer) {
        var ev = {
            channel: {
                label: channel.label,
                ice_candidates: candidates
            }
        };
        return this.triggerSend('update_ice_candidates', ev, remotePeer);
    };
    ServerManagerScala.prototype.offer = function (localPeer, remotePeer, channel, candidates, offer) {
        var ev = {
            peer: {
                guid: localPeer,
                first_seen: Framework_1.Framework.time()
            },
            channel: {
                label: channel.label,
                ice_candidates: candidates,
                offer: offer
            }
        };
        return this.triggerSend('offer', ev, channel.remotePeer);
    };
    ServerManagerScala.prototype.rejectOffer = function (localPeer, remotePeer, channelLabel) {
        if (this.netManager.detailedLog)
            this.logger.debug('Discovery service rejects offer from peer ' + remotePeer + ' on channel ' + channelLabel);
        var ev = {
            rejected_by: localPeer,
            channel: channelLabel
        };
        // TODO check reject offer correctness
        return this.triggerSend('answer', ev, remotePeer);
    };
    ServerManagerScala.prototype.answer = function (channel, answerData, candidates, remotePeer) {
        var ev = {
            answer: answerData,
            remote_peer: this.netManager.myId,
            channel: {
                label: channel.label,
                ice_candidates: candidates
            }
        };
        return this.triggerSend('answer', ev, remotePeer);
    };
    return ServerManagerScala;
}());
exports.ServerManagerScala = ServerManagerScala;
//# sourceMappingURL=ServerManagerScala.js.map

/***/ }),

/***/ "../../../core/build/core/src/webrtc/node-info/DefaultPeerNodeInfo.js":
/*!*********************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/webrtc/node-info/DefaultPeerNodeInfo.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.DefaultPeerNodeInfo = void 0;
var HashMap = __webpack_require__(/*! @hivestreaming/collections/map */ "../../../node_modules/@hivestreaming/collections/map.js");
var PeerConstants_1 = __webpack_require__(/*! ../PeerConstants */ "../../../core/build/core/src/webrtc/PeerConstants.js");
var Utils_1 = __webpack_require__(/*! ../../core/Utils */ "../../../core/build/core/src/core/Utils.js");
var jsrsasign_1 = __webpack_require__(/*! @hivestreaming/jsrsasign */ "../../../node_modules/@hivestreaming/jsrsasign/lib/jsrsasign.js");
var DefaultPeerNodeInfo = /** @class */ (function () {
    function DefaultPeerNodeInfo() {
        this.udpScore = 0;
        this.currentScore = 0;
        this.lanLeader = false;
        this.siteLeader = false;
        this.haveOtherLanPartners = false;
        this.haveOtherSitePartners = false;
        this.haveOtherAsPartners = false;
        this.prefetchStreamCharacteristics = new HashMap();
        this.srcThroughput = new Utils_1.Bandwidth();
    }
    DefaultPeerNodeInfo.prototype.setId = function (id) {
        this.guId = id;
    };
    DefaultPeerNodeInfo.prototype.getId = function () {
        return this.guId;
    };
    DefaultPeerNodeInfo.prototype.setUDPScore = function (score) {
        this.udpScore = score;
    };
    DefaultPeerNodeInfo.prototype.getUDPScore = function () {
        return this.udpScore;
    };
    DefaultPeerNodeInfo.prototype.setCurrentScore = function (score) {
        this.currentScore = score;
    };
    DefaultPeerNodeInfo.prototype.getCurrentScore = function () {
        return this.currentScore;
    };
    DefaultPeerNodeInfo.prototype.setContextId = function (contextId) {
        var urlHashed = jsrsasign_1.CryptoJS.SHA1(contextId + '_' + PeerConstants_1.PeerConstants.PartnershipConstants.P2P_PROTOCOL_VERSION).toString(jsrsasign_1.CryptoJS.enc.Hex);
        this.contextId = urlHashed;
    };
    DefaultPeerNodeInfo.prototype.getContextId = function () {
        return this.contextId;
    };
    DefaultPeerNodeInfo.prototype.setLanLeader = function (leader) {
        this.lanLeader = leader;
    };
    DefaultPeerNodeInfo.prototype.isLanLeader = function () {
        return this.lanLeader;
    };
    DefaultPeerNodeInfo.prototype.setLanPartnershipFlag = function (haveLan) {
        this.haveOtherLanPartners = haveLan;
    };
    DefaultPeerNodeInfo.prototype.haveLanPartners = function () {
        return this.haveOtherLanPartners;
    };
    DefaultPeerNodeInfo.prototype.setSitePartnershipFlag = function (haveSitePartners) {
        this.haveOtherSitePartners = haveSitePartners;
    };
    DefaultPeerNodeInfo.prototype.haveSitePartners = function () {
        return this.haveOtherSitePartners;
    };
    DefaultPeerNodeInfo.prototype.setAsPartnershipFlag = function (haveAsPartners) {
        this.haveOtherAsPartners = haveAsPartners;
    };
    DefaultPeerNodeInfo.prototype.haveAsPartners = function () {
        return this.haveOtherAsPartners;
    };
    DefaultPeerNodeInfo.prototype.setLeader = function (leader) {
        this.leaderMember = leader;
    };
    DefaultPeerNodeInfo.prototype.getLeader = function () {
        return this.leaderMember;
    };
    DefaultPeerNodeInfo.prototype.setSiteLeader = function (leader) {
        this.siteLeader = leader;
    };
    DefaultPeerNodeInfo.prototype.amISiteLeader = function () {
        return this.siteLeader;
    };
    DefaultPeerNodeInfo.prototype.setWatchingQualityLevel = function (qualityLevel) {
        this.watchingQualityLevel = qualityLevel;
    };
    DefaultPeerNodeInfo.prototype.getWatchingQualityLevel = function () {
        return this.watchingQualityLevel;
    };
    DefaultPeerNodeInfo.prototype.setSortedLANMembers = function (sortedLM) {
        this.sortedLANMembers = sortedLM;
    };
    DefaultPeerNodeInfo.prototype.getSortedLANMembers = function () {
        return this.sortedLANMembers;
    };
    DefaultPeerNodeInfo.prototype.setReportingGuid = function (reportingGuid) {
        this.reportingGuid = reportingGuid;
    };
    DefaultPeerNodeInfo.prototype.getReportingGuid = function () {
        return this.reportingGuid;
    };
    DefaultPeerNodeInfo.prototype.setDelta = function (delta) {
        this.delta = delta;
    };
    DefaultPeerNodeInfo.prototype.getDelta = function () {
        return this.delta;
    };
    DefaultPeerNodeInfo.prototype.addPrefetchingQualityLevel = function (qualityLevel, prefetchSession) {
        this.prefetchStreamCharacteristics.set(qualityLevel.id, prefetchSession);
    };
    DefaultPeerNodeInfo.prototype.removePrefetchingQualityLevel = function (qualityLevel) {
        this.prefetchStreamCharacteristics.delete(qualityLevel.id);
    };
    DefaultPeerNodeInfo.prototype.getPrefetchingQualityLevels = function () {
        return this.prefetchStreamCharacteristics;
    };
    /**
     * This function returns an array of the quality levels that the peer is prefetching
     * iff this peer is a site leader. Then we call that this peer is a first tier prefetcher
     * @returns {Array<number>}
     */
    DefaultPeerNodeInfo.prototype.getFirstTierQualityLevels = function () {
        if (this.amISiteLeader()) {
            return this.prefetchStreamCharacteristics.values()
                .map(function (value) { return value.qualityLevel; });
        }
        return [];
    };
    /**
     * This function returns an array of the quality levels that the peer is prefetching. This peer should not be
     * a site leader and this is why we call him a second tier prefetcher.
     *
     * @returns {Array<number>}
     */
    DefaultPeerNodeInfo.prototype.getSecondTierQualityLevels = function () {
        if (!this.amISiteLeader()) {
            return this.prefetchStreamCharacteristics.values()
                .map(function (value) { return value.qualityLevel; });
        }
        return [];
    };
    DefaultPeerNodeInfo.prototype.setTicket = function (ticket) {
        this.ticket = ticket;
    };
    DefaultPeerNodeInfo.prototype.getTicket = function () {
        return this.ticket;
    };
    DefaultPeerNodeInfo.prototype.setAndroidDeviceFlag = function (android) {
        this.androidDevice = android;
    };
    DefaultPeerNodeInfo.prototype.amIOnAndroid = function () {
        return this.androidDevice;
    };
    DefaultPeerNodeInfo.prototype.getSourceThroughput = function () {
        return this.srcThroughput;
    };
    return DefaultPeerNodeInfo;
}());
exports.DefaultPeerNodeInfo = DefaultPeerNodeInfo;
//# sourceMappingURL=DefaultPeerNodeInfo.js.map

/***/ }),

/***/ "../../../core/build/core/src/webrtc/p2ptransfer/P2PFragmentRequester.js":
/*!************************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/webrtc/p2ptransfer/P2PFragmentRequester.js ***!
  \************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.FragmentRequester = void 0;
var Q = __webpack_require__(/*! @hivestreaming/q */ "../../../node_modules/@hivestreaming/q/q.js");
var SortedMap = __webpack_require__(/*! @hivestreaming/collections/sorted-map */ "../../../node_modules/@hivestreaming/collections/sorted-map.js");
var P2PTransport_1 = __webpack_require__(/*! ../transport/P2PTransport */ "../../../core/build/core/src/webrtc/transport/P2PTransport.js");
var Framework_1 = __webpack_require__(/*! ../../core/Framework */ "../../../core/build/core/src/core/Framework.js");
var Utils = __webpack_require__(/*! ../../core/Utils */ "../../../core/build/core/src/core/Utils.js");
var PeerConstants_1 = __webpack_require__(/*! ../PeerConstants */ "../../../core/build/core/src/webrtc/PeerConstants.js");
var Partnership_1 = __webpack_require__(/*! ../partnership/Partnership */ "../../../core/build/core/src/webrtc/partnership/Partnership.js");
var logger_hive_1 = __webpack_require__(/*! ../../common/logger.hive */ "../../../core/build/core/src/common/logger.hive.js");
var ErrorCodes = __webpack_require__(/*! ../../common/error.hive */ "../../../core/build/core/src/common/error.hive.js");
/**
 * class that handles a single p2p transfer from the requester point of view
 */
var FragmentRequester = /** @class */ (function () {
    function FragmentRequester(myGuid, otherGuid, swarm) {
        this.loggerId = '[FragmentRequester] ';
        this.pendingRequests = new SortedMap();
        this.requestTimings = new SortedMap();
        this.currentFragmentTransfer = null;
        this.netLogging = P2PTransport_1.netLogging;
        this.myGuid = myGuid;
        this.otherGuid = otherGuid;
        this.requester = swarm.p2pRequester;
        this.nodeInfo = swarm.nodeInfo;
        this.networkManager = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.RTC_MANAGER);
        this.logger = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.LOGGER).log(swarm.sessionId);
        // this.loggerId = `S[${swarm.sessionId}]`;
    }
    FragmentRequester.prototype.setReportingGuid = function (otherReportingGuid) {
        this.otherReportingGuid = otherReportingGuid;
    };
    FragmentRequester.prototype.inUse = function () {
        return !(this.pendingRequests.keys().length === 0 && this.currentFragmentTransfer === null);
    };
    /**
     * called by requester we want to initiate a transfer
     * @param hiveRequest
     */
    FragmentRequester.prototype.sendRequestInternal = function (hiveRequest) {
        // var requestNumber = hiveRequest.requestNumber;
        var request = new P2PTransport_1.P2PTransport.msgBuilder.Request();
        try {
            request.fragmentId = hiveRequest.getEntityId();
            request.transferId = hiveRequest.transferNum;
            if (this.netLogging) {
                this.logger.debug('INITIATING TR-' + hiveRequest.transferNum + ' TIMEOUT: ' + hiveRequest.transferTimeout + ' FRAGMENT: ' + hiveRequest.getEntityId() + ' FROM: ' + this.otherGuid);
            }
            this.pendingRequests.set(hiveRequest.transferNum, hiveRequest);
            this.requestTimings.set(hiveRequest.transferNum, Framework_1.Framework.time());
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error constructing fragment request message', this.loggerId, ErrorCodes.FRAGMENT_REQUESTER_CODES.CONSTRUCT_FRAGMENT_REQUEST_MESSAGE, {
                detailedError: error,
                otherGuid: this.otherGuid
            });
            request = null;
        }
        try {
            if (request)
                hiveRequest.partner.dispatcher.sendMessage(P2PTransport_1.P2PMsgTypes.Request, request);
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error sending fragment request', this.loggerId, ErrorCodes.FRAGMENT_REQUESTER_CODES.SEND_FRAGMENT_REQUEST, {
                detailedError: error,
                otherGuid: this.otherGuid
            });
        }
    };
    FragmentRequester.prototype.receiveChunk = function (chunk) {
        try {
            // Read transfer ID
            var transferId = chunk.transferId;
            var chunkData = chunk.data.toBuffer();
            var chunkSize = chunk.chunkSize;
            var fragmentSize = chunk.totalSize;
            var headers = chunk.headers;
            if (this.netLogging) {
                this.logger.debug('RCV Chunk ' + chunkData.byteLength);
            }
            if (this.pendingRequests.has(transferId)) {
                if (this.currentFragmentTransfer == null) {
                    if (this.netLogging) {
                        this.logger.debug('INITIATED TR-' + transferId + ',SIZE=' + fragmentSize);
                    }
                    this.currentFragmentTransfer = this.pendingRequests.get(transferId);
                    this.currentFragmentTransfer.transferNum = transferId;
                    if (PeerConstants_1.PeerConstants.Transport.USE_ACK)
                        this.sendAck(transferId, this.currentFragmentTransfer.partner);
                    if (headers != null) {
                        this.currentFragmentTransfer.respHeaders = headers;
                    }
                    else {
                        this.logger.warn('HEADERS NULL IN FIRST CHUNK');
                    }
                    this.requester.firstResponse(this.otherGuid, this.currentFragmentTransfer, chunkSize, fragmentSize);
                    this.currentFragmentTransfer.rcvMesgLength = chunkSize;
                    if (!Framework_1.Framework.isSimulated()) {
                        this.currentFragmentTransfer.binaryData = chunkData;
                    }
                }
                else {
                    if (PeerConstants_1.PeerConstants.Transport.USE_ACK)
                        this.sendAck(transferId, this.currentFragmentTransfer.partner);
                    this.currentFragmentTransfer.rcvMesgLength += chunkSize;
                    if (!Framework_1.Framework.isSimulated()) {
                        this.currentFragmentTransfer.binaryData = Utils.appendBuffer(this.currentFragmentTransfer.binaryData, chunkData);
                    }
                }
                var length_1 = Framework_1.Framework.isSimulated() ? this.currentFragmentTransfer.rcvMesgLength : this.currentFragmentTransfer.binaryData.byteLength;
                if (this.netLogging) {
                    this.logger.debug('RECEIVED ' + length_1 + '/' + fragmentSize + ' TRID ' + transferId);
                }
                // this.sendAck(transferId, this.currentFragmentTransfer.partner);
                if (length_1 == fragmentSize) {
                    if (this.netLogging) {
                        this.logger.debug('RCV ALL DATA ' + length_1 + ' TR-' + this.currentFragmentTransfer.requestNumber);
                    }
                    // this.currentFragmentTransfer.retMsgData = this.currentFragmentTransfer.binaryData;
                    this.currentFragmentTransfer.requestStats.totalFromP2P = length_1;
                    Framework_1.Framework.clearTimeout(this.currentFragmentTransfer.timerId);
                    this.pendingRequests.delete(transferId);
                    var spendTime = Framework_1.Framework.time() - this.requestTimings.get(transferId);
                    this.logger.debug('RCV ALL DATA FROM ' + this.otherGuid + ' AFTER ' + spendTime + ' mseconds');
                    this.requestTimings.delete(transferId);
                    this.requester.fragmentRetrieved(transferId, this.currentFragmentTransfer);
                    this.currentFragmentTransfer = null;
                }
            }
            else {
                // ErrorMonitor.getInstance().logError("Error receiving chunk of expired transfer id", this.loggerId, ErrorCodes.FRAGMENT_REQUESTER_CODES.RECEIVE_EXPIRED_CHUNK);
                return;
            }
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error receiving chunk', this.loggerId, ErrorCodes.FRAGMENT_REQUESTER_CODES.RECEIVE_CHUNK, {
                detailedError: error,
                otherGuid: this.otherGuid
            });
        }
    };
    FragmentRequester.prototype.sendAck = function (transferId, partner) {
        try {
            if (this.netLogging) {
                this.logger.debug('SEND ACK ' + transferId + ' TO ' + this.otherGuid);
            }
            var response = new P2PTransport_1.P2PTransport.msgBuilder.Ack();
            response.transferId = transferId;
            partner.dispatcher.sendMessage(P2PTransport_1.P2PMsgTypes.Ack, response);
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error sending ack', this.loggerId, ErrorCodes.FRAGMENT_REQUESTER_CODES.SEND_ACK, {
                detailedError: error,
                otherGuid: this.otherGuid
            });
        }
    };
    FragmentRequester.prototype.close = function (str) {
        var _this = this;
        var deferred = Q.defer();
        if (this.currentFragmentTransfer != null) {
            this.stopTransfer(this.currentFragmentTransfer.transferNum);
        }
        var keys = this.pendingRequests.keys().slice();
        keys.forEach(function (reqNumber) {
            _this.stopTransfer(reqNumber);
        });
        deferred.resolve(Partnership_1.PartnershipCloseType.ALL);
        return deferred.promise;
    };
    /**
     * called when the p2p timeout expires
     * @param transferNum
     */
    FragmentRequester.prototype.stopTransfer = function (transferNum) {
        try {
            if (this.pendingRequests.has(transferNum)) {
                var request = this.pendingRequests.get(transferNum);
                request.requestStats.totalFromP2P = request.rcvMesgLength;
                this.logger.debug('SEND CANCEL FOR ' + transferNum + ' TO ' + this.otherGuid);
                this.requestTimings.delete(transferNum);
                var cancel = new P2PTransport_1.P2PTransport.msgBuilder.Cancel();
                cancel.transferId = transferNum;
                request.partner.dispatcher.sendMessage(P2PTransport_1.P2PMsgTypes.Cancel, cancel);
                if (this.currentFragmentTransfer !== null && this.currentFragmentTransfer.getRequestId() === request.getRequestId()) {
                    this.currentFragmentTransfer = null;
                }
                this.pendingRequests.delete(transferNum);
            }
            else {
                logger_hive_1.ErrorMonitor.getInstance().logError('Error cleaning up a not pending transfer', this.loggerId, ErrorCodes.FRAGMENT_REQUESTER_CODES.CLEAN_UP_NOT_PENDING);
            }
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error sending stop transfer', this.loggerId, ErrorCodes.FRAGMENT_REQUESTER_CODES.STOP_TRANSFER, {
                detailedError: error,
                otherGuid: this.otherGuid
            });
        }
    };
    return FragmentRequester;
}());
exports.FragmentRequester = FragmentRequester;
//# sourceMappingURL=P2PFragmentRequester.js.map

/***/ }),

/***/ "../../../core/build/core/src/webrtc/p2ptransfer/P2PFragmentSender.js":
/*!*********************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/webrtc/p2ptransfer/P2PFragmentSender.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.FragmentSender = void 0;
var Q = __webpack_require__(/*! @hivestreaming/q */ "../../../node_modules/@hivestreaming/q/q.js");
var SortedMap = __webpack_require__(/*! @hivestreaming/collections/sorted-map */ "../../../node_modules/@hivestreaming/collections/sorted-map.js");
var ByteBuffer = __webpack_require__(/*! bytebuffer */ "../../../core/node_modules/bytebuffer/dist/bytebuffer.js");
var P2PTransport_1 = __webpack_require__(/*! ../transport/P2PTransport */ "../../../core/build/core/src/webrtc/transport/P2PTransport.js");
var Framework_1 = __webpack_require__(/*! ../../core/Framework */ "../../../core/build/core/src/core/Framework.js");
var P2PResponse_1 = __webpack_require__(/*! ../msgs/P2PResponse */ "../../../core/build/core/src/webrtc/msgs/P2PResponse.js");
var PeerConstants_1 = __webpack_require__(/*! ../PeerConstants */ "../../../core/build/core/src/webrtc/PeerConstants.js");
var logger_hive_1 = __webpack_require__(/*! ../../common/logger.hive */ "../../../core/build/core/src/common/logger.hive.js");
var ErrorCodes = __webpack_require__(/*! ../../common/error.hive */ "../../../core/build/core/src/common/error.hive.js");
/**
 * class that handles a single p2p transfer from the responder point of view
 */
var FragmentSender = /** @class */ (function () {
    function FragmentSender(myGuid, otherGuid, swarm, dispatcher) {
        this.loggerId = '[FragmentSender] ';
        this.netLogging = P2PTransport_1.netLogging;
        this.response = null;
        this.pendingResponses = new Array();
        this.sendingFragmentsTimings = new SortedMap();
        this.totalChunkCount = 0;
        this.close = null;
        this.myGuid = myGuid;
        this.otherGuid = otherGuid;
        this.responder = swarm.responder;
        this.dispatcher = dispatcher;
        this.chunkHandler = swarm.chunkHandler;
        this.logger = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.LOGGER).log(swarm.sessionId);
        // this.loggerId = `S[${swarm.sessionId}]`;
        this.networkManager = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.RTC_MANAGER);
    }
    FragmentSender.prototype.setReportingGuid = function (otherReportingGuid) {
        this.otherReportingGuid = otherReportingGuid;
    };
    /**
     * called by the p2p responder when we can serve a fragment
     *
     * generate a p2p response message
     * add it to the queue of transfers (NOTE: in practice we handle only one transfer at the time from a peer to another)
     * start to send chunks
     *
     * @param fragmentId
     * @param transferId
     * @param length
     * @param headers
     * @param data
     */
    FragmentSender.prototype.sendFragment = function (fragmentId, transferId, length, headers, data) {
        var _this = this;
        if (this.netLogging) {
            this.logger.info('SEND FRAGMENT ' + fragmentId + ' TO ' + this.otherGuid);
        }
        try {
            var response = new P2PResponse_1.P2PResponse();
            response.transferId = transferId;
            response.fragmentId = fragmentId;
            response.dataToSend = data;
            response.headers = headers;
            response.dataToSendLength = length;
            response.chunkCount = Math.ceil(response.dataToSendLength / PeerConstants_1.PeerConstants.Transport.ChunkSize);
            response.sentAlready = 0;
            this.pendingResponses.push(response);
            if (this.netLogging) {
                this.pendingResponses.forEach(function (respL) {
                    _this.logger.debug(_this.otherGuid + ' PENDING OUT ' + respL);
                });
            }
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error constructing chunk response', this.loggerId, ErrorCodes.FRAGMENT_SENDER_CODES.CONSTRUCT_CHUNK_RESPONSE, {
                detailedError: error,
                otherGuid: this.otherGuid
            });
        }
        if (this.response === null) {
            this.sendFragmentChunks();
        }
        else if (this.netLogging) {
            this.logger.debug(this.otherGuid + ' OUT MSG NOT NULL');
        }
    };
    /**
     * called by dispatcher when receiving an ack
     * @param transferId
     */
    FragmentSender.prototype.ackReceived = function (transferId) {
        if (this.netLogging) {
            this.logger.debug('ONGOING ' + transferId + ' GOT ACK');
        }
        if (this.response !== null && this.response.transferId.toString() === transferId.toString()) {
            this.sendChunks(false);
        }
        else {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error receiving ack for unknown transfer', this.loggerId, ErrorCodes.FRAGMENT_SENDER_CODES.UNKNOWN_ACK);
        }
    };
    FragmentSender.prototype.onBufferedAmountLow = function () {
        if (this.response != null) {
            this.sendChunks(false);
        }
    };
    /**
     * called by dispatcher when receiving an cancel transfer
     * @param transferId
     */
    FragmentSender.prototype.cancelReceived = function (transferId) {
        if (this.response != null && this.response.transferId === transferId) {
            this.logger.debug('GOT CANCEL FOR ONGOING TRANSFER-' + transferId + ',' + this.myGuid + ',' + this.otherGuid);
            this.sendingFragmentsTimings.delete(transferId);
            if (this.response.sentAlready != 0) {
                this.responder.requestPartiallySatisfied(this.otherGuid, this.otherReportingGuid, this.response.sentAlready, this.response.dataToSendLength);
            }
            else {
                this.responder.requestNotSatisfied(this.otherGuid, this.otherReportingGuid, this.response.dataToSendLength);
            }
            this.response = null;
            // Keep sending other messages
            this.sendFragmentChunks();
        }
        else {
            this.pendingResponses = this.pendingResponses.filter(function (req) {
                return req.transferId !== transferId;
            });
        }
    };
    /**
     * flush the queue of p2p responses
     */
    FragmentSender.prototype.sendFragmentChunks = function () {
        try {
            if (this.response === null) {
                if (this.pendingResponses.length !== 0) {
                    var response = this.pendingResponses.shift();
                    // this.logger.debug("START SENDING " + response.fragmentId);
                    this.response = response;
                    if (this.netLogging) {
                        this.logger.debug('DATA TO SEND LENGTH ' + this.response.dataToSendLength + ' IN ' + this.response.chunkCount + ' CHUNKS WITH TR-' + this.response.transferId);
                    }
                    this.sendChunks(true);
                }
            }
        }
        catch (err) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error start sending chunks', this.loggerId, ErrorCodes.FRAGMENT_SENDER_CODES.START_SENDING_CHUNK, err);
            this.resetSendState();
        }
    };
    /**
     *
     * @param first
     */
    FragmentSender.prototype.sendChunks = function (first) {
        // performance monitoring
        // TODO check if we need the timings performance on the sender
        if (first) {
            this.sendingFragmentsTimings.set(this.response.transferId, Framework_1.Framework.time());
            this.totalChunkCount = this.response.chunkCount;
        }
        try {
            if (this.response != null) {
                // check if all the chunks have been sent
                if (this.response.chunkCount === 0) {
                    this.logger.debug('FINISHED SENDING TRANSFER ' + this.response.transferId + ' TO ' + this.otherGuid + ' WITH ' + this.response.sentAlready + ' BYTES');
                    this.sendingFragmentsTimings.delete(this.response.transferId);
                    this.responder.requestSatisfied(this.otherGuid, this.otherReportingGuid, this.response.dataToSendLength);
                    // record the stats
                    // this.statsStore.getPartnerTrafficStore(this.otherGuid).p2pSuccSent += this.response.sentAlready
                    this.response = null;
                    this.finishedTransfer();
                    // flush other fragments
                    this.sendFragmentChunks();
                }
                else {
                    if (this.netLogging) {
                        this.logger.debug('A CHUNK');
                    }
                    var till = Math.min(this.response.sentAlready + PeerConstants_1.PeerConstants.Transport.ChunkSize, this.response.dataToSendLength);
                    // this.logger.debug("SA "+this.response.sentAlready+" DTSL "+this.response.dataToSendLength+" till "+till+" TOS "+this.response.dataToSend.byteLength)
                    var toSend = (till - this.response.sentAlready);
                    var chunk = new P2PTransport_1.P2PTransport.msgBuilder.Chunk();
                    chunk.transferId = this.response.transferId;
                    chunk.totalSize = this.response.dataToSendLength;
                    chunk.chunkSize = toSend;
                    if (first && this.response.headers != null) {
                        chunk.headers = this.response.headers;
                    }
                    if (!Framework_1.Framework.isSimulated() && this.response.dataToSend != null) {
                        // try to retrieve a ready chunk from the chunk handler, otherwise split it on the fly
                        chunk.data = this.chunkHandler.getChunk(this.response.fragmentId, (this.totalChunkCount - this.response.chunkCount));
                        if (chunk.data == null) {
                            var sl = this.response.dataToSend.slice(this.response.sentAlready, till);
                            // this.logger.debug("WRAPPING BUFFER "+sl.byteLength)
                            chunk.data = ByteBuffer.wrap(sl);
                        }
                    }
                    else {
                        // simulation!
                        // wee need anyhow to set the data or the protobuffer gives an error
                        chunk.data = ByteBuffer.wrap(new ArrayBuffer(0));
                    }
                    this.response.sentAlready = this.response.sentAlready + toSend;
                    // send the chunk and get the new buffered amount
                    this.dispatcher.sendMessage(P2PTransport_1.P2PMsgTypes.Chunk, chunk);
                    if (this.netLogging) {
                        this.logger.debug('SND [' + this.response.sentAlready + '-' + (this.response.sentAlready + toSend) + '/' +
                            this.response.dataToSendLength + '] TO ' + this.otherGuid + ' OF TR-' + this.response.transferId);
                    }
                    this.response.chunkCount--;
                }
            }
            else {
                this.logger.debug('NO MESSAGE TO SEND');
            }
        }
        catch (err) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error sending chunk', this.loggerId, ErrorCodes.FRAGMENT_SENDER_CODES.SEND_CHUNK, {
                detailedError: err,
                otherGuid: this.otherGuid
            });
            this.resetSendState();
        }
    };
    FragmentSender.prototype.inUse = function () {
        return !(this.pendingResponses.length === 0 && this.response === null);
    };
    /**
     * called by the dispatcher to know when the sender is done with a connection
     * @returns {Promise<string>}
     */
    FragmentSender.prototype.closeWhenFinished = function () {
        var deferred = Q.defer();
        this.pendingResponses.length = 0;
        if (this.inUse()) {
            this.close = deferred;
        }
        else {
            deferred.resolve('CLOSE');
        }
        return deferred.promise;
    };
    /**
     * resolve any pending close promise
     */
    FragmentSender.prototype.finishedTransfer = function () {
        if (this.close) {
            this.close.resolve('CLOSED');
        }
    };
    FragmentSender.prototype.resetSendState = function () {
        this.response = null;
    };
    return FragmentSender;
}());
exports.FragmentSender = FragmentSender;
//# sourceMappingURL=P2PFragmentSender.js.map

/***/ }),

/***/ "../../../core/build/core/src/webrtc/p2ptransfer/P2PRequester.js":
/*!****************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/webrtc/p2ptransfer/P2PRequester.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.P2PRequester = void 0;
var HashMap = __webpack_require__(/*! @hivestreaming/collections/map */ "../../../node_modules/@hivestreaming/collections/map.js");
var Utils_1 = __webpack_require__(/*! ../../core/Utils */ "../../../core/build/core/src/core/Utils.js");
var Framework_1 = __webpack_require__(/*! ../../core/Framework */ "../../../core/build/core/src/core/Framework.js");
var EntityType_1 = __webpack_require__(/*! ../../core/entity/EntityType */ "../../../core/build/core/src/core/entity/EntityType.js");
var DiscoveryInfo_1 = __webpack_require__(/*! ../discovery/DiscoveryInfo */ "../../../core/build/core/src/webrtc/discovery/DiscoveryInfo.js");
var logger_hive_1 = __webpack_require__(/*! ../../common/logger.hive */ "../../../core/build/core/src/common/logger.hive.js");
var ErrorCodes = __webpack_require__(/*! ../../common/error.hive */ "../../../core/build/core/src/common/error.hive.js");
var P2PRequester = /** @class */ (function () {
    function P2PRequester() {
        this.loggerId = '[P2PRequester] ';
        this.counter = new Utils_1.Counter();
        this.pendingRequests = new HashMap();
        this.transferToIds = new HashMap();
        this.picker = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.PICKER);
    }
    P2PRequester.prototype.init = function (swarm) {
        this.logger = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.LOGGER).log(swarm.sessionId);
        this.objectIndex = swarm.objectIndex;
        this.partnership = swarm.partnership;
        this.hiveCache = swarm.hiveCache;
        this.nodeInfo = swarm.nodeInfo;
        this.snapAccountManager = swarm.snapAccountingManager;
        this.picker.initNodeInfo(swarm.nodeInfo);
    };
    P2PRequester.prototype.request = function (request) {
        this.logger.debug('REQ FOR FRAGMENT ' + request.entityCharacteristics.toString() + '-' + request.requestStats.totalFromP2P + ' [' + EntityType_1.EntityType[request.getEntityType()] + '] TO P2P');
        this.pendingRequests.set(request.getRequestId(), request);
        var transferNum = this.counter.increment();
        request.transferNum = transferNum;
        this.transferToIds.set(transferNum, request.getRequestId());
        this.prepareRequest(request);
    };
    P2PRequester.prototype.prepareRequest = function (request) {
        var entityId = request.getEntityId();
        var requestId = request.getRequestId();
        // We filter the partners that already sent us a have for this entityId based on
        // their existence in our in-partner list
        var partners = this.filterInPartners(entityId);
        request.size = this.objectIndex.getElement(entityId).size;
        var chosen = this.picker.choose(partners, request.type);
        if (chosen != null) {
            this.logger.debug('SELECT ' + chosen.dispatcher.otherGuid +
                ' (LAN LEADER ' + chosen.member.peerInfo.isLeader + ' iAS ' + chosen.member.peerInfo.internalAs +
                ' eAS ' + chosen.member.peerInfo.externalAs + ' privateIp ' + chosen.member.peerInfo.privateIpString + ' ) out of '
                + partners.length + ' type ' + DiscoveryInfo_1.DiscoveryType[chosen.member.peerInfo.type] + ' size:' + request.size + ' FOR TRANSFER' + request.transferNum + ' REQUEST ID ' + requestId);
            request.partner = chosen;
            request.partnerInfo = chosen.member.peerInfo;
            request.partner.newRequest(request.transferNum);
            request.requestStats.p2pRequest = true;
            request.requestStats.p2pRequestStartedTs = Framework_1.Framework.time();
            // We set a request timeout for each p2p request.
            // In case of prefetcher request we use the time doubled
            if (this.setRequestTimeout(request)) {
                request.startAuthentication();
                // We account the P2P request only if we actually proceed with the P2P request.
                this.snapAccountManager.accountP2PRequest(request);
                chosen.dispatcher.receiver.sendRequestInternal(request);
            }
            else {
                // Instead of triggering the requestFailed, we trigger the setRequestAborted.
                // If we use the requestFailed, we will account this P2P as a failure which will
                // reduce the score of this partner, while we didn't even try the P2P.
                request.cancelValidation();
                this.setRequestAborted(request);
            }
        }
        else {
            request.cancelValidation();
            logger_hive_1.ErrorMonitor.getInstance().logError('Error sending p2p request because we cannot find a partner', this.loggerId, ErrorCodes.P2P_REQUESTER_CODES.NO_PARTNER_FOUND);
            this.requestFailed(request.transferNum, 'NO PARTNERS FOUND FOR REQUEST');
        }
    };
    P2PRequester.prototype.filterInPartners = function (entityId) {
        var _this = this;
        var partners = [];
        try {
            var objIdxPartners = this.objectIndex.getPartners(entityId);
            objIdxPartners.forEach(function (partner) {
                if (_this.partnership.isInPartnerById(partner.guid)) {
                    partners.push(partner);
                }
                else {
                    // TODO: WE SHOULD REMOVE HIM FROM THE OBJECT INDEX
                    _this.logger.warn('I HAVE A HAVE FROM A NON IN-PARTNER ' + partner.guid);
                }
            });
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error filtering in partners', this.loggerId, ErrorCodes.P2P_REQUESTER_CODES.FILTER_IN_PARTNERS, error);
        }
        return partners;
    };
    /**
     * The request is aborted because the P2P connection was extremely slow and we don't want to
     * risk the P2P transfer to go to compensation.
     * @param {HiveInternalRequest} request
     */
    P2PRequester.prototype.setRequestAborted = function (request) {
        var transferNum = request.transferNum;
        this.logger.debug('REQUEST ' + request.transferNum + ' TO ' + request.partner.guid + ' ABORTED BECAUSE OF SLOW P2P CONNECTION');
        if (this.transferToIds.has(transferNum)) {
            var requestId = this.transferToIds.get(transferNum);
            this.transferToIds.delete(transferNum);
            var request_1 = this.pendingRequests.get(requestId);
            this.pendingRequests.delete(requestId);
            this.hiveCache.p2pRequestAborted(request_1);
        }
    };
    P2PRequester.prototype.setRequestTimeout = function (request) {
        var _this = this;
        var requestTimeoutInitiated = false;
        try {
            var size = 0;
            if (request.size == null) {
                size = this.objectIndex.getElement(request.getEntityId()).size;
                request.size = size;
                this.logger.warn('request size not set - this should not happen');
            }
            else {
                size = request.size;
            }
            // we have to measure the P2P timer for the remaining fragments in case
            // of P2P Prefetch upgrade
            var leftToDownload = size - request.rcvMesgLength;
            var timeout = request.entityContext.getTimerHandler().getP2PTimeout(request, leftToDownload);
            request.transferTimeout = timeout;
            if (timeout > 0) {
                requestTimeoutInitiated = true;
                if (request.timerId == null) {
                    request.timerId = Framework_1.Framework.setTimeout(function () {
                        _this.verifyTimeout(request);
                    }, timeout);
                }
            }
            return requestTimeoutInitiated;
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error setting request timeout', this.loggerId, ErrorCodes.P2P_REQUESTER_CODES.SET_REQUEST_TIMEOUT, error);
            return false;
        }
    };
    P2PRequester.prototype.verifyTimeout = function (request) {
        this.snapAccountManager.accountP2PRequestExpired(request);
        this.requestFailed(request.transferNum, 'TIMED-OUT');
    };
    P2PRequester.prototype.requestFailed = function (transferNum, reason) {
        var request = this.removeRequest(transferNum, true);
        this.logger.warn('REQUEST ' + transferNum + ' FOR ' + request.getRequestId() + ' FAILED BECAUSE ' + reason);
        if (request) {
            this.hiveCache.p2pRequestFailed(request);
        }
    };
    /**
     * This function removes the request from the P2P logic.
     * This can happen:
     * 1. P2P timeout
     * 2. I received a do not have
     * 3. I received a Not a partner message
     *
     *
     * In all cases we need
     * 1. Delete the request from the hashmaps
     * 2. Clear the timeout if it exists
     *
     * If we have a isATimeout flag true we need to send a message to the
     * P2PResponder to stop sending us more chunks.
     * @param transferNum
     * @param isATimeout
     * @returns {any}
     */
    P2PRequester.prototype.removeRequest = function (transferNum, isATimeout) {
        try {
            if (this.transferToIds.has(transferNum)) {
                var requestId = this.transferToIds.get(transferNum);
                this.transferToIds.delete(transferNum);
                var request = this.pendingRequests.get(requestId);
                this.pendingRequests.delete(requestId);
                Framework_1.Framework.clearTimeout(request.timerId);
                if (isATimeout && this.partnership.isInPartnerById(request.partner.dispatcher.otherGuid)) {
                    request.partner.dispatcher.receiver.stopTransfer(transferNum);
                    var isVideo = request.getEntityType() == EntityType_1.EntityType.VIDEO;
                    if (request.rcvMesgLength != 0) {
                        request.partner.requestPartiallyFailed(request.transferNum, request.rcvMesgLength, request.requestStats.p2pAgenTrafficSuccessQt, request.size, isVideo, request.type);
                    }
                    else {
                        request.partner.requestFailed(request.transferNum, isVideo, request.size);
                    }
                }
                return request;
            }
            else {
                logger_hive_1.ErrorMonitor.getInstance().logError('Error cancelling request on non existing session', this.loggerId, ErrorCodes.P2P_REQUESTER_CODES.CANCEL_ON_NON_EXISTING_SESSION);
                return null;
            }
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error removing request', this.loggerId, ErrorCodes.P2P_REQUESTER_CODES.REMOVE_REQUEST, error);
            return null;
        }
    };
    P2PRequester.prototype.cancelRequest = function (requestId) {
        if (this.pendingRequests.has(requestId)) {
            var transferNum = this.pendingRequests.get(requestId).transferNum;
            this.removeRequest(transferNum, true);
        }
    };
    P2PRequester.prototype.firstResponse = function (otherGuid, request, loaded, length) {
        this.logger.debug('DOWNLOADING ' + request.getRequestId() + ' FROM ' + otherGuid + ' P2P');
    };
    P2PRequester.prototype.fragmentRetrieved = function (transferNum, request) {
        var _this = this;
        request.requestStats.fragmentDownloadedTs = Framework_1.Framework.time();
        request.authenticateResponse().then(function (isAuthentic) {
            if (!isAuthentic) {
                _this.logger.error("RECEIVED FRAGMENT IS NOT AUTHENTIC. REMOVING " + request.partner.guid + " FRAGMENT " + request.getRequestUrl());
                _this.partnership.removePartner(request.partner);
                _this.hiveCache.removeFromCache(request);
                _this.requestFailed(transferNum, 'FAILED TO AUTHENTICATE FRAGMENT');
                return;
            }
            _this.logger.debug('PROMISED FRAGMENT ' + request.getRequestId() + ' RETURNED FROM P2P SIZE ' + request.requestStats.totalFromP2P);
            var pendingRequest = _this.removeRequest(transferNum, false);
            if (pendingRequest) {
                var isVideo = pendingRequest.getEntityType() == EntityType_1.EntityType.VIDEO;
                pendingRequest.partner.requestCompleted(pendingRequest, true, isVideo);
                _this.hiveCache.p2pRequestSuccessful(pendingRequest);
            }
            else {
                _this.logger.warn('TRIED TO REMOVE A NON EXISTING REQUEST ' + transferNum + ' (THIS SHOULD NOT HAPPEN. AT LEAST NOT TOO OFTEN)');
            }
        });
    };
    /**
     * We received a do not have message.
     * 1. We remove the request from the P2P logic.
     * 2. We inform the hivecache that the p2p request failed in order to proceed
     *    with either another p2p request (if P2P_PREFETCH) or fallback
     * @param doNotHave
     */
    P2PRequester.prototype.doNotHaveReceived = function (doNotHave) {
        var transferId = doNotHave.getTransferId();
        if (this.transferToIds.has(transferId)) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error receiving a do not have for my request', this.loggerId, ErrorCodes.P2P_REQUESTER_CODES.DO_NOT_HAVE);
            this.logger.debug('DO NOT HAVE RECEIVED FOR ' + transferId);
            var request = this.removeRequest(transferId, false);
            if (request) {
                var isVideo = request.getEntityType() == EntityType_1.EntityType.VIDEO;
                request.partner.requestFailed(request.transferNum, isVideo, request.size);
                this.hiveCache.p2pRequestFailed(request);
            }
        }
        else {
            this.logger.warn('UNKNOWN DO NOT HAVE ' + transferId);
        }
    };
    /**
     * I sent a request to a partner that he doesn't have me on his out-partner list.
     * So I received a non partner message.
     * 1. I am removing the partner from the partnership
     * 2. I am removing the request from the P2PRequester
     * 3. I am forcing a p2pRequest failed to the hivecache in order to either go to fallback or reset
     *    the request for another p2p_prefetch
     * @param otherGuid
     * @param nonPartnerMsg
     */
    P2PRequester.prototype.requestedToNonPartner = function (otherGuid, nonPartnerMsg) {
        var transferId = nonPartnerMsg.transferId;
        if (this.transferToIds.has(transferId)) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error rejected request by a non partner', this.loggerId, ErrorCodes.P2P_REQUESTER_CODES.REQUESTED_TO_NON_PARTNER);
            // this.logger.debug("REJECTED BY NON PARTNER FOR " + transferId);
            this.partnership.removeInPartner(otherGuid);
            var request = this.removeRequest(transferId, false);
            if (request)
                this.hiveCache.p2pRequestFailed(request);
        }
    };
    P2PRequester.prototype.isPending = function (requestId) {
        return this.pendingRequests.has(requestId);
    };
    return P2PRequester;
}());
exports.P2PRequester = P2PRequester;
//# sourceMappingURL=P2PRequester.js.map

/***/ }),

/***/ "../../../core/build/core/src/webrtc/p2ptransfer/P2PResponder.js":
/*!****************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/webrtc/p2ptransfer/P2PResponder.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.P2PResponder = void 0;
var Framework_1 = __webpack_require__(/*! ../../core/Framework */ "../../../core/build/core/src/core/Framework.js");
var P2PTransport_1 = __webpack_require__(/*! ../transport/P2PTransport */ "../../../core/build/core/src/webrtc/transport/P2PTransport.js");
var logger_hive_1 = __webpack_require__(/*! ../../common/logger.hive */ "../../../core/build/core/src/common/logger.hive.js");
var ErrorCodes = __webpack_require__(/*! ../../common/error.hive */ "../../../core/build/core/src/common/error.hive.js");
var P2PResponder = /** @class */ (function () {
    function P2PResponder() {
        this.loggerId = '[P2PResponder] ';
    }
    P2PResponder.prototype.init = function (swarm) {
        this.logger = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.LOGGER).log(swarm.sessionId);
        this.swarm = swarm;
        this.objectIndex = swarm.objectIndex;
        this.cache = swarm.cache;
        this.partnership = swarm.partnership;
        this.uploadScore = swarm.uploadScore;
        this.nodeInfo = swarm.nodeInfo;
        this.snapAccountManager = swarm.snapAccountingManager;
    };
    /**
     * called by the dispatcher with a p2p fragment request message
     * @param guid
     * @param request
     */
    P2PResponder.prototype.requestReceived = function (guid, request, dispatcher) {
        try {
            if (this.partnership.isOutPartnerById(guid)) {
                var partner = this.partnership.getOutPartnerById(guid);
                this.respondToPeer(guid, request, partner);
            }
            else
                this.sendNoPartners(guid, request, dispatcher);
        }
        catch (e) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error on responding to p2p request', this.loggerId, ErrorCodes.P2P_RESPONDER_CODES.RESPOND_TO_PEER, e);
        }
    };
    P2PResponder.prototype.requestSatisfied = function (partnerId, partnerReportingGuid, total) {
        try {
            this.uploadScore.success(total);
            if (this.partnership.isOutPartnerById(partnerId)) {
                var partner = this.partnership.getOutPartnerById(partnerId);
                partner.scoreUpdaterOut.success(total);
                // var partner = this.partnership.inPartners.get(partnerId)
                partner.responseSuccessAccount(total, partnerReportingGuid);
            }
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error on request satisfied', this.loggerId, ErrorCodes.P2P_RESPONDER_CODES.REQUEST_SATISFIED, error);
        }
    };
    P2PResponder.prototype.requestPartiallySatisfied = function (partnerId, partnerReportingGuid, sent, total) {
        try {
            this.uploadScore.partial(sent, total);
            if (this.partnership.isOutPartnerById(partnerId)) {
                var partner = this.partnership.getOutPartnerById(partnerId);
                partner.scoreUpdaterOut.partial(sent, total);
                partner.responsePartiallyFailedAccount(sent, total, partnerReportingGuid);
            }
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error on request partially satisfied', this.loggerId, ErrorCodes.P2P_RESPONDER_CODES.REQUEST_PARTIALLY_SATISFIED, error);
        }
    };
    P2PResponder.prototype.requestNotSatisfied = function (partnerId, partnerReportingGuid, total) {
        try {
            this.uploadScore.failed();
            if (this.partnership.isOutPartnerById(partnerId)) {
                var partner = this.partnership.getOutPartnerById(partnerId);
                partner.scoreUpdaterOut.failed();
                // var partner = this.partnership.inPartners.get(partnerId)
                partner.responseFailedAccount(total, partnerReportingGuid);
            }
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error on request not satisfied', this.loggerId, ErrorCodes.P2P_RESPONDER_CODES.REQUEST_NOT_SATISFIED, error);
        }
    };
    P2PResponder.prototype.respondToPeer = function (guid, request, partner) {
        var _this = this;
        this.cache.get(request.fragmentId).then(function (fragment) {
            if (fragment) {
                _this.logger.debug('SENDING TRANSFER ' + request.transferId + ' TO ' + guid.substring(0, 8) + ' - FRAGMENT: ' + request.fragmentId + ' SIZE: ' + fragment.length);
                partner.dispatcher.sender.sendFragment(request.fragmentId, request.transferId, fragment.length, fragment.headers, fragment.data);
            }
            else {
                _this.logger.debug('RECEIVED REQUEST FOR ' + request.fragmentId + ' FROM ' + guid + " CAN'T BE SERVED");
                _this.sendDoNotHave(request.transferId, partner);
            }
        });
    };
    P2PResponder.prototype.sendDoNotHave = function (transferId, partner) {
        try {
            this.logger.info('SEND DO NOT HAVE ' + transferId + ' TO ' + partner.dispatcher.myGuid);
            var doNotHave = new P2PTransport_1.P2PTransport.msgBuilder.DoNotHave();
            doNotHave.setTransferId(transferId);
            partner.dispatcher.sendMessage(P2PTransport_1.P2PMsgTypes.DoNotHave, doNotHave);
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error on sending do not have', this.loggerId, ErrorCodes.P2P_RESPONDER_CODES.SEND_DO_NOT_HAVE, error);
        }
    };
    P2PResponder.prototype.sendNoPartners = function (guid, request, dispatcher) {
        try {
            this.logger.warn('GOT REQUEST FROM NON-PARTNER ' + guid + ' FOR ' + request.fragmentId);
            var noPartnerMsg = new P2PTransport_1.P2PTransport.msgBuilder.NoPartners();
            noPartnerMsg.setTransferId(request.transferId);
            dispatcher.sendMessage(P2PTransport_1.P2PMsgTypes.NoPartnerResp, noPartnerMsg);
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error on send no partners', this.loggerId, ErrorCodes.P2P_RESPONDER_CODES.SEND_NO_PARTNERS, error);
        }
    };
    return P2PResponder;
}());
exports.P2PResponder = P2PResponder;
//# sourceMappingURL=P2PResponder.js.map

/***/ }),

/***/ "../../../core/build/core/src/webrtc/p2ptransfer/authentication/FragmentAuthenticator.js":
/*!****************************************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/webrtc/p2ptransfer/authentication/FragmentAuthenticator.js ***!
  \****************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.FragmentAuthenticator = void 0;
var Framework_1 = __webpack_require__(/*! ../../../core/Framework */ "../../../core/build/core/src/core/Framework.js");
var PeerConstants_1 = __webpack_require__(/*! ../../PeerConstants */ "../../../core/build/core/src/webrtc/PeerConstants.js");
var FragmentAuthenticator = /** @class */ (function () {
    function FragmentAuthenticator(playerRequest) {
        this.logger = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.LOGGER).log();
        this.configStore = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.CONFIG_STORE);
        this.playerRequest = playerRequest;
        this.canceled = false;
    }
    FragmentAuthenticator.prototype.request = function () {
        if (!this.disabled()) {
            this.cdnResponse = this.requestValidationBytes();
        }
    };
    /**
     * Fetches the last (by default) 32 bytes of a fragment to compare it to the last 32 bytes
     * received from p2p. The number of bytes is configured in `PeerConstants.FragmentAuthenticator.RANGE`
     *
     * @param size - The total size of the fragment that we are requesting the validation bytes for
     */
    FragmentAuthenticator.prototype.requestValidationBytes = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var request = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.HTTP_REQUEST);
            var _a = _this.playerRequest, url = _a.url, async = _a.async, username = _a.username, password = _a.password;
            // Important! The request has to be opened before setting headers on the request
            request.open('GET', url + '?range', async, username, password);
            request.setRequestHeader('Range', "bytes=-" + PeerConstants_1.PeerConstants.FragmentAuthenticator.RANGE);
            request.responseType = 'arraybuffer';
            // Copy headers and attributes from original request to new XHR
            _this.playerRequest.copyTo(request);
            request.onload = function () {
                if (request.status === PeerConstants_1.PeerConstants.HTTP.RANGE_REQUEST_RESPONSE_CODE) {
                    var response = request.response;
                    if (response.byteLength !== PeerConstants_1.PeerConstants.FragmentAuthenticator.RANGE) {
                        reject("Received wrong length. Length: " + response.byteLength);
                    }
                    else {
                        _this.logger.log('Received Fragment Authentication response');
                        resolve(response);
                    }
                }
                else {
                    FragmentAuthenticator.rangeRequestSupported = false;
                    reject("Received wrong status code. Status code: " + request.status);
                }
            };
            request.onerror = function (error) {
                reject(error);
            };
            request.send();
        });
    };
    /**
     * Authenticates a fragment by comparing the last 32 bytes of the `p2pResponse` to the last 32 bytes fetched from the CDN.
     *
     * Compares the `p2pResponse` to the `cdnResponse`. If they are the same we return true.
     * If we get a response from p2p before we get a response from the CDN we return true
     * If the p2p request was canceled and we compensate we return true
     *
     * @param p2pResponse - The response we have received from P2P
     * @returns - True if the `p2pResponse` === `cdnResponse`
     */
    FragmentAuthenticator.prototype.authenticate = function (p2pResponse) {
        var _this = this;
        return new Promise(function (resolve) {
            // If disabled or the promise was never created return true
            if (_this.disabled() || !_this.cdnResponse)
                return resolve(true);
            // Await the CDN response. If we received it already it will be instant
            _this.cdnResponse.then(function (response) {
                // Slice the p2p resposne and compare the 2 buffers
                var p2pResponseRange = p2pResponse.slice(p2pResponse.byteLength - PeerConstants_1.PeerConstants.FragmentAuthenticator.RANGE);
                var isAuthentic = _this.compareBuffers(response, p2pResponseRange);
                if (!isAuthentic) {
                    // Convert the bytesArray to base64 for printing
                    var p2pResponseRangeBase64 = btoa(String.fromCharCode.apply(null, new Uint8Array(p2pResponseRange)));
                    var responseBase64 = btoa(String.fromCharCode.apply(null, new Uint8Array(response)));
                    _this.logger.error("P2P Validation Bytes: [" + p2pResponseRangeBase64 + "] - CDN Validation Bytes: [" + responseBase64 + "]");
                }
                resolve(isAuthentic);
            }).catch(function (error) {
                _this.logger.log("FragmentAuthentication error " + error);
                resolve(true);
            });
        });
    };
    /**
     * If a p2p request times out we cancel the authentication
     */
    FragmentAuthenticator.prototype.cancel = function () {
        this.logger.debug("CANCELING FRAGMENT AUTHENTICATION FOR " + this.playerRequest.url);
        this.canceled = true;
    };
    /**
     * Compares two ArrayBuffers and returns true if they are the same
     *
     * @param cdnResponse - Response from the CDN
     * @param p2pResponse - Response from p2p
     * @returns - true if both ArrayBuffers are the same
     */
    FragmentAuthenticator.prototype.compareBuffers = function (cdnResponse, p2pResponse) {
        if (p2pResponse.byteLength !== cdnResponse.byteLength)
            return false;
        var p2pArray = new Int8Array(p2pResponse);
        var cdnArray = new Int8Array(cdnResponse);
        for (var i = 0; i < p2pResponse.byteLength; i++) {
            if (p2pArray[i] !== cdnArray[i])
                return false;
        }
        return true;
    };
    FragmentAuthenticator.prototype.disabled = function () {
        return this.canceled || !this.configStore.getConfig('security.fragmentAuthenticationEnabled') || !FragmentAuthenticator.rangeRequestSupported;
    };
    /**
     * If range requests are not supported we would end up downloading entire fragments instead of the last 32 bytes.
     * Therefore, if we download a fragment and receive more than just a range, we set this to false to stop all
     * future requests
     */
    FragmentAuthenticator.rangeRequestSupported = true;
    return FragmentAuthenticator;
}());
exports.FragmentAuthenticator = FragmentAuthenticator;
//# sourceMappingURL=FragmentAuthenticator.js.map

/***/ }),

/***/ "../../../core/build/core/src/webrtc/p2ptransfer/picker/PickerExt.js":
/*!********************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/webrtc/p2ptransfer/picker/PickerExt.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.PickerExt = void 0;
var DiscoveryInfo_1 = __webpack_require__(/*! ../../discovery/DiscoveryInfo */ "../../../core/build/core/src/webrtc/discovery/DiscoveryInfo.js");
var PickerTRSingle_1 = __webpack_require__(/*! ./PickerTRSingle */ "../../../core/build/core/src/webrtc/p2ptransfer/picker/PickerTRSingle.js");
var ErrorCodes = __webpack_require__(/*! ../../../common/error.hive */ "../../../core/build/core/src/common/error.hive.js");
var logger_hive_1 = __webpack_require__(/*! ../../../common/logger.hive */ "../../../core/build/core/src/common/logger.hive.js");
var PeerConstants_1 = __webpack_require__(/*! ../../PeerConstants */ "../../../core/build/core/src/webrtc/PeerConstants.js");
/**
 * this picker extends the normal one by giving preference to LAN, the SITE, and finally all others
 */
var PickerExt = /** @class */ (function (_super) {
    __extends(PickerExt, _super);
    function PickerExt() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    PickerExt.prototype.choose = function (partners, reqType) {
        var lanPartners = [];
        var sitePartners = [];
        var asPartners = [];
        var otherPartners = [];
        try {
            var mySiteId_1 = this.connectivityInfo.getNetworkInfo().getSiteId();
            var myAsId_1 = this.connectivityInfo.getNetworkInfo().getExternalAsId();
            partners.forEach(function (partner) {
                if (partner.member.peerInfo.type == DiscoveryInfo_1.DiscoveryType.UDP) {
                    lanPartners.push(partner);
                }
                var partnerSiteId = partner.member.peerInfo.internalAs;
                if (mySiteId_1 != 0 && mySiteId_1 === partnerSiteId) {
                    sitePartners.push(partner);
                }
                if (PeerConstants_1.PeerConstants.Transport.PICKER_EX_AS_PREFERENCE) {
                    var partnerAsId = partner.member.peerInfo.externalAs;
                    if (myAsId_1 != 0 && myAsId_1 === partnerAsId) {
                        asPartners.push(partner);
                    }
                }
                if (partner.member.peerInfo.type == DiscoveryInfo_1.DiscoveryType.TRACKER) {
                    otherPartners.push(partner);
                }
            });
            if (lanPartners.length > 0) {
                // if (reqType == ReqType.P2P_PREFETCH) {
                //     if (lanPartners.length > 1) {
                //         let leaderPos = -1
                //         for (let i = 0; i < lanPartners.length; i++) {
                //             if (lanPartners[i].guid == this.nodeInfo.getLeader().uuid) {
                //                 leaderPos = i;
                //             }
                //         }
                //
                //         if (leaderPos != -1) {
                //             lanPartners.splice(leaderPos, 1)
                //         }
                //     }
                //
                //     return super.choose(lanPartners, reqType)
                //     // var sorted = super.getPartnersSorted(lanPartners)
                //     // return this.chooseTheBestCandidate(sorted)
                // } else if (this.nodeInfo.haveLanPartners() && (lanPartners.length > 1)) {
                //     let leaderPos = -1
                //     for (let i = 0; i < lanPartners.length; i++) {
                //         if (lanPartners[i].guid == this.nodeInfo.getLeader().uuid) {
                //             leaderPos = i;
                //         }
                //     }
                //
                //     if (leaderPos != -1) {
                //         lanPartners.splice(leaderPos, 1)
                //     }
                //     return super.choose(lanPartners, reqType)
                // } else {
                return _super.prototype.choose.call(this, lanPartners, reqType);
                // }
            }
            else if (sitePartners.length > 0) {
                return _super.prototype.choose.call(this, sitePartners, reqType);
            }
            else if (asPartners.length > 0) {
                return _super.prototype.choose.call(this, asPartners, reqType);
            }
            else {
                return _super.prototype.choose.call(this, otherPartners, reqType);
            }
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error choosing partner for p2p', this.loggerId, ErrorCodes.PICKER_EXT_CODES.CHOOSE_PARTNER, error);
            // We can return null at this point. If something goes wrong then the P2PRequester will not break.
            return null;
        }
    };
    return PickerExt;
}(PickerTRSingle_1.PickerTRSingle));
exports.PickerExt = PickerExt;
//# sourceMappingURL=PickerExt.js.map

/***/ }),

/***/ "../../../core/build/core/src/webrtc/p2ptransfer/picker/PickerTRSingle.js":
/*!*************************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/webrtc/p2ptransfer/picker/PickerTRSingle.js ***!
  \*************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.PickerTRSingle = void 0;
var Framework_1 = __webpack_require__(/*! ../../../core/Framework */ "../../../core/build/core/src/core/Framework.js");
var PeerConstants_1 = __webpack_require__(/*! ../../PeerConstants */ "../../../core/build/core/src/webrtc/PeerConstants.js");
var logger_hive_1 = __webpack_require__(/*! ../../../common/logger.hive */ "../../../core/build/core/src/common/logger.hive.js");
var ErrorCodes = __webpack_require__(/*! ../../../common/error.hive */ "../../../core/build/core/src/common/error.hive.js");
var PickerTRSingle = /** @class */ (function () {
    function PickerTRSingle() {
        this.loggerId = '[PickerTRSingle] ';
        this.logger = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.LOGGER).log();
        this.connectivityInfo = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.PEER_CONNECTIVITY_INFO);
    }
    PickerTRSingle.prototype.initNodeInfo = function (nodeInfo) {
        this.nodeInfo = nodeInfo;
    };
    PickerTRSingle.prototype.choose = function (partners, reqType) {
        var sorted = this.getPartnersSorted(partners);
        if (sorted) {
            // return the first one (best score)
            return sorted[0];
        }
        else {
            return null;
        }
    };
    PickerTRSingle.prototype.getCompositeScore = function (p, trSum) {
        return PeerConstants_1.PeerConstants.Transport.PICKER_ERR_ALPHA * (p.getRcvRatesAvg() / trSum) + PeerConstants_1.PeerConstants.Transport.PICKER_ERR_BETA * (1 - p.getUploadFailureRatio());
    };
    PickerTRSingle.prototype.getPartnersSorted = function (partners) {
        var _this = this;
        try {
            var trSum_1 = 0.1;
            trSum_1 += partners.map(function (partner) {
                return partner.getRcvRatesAvg();
            }).reduce(function (pp, cp) {
                return pp + cp;
            });
            // TODO optimize the comparator?
            var sorted = partners.sort(function (a, b) { return _this.getCompositeScore(b, trSum_1) - _this.getCompositeScore(a, trSum_1); });
            // logging
            var debugArray_1 = [];
            sorted.forEach(function (p) {
                debugArray_1.push(p.guid.substring(0, 8) + ':' + _this.getCompositeScore(p, trSum_1));
            });
            this.logger.debug(this.loggerId + '[' + debugArray_1.join(', ') + ']');
            return sorted;
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error sorting the partners', this.loggerId, ErrorCodes.PICKER_SINGLE_CODES.SORT_PARTNERS, error);
            return null;
        }
    };
    return PickerTRSingle;
}());
exports.PickerTRSingle = PickerTRSingle;
//# sourceMappingURL=PickerTRSingle.js.map

/***/ }),

/***/ "../../../core/build/core/src/webrtc/partnership/BasePartnership.js":
/*!*******************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/webrtc/partnership/BasePartnership.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.BasePartnership = void 0;
var ByteBuffer = __webpack_require__(/*! bytebuffer */ "../../../core/node_modules/bytebuffer/dist/bytebuffer.js");
var HashMap = __webpack_require__(/*! @hivestreaming/collections/map */ "../../../node_modules/@hivestreaming/collections/map.js");
var Framework_1 = __webpack_require__(/*! ../../core/Framework */ "../../../core/build/core/src/core/Framework.js");
var DiscoveryInfo_1 = __webpack_require__(/*! ../discovery/DiscoveryInfo */ "../../../core/build/core/src/webrtc/discovery/DiscoveryInfo.js");
var P2PTransport_1 = __webpack_require__(/*! ../transport/P2PTransport */ "../../../core/build/core/src/webrtc/transport/P2PTransport.js");
var PeerConstants_1 = __webpack_require__(/*! ../PeerConstants */ "../../../core/build/core/src/webrtc/PeerConstants.js");
var logger_hive_1 = __webpack_require__(/*! ../../common/logger.hive */ "../../../core/build/core/src/common/logger.hive.js");
var PartnersAccounting_1 = __webpack_require__(/*! ./PartnersAccounting */ "../../../core/build/core/src/webrtc/partnership/PartnersAccounting.js");
var ErrorCodes = __webpack_require__(/*! ../../common/error.hive */ "../../../core/build/core/src/common/error.hive.js");
/**
 * Base for partnership:
 * - HAVEs logic
 * - PING/PONG initial measurement logic
 * - P2PInfoProvider logic
 */
var BasePartnership = /** @class */ (function () {
    function BasePartnership() {
        this.baseLoggerId = '[PARTNERSHIP] ';
        this.inPartners = new HashMap();
        this.removedInPartnersToReport = new HashMap();
        this.recentlyRemovedPartners = new Set();
        this.outPartners = new HashMap();
        this.logSendHave = false;
        this.logRcvHave = false;
        this.isSendHaves = true;
        this.active = false;
        this.createRandomBufferForPingPong();
        this.tobeRemovedInPartners = [];
    }
    BasePartnership.prototype.init = function (swarm) {
        this.logger = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.LOGGER).log(swarm.sessionId);
        this.connectivityInfo = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.PEER_CONNECTIVITY_INFO);
        this.nodeInfo = swarm.nodeInfo;
        this.cache = swarm.cache;
        this.uploadScore = swarm.uploadScore;
        this.objectIndex = swarm.objectIndex;
        this.statsAccountingManager = swarm.snapAccountingManager;
    };
    BasePartnership.prototype.isOutPartner = function (member) {
        return this.isOutPartnerById(member.peerInfo.guid);
    };
    BasePartnership.prototype.isOutPartnerById = function (peerId) {
        return this.outPartners.has(peerId);
    };
    BasePartnership.prototype.getOutPartnerById = function (peerId) {
        return this.outPartners.get(peerId);
    };
    BasePartnership.prototype.isInPartner = function (member) {
        return this.isInPartnerById(member.peerInfo.guid);
    };
    BasePartnership.prototype.isInPartnerById = function (peerId) {
        return this.inPartners.has(peerId);
    };
    BasePartnership.prototype.getInPartnerById = function (peerId) {
        return this.inPartners.get(peerId);
    };
    /**
     * This function is called when a new out partnership has been established
     * @param remotePeer
     */
    BasePartnership.prototype.sendAllHaves = function (remotePeer) {
        var _this = this;
        try {
            // We want to exclude sending haves to other partners when we are on an android device.
            // TODO: something clever for this. If we keep it like this we maintain some outPartner slots that we don't use at all.
            var amIOnAndroid = this.nodeInfo.amIOnAndroid();
            if (this.isSendHaves && !amIOnAndroid) {
                if (this.isOutPartnerById(remotePeer)) {
                    var partner_1 = this.getOutPartnerById(remotePeer);
                    var failureScore_1 = this.uploadScore.getFailureScore(false);
                    var haves_1 = [];
                    this.cache.getElements().then(function (ids) {
                        _this.logger.debug(_this.baseLoggerId + 'SEND ALL HAVES ' + ids.length + ' TO ' + remotePeer);
                        for (var i = 0; i < ids.length; i++) {
                            var size = 0;
                            // TODO: optimize this
                            if (_this.context.hasBeenLive()) {
                                size = ids[i].size();
                            }
                            else {
                                size = ids[i].totalSize;
                            }
                            var entityCharacteristics = ids[i].entityCharacteristics;
                            var have = new P2PTransport_1.P2PTransport.msgBuilder.Have();
                            have.setFragmentId(entityCharacteristics.getEntityId());
                            have.setSize(size);
                            have.setUploadScore(failureScore_1);
                            var videoChars = entityCharacteristics;
                            have.setId(videoChars.getSegmentId());
                            var qualityLevel = new P2PTransport_1.P2PTransport.msgBuilder.QualityLevel();
                            qualityLevel.id = videoChars.getQualityLevel().id;
                            qualityLevel.bitrate = videoChars.getQualityLevel().bitrate;
                            have.setQualityLevel(qualityLevel);
                            have.setDuration(videoChars.getDuration());
                            have.setType(videoChars.getEntityType());
                            haves_1.push(have);
                        }
                        if (haves_1.length > 0) {
                            var batchHaves = new P2PTransport_1.P2PTransport.msgBuilder.Haves();
                            batchHaves.setHave(haves_1);
                            partner_1.dispatcher.sendMessage(P2PTransport_1.P2PMsgTypes.Haves, batchHaves);
                        }
                    });
                }
                else {
                    logger_hive_1.ErrorMonitor.getInstance().logError('Error sending all haves to peer who is not out partner', this.baseLoggerId, ErrorCodes.BASE_PARTNERSHIP_CODES.NO_OUT_PARTNER, {
                        otherGuid: remotePeer
                    });
                }
            }
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error sending all haves', this.baseLoggerId, ErrorCodes.BASE_PARTNERSHIP_CODES.SEND_ALL_HAVES, {
                detailedError: error,
                otherGuid: remotePeer
            });
        }
    };
    /**
     * This function is used by the HiveCache when we want to advertise a have for a newly downloaded fragment to all of our partners.
     * If the receivedHavePartner is specified, means that we downloaded the fragment from him, so we can skip from sending it to him
     * (as a prefetcher optimization)
     *
     * @param entityCharacteristics
     * @param size
     * @param receivedHavePartner
     */
    BasePartnership.prototype.sendHaves = function (entityCharacteristics, size, receivedHavePartner) {
        var _this = this;
        // We want to exclude sending haves to other partners when we are on an android device.
        // TODO: something clever for this. If we keep it like this we maintain some outPartner slots that we don't use at all.
        var amIOnAndroid = this.nodeInfo.amIOnAndroid();
        if (this.isSendHaves && !amIOnAndroid) {
            // we send with the haves our historic upload score
            var failureScore_2 = this.uploadScore.getFailureScore(false);
            this.outPartners.values().forEach(function (partner) {
                if (!receivedHavePartner || (receivedHavePartner && (partner.guid != receivedHavePartner.guid))) {
                    _this.sendHave(partner.dispatcher, entityCharacteristics, size, failureScore_2);
                }
            });
        }
    };
    BasePartnership.prototype.sendHave = function (dispatcher, entityCharacteristics, size, failureScore) {
        if (this.logSendHave) {
            this.logger.debug(this.baseLoggerId + 'SEND HAVE TO ' + dispatcher.otherGuid + ' FOR ' + entityCharacteristics.getEntityId());
        }
        try {
            var have = new P2PTransport_1.P2PTransport.msgBuilder.Have();
            have.setFragmentId(entityCharacteristics.getEntityId());
            have.setSize(size);
            have.setUploadScore(failureScore);
            var videoChars = entityCharacteristics;
            have.setId(videoChars.getSegmentId());
            var qualityLevel = new P2PTransport_1.P2PTransport.msgBuilder.QualityLevel();
            qualityLevel.id = videoChars.getQualityLevel().id;
            qualityLevel.bitrate = videoChars.getQualityLevel().bitrate;
            have.setQualityLevel(qualityLevel);
            have.setDuration(videoChars.getDuration());
            have.setType(videoChars.getEntityType());
            dispatcher.sendMessage(P2PTransport_1.P2PMsgTypes.Have, have);
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error sending have', this.baseLoggerId, ErrorCodes.BASE_PARTNERSHIP_CODES.SEND_HAVE, {
                detailedError: error,
                otherGuid: dispatcher.otherGuid
            });
        }
    };
    BasePartnership.prototype.haveReceived = function (guid, have) {
        try {
            if (this.isInPartnerById(guid)) {
                if (this.logRcvHave) {
                    this.logger.debug(this.baseLoggerId + 'HAVE RECEIVED FROM ' + guid + ': ' + have.fragmentId);
                }
                var partner = this.getInPartnerById(guid);
                partner.setUploadFailureRatio(have.getUploadScore());
                this.objectIndex.put(have, partner);
                this.context.gotHave(have);
            }
            else {
                logger_hive_1.ErrorMonitor.getInstance().logError('Error receiving have from unknown peer', this.baseLoggerId, ErrorCodes.BASE_PARTNERSHIP_CODES.UNKNOWN_HAVE, {
                    otherGuid: guid
                });
            }
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error handling received have', this.baseLoggerId, ErrorCodes.BASE_PARTNERSHIP_CODES.RECEIVED_HAVE, {
                detailedError: error,
                otherGuid: guid
            });
        }
    };
    BasePartnership.prototype.havesReceived = function (guid, haves) {
        var _this = this;
        try {
            if (this.isInPartnerById(guid)) {
                if (this.logRcvHave) {
                    this.logger.debug(this.baseLoggerId + 'BATCH HAVES RECEIVED FROM ' + guid);
                }
                var partner_2 = this.getInPartnerById(guid);
                haves.getHave().forEach(function (have) {
                    partner_2.setUploadFailureRatio(have.getUploadScore());
                    _this.objectIndex.put(have, partner_2);
                });
                this.context.gotHave(haves.getHave()[0]);
            }
            else {
                logger_hive_1.ErrorMonitor.getInstance().logError('Error receiving haves from unknown peer', this.baseLoggerId, ErrorCodes.BASE_PARTNERSHIP_CODES.UNKNOWN_HAVES, {
                    otherGuid: guid
                });
            }
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error handling received haves', this.baseLoggerId, ErrorCodes.BASE_PARTNERSHIP_CODES.RECEIVED_HAVES, {
                detailedError: error,
                otherGuid: guid
            });
        }
    };
    /*
     * -------------------------------------------------------------------------------
     * Ping pong logic - functions for the evaluation of the speed connection between
     * me and the other peer
     * -------------------------------------------------------------------------------
     */
    /**
     * Send a ping request to the in-partner passing the starting timestamp
     * This timestamp should be received back and used for
     * the evaluation of the speed.
     * @param dispatcher
     */
    BasePartnership.prototype.sendPingRequest = function (dispatcher) {
        try {
            var msg = new P2PTransport_1.P2PTransport.msgBuilder.Ping();
            msg.id = this.nodeInfo.getId();
            msg.startTs = Framework_1.Framework.time();
            dispatcher.sendMessage(P2PTransport_1.P2PMsgTypes.Ping, msg);
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error requesting ping', this.baseLoggerId, ErrorCodes.BASE_PARTNERSHIP_CODES.REQUEST_PING, {
                detailedError: error,
                otherGuid: dispatcher.otherGuid
            });
        }
    };
    /**
     * The in partner received the ping request.
     * First it checks if he already contains a connection with
     * the out-partner requester.
     * Then it checks if the startTs is included.
     * Finally it constructs and sends the pong message
     * @param pingMsg
     */
    BasePartnership.prototype.receivePingRequest = function (pingMsg) {
        try {
            var otherGuid = pingMsg.id;
            if (!this.isOutPartnerById(otherGuid)) {
                logger_hive_1.ErrorMonitor.getInstance().logError('Error receiving ping from an unknown peer', this.baseLoggerId, ErrorCodes.BASE_PARTNERSHIP_CODES.UNKNOWN_PING, {
                    otherGuid: otherGuid
                });
                return;
            }
            var startTs = -1;
            if (pingMsg.startTs) {
                startTs = pingMsg.startTs;
            }
            this.sendPongMessage(this.getOutPartnerById(otherGuid).dispatcher, startTs);
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error handling received ping', this.baseLoggerId, ErrorCodes.BASE_PARTNERSHIP_CODES.RECEIVED_PING, {
                detailedError: error,
                otherGuid: pingMsg.id
            });
        }
    };
    /**
     * We create a random buffer that is used for the ping pong
     * functionality.
     * This is usually called once by the Partnership constructor and
     * the generated bytebuffer is stored in the pingPongBuffer.
     */
    BasePartnership.prototype.createRandomBufferForPingPong = function () {
        try {
            var result = '';
            for (var i = 0; i < PeerConstants_1.PeerConstants.Transport.ChunkSize; i++) {
                // Visible ASCII chars are between 33 and 126.
                result += String.fromCharCode(33 + Math.random() * 93);
            }
            var buf = new ArrayBuffer(result.length);
            var tmpBuffer = new Uint8Array(buf);
            var strLen = result.length;
            for (var i = 0; i < strLen; i++) {
                tmpBuffer[i] = result.charCodeAt(i);
            }
            this.pingPongBuffer = ByteBuffer.wrap(tmpBuffer);
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error creating random buffer for ping pong', this.logger, ErrorCodes.BASE_PARTNERSHIP_CODES.CREATE_RANDOM_BUFFER, error);
        }
    };
    /**
     * The out-partner sends back a pong message including the startTs
     * that he received from his out-partner.
     * If he doesn't find the pingPongbuffer set, he creates a
     * chunk on the fly.
     * @param dispatcher
     * @param startTs
     */
    BasePartnership.prototype.sendPongMessage = function (dispatcher, startTs) {
        try {
            var pongMsg = new P2PTransport_1.P2PTransport.msgBuilder.Pong();
            pongMsg.id = this.nodeInfo.getId();
            pongMsg.startTs = startTs;
            if (!this.pingPongBuffer) {
                this.createRandomBufferForPingPong();
            }
            pongMsg.data = this.pingPongBuffer;
            pongMsg.dataSize = PeerConstants_1.PeerConstants.Transport.ChunkSize;
            this.logger.debug(this.baseLoggerId + 'SEND PONG TO PEER GUID ' + dispatcher.otherGuid);
            dispatcher.sendMessage(P2PTransport_1.P2PMsgTypes.Pong, pongMsg);
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error sending pong', this.baseLoggerId, ErrorCodes.BASE_PARTNERSHIP_CODES.SEND_PONG, {
                detailedError: error,
                otherGuid: dispatcher.otherGuid
            });
        }
    };
    /**
     * I received a pong message from my in-partner.
     * First we check if we still have partnership with this peer.
     * Then we check if we received the proper startTs. This must be defined
     * and bigger than 0
     * Finally we update the receiving rate time period based on the reported dataSize
     *
     * @param pongMessage
     */
    BasePartnership.prototype.receivePong = function (pongMessage) {
        try {
            var otherGuid = pongMessage.id;
            if (!this.isInPartnerById(otherGuid)) {
                logger_hive_1.ErrorMonitor.getInstance().logError('Error receiving a pong from an unknown peer', this.baseLoggerId, ErrorCodes.BASE_PARTNERSHIP_CODES.UNKOWN_PONG, {
                    otherGuid: otherGuid
                });
                return;
            }
            var receivedTs = Framework_1.Framework.time();
            if (pongMessage.startTs && (pongMessage.startTs > 0)) {
                var totalTime = receivedTs - pongMessage.startTs;
                var partner = this.getInPartnerById(otherGuid);
                if (pongMessage.dataSize == pongMessage.data.toArrayBuffer().byteLength) {
                    partner.updateReceivingRateTimePeriod(pongMessage.dataSize, totalTime, true);
                }
                else {
                    logger_hive_1.ErrorMonitor.getInstance().logError('Error receing pong with wrong data size', this.baseLoggerId, ErrorCodes.BASE_PARTNERSHIP_CODES.WRONG_PONG_SIZE, {
                        otherGuid: otherGuid
                    });
                }
            }
            else {
                logger_hive_1.ErrorMonitor.getInstance().logError('Error receiving pong with wrong timestamp', this.baseLoggerId, ErrorCodes.BASE_PARTNERSHIP_CODES.WRONG_TIMESTAMP, {
                    otherGuid: otherGuid
                });
            }
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error receiving pong', this.baseLoggerId, ErrorCodes.BASE_PARTNERSHIP_CODES.RECEIVED_PONG, {
                detailedError: error,
                otherGuid: pongMessage.id
            });
        }
    };
    /**
     * This function collect the partnership snapshots
     * @returns {HashMap<string, hive.snapshots.Partner>}
     */
    BasePartnership.prototype.getPartnerSnapshots = function () {
        try {
            var snapshots = new HashMap();
            this.collectPartnerSnapshots(this.inPartners, snapshots);
            return snapshots;
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error getting partner snapshots', this.baseLoggerId, ErrorCodes.BASE_PARTNERSHIP_CODES.COLLECT_PARTNER_SNAPSHOTS, error);
            return new HashMap();
        }
    };
    /**
     * This function parses each partner and sets the partner snapshot to the snapshots hashmap
     * @param partnerMap
     * @param snapshots
     */
    BasePartnership.prototype.collectPartnerSnapshots = function (partnerMap, snapshots) {
        var _this = this;
        partnerMap.forEach(function (partner, guid) {
            var partnerSnap = new hive.snapshots.Partner();
            partnerSnap.inPart = true;
            partnerSnap.outPart = _this.isOutPartnerById(guid);
            partnerSnap.connInfo = new hive.snapshots.ConnectivityInfo();
            var publicIp = undefined;
            if (partner.member.peerInfo.publicIpString) {
                publicIp = partner.member.peerInfo.publicIpString;
            }
            var privateIp = undefined;
            if (partner.member.peerInfo.privateIpString) {
                privateIp = partner.member.peerInfo.privateIpString;
            }
            partnerSnap.connInfo.publicIp = publicIp;
            partnerSnap.connInfo.privateIp = privateIp;
            partnerSnap.connInfo.externalAs = partner.member.peerInfo.externalAs;
            partnerSnap.connInfo.internalAs = partner.member.peerInfo.internalAs;
            partnerSnap.connInfo.isVpn = partner.member.peerInfo.isVpn;
            var metrics = _this.initializePartnerMetrics();
            metrics.rateReceived = partner.getRcvRatesAvg();
            partnerSnap.metrics = metrics;
            // By default the handshake delay is set to -1. If it's still -1, do not include it in the metrics
            if (partner.getHandshakeDelay() != -1) {
                partnerSnap.metrics.handshakeDelay = partner.getHandshakeDelay();
            }
            partnerSnap.udp = partner.member.peerInfo.type == DiscoveryInfo_1.DiscoveryType.UDP;
            snapshots.set(partner.reportingGuid, partnerSnap);
        });
    };
    BasePartnership.prototype.getPartnerInfo = function () {
        return new PartnersAccounting_1.PartnersAccounting(this.inPartners.length, this.outPartners.length);
    };
    /**
     * initialize the partner metrics to 0 in order not to have null on metric snapshots
     * @returns {hive.snapshots.PartnerMetrics}
     */
    BasePartnership.prototype.initializePartnerMetrics = function () {
        var metrics = new hive.snapshots.PartnerMetrics();
        metrics.rateReceived = 0;
        metrics.rateSent = 0;
        metrics.handshakeDelay = 0;
        return metrics;
    };
    /**
     * Keeps track of in partners that are removed so we can report
     * them properly in the next snapshot
     *
     * @param guid guid of the in partner that was removed
     * @param partner partner that was removed
     */
    BasePartnership.prototype.trackRemovedPartner = function (guid, partner) {
        var _this = this;
        // add the guid to the blocked partners set and remove it after the quarantine has elapsed
        this.recentlyRemovedPartners.add(guid);
        Framework_1.Framework.setTimeout(function () { return _this.removedFromBlockedPartners(guid); }, PeerConstants_1.PeerConstants.PartnershipConstants.PARTNERSHIP_QUARANTINE_TIME_MS);
        this.removedInPartnersToReport.set(guid, partner);
    };
    BasePartnership.prototype.removedFromBlockedPartners = function (guid) {
        this.recentlyRemovedPartners.delete(guid);
    };
    /**
     * This function collects partnership snapshots for peers that have been removed (disconnected)
     * @returns {HashMap<string, hive.snapshots.Partner>}
     */
    BasePartnership.prototype.getAndResetRemovedPartnerSnapshots = function () {
        try {
            var snapshots = new HashMap();
            this.collectPartnerSnapshots(this.removedInPartnersToReport, snapshots);
            this.removedInPartnersToReport.clear();
            return snapshots;
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error getting removed partner snapshots', this.baseLoggerId, ErrorCodes.BASE_PARTNERSHIP_CODES.COLLECT_PARTNER_SNAPSHOTS, error);
            return new HashMap();
        }
    };
    return BasePartnership;
}());
exports.BasePartnership = BasePartnership;
//# sourceMappingURL=BasePartnership.js.map

/***/ }),

/***/ "../../../core/build/core/src/webrtc/partnership/InPartnerUpdate.js":
/*!*******************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/webrtc/partnership/InPartnerUpdate.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.InPartnerUpdate = void 0;
var InPartnerUpdate = /** @class */ (function () {
    function InPartnerUpdate(toAdd, toRemove) {
        this.toAdd = toAdd;
        this.toRemove = toRemove;
    }
    InPartnerUpdate.prototype.getPartnersToRemove = function () {
        return this.toRemove;
    };
    InPartnerUpdate.prototype.getMembersToAdd = function () {
        return this.toAdd;
    };
    return InPartnerUpdate;
}());
exports.InPartnerUpdate = InPartnerUpdate;
//# sourceMappingURL=InPartnerUpdate.js.map

/***/ }),

/***/ "../../../core/build/core/src/webrtc/partnership/IpSpoofing.js":
/*!**************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/webrtc/partnership/IpSpoofing.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.IpSpoofing = void 0;
var HashMap = __webpack_require__(/*! @hivestreaming/collections/map */ "../../../node_modules/@hivestreaming/collections/map.js");
var PeerConstants_1 = __webpack_require__(/*! ../PeerConstants */ "../../../core/build/core/src/webrtc/PeerConstants.js");
var Framework_1 = __webpack_require__(/*! ../../core/Framework */ "../../../core/build/core/src/core/Framework.js");
var ErrorCodes = __webpack_require__(/*! ../../common/error.hive */ "../../../core/build/core/src/common/error.hive.js");
var logger_hive_1 = __webpack_require__(/*! ../../common/logger.hive */ "../../../core/build/core/src/common/logger.hive.js");
var IpSpoofing = /** @class */ (function () {
    function IpSpoofing() {
        this.loggerId = '[IPSpoofing] ';
        this.spoofingEnabled = PeerConstants_1.PeerConstants.IpSpoofing.ENABLED;
    }
    IpSpoofing.prototype.init = function (swarm) {
        this.logger = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.LOGGER).log(swarm.sessionId);
        this.partnership = swarm.partnership;
        this.guidToIpPair = new HashMap();
        this.ipPairToGuidList = new HashMap();
        if (this.spoofingEnabled) {
            // We initiate a periodic check that the ip spoofing rules are not violated
            this.startPeriodicIpSpoofingCheck();
        }
    };
    /**
     * This function reports if the ip spoofing rules are violated.
     * First we check if we already know this guid. If yes, then we don't violate anything.
     * Then we create a pair hash based on the peer's private and the public ip. If public ip is not
     * currently available we create a hash based on the private ip only.
     * If the pairhash is not null and we have prior info about this hash, we check the number of
     * guids that previously reported this pairhash. If the number of guids exceed the defined threshold
     * then we respond that the rule has been violated.
     * @param guid
     * @param privateIp
     * @param publicIp
     * @returns {boolean}
     */
    IpSpoofing.prototype.violatesSpoofingRules = function (guid, privateIp, publicIp) {
        try {
            if (!this.spoofingEnabled)
                return false;
            if (this.guidToIpPair.has(guid) || !privateIp || !publicIp) {
                return false;
            }
            var pairHash = this.createPairHash(privateIp, publicIp);
            if (pairHash && this.ipPairToGuidList.has(pairHash)) {
                var guidList = this.ipPairToGuidList.get(pairHash);
                if (guidList.length >= PeerConstants_1.PeerConstants.IpSpoofing.MAX_NUMBER_OF_PARTNERS) {
                    logger_hive_1.ErrorMonitor.getInstance().logError('Error peer violates ip spoofing rules', this.loggerId, ErrorCodes.IP_SPOOFING_CODES.VIOLATE_SPOOFING_RULES, {
                        privateIp: privateIp,
                        publicIp: publicIp,
                        otherGuid: guid
                    });
                    this.logger.debug(this.loggerId + 'Spoofing rule violated for ' + guid + ' with privateIp ' + privateIp + ' publicIp ' + publicIp);
                    return true;
                }
            }
            return false;
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error checking if peer violates ip spoofing rules', this.loggerId, ErrorCodes.IP_SPOOFING_CODES.VIOLATE_SPOOFING_HANDLER, {
                detailedError: error,
                otherGuid: guid
            });
            return false;
        }
    };
    /**
     * This function is called by the partnership when either a new partnership has been established
     * or we have received a peerInfo message from one of our currently existing partners.
     * First we create a pairHash. Then we check if we already have knowledge for this guid but with a different hash.
     * This could happen when we establish a connection based on a udp message. The peer initially managed to establish a connection
     * with me without even knowing his public ip. A few seconds later, the tracker responded and he published his new information.
     * Therefore we clear the guid list based on the previous hash and add the peer with the new hash
     * @param guid
     * @param privateIp
     * @param publicIp
     */
    IpSpoofing.prototype.addOrUpdateToSpoofingMaps = function (guid, privateIp, publicIp) {
        try {
            // don't add if we don't know public or private ip
            if (this.spoofingEnabled && publicIp && privateIp) {
                var pairHash = this.createPairHash(privateIp, publicIp);
                var previousPairHash = this.guidToIpPair.get(guid);
                if (previousPairHash && (previousPairHash != pairHash)) {
                    this.clearGuidList(guid, previousPairHash);
                }
                this.addPeer(guid, pairHash);
            }
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error adding or updating ip spoofing maps', this.loggerId, ErrorCodes.IP_SPOOFING_CODES.ADD_OR_UPDATE_SPOOFING_MAPS, {
                detailedError: error,
                otherGuid: guid
            });
        }
    };
    IpSpoofing.prototype.removeFromSpoofingMaps = function (guid) {
        if (this.spoofingEnabled)
            this.removePeer(guid);
    };
    IpSpoofing.prototype.peerDisconnected = function (guid) {
        if (this.spoofingEnabled)
            this.removePeer(guid);
    };
    /**
     * In this function we add the peer guid to the guidToIpPair map and the ipPairToGuidList.
     * First we set the guid with it's pairHash to the guidToIpPair.
     * Then we check if we already have this guid to the proper guid list.
     * If the guid is not in the proper guidList we set it.
     * @param guid
     * @param pairHash
     */
    IpSpoofing.prototype.addPeer = function (guid, pairHash) {
        this.guidToIpPair.set(guid, pairHash);
        var guidList = [];
        if (this.ipPairToGuidList.has(pairHash)) {
            guidList = this.ipPairToGuidList.get(pairHash);
            if (guidList.indexOf(guid) != -1) {
                return;
            }
        }
        guidList.push(guid);
        this.ipPairToGuidList.set(pairHash, guidList);
    };
    IpSpoofing.prototype.removePeer = function (guid) {
        var pair = this.guidToIpPair.get(guid);
        if (pair) {
            this.clearGuidList(guid, pair);
            this.guidToIpPair.delete(guid);
        }
    };
    /**
     * In this function we remove the guid from the guidList assigned to the key pair.
     * If the guidList is empty after the removal, we completely delete the mapping
     * @param guid
     * @param pair
     */
    IpSpoofing.prototype.clearGuidList = function (guid, pair) {
        var guidList = this.ipPairToGuidList.get(pair);
        var indexId = guidList.indexOf(guid);
        if (indexId != -1) {
            guidList.splice(indexId, 1);
            if (guidList.length == 0)
                this.ipPairToGuidList.delete(pair);
            else {
                this.ipPairToGuidList.set(guid, guidList);
            }
        }
        else {
            this.logger.warn(this.loggerId + 'pair list ' + pair + ' does not contain guid ' + guid);
        }
    };
    /**
     * In this function we create a hash value based on the privateIp and the public ip if it exists
     * @param privateIp
     * @param publicIp
     * @returns {string}
     */
    IpSpoofing.prototype.createPairHash = function (privateIp, publicIp) {
        // no read need to have hash it like this
        // let hash = CryptoJS.SHA1(privateIp + publicIp);
        // return hash.toString(CryptoJS.enc.Hex);
        // simple string, easier to debug
        return publicIp + ':' + privateIp;
    };
    /**
     * In this function we periodically check the size of the guidlist assigned to each pair hash.
     * If there is a guidList that exceeds the threshold, we keep the guids that exceed the threshold
     * and we close the connection using the partnership.
     * Finally we remove the peer from our lists.
     */
    IpSpoofing.prototype.startPeriodicIpSpoofingCheck = function () {
        var _this = this;
        Framework_1.Framework.setInterval(function () {
            try {
                var guidsToDisconnect_1 = [];
                _this.ipPairToGuidList.forEach(function (guidList, pairHash) {
                    if (guidList.length > PeerConstants_1.PeerConstants.IpSpoofing.MAX_NUMBER_OF_PARTNERS) {
                        var pairToDisconnect = [];
                        for (var i = PeerConstants_1.PeerConstants.IpSpoofing.MAX_NUMBER_OF_PARTNERS; i < guidList.length; i++) {
                            pairToDisconnect.push(guidList[i]);
                        }
                        _this.logger.warn('IpSpoofing violation for ' + pairHash + ' - closing: ' + pairToDisconnect);
                        guidsToDisconnect_1.concat(pairToDisconnect);
                    }
                });
                guidsToDisconnect_1.forEach(function (guid) {
                    _this.partnership.closeConnection(guid);
                });
            }
            catch (error) {
                logger_hive_1.ErrorMonitor.getInstance().logError('Error checking periodic ip spoofing tables', _this.loggerId, ErrorCodes.IP_SPOOFING_CODES.PERIODIC_CHECK_IP_SPOOFING, error);
            }
        }, PeerConstants_1.PeerConstants.IpSpoofing.IP_SPOOFING_VIOLATION_INTERVAL);
    };
    return IpSpoofing;
}());
exports.IpSpoofing = IpSpoofing;
//# sourceMappingURL=IpSpoofing.js.map

/***/ }),

/***/ "../../../core/build/core/src/webrtc/partnership/Partner.js":
/*!***********************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/webrtc/partnership/Partner.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Partner = void 0;
var HashMap = __webpack_require__(/*! @hivestreaming/collections/map */ "../../../node_modules/@hivestreaming/collections/map.js");
var Framework_1 = __webpack_require__(/*! ../../core/Framework */ "../../../core/build/core/src/core/Framework.js");
var PeerConstants_1 = __webpack_require__(/*! ../PeerConstants */ "../../../core/build/core/src/webrtc/PeerConstants.js");
var ErrorCodes = __webpack_require__(/*! ../../common/error.hive */ "../../../core/build/core/src/common/error.hive.js");
var logger_hive_1 = __webpack_require__(/*! ../../common/logger.hive */ "../../../core/build/core/src/common/logger.hive.js");
var Partner = /** @class */ (function () {
    function Partner(guid, snapAccountManager, dispatcher, logger, inPartner, member, handshakeStartedTs) {
        this.loggerId = '[Partner] ';
        // TODO: These properties could be removed. But we can keep them to do clever things in the future if needed.
        this.cumulativeReceivedAmount = 0;
        this.cumulativeReceivedTime = 0;
        this.failureUploadScore = 0;
        this.receiveRates = new Array();
        // TODO: Track sent rates .This is going to be used in the future. Keep it here
        this.sentRates = new Array();
        this.pendingRequests = new HashMap();
        this.handshakeDelay = -1;
        this.logger = logger;
        this.dispatcher = dispatcher;
        this.guid = guid;
        this.member = member;
        this.inPartner = inPartner;
        this.snapAccountManager = snapAccountManager;
        this.scoreUpdaterIn = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.SCORE_UPDATER);
        this.scoreUpdaterOut = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.SCORE_UPDATER);
        this.partnershipStartedTs = Framework_1.Framework.time();
        // We calculate the handshake only for the inPartners and not for the outPartners.
        // TODO: fix it in the new versions and split the delays to network latency (webRTC) and application latency (Partnership Request/Response)
        if (handshakeStartedTs)
            this.calculateHandshakeDelay(handshakeStartedTs);
    }
    /**
     * update the partner reporting guid to the dispatchers
     * @param reportingGuid
     */
    Partner.prototype.updateReportingGuid = function (reportingGuid) {
        this.reportingGuid = reportingGuid;
        if (this.dispatcher) {
            this.dispatcher.receiver.setReportingGuid(this.reportingGuid);
            this.dispatcher.sender.setReportingGuid(this.reportingGuid);
        }
    };
    /**
     * This function updates the statistics that we have for this partner based on the received data and the total time that took us to download them
     * The receiveRates is primarily used by the picker in order to calculate the composition of each partner.
     * This function is used when one of the three following tasks happen:
     * 1. The P2PRequest is completed and we downloaded all the fragment. (Partner.requestCompleted)
     * 2. The P2PRequest failed and we didn't receive not even a single byte from this partner (Partner.requestFailed)
     * 3. The P2PRequest partially failed. We managed to download some chunks from the partner but then either we used the CDN_Compensation
     *    or we had a network issue (Partner.requestPartiallyFailed)
     * @param receivedAmount
     * @param elapsedPeriod
     * @param account
     */
    Partner.prototype.updateReceivingRateTimePeriod = function (receivedAmount, elapsedPeriod, account) {
        // Overall rate towards the peer
        // reqNumber++;
        var elapsedTime = Math.max(1, elapsedPeriod);
        if (account) {
            this.cumulativeReceivedTime += elapsedTime;
            this.cumulativeReceivedAmount += receivedAmount;
        }
        while (this.receiveRates.length > PeerConstants_1.PeerConstants.PerfMetrics.NUM_HISTORIC_UPDATES) {
            this.receiveRates.pop();
        }
        var receiveRate = receivedAmount / elapsedTime;
        this.receiveRates.unshift(receiveRate);
    };
    /**
     * This function is called by the P2PRequester.sendRequest
     * it sets the transferNum to the pendingRequests and assigns the current timestamp as value.
     * The timestamp is afterwards used to calculate the total time required to retrieve a full fragment
     * and the bandwidth of the Partner.
     * @param requestNum
     */
    Partner.prototype.newRequest = function (requestNum) {
        // this.logger.debug("PRT REQ SETTING " + requestNum)
        if (!this.pendingRequests.has(requestNum)) {
            this.pendingRequests.set(requestNum, Framework_1.Framework.time());
        }
        else {
            this.logger.warn(this.guid + ' DUPLICATE {} PENDING REQUESTS ' + requestNum);
        }
    };
    /**
     * This function is called by the P2PRequester.fragmentRetrieved
     * --- First it checks if the the received request is still pending or it compensated
     * --- If we didn't componesate, we retrieve the timestamp when the request started, calculate the elapsed time and delete the request
     *     from the pendingRequests.
     * --- Then we update the receiving rate time period based on the received amount and the elapsed time
     * --- Finally we increase the traffic stats of the partner.
     * @param requestNum
     * @param receivedAmount
     * @param updateRate
     * @param isVideo
     */
    Partner.prototype.requestCompleted = function (request, updateRate, isVideo) {
        try {
            // this.logger.debug("PRT REQ FINISHING " + requestNum)
            var transferNum = request.transferNum, size = request.size, type = request.type;
            var _a = request.requestStats, p2pAgenTrafficSuccessQt = _a.p2pAgenTrafficSuccessQt, fragmentDownloadedTs = _a.fragmentDownloadedTs;
            if (this.pendingRequests.has(transferNum)) {
                var started = this.pendingRequests.get(transferNum);
                var elapsedPeriod = fragmentDownloadedTs - started;
                this.pendingRequests.delete(transferNum);
                // only update receiving rate on video fragments
                if (updateRate && isVideo) {
                    this.updateReceivingRateTimePeriod(size, elapsedPeriod, true);
                }
                // this.logger.debug(this.guid + " REM C " + requestNum)
                // if (updateRate || CacheConstants.SCORE_PARTNER_USE_AUDIO)
                //    scoreUpdaterIn.success((int)
                // receivedAmount
                // )
                // We need to update his score updater in for both audio and video
                // This is important accounting for partnership
                this.scoreUpdaterIn.success(size);
                this.snapAccountManager.accountPartnerRequestCompleted(this.reportingGuid, size, p2pAgenTrafficSuccessQt, isVideo, type);
            }
            else {
                logger_hive_1.ErrorMonitor.getInstance().logError('Error completing a non-existing request', this.loggerId, ErrorCodes.PARTNER_CODES.REQUEST_NOT_EXISTING_COMPLETED, {
                    otherGuid: this.guid,
                    otherReportingGuid: this.reportingGuid
                });
            }
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error handling request completed', this.loggerId, ErrorCodes.PARTNER_CODES.REQUEST_COMPLETED, {
                detailedError: error,
                otherGuid: this.guid,
                otherReportingGuid: this.reportingGuid
            });
        }
    };
    Partner.prototype.requestPartiallyFailed = function (requestNum, receivedAmount, receivedLowAmount, total, isVideo, reqType) {
        try {
            if (this.pendingRequests.has(requestNum)) {
                var started = this.pendingRequests.get(requestNum);
                this.pendingRequests.delete(requestNum);
                if (PeerConstants_1.PeerConstants.PerfMetrics.USE_PARTIAL_THROUGHPUT_RATE) {
                    this.updateReceivingRateTimePeriod(receivedAmount, started, true);
                }
                else {
                    this.updateReceivingRateTimePeriod(0, started, true);
                }
                this.scoreUpdaterIn.partial(receivedAmount, total);
                this.snapAccountManager.accountPartnerRequestPartiallyCompleted(this.reportingGuid, receivedAmount, receivedLowAmount, total, isVideo, reqType);
            }
            else {
                logger_hive_1.ErrorMonitor.getInstance().logError('Error partially failed a non-existing request', this.loggerId, ErrorCodes.PARTNER_CODES.REQUEST_NOT_EXISTING_PARTIALLY_FAILED, {
                    otherGuid: this.guid,
                    otherReportingGuid: this.reportingGuid
                });
            }
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error handling request partially failed', this.loggerId, ErrorCodes.PARTNER_CODES.REQUEST_PARTIALLY_FAILED, {
                detailedError: error,
                otherGuid: this.guid
            });
        }
    };
    Partner.prototype.requestFailed = function (requestNum, isVideo, size) {
        try {
            if (this.pendingRequests.has(requestNum)) {
                var started = this.pendingRequests.get(requestNum);
                // var request = this.pendingRequests.get(requestNum)
                this.pendingRequests.delete(requestNum);
                this.updateReceivingRateTimePeriod(0, started, true);
                // this.logger.debug(this.guid + " REM C " + requestNum)
                this.scoreUpdaterIn.failed();
                this.snapAccountManager.accountPartnerRequestFailed(this.reportingGuid, size, isVideo);
            }
            else {
                logger_hive_1.ErrorMonitor.getInstance().logError('Error failed a non-existing request', this.loggerId, ErrorCodes.PARTNER_CODES.REQUEST_NOT_EXISTING_FAILED, {
                    otherGuid: this.guid,
                    otherReportingGuid: this.reportingGuid
                });
            }
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error handling request failed', this.loggerId, ErrorCodes.PARTNER_CODES.REQUEST_FAILED, {
                detailedError: error,
                otherGuid: this.guid
            });
        }
    };
    Partner.prototype.responseSuccessAccount = function (total, partnerGuid) {
        this.snapAccountManager.accountPartnerResponseCompleted(total, partnerGuid, true);
    };
    Partner.prototype.responseFailedAccount = function (total, partnerGuid) {
        this.snapAccountManager.accountPartnerResponseFailed(total, partnerGuid, true);
    };
    Partner.prototype.responsePartiallyFailedAccount = function (amountSent, total, partnerGuid) {
        this.snapAccountManager.accountPartnerResponsePartiallyCompleted(amountSent, total, partnerGuid, true);
    };
    /**
     * returns the average throughput of the last received fragments
     * in bytes per milliseconds or simply KBps
     */
    Partner.prototype.getRcvRatesAvg = function () {
        var ratesSum = this.receiveRates.reduce(function (pv, cv) {
            return pv + cv;
        }, 0);
        return this.receiveRates.length > 0 ? ratesSum / this.receiveRates.length : 0;
    };
    Partner.prototype.setUploadFailureRatio = function (uploadScore) {
        this.failureUploadScore = uploadScore;
    };
    Partner.prototype.getUploadFailureRatio = function () {
        return this.failureUploadScore;
    };
    Partner.prototype.isInLan = function () {
        return this.member.isInLan();
    };
    Partner.prototype.getHandshakeDelay = function () {
        return this.handshakeDelay;
    };
    /**
     * calculates the handshake delay to establish a connection with the partner.
     * This takes into account the WebRTC connection time and the partnership request/respond
     * time
     * @param {number} timeStarted
     */
    Partner.prototype.calculateHandshakeDelay = function (handshakeStartedTs) {
        var timeElapsed = Math.max(0, this.partnershipStartedTs - handshakeStartedTs);
        // handshakeDelay should be bigger than 0 milliseconds and less than MAX_HANDSHAKE_DELAY (10000 milliseconds)
        // P2P connection expires in 5 seconds at the network level and 5 more seconds at the application level.
        // So the handshake delay should not be more than 10000 milliseconds
        if (timeElapsed > 0 && timeElapsed < PeerConstants_1.PeerConstants.PartnershipConstants.MAX_HANDSHAKE_DELAY) {
            this.handshakeDelay = timeElapsed;
        }
    };
    return Partner;
}());
exports.Partner = Partner;
//# sourceMappingURL=Partner.js.map

/***/ }),

/***/ "../../../core/build/core/src/webrtc/partnership/PartnersAccounting.js":
/*!**********************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/webrtc/partnership/PartnersAccounting.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.PartnersAccounting = void 0;
var PartnersAccounting = /** @class */ (function () {
    function PartnersAccounting(inPartners, outPartners) {
        this.inPartners = inPartners;
        this.outPartners = outPartners;
    }
    return PartnersAccounting;
}());
exports.PartnersAccounting = PartnersAccounting;
//# sourceMappingURL=PartnersAccounting.js.map

/***/ }),

/***/ "../../../core/build/core/src/webrtc/partnership/Partnership.js":
/*!***************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/webrtc/partnership/Partnership.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.Partnership = exports.PartnershipCloseType = exports.PartnershipAnswer = void 0;
__webpack_require__(/*! hivejs-protocol/services/new_tracker_types */ "../../../protocol/services/new_tracker_types.js");
var TrackerPeerInfo = hive.services.protocol.tracker.TrackerPeerInfo;
var TrackerPeerStreamInfo = hive.services.protocol.tracker.TrackerPeerStreamInfo;
var Q = __webpack_require__(/*! @hivestreaming/q */ "../../../node_modules/@hivestreaming/q/q.js");
var HashMap = __webpack_require__(/*! @hivestreaming/collections/map */ "../../../node_modules/@hivestreaming/collections/map.js");
var Framework_1 = __webpack_require__(/*! ../../core/Framework */ "../../../core/build/core/src/core/Framework.js");
var Partner_1 = __webpack_require__(/*! ./Partner */ "../../../core/build/core/src/webrtc/partnership/Partner.js");
var PeerConstants_1 = __webpack_require__(/*! ../PeerConstants */ "../../../core/build/core/src/webrtc/PeerConstants.js");
var P2PTransport_1 = __webpack_require__(/*! ../transport/P2PTransport */ "../../../core/build/core/src/webrtc/transport/P2PTransport.js");
var DiscoveryInfo_1 = __webpack_require__(/*! ../discovery/DiscoveryInfo */ "../../../core/build/core/src/webrtc/discovery/DiscoveryInfo.js");
var BasePartnership_1 = __webpack_require__(/*! ./BasePartnership */ "../../../core/build/core/src/webrtc/partnership/BasePartnership.js");
var logger_hive_1 = __webpack_require__(/*! ../../common/logger.hive */ "../../../core/build/core/src/common/logger.hive.js");
var ErrorCodes = __webpack_require__(/*! ../../common/error.hive */ "../../../core/build/core/src/common/error.hive.js");
var QualityLevel_1 = __webpack_require__(/*! ../../core/quality-level/QualityLevel */ "../../../core/build/core/src/core/quality-level/QualityLevel.js");
var ConfigStore_1 = __webpack_require__(/*! ../config-store/ConfigStore */ "../../../core/build/core/src/webrtc/config-store/ConfigStore.js");
var Utils_1 = __webpack_require__(/*! ../../core/Utils */ "../../../core/build/core/src/core/Utils.js");
var PartnershipAnswer;
(function (PartnershipAnswer) {
    PartnershipAnswer[PartnershipAnswer["ACCEPT"] = 1] = "ACCEPT";
    PartnershipAnswer[PartnershipAnswer["REJECT"] = 2] = "REJECT";
})(PartnershipAnswer = exports.PartnershipAnswer || (exports.PartnershipAnswer = {}));
var PartnershipCloseType;
(function (PartnershipCloseType) {
    PartnershipCloseType[PartnershipCloseType["ALL"] = 0] = "ALL";
    PartnershipCloseType[PartnershipCloseType["IN"] = 1] = "IN";
    PartnershipCloseType[PartnershipCloseType["OUT"] = 2] = "OUT";
})(PartnershipCloseType = exports.PartnershipCloseType || (exports.PartnershipCloseType = {}));
var Partnership = /** @class */ (function (_super) {
    __extends(Partnership, _super);
    function Partnership() {
        var _this = _super.call(this) || this;
        _this.loggerId = '[Partnership] ';
        _this.pendingPartnerRequests = new HashMap();
        _this.pendingConnection = new HashMap();
        _this.partnerChoiceTimer = -1;
        _this.qualityLevelAnnounceTimer = -1;
        _this.peerInfoAnnounceTimer = -1;
        _this.connected = false;
        _this.networkManager = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.RTC_MANAGER);
        _this.inPartnerSelection = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.IN_PARTNERSHIP);
        _this.outPartnerSelection = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.OUT_PARTNERSHIP);
        _this.inPrefetcherSelection = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.IN_PREFETCHER_PARTNERSHIP);
        _this.outPrefetcherSelection = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.OUT_PREFETCHER_PARTNERSHIP);
        return _this;
    }
    Partnership.prototype.init = function (swarm) {
        _super.prototype.init.call(this, swarm);
        this.configStore = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.CONFIG_STORE);
        this.swarm = swarm;
        this.membership = swarm.membership;
        this.prefetchManager = swarm.prefetchManager;
        this.ipSpoofing = swarm.ipSpoofing;
        this.inPartnerSelection.init(swarm);
        this.inPrefetcherSelection.init(swarm);
    };
    Partnership.prototype.start = function (context) {
        try {
            this.logger.debug(this.loggerId + 'PARTNERSHIP STARTED ' + context.getContextId());
            this.context = context;
            this.contextId = context.getContextId();
            this.startPeriodicInPartnerChoice(PeerConstants_1.PeerConstants.Overlay.InPartnerChoiceInterval);
            this.startPeriodicAnnouncePeerInfo(PeerConstants_1.PeerConstants.PartnershipConstants.PEER_INFO_ANNOUNCE_INTERVAL);
            this.active = true;
            this.configStore.on('p2p.siteToSiteEnabled', this.removePartnersFromOtherSite.bind(this));
            this.configStore.on('p2p.peeringPolicy', this.applyPeeringPolicy.bind(this));
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error in partnership initialization', this.loggerId, ErrorCodes.PARTNERSHIP_CODES.START_PARTNERSHIP, error);
        }
    };
    Partnership.prototype.stop = function () {
        Framework_1.Framework.clearInterval(this.partnerChoiceTimer);
        Framework_1.Framework.clearInterval(this.qualityLevelAnnounceTimer);
        Framework_1.Framework.clearInterval(this.peerInfoAnnounceTimer);
        this.context = null;
        this.contextId = null;
        this.active = false;
        return this.closePartnership();
    };
    Partnership.prototype.serverConnected = function (guid) {
        this.logger.debug('PARTNERSHIP SERVER CONNECTED');
        this.myId = guid;
        this.connected = true;
        if (this.nodeInfo.getId() == null) {
            this.nodeInfo.setId(this.myId);
        }
    };
    Partnership.prototype.serverDisconnected = function () {
        this.connected = false;
    };
    Partnership.prototype.startPeriodicInPartnerChoice = function (period) {
        var _this = this;
        if (this.partnerChoiceTimer != -1) {
            Framework_1.Framework.clearInterval(this.partnerChoiceTimer);
        }
        this.partnerChoiceTimer = Framework_1.Framework.setInterval(function () {
            _this.partnerChoice(false);
        }, period);
    };
    /**
     * try to fill up the in partners slots
     */
    Partnership.prototype.partnerChoice = function (firstTrackResponse) {
        var _this = this;
        if (firstTrackResponse && this.partnerChoiceTimer) {
            Framework_1.Framework.clearInterval(this.partnerChoiceTimer);
            this.startPeriodicInPartnerChoice(PeerConstants_1.PeerConstants.Overlay.InPartnerChoiceInterval);
        }
        try {
            if (this.connected) {
                this.logger.debug(this.loggerId + 'ADDING NEW PEERS IF POSSIBLE, NOW ' + this.inPartners.length + '/' + PeerConstants_1.PeerConstants.Overlay.MaxInPartners + ',' + this.inPartners.length + '/infinity');
                var pending_1 = [].concat(this.pendingPartnerRequests.keys()).concat(this.pendingConnection.keys());
                var sample = this.membership.sample(true);
                // Calculate the partners to remove and partners to add based on the current information
                // console.log("Current active inPartners " + this.inPartners.values().length);
                var update = void 0;
                // the potential candidates are members that are not already partners or waiting to become partners (pending).
                // Members just removed from the partnerhip cannot be added immidiately back
                // already partners
                var candidates = sample.filter(function (m) { return !_this.inPartners.has(m.peerInfo.guid); });
                // pending partners
                candidates = candidates.filter(function (m) { return pending_1.indexOf(m.peerInfo.guid) === -1; });
                // recently removed
                candidates = candidates.filter(function (m) { return !_this.recentlyRemovedPartners.has(m.peerInfo.guid); });
                if (this.nodeInfo.isLanLeader() || this.nodeInfo.amISiteLeader()) {
                    update = this.inPrefetcherSelection.updateIn(PeerConstants_1.PeerConstants.Overlay.MaxInPartners, this.inPartners.values(), candidates);
                }
                else {
                    update = this.inPartnerSelection.updateIn(PeerConstants_1.PeerConstants.Overlay.MaxInPartners, this.inPartners.values(), candidates);
                }
                this.tobeRemovedInPartners = update.getPartnersToRemove();
                update.getMembersToAdd().forEach(function (member) {
                    _this.inPartnerAddProcess(member);
                });
            }
            else {
                this.logger.warn(this.loggerId + 'NOT RUNNING IN PARTNER CHOICE, SRV DISCONNECTED');
            }
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error in choosing in partners', this.loggerId, ErrorCodes.PARTNERSHIP_CODES.IN_PARTNER_CHOICE, error);
        }
    };
    /**
     * attempts to add a member to the partnership
     * - check that a member is not already a partner, or pending request, or pending connection establishment
     * - add the member to the pending connection establishment
     * - attempt to connect
     *      - once a connection is established, get the P2P Transport. NOTE: the P2P Transport is singleton per peer connection
     *        so if any other swarm already connected to the same peer, the connect will just return the same object
     *      - register the current swarm id on the transport dispatcher manager
     *      - remove the connection from pending
     *      --------------------- CONNECTION ESTABLISHED/RETRIEVED -----------------
     *      - send the partnership request
     *          - if works, add the member to the inPartners
     *          - otherwise disconnect the guy
     *
     *      - if the connection fails, remove pending connection and remove the membership
     */
    Partnership.prototype.inPartnerAddProcess = function (member) {
        var _this = this;
        var guid = member.peerInfo.guid;
        var partnerPrivateIp = member.peerInfo.privateIpString;
        var partnerPublicIp = member.peerInfo.publicIpString;
        // First we check if the new member is not in our inpartner list
        // Second we check if we don't have any pending partnership request
        // Third we check if we don't have any pending connection process
        // Finally we check if we don't violate any ip spoofing rule.
        if (!this.isInPartner(member) && !this.pendingPartnerRequests.has(guid) && !this.pendingConnection.has(guid) && !this.ipSpoofing.violatesSpoofingRules(guid, partnerPrivateIp, partnerPublicIp)) {
            this.pendingConnection.set(guid, Date.now());
            //
            this.networkManager.connect(guid)
                .then(function (p2ptransport) {
                var dispatcher = p2ptransport.dispatcherManager.get(_this.swarm.swarmId);
                if (dispatcher == null) {
                    dispatcher = p2ptransport.dispatcherManager.create(_this.swarm.swarmId);
                }
                if (dispatcher) {
                    var handshakeStartTs_1 = _this.pendingConnection.get(guid);
                    _this.pendingConnection.delete(guid);
                    if (_this.active) {
                        // here we have an established connection
                        // now we can proceed in attempt to add the guy to the partnership
                        _this.sendPartRequest(dispatcher)
                            .then(function (resp) {
                            _this.newInPartner(dispatcher, member, resp.msg, handshakeStartTs_1);
                            _this.statsAccountingManager.accountInPartnerLookupStats(false, false);
                            // Since we managed to create a partnership we add the new peer to the ipspoofing map
                            _this.ipSpoofing.addOrUpdateToSpoofingMaps(guid, member.peerInfo.privateIpString, member.peerInfo.publicIpString);
                            _this.sendPingRequest(dispatcher);
                            if (_this.tobeRemovedInPartners.length > 0 && !member.isInLan()) {
                                var partner = _this.tobeRemovedInPartners[0];
                                _this.removeInPartner(partner.guid);
                                partner.dispatcher.sendClose(PartnershipCloseType.OUT);
                                _this.tobeRemovedInPartners.splice(0, 1);
                            }
                        }).fail(function (err) {
                            if (err && err != 'NOT ACCEPTED') {
                                logger_hive_1.ErrorMonitor.getInstance().logError('Error in requesting partnership', _this.loggerId, ErrorCodes.PARTNERSHIP_CODES.IN_PARTNERSHIP_REQUEST, {
                                    otherGuid: guid,
                                    detailedError: err
                                });
                            }
                            _this.statsAccountingManager.accountInPartnerLookupStats(false, true);
                            // We immediately disconnect through the network manager without checking the dispatcher.inUse.
                            // If something breaks at this point, this means that we have a corrupted connection.
                            // So even if we have another swarm running, the connection should be closed as both of them will fail
                            _this.closeConnection(guid);
                            // this.networkManager.disconnect(guid)
                            // this.membership.peerDisconnected(guid)
                            // this.peerDisconnected(guid)
                        });
                    }
                }
            }).fail(function (error) {
                logger_hive_1.ErrorMonitor.getInstance().logError('Error in creating new p2p connection', _this.loggerId, ErrorCodes.PARTNERSHIP_CODES.IN_PARTNER_CONNECT, {
                    otherGuid: guid,
                    detailedError: error
                });
                _this.statsAccountingManager.accountInPartnerLookupStats(true, true);
                _this.pendingConnection.delete(guid);
                _this.membership.peerDisconnected(guid);
            }).done();
        }
    };
    /**
     * called by the dispatcher when we receive a out partnership request.
     * This means that some peer is trying to put us in his inPartners
     *
     * - check if he is not already our out partner
     * - check if we are actually watching the same event (contextId)
     * - TODO add out partner limit + selection (choking)
     * - create a partner and add him to the right list (lan or random)
     * - send a positive response
     * - wait half a second and bombard him with all the haves
     *
     *
     * @param request
     * @param p2pTransport
     */
    Partnership.prototype.outPartRequestReceived = function (request, p2pTransport) {
        var _this = this;
        try {
            var otherGuid_1 = request.guid;
            var partnerPublicIp = null;
            var partnerPrivateIp = null;
            if (request.privateIpString) {
                partnerPrivateIp = request.privateIpString;
            }
            if (request.publicIpString) {
                partnerPublicIp = request.publicIpString;
            }
            if (!this.isOutPartnerById(otherGuid_1)) {
                var contextId = request.contextId;
                var dispatcher = p2pTransport.dispatcherManager.get(this.swarm.swarmId);
                // We accept the incoming partnership iff the following preconditions are valid
                // 1. We watch the same context
                // 2. Our clients report the same P2P protocol version
                // 3. We don't violate any ip spoofing rule
                if ((this.contextId === contextId) && (PeerConstants_1.PeerConstants.PartnershipConstants.P2P_PROTOCOL_VERSION === request.p2pProtocolVersion) && (!this.ipSpoofing.violatesSpoofingRules(otherGuid_1, partnerPrivateIp, partnerPublicIp))) {
                    // Construct a DiscoveredPeerInfo and add him in the Membership.
                    // This peer may already exist in our membership list but we can update with new information
                    // especially internal As, externalAs, public/private ips
                    var discoveredPeerInfo = this.constructDiscoveredPeerInfo(request);
                    var allowPartner = void 0;
                    var member = void 0;
                    if (discoveredPeerInfo) {
                        this.membership.discoveredPeers([discoveredPeerInfo], false);
                        member = this.membership.retrieveMember(otherGuid_1);
                        // TODO: CHANGE THIS CHECK WITH QUALITY LEVEL OUT SLOTS
                        allowPartner = this.outPartners.length < PeerConstants_1.PeerConstants.Overlay.MaxOutPartner;
                        if (!allowPartner) {
                            /*
                             * we need to choke someone before allowing a new out partner
                             * we ask the outPartnerSelection to pick one, and we choke him
                             */
                            this.logger.debug(this.loggerId + " got out part req from " + otherGuid_1 + " - reached max " + this.outPartners.length + "/" + PeerConstants_1.PeerConstants.Overlay.MaxOutPartner);
                            var toChoke = void 0;
                            if (this.nodeInfo.isLanLeader() || this.nodeInfo.amISiteLeader()) {
                                toChoke = this.outPrefetcherSelection.updateOut(this.nodeInfo, discoveredPeerInfo, this.outPartners.values());
                            }
                            else {
                                toChoke = this.outPartnerSelection.updateOut(this.outPartners.values());
                            }
                            if (toChoke) {
                                this.logger.debug(this.loggerId + " chocking " + toChoke.guid);
                                this.outPartners.delete(toChoke.guid);
                                toChoke.dispatcher.sendClose(PartnershipCloseType.IN);
                                allowPartner = true;
                            }
                        }
                    }
                    else {
                        allowPartner = false;
                    }
                    if (allowPartner) {
                        var partner = new Partner_1.Partner(otherGuid_1, this.statsAccountingManager, dispatcher, this.logger, false, member);
                        if (request.reportingGuid) {
                            partner.updateReportingGuid(request.reportingGuid);
                        }
                        this.outPartners.set(otherGuid_1, partner);
                        this.logger.debug(this.loggerId + 'ADDED OUT PART ' + otherGuid_1);
                        this.sendPartResp(dispatcher, PartnershipAnswer.ACCEPT);
                        // Since we accepted the incoming partnership, we add the peer to our spoofing maps
                        this.ipSpoofing.addOrUpdateToSpoofingMaps(otherGuid_1, partnerPrivateIp, partnerPublicIp);
                        // delay the send of all the have to be sure that the
                        // partner handles the partnership response first
                        // TODO replace 500 with constant
                        Framework_1.Framework.setTimeout(function () {
                            _this.sendAllHaves(otherGuid_1);
                        }, 500);
                        // handle lookup metrics
                        this.statsAccountingManager.accountOutPartnerLookupStats();
                    }
                    else {
                        this.logger.debug(this.loggerId + " cannot establish partnership to " + otherGuid_1 + " - reached max " + this.outPartners.length + "/" + PeerConstants_1.PeerConstants.Overlay.MaxOutPartner);
                        this.sendPartResp(dispatcher, PartnershipAnswer.REJECT);
                    }
                }
                else {
                    this.logger.debug(this.loggerId + 'PARTNERSHIP CANNOT BE ESTABLISHED WITH ' + otherGuid_1 + ' CONTEXT ID ' + contextId + ' protocol version ' + request.p2pProtocolVersion);
                    this.sendPartResp(dispatcher, PartnershipAnswer.REJECT);
                }
            }
            else {
                this.logger.debug(this.loggerId + 'ALREADY OUT PARTNER ' + otherGuid_1);
            }
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error receiving out partnership request', this.loggerId, ErrorCodes.PARTNERSHIP_CODES.OUT_PARNTERSHIP_REQUEST_PROCESS, {
                detailedError: error,
                otherGuid: request.guid
            });
        }
    };
    Partnership.prototype.constructDiscoveredPeerInfo = function (request) {
        try {
            var trackerPeerInfo = new TrackerPeerInfo();
            trackerPeerInfo.guid = request.guid;
            trackerPeerInfo.internalAs = 0;
            trackerPeerInfo.isVpn = request.isVpn;
            if (request.internalAs) {
                trackerPeerInfo.internalAs = request.internalAs;
            }
            if (request.externalAs) {
                trackerPeerInfo.externalAs = request.externalAs;
            }
            if (request.publicIpString) {
                trackerPeerInfo.publicIpString = request.publicIpString;
            }
            if (request.privateIpString) {
                trackerPeerInfo.privateIpString = request.privateIpString;
            }
            var isLeader = false;
            var member = this.membership.retrieveMember(request.guid);
            if (member) {
                isLeader = member.peerInfo.isLeader;
            }
            if (request.streamCharacteristics) {
                var trackerPeerStreams_1 = [];
                request.streamCharacteristics.forEach(function (streamChar) {
                    var streamInfo = new TrackerPeerStreamInfo();
                    streamInfo.state = streamChar.streamState;
                    streamInfo.bitrate = streamChar.qualityLevel.bitrate;
                    streamInfo.qualityLevel = streamChar.qualityLevel.id;
                    streamInfo.delta = streamChar.delta;
                    trackerPeerStreams_1.push(streamInfo);
                });
                trackerPeerInfo.streams = trackerPeerStreams_1;
            }
            // We set the discovery type to Tracker because either we already know about this peer so
            // the membership will modify it afterwards or we continue as DiscoveryType.Tracker
            // which is also true because he is not in our LAN. If we receive an udp message from him after a while
            // the discovery type will immediately change.
            return DiscoveryInfo_1.DiscoveredPeerInfo.trackerDiscoveredPeerInfo(trackerPeerInfo, isLeader);
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error constructing discovered peer info', this.loggerId, ErrorCodes.PARTNERSHIP_CODES.CONSTRUCT_DISCOVER_PEER_INFO, {
                detailedError: error,
                otherGuid: request.guid
            });
            return null;
        }
    };
    Partnership.prototype.sendPartResp = function (dispatcher, respMsg) {
        var _this = this;
        this.logger.debug(this.loggerId + 'SEND PART RESPONSE TO ' + dispatcher.otherGuid);
        try {
            var networkInfo = this.connectivityInfo.getNetworkInfo();
            var resp = new P2PTransport_1.P2PTransport.msgBuilder.OutPartnershipResponse();
            resp.accept = respMsg;
            if (resp.accept === PartnershipAnswer.ACCEPT) {
                resp.internalAs = networkInfo.getSiteId();
                resp.isVpn = networkInfo.isVpn();
                if (networkInfo.getExternalAsId()) {
                    resp.externalAs = networkInfo.getExternalAsId();
                }
                if (networkInfo.getPublicIp()) {
                    resp.publicIpString = networkInfo.getPublicIp();
                }
                if (networkInfo.getPrivateIp()) {
                    resp.privateIpString = networkInfo.getPrivateIp();
                }
                resp.reportingGuid = this.nodeInfo.getReportingGuid();
                var prefetchedStreams = this.nodeInfo.getPrefetchingQualityLevels();
                var streamCharacteristics_1 = [];
                prefetchedStreams.forEach(function (session, qualityLevel) {
                    var streamChar = new P2PTransport_1.P2PTransport.msgBuilder.StreamCharacteristics();
                    streamChar.qualityLevel = new P2PTransport_1.P2PTransport.msgBuilder.QualityLevel();
                    streamChar.qualityLevel.id = session.qualityLevel.id;
                    streamChar.qualityLevel.bitrate = session.qualityLevel.bitrate;
                    streamChar.streamState = session.type;
                    streamChar.delta = _this.nodeInfo.getDelta() != null ? _this.nodeInfo.getDelta() : -1;
                    streamCharacteristics_1.push(streamChar);
                });
                if (streamCharacteristics_1.length > 0) {
                    resp.setStreamCharacteristics(streamCharacteristics_1);
                }
            }
            dispatcher.sendMessage(P2PTransport_1.P2PMsgTypes.OutPartResp, resp);
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error constructing partnership response message', this.loggerId, ErrorCodes.PARTNERSHIP_CODES.SEND_PARTN_RESP, {
                detailedError: error,
                otherGuid: dispatcher.otherGuid
            });
        }
    };
    Partnership.prototype.newInPartner = function (dispatcher, member, outPartResp, handshakeStartedTs) {
        var otherGuid = dispatcher.otherGuid;
        member.peerInfo.internalAs = 0;
        member.peerInfo.isVpn = outPartResp.isVpn;
        // fill the peerinfo properties with the values provided by the message
        if (outPartResp.externalAs) {
            member.peerInfo.externalAs = outPartResp.externalAs;
        }
        if (outPartResp.internalAs) {
            member.peerInfo.internalAs = outPartResp.internalAs;
        }
        if (outPartResp.publicIpString) {
            member.peerInfo.publicIpString = outPartResp.publicIpString;
        }
        if (outPartResp.privateIpString) {
            member.peerInfo.privateIpString = outPartResp.privateIpString;
        }
        if (outPartResp.streamCharacteristics) {
            var trackerPeerStreams_2 = [];
            outPartResp.streamCharacteristics.forEach(function (streamChar) {
                var streamInfo = new TrackerPeerStreamInfo();
                streamInfo.state = streamChar.streamState;
                streamInfo.bitrate = streamChar.qualityLevel.bitrate;
                streamInfo.qualityLevel = streamChar.qualityLevel.id;
                streamInfo.delta = streamChar.delta;
                trackerPeerStreams_2.push(streamInfo);
            });
            member.peerInfo.streams = trackerPeerStreams_2;
        }
        try {
            var partner = new Partner_1.Partner(otherGuid, this.statsAccountingManager, dispatcher, this.logger, true, member, handshakeStartedTs);
            if (outPartResp.reportingGuid) {
                partner.reportingGuid = outPartResp.reportingGuid;
                dispatcher.receiver.setReportingGuid(outPartResp.reportingGuid);
                dispatcher.sender.setReportingGuid(outPartResp.reportingGuid);
            }
            this.inPartners.set(otherGuid, partner);
            this.setPartnershipFlags(member.peerInfo);
            this.logger.debug(this.loggerId + otherGuid + ' IS NOW IN PARTNER');
            return partner;
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error adding a new partner object in the list', this.loggerId, ErrorCodes.PARTNERSHIP_CODES.NEW_IN_PARTNER_TO_LIST, {
                detailedError: error,
                otherGuid: otherGuid
            });
        }
    };
    Partnership.prototype.peerDisconnected = function (guid) {
        try {
            if (this.isInPartnerById(guid)) {
                this.logger.debug(this.loggerId + 'IN PRT DISC ' + guid);
                this.removeInPartner(guid);
            }
            if (this.isOutPartnerById(guid)) {
                this.logger.debug(this.loggerId + 'OUT PRT DISC ' + guid);
                this.outPartners.delete(guid);
            }
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error removing disconected partner from the list', this.loggerId, ErrorCodes.PARTNERSHIP_CODES.REMOVE_DISCONNECTED_PEER, {
                detailedError: error,
                otherGuid: guid
            });
        }
    };
    /**
     * update the centralized partnership state flags (partnership locality) regarding one specific partner
     */
    Partnership.prototype.setPartnershipFlags = function (peerInfo, mySiteId, myAsId) {
        var networkInfo = this.connectivityInfo.getNetworkInfo();
        if (peerInfo.type === DiscoveryInfo_1.DiscoveryType.UDP) {
            this.nodeInfo.setLanPartnershipFlag(true);
        }
        if (!Utils_1.isSet(mySiteId)) {
            mySiteId = networkInfo.getSiteId();
        }
        if (mySiteId > 0 && mySiteId === networkInfo.getSiteId()) {
            this.nodeInfo.setSitePartnershipFlag(true);
        }
        if (!Utils_1.isSet(myAsId)) {
            myAsId = networkInfo.getExternalAsId();
        }
        if (myAsId > 0 && myAsId === peerInfo.externalAs) {
            this.nodeInfo.setAsPartnershipFlag(true);
        }
    };
    Partnership.prototype.removeInPartner = function (guid) {
        var _this = this;
        try {
            this.logger.debug(this.loggerId + 'IN PARTNER REMOVE ' + guid);
            var partner = this.getInPartnerById(guid);
            this.objectIndex.removePeer(partner);
            this.inPartners.delete(guid);
            this.membership.removeMemberFromGuid(guid);
            this.trackRemovedPartner(guid, partner);
            this.nodeInfo.setLanPartnershipFlag(false);
            this.nodeInfo.setSitePartnershipFlag(false);
            this.nodeInfo.setAsPartnershipFlag(false);
            this.inPartners.forEach(function (p) {
                _this.setPartnershipFlags(p.member.peerInfo);
            });
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error removing the in partner', this.loggerId, ErrorCodes.PARTNERSHIP_CODES.REMOVE_IN_PARTNER, {
                detailedError: error,
                otherGuid: guid
            });
        }
    };
    /**
     * reset the centralized node info partnership flags, and recalculate them
     * on the current in partners
     */
    Partnership.prototype.updatePartnershipFlags = function () {
        var _this = this;
        this.nodeInfo.setLanPartnershipFlag(false);
        this.nodeInfo.setSitePartnershipFlag(false);
        this.nodeInfo.setAsPartnershipFlag(false);
        this.inPartners.forEach(function (p) {
            _this.setPartnershipFlags(p.member.peerInfo);
        });
    };
    Partnership.prototype.closeReceived = function (guid, close) {
        try {
            if (close.getType() === PartnershipCloseType.ALL || close.getType() === PartnershipCloseType.OUT) {
                if (close.getType() === PartnershipCloseType.OUT && !this.outPartners.has(guid)) {
                    this.logger.warn(this.loggerId + ("received close out partnership from " + guid + " but peer is not in outPartners"));
                }
                if (this.outPartners.has(guid)) {
                    this.outPartners.delete(guid);
                }
            }
            if (close.getType() === PartnershipCloseType.ALL || close.getType() === PartnershipCloseType.IN) {
                if (close.getType() === PartnershipCloseType.IN && !this.inPartners.has(guid)) {
                    this.logger.warn(this.loggerId + ("received close in parnership from " + guid + " but peer is not in inPartners"));
                }
                if (this.inPartners.has(guid)) {
                    this.removeInPartner(guid);
                }
            }
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error when close received', this.loggerId, ErrorCodes.PARTNERSHIP_CODES.CLOSE_RECEIVED, {
                detailedError: error,
                otherGuid: guid
            });
        }
    };
    /**
     * when we want to add a peer in out IN partners, we send him a OUT Partnership request
     * to ask him if we can be his OUT partner (convoluted but logic...kinda...)
     *
     * we send the message to a connected member
     * and start a timeout for getting an answer
     * save the pending request together with the timerId and the promise
     * for later handling in case of answer or timeout expiration
     * @param dispatcher
     * @returns {Promise<P2PTransport>}
     */
    Partnership.prototype.sendPartRequest = function (dispatcher) {
        var _this = this;
        var defer = Q.defer();
        try {
            var msg = new P2PTransport_1.P2PTransport.msgBuilder.OutPartnershipRequest();
            var networkInfo = this.connectivityInfo.getNetworkInfo();
            msg.guid = this.myId;
            msg.contextId = this.contextId;
            msg.p2pProtocolVersion = PeerConstants_1.PeerConstants.PartnershipConstants.P2P_PROTOCOL_VERSION;
            msg.reportingGuid = this.nodeInfo.getReportingGuid();
            msg.internalAs = networkInfo.getSiteId();
            msg.isVpn = networkInfo.isVpn();
            if (networkInfo.getExternalAsId()) {
                msg.externalAs = networkInfo.getExternalAsId();
            }
            if (networkInfo.getPrivateIp()) {
                msg.privateIpString = networkInfo.getPrivateIp();
            }
            if (networkInfo.getPublicIp()) {
                msg.publicIpString = networkInfo.getPublicIp();
            }
            var prefetchedStreams = this.nodeInfo.getPrefetchingQualityLevels();
            var streamCharacteristics_2 = [];
            prefetchedStreams.forEach(function (session, qualityLevel) {
                var streamChar = new P2PTransport_1.P2PTransport.msgBuilder.StreamCharacteristics();
                streamChar.qualityLevel = new P2PTransport_1.P2PTransport.msgBuilder.QualityLevel();
                streamChar.qualityLevel.id = session.qualityLevel.id;
                streamChar.qualityLevel.bitrate = session.qualityLevel.bitrate;
                streamChar.streamState = session.type;
                streamChar.delta = _this.nodeInfo.getDelta() != null ? _this.nodeInfo.getDelta() : -1;
                streamCharacteristics_2.push(streamChar);
            });
            if (streamCharacteristics_2.length > 0) {
                msg.setStreamCharacteristics(streamCharacteristics_2);
            }
            this.logger.debug(this.loggerId + 'SEND PART REQ TO ' + dispatcher.otherGuid);
            // start the timeout
            var timerId = Framework_1.Framework.setTimeout(function () {
                _this.partnershipRequestTimedout(defer, dispatcher.otherGuid);
            }, PeerConstants_1.PeerConstants.Overlay.PartnershipOutReqTimeout);
            // save the pending info
            this.pendingPartnerRequests.set(dispatcher.otherGuid, { timerId: timerId, defer: defer });
            dispatcher.sendMessage(P2PTransport_1.P2PMsgTypes.OutPartRequest, msg);
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error sending partnership request', this.loggerId, ErrorCodes.PARTNERSHIP_CODES.SEND_PART_REQUEST, {
                detailedError: error,
                otherGuid: dispatcher.otherGuid
            });
            defer.reject(error);
        }
        return defer.promise;
    };
    Partnership.prototype.outPartRespReceived = function (outPartResp, transport) {
        var otherGuid = transport.otherGuid;
        var details = this.pendingPartnerRequests.get(otherGuid);
        if (details) {
            Framework_1.Framework.clearTimeout(details.timerId);
            this.pendingPartnerRequests.delete(otherGuid);
            if (outPartResp.accept === PartnershipAnswer.ACCEPT) {
                details.defer.resolve({ transport: transport, msg: outPartResp });
            }
            else {
                details.defer.reject('NOT ACCEPTED');
            }
        }
        else {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error receiving out partnership response from an unknown peer', this.loggerId, ErrorCodes.PARTNERSHIP_CODES.UNKNOWN_OUT_PART_RESP, { otherGuid: otherGuid });
        }
    };
    Partnership.prototype.partnershipRequestTimedout = function (defer, guid) {
        if (this.pendingPartnerRequests.has(guid)) {
            var details = this.pendingPartnerRequests.get(guid);
            this.pendingPartnerRequests.delete(guid);
            details.defer.reject('Expired');
        }
        else {
            defer.reject('Expired for unknown peer');
        }
    };
    Partnership.prototype.closePartnership = function () {
        var _this = this;
        var q = Q.defer();
        var chain = this.inPartners.values().slice().map(function (item) {
            return item.dispatcher.close();
        });
        Q.all(chain).then(function (results) {
            q.resolve('resolved');
        }).fail(function (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error closing partnership', _this.loggerId, ErrorCodes.PARTNERSHIP_CODES.CLOSE_PARTNERSHIP, error);
            q.reject('could not close');
        });
        return q.promise;
    };
    /**
     * We close the connection to a specific peer.

     * When the channel is closed it will trigger the peerDisconnected
     * on all listeners, included membership and partnership
     * @param guid
     */
    Partnership.prototype.closeConnection = function (guid) {
        this.networkManager.disconnect(guid);
    };
    /*
     * -------------------------------------------------------------------------------
     *           PARTNERSHIP OPS - QUALITY LEVEL ANNOUNCE & PEER INFO UPDATES
     * -------------------------------------------------------------------------------
     */
    Partnership.prototype.announceActiveQualityLevel = function (dispatcher, qualityLevel) {
        try {
            var msg = new P2PTransport_1.P2PTransport.msgBuilder.QualityLevelMessage();
            msg.guid = this.myId;
            msg.qualityLevel = new P2PTransport_1.P2PTransport.msgBuilder.QualityLevel();
            msg.qualityLevel.id = qualityLevel.id;
            msg.qualityLevel.bitrate = qualityLevel.bitrate;
            this.logger.debug(this.loggerId + 'ANNOUNCE QUALITY LEVEL ' + msg.qualityLevel.id + ' TO PEER GUID ' + dispatcher.otherGuid);
            dispatcher.sendMessage(P2PTransport_1.P2PMsgTypes.QualityLevelMessage, msg);
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error constructing quality level announcement', this.loggerId, ErrorCodes.PARTNERSHIP_CODES.CONSTRUCT_ANNOUNCE_QUALITY_LEVEL_MSG, {
                detailedError: error,
                otherGuid: dispatcher.otherGuid
            });
        }
    };
    /**
     * Somebody thinks I'm a leader and sent me an update on his watched quality level
     * @param qualityLevelMsg
     */
    Partnership.prototype.qualityLevelInfoReceived = function (qualityLevelMsg) {
        try {
            this.logger.debug(this.loggerId + 'RECEIVED QUALITY LEVEL ' + qualityLevelMsg.qualityLevel.id + ' FROM PEER GUID ' + qualityLevelMsg.guid);
            if (this.membership.hasMember(qualityLevelMsg.getGuid())) {
                var qualityLevel = QualityLevel_1.QualityLevel.from(qualityLevelMsg.qualityLevel);
                var member = this.membership.retrieveMember(qualityLevelMsg.guid);
                member.peerInfo.watchingQualityLevel = qualityLevel;
                this.prefetchManager.updateLanWatchedQualityLevels();
            }
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error receiving quality level info', this.loggerId, ErrorCodes.PARTNERSHIP_CODES.RECEIVE_QUALITY_LEVEL_INFO, {
                detailedError: error,
                otherGuid: qualityLevelMsg.guid
            });
        }
    };
    /**
     * We receive a peer info message from one of our partners.
     * We update the peerinfo variables of our partner and
     * also update the ipspoofing maps with the new information.
     * @param peerInfoMsg
     */
    Partnership.prototype.peerInfoReceived = function (peerInfoMsg) {
        try {
            var otherGuid = peerInfoMsg.guid;
            var partner = this.getInPartnerById(otherGuid);
            if (partner) {
                this.updatePartnerPeerInfo(partner, peerInfoMsg);
            }
            partner = this.getOutPartnerById(otherGuid);
            if (partner) {
                this.updatePartnerPeerInfo(partner, peerInfoMsg);
            }
            this.ipSpoofing.addOrUpdateToSpoofingMaps(otherGuid, peerInfoMsg.privateIpString, peerInfoMsg.publicIpString);
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error receiving peer info', this.loggerId, ErrorCodes.PARTNERSHIP_CODES.PEER_INFO_RECEIVED, {
                detailedError: error,
                otherGuid: peerInfoMsg.guid
            });
        }
    };
    Partnership.prototype.updatePartnerPeerInfo = function (partner, peerInfoMsg) {
        var peerInfo = partner.member.peerInfo;
        if (peerInfoMsg.privateIpString) {
            peerInfo.privateIpString = peerInfoMsg.privateIpString;
        }
        if (peerInfoMsg.publicIpString) {
            peerInfo.publicIpString = peerInfoMsg.publicIpString;
        }
        if (peerInfoMsg.externalAs) {
            peerInfo.externalAs = peerInfoMsg.externalAs;
        }
        if (Utils_1.isSet(peerInfoMsg.internalAs)) {
            peerInfo.internalAs = peerInfoMsg.internalAs;
        }
        if (peerInfoMsg.streamCharacteristics) {
            var trackerPeerStreamInfo_1 = [];
            peerInfoMsg.streamCharacteristics.forEach(function (stream) {
                var tmpStream = new TrackerPeerStreamInfo();
                tmpStream.bitrate = stream.qualityLevel.bitrate;
                tmpStream.qualityLevel = stream.qualityLevel.id;
                tmpStream.delta = stream.delta;
                tmpStream.state = stream.streamState;
                trackerPeerStreamInfo_1.push(tmpStream);
            });
            peerInfo.streams = trackerPeerStreamInfo_1;
        }
    };
    /**
     * Every x seconds we report to all our partners (in and out)
     * our private/public ip and the external/internal as information.
     */
    Partnership.prototype.startPeriodicAnnouncePeerInfo = function (period) {
        var _this = this;
        if (this.peerInfoAnnounceTimer) {
            Framework_1.Framework.clearInterval(this.peerInfoAnnounceTimer);
        }
        this.peerInfoAnnounceTimer = Framework_1.Framework.setInterval(function () {
            _this.announcePeerInfo();
        }, period);
    };
    Partnership.prototype.announcePeerInfo = function () {
        var _this = this;
        try {
            var networkInfo = this.connectivityInfo.getNetworkInfo();
            if (networkInfo.getPrivateIp() || networkInfo.getPublicIp() || networkInfo.getSiteId() || networkInfo.getExternalAsId()) {
                var partnerMap = this.collectAllPartners();
                var msg_1 = new P2PTransport_1.P2PTransport.msgBuilder.PeerInfoMessage();
                msg_1.guid = this.nodeInfo.getId();
                msg_1.internalAs = networkInfo.getSiteId();
                if (networkInfo.getPrivateIp()) {
                    msg_1.privateIpString = networkInfo.getPrivateIp();
                }
                if (networkInfo.getPublicIp()) {
                    msg_1.publicIpString = networkInfo.getPublicIp();
                }
                if (networkInfo.getExternalAsId()) {
                    msg_1.externalAs = networkInfo.getExternalAsId();
                }
                var prefetchedStreams = this.nodeInfo.getPrefetchingQualityLevels();
                var streamCharacteristics_3 = [];
                prefetchedStreams.forEach(function (session, qualityLevel) {
                    var streamChar = new P2PTransport_1.P2PTransport.msgBuilder.StreamCharacteristics();
                    streamChar.qualityLevel = new P2PTransport_1.P2PTransport.msgBuilder.QualityLevel();
                    streamChar.qualityLevel.id = session.qualityLevel.id;
                    streamChar.qualityLevel.bitrate = session.qualityLevel.bitrate;
                    streamChar.streamState = session.type;
                    streamChar.delta = _this.nodeInfo.getDelta() != null ? _this.nodeInfo.getDelta() : -1;
                    streamCharacteristics_3.push(streamChar);
                });
                if (streamCharacteristics_3.length > 0) {
                    msg_1.setStreamCharacteristics(streamCharacteristics_3);
                }
                partnerMap.forEach(function (partner, guid) {
                    partner.dispatcher.sendMessage(P2PTransport_1.P2PMsgTypes.PeerInfo, msg_1);
                });
            }
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error announcing peer info to all partners', this.loggerId, ErrorCodes.PARTNERSHIP_CODES.PEER_INFO_ANNOUNCED, error);
        }
    };
    /**
     * We create a hashmap which contains all the current partners (in and out).
     * This is used by the periodic announce peer info
     * @returns {HashMap<string, Partner>}
     */
    Partnership.prototype.collectAllPartners = function () {
        try {
            return this.outPartners.concat(this.inPartners);
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error collecting all partners', this.loggerId, ErrorCodes.PARTNERSHIP_CODES.COLLECT_ALL_PARTNERS, error);
            return new HashMap();
        }
    };
    Partnership.prototype.removePartnersFromOtherSite = function (p2pSiteToSiteEnabled) {
        var _this = this;
        if (!p2pSiteToSiteEnabled) {
            this.collectAllPartners().filter(function (partner) { return partner.member.peerInfo.internalAs !== _this.connectivityInfo.getNetworkInfo().getSiteId(); })
                .map(function (p) { return _this.removePartner(p); });
        }
    };
    Partnership.prototype.applyPeeringPolicy = function (policy) {
        var _this = this;
        if ((policy === ConfigStore_1.PeeringPolicy.EXCLUDE_VPN_SITES || policy === ConfigStore_1.PeeringPolicy.EXCLUDE_VPN_AND_UNKNOWN_SITES) && this.connectivityInfo.getNetworkInfo().isVpn()) {
            this.collectAllPartners().map(function (p) { return _this.removePartner(p); });
        }
        else if (policy === ConfigStore_1.PeeringPolicy.EXCLUDE_VPN_AND_UNKNOWN_SITES && !this.connectivityInfo.getNetworkInfo().getSiteId()) {
            this.collectAllPartners().map(function (p) { return _this.removePartner(p); });
        }
        else if (policy === ConfigStore_1.PeeringPolicy.EXCLUDE_VPN_SITES) {
            this.removeVpnPartners();
        }
        else if (policy === ConfigStore_1.PeeringPolicy.EXCLUDE_VPN_AND_UNKNOWN_SITES) {
            this.removeVpnPartners();
            this.removePartnersUnknownSites();
        }
    };
    Partnership.prototype.removeVpnPartners = function () {
        var _this = this;
        this.collectAllPartners().filter(function (partner) { return partner.member.peerInfo.isVpn; })
            .map(function (p) { return _this.removePartner(p); });
    };
    Partnership.prototype.removePartnersUnknownSites = function () {
        var _this = this;
        this.collectAllPartners().filter(function (partner) { return !partner.member.peerInfo.internalAs; })
            .map(function (p) { return _this.removePartner(p); });
    };
    Partnership.prototype.removePartner = function (partner) {
        if (this.isInPartnerById(partner.guid)) {
            this.removeInPartner(partner.guid);
            partner.dispatcher.sendClose(PartnershipCloseType.OUT);
        }
        if (this.isOutPartnerById(partner.guid)) {
            this.removeOutPartner(partner);
        }
    };
    Partnership.prototype.removeOutPartner = function (partner) {
        this.logger.debug(this.loggerId + 'OUT PRT REMOVED ' + partner.guid);
        this.outPartners.delete(partner.guid);
        partner.dispatcher.sendClose(PartnershipCloseType.IN);
    };
    return Partnership;
}(BasePartnership_1.BasePartnership));
exports.Partnership = Partnership;
//# sourceMappingURL=Partnership.js.map

/***/ }),

/***/ "../../../core/build/core/src/webrtc/partnership/locality/LocalityScore.js":
/*!**************************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/webrtc/partnership/locality/LocalityScore.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.LocalityScore = void 0;
var LocalityScore = /** @class */ (function () {
    function LocalityScore() {
    }
    LocalityScore.prototype.setValue = function (value) {
        this.value = value;
    };
    LocalityScore.prototype.getValue = function () {
        return this.value;
    };
    LocalityScore.prototype.setNetworkRange = function (networkRange) {
        this.networkRange = networkRange;
    };
    LocalityScore.prototype.getNetworkRange = function () {
        return this.networkRange;
    };
    return LocalityScore;
}());
exports.LocalityScore = LocalityScore;
//# sourceMappingURL=LocalityScore.js.map

/***/ }),

/***/ "../../../core/build/core/src/webrtc/partnership/locality/NetworkRangeLocalityScore.js":
/*!**************************************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/webrtc/partnership/locality/NetworkRangeLocalityScore.js ***!
  \**************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.NetworkRangeLocalityScore = exports.NetworkRange = void 0;
var PeerConstants_1 = __webpack_require__(/*! ../../PeerConstants */ "../../../core/build/core/src/webrtc/PeerConstants.js");
var HashMap = __webpack_require__(/*! @hivestreaming/collections/map */ "../../../node_modules/@hivestreaming/collections/map.js");
var Utils_1 = __webpack_require__(/*! ../../../core/Utils */ "../../../core/build/core/src/core/Utils.js");
var DiscoveryInfo_1 = __webpack_require__(/*! ../../discovery/DiscoveryInfo */ "../../../core/build/core/src/webrtc/discovery/DiscoveryInfo.js");
var Framework_1 = __webpack_require__(/*! ../../../core/Framework */ "../../../core/build/core/src/core/Framework.js");
var NetworkRange;
(function (NetworkRange) {
    NetworkRange[NetworkRange["random"] = 0] = "random";
    NetworkRange[NetworkRange["sameAs"] = 1] = "sameAs";
    NetworkRange[NetworkRange["samePublicIp"] = 2] = "samePublicIp";
    NetworkRange[NetworkRange["sameSite"] = 3] = "sameSite";
    NetworkRange[NetworkRange["sameSiteSameLanMask16"] = 4] = "sameSiteSameLanMask16";
    NetworkRange[NetworkRange["sameSiteSameLanMask24"] = 5] = "sameSiteSameLanMask24";
    NetworkRange[NetworkRange["udp"] = 6] = "udp";
})(NetworkRange = exports.NetworkRange || (exports.NetworkRange = {}));
/**
 * This class calculates the members locality score
 * Members are split in different LocalityClass
 * Members in the same LocalityClass have the same probability to be selected
 * Each LocalityClass has a different probability defined in PeerConstants.LocalityScore
 * When a member is added we set its LocalityClass
 */
var NetworkRangeLocalityScore = /** @class */ (function () {
    function NetworkRangeLocalityScore() {
    }
    NetworkRangeLocalityScore.prototype.init = function (swarm) {
        this.connectivityInfo = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.PEER_CONNECTIVITY_INFO);
    };
    NetworkRangeLocalityScore.prototype.updateView = function () {
    };
    NetworkRangeLocalityScore.prototype.computeBatchLocalityScores = function (candidates, log) {
        var _this = this;
        var networkRangeSize = new HashMap();
        candidates.forEach(function (candidate) {
            var memberNetworkRange = candidate.getLocalityScore().getNetworkRange();
            var currentSize = networkRangeSize.get(memberNetworkRange);
            if (Utils_1.isSet(currentSize)) {
                currentSize++;
            }
            else {
                currentSize = 1;
            }
            networkRangeSize.set(memberNetworkRange, currentSize);
        });
        candidates.forEach(function (candidate) {
            var memberNetworkRange = candidate.getLocalityScore().getNetworkRange();
            var rangeSize = networkRangeSize.get(memberNetworkRange);
            var rangeProbability = _this.networkRangeToProbability(memberNetworkRange);
            var score = rangeProbability / rangeSize;
            candidate.getLocalityScore().setValue(score);
        });
    };
    NetworkRangeLocalityScore.prototype.networkRangeToProbability = function (networkRange) {
        switch (networkRange) {
            case NetworkRange.udp:
                return PeerConstants_1.PeerConstants.LocalityScores.UDP_BROADCAST_CLASS;
            case NetworkRange.sameSiteSameLanMask24:
                return PeerConstants_1.PeerConstants.LocalityScores.SAME_SITE_SAME_LAN_MASK_24_CLASS;
            case NetworkRange.sameSiteSameLanMask16:
                return PeerConstants_1.PeerConstants.LocalityScores.SAME_SITE_SAME_LAN_MASK_16_CLASS;
            case NetworkRange.sameSite:
                return PeerConstants_1.PeerConstants.LocalityScores.SAME_SITE_CLASS;
            case NetworkRange.samePublicIp:
                return PeerConstants_1.PeerConstants.LocalityScores.SAME_PUBLIC_IP_CLASS;
            case NetworkRange.sameAs:
                return PeerConstants_1.PeerConstants.LocalityScores.SAME_AS_CLASS;
            case NetworkRange.random: {
                return PeerConstants_1.PeerConstants.LocalityScores.RANDOM_CLASS;
            }
        }
    };
    NetworkRangeLocalityScore.prototype.peerNetworkRange = function (peerInfo) {
        // extract first 3 octets
        var privateIp = this.connectivityInfo.getNetworkInfo().getPrivateIp();
        var privateIpRangeNetMask24 = privateIp === null || privateIp === void 0 ? void 0 : privateIp.split('.').slice(0, 3).join('.');
        // extract first 2 octets
        var privateIpRangeNetMask16 = privateIp === null || privateIp === void 0 ? void 0 : privateIp.split('.').slice(0, 2).join('.');
        var mySiteId = this.connectivityInfo.getNetworkInfo().getSiteId();
        var publicIp = this.connectivityInfo.getNetworkInfo().getPublicIp();
        var myAsId = this.connectivityInfo.getNetworkInfo().getExternalAsId();
        if (peerInfo.type === DiscoveryInfo_1.DiscoveryType.UDP) {
            // The UDP info has higher priority than every other information because it means the peer was discovered via UDP broadcast.
            // Hence it lays in the same LAN.
            return NetworkRange.udp;
        }
        else {
            if (mySiteId > 0 && mySiteId === peerInfo.internalAs) {
                // Peer has the same site, if the private ips start with the same 2 octets we assume it lays in the same LAN
                if (Utils_1.isSet(peerInfo.privateIpString)) {
                    if (peerInfo.privateIpString.startsWith(privateIpRangeNetMask24)) {
                        return NetworkRange.sameSiteSameLanMask24;
                    }
                    if (peerInfo.privateIpString.startsWith(privateIpRangeNetMask16)) {
                        return NetworkRange.sameSiteSameLanMask16;
                    }
                    // THe first 2 private ips octets differ. Only thing we can say is that peers are in the same site
                }
                return NetworkRange.sameSite;
            }
            else if (Utils_1.isSet(publicIp) && publicIp === peerInfo.publicIpString) {
                // The public ips match but there is no site assigned
                return NetworkRange.samePublicIp;
            }
            else if (myAsId > 0 && myAsId === peerInfo.externalAs) {
                // Peers are in the same autonomus system
                return NetworkRange.sameAs;
            }
        }
        // Every previous check failed, so we consider this peer just random
        return NetworkRange.random;
    };
    NetworkRangeLocalityScore.prototype.computeMemberLocalityScore = function (member) {
        var networkRange = this.peerNetworkRange(member.peerInfo);
        member.getLocalityScore().setNetworkRange(networkRange);
    };
    return NetworkRangeLocalityScore;
}());
exports.NetworkRangeLocalityScore = NetworkRangeLocalityScore;
//# sourceMappingURL=NetworkRangeLocalityScore.js.map

/***/ }),

/***/ "../../../core/build/core/src/webrtc/partnership/policies/BasePartnerSelection.js":
/*!*********************************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/webrtc/partnership/policies/BasePartnerSelection.js ***!
  \*********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseInPartnerSelection = void 0;
var InPartnerUpdate_1 = __webpack_require__(/*! ../InPartnerUpdate */ "../../../core/build/core/src/webrtc/partnership/InPartnerUpdate.js");
var PeerConstants_1 = __webpack_require__(/*! ../../PeerConstants */ "../../../core/build/core/src/webrtc/PeerConstants.js");
var Framework_1 = __webpack_require__(/*! ../../../core/Framework */ "../../../core/build/core/src/core/Framework.js");
var logger_hive_1 = __webpack_require__(/*! ../../../common/logger.hive */ "../../../core/build/core/src/common/logger.hive.js");
var ErrorCodes = __webpack_require__(/*! ../../../common/error.hive */ "../../../core/build/core/src/common/error.hive.js");
var BaseInPartnerSelection = /** @class */ (function () {
    function BaseInPartnerSelection() {
        this.baseLoggerId = '[BaseInPartnerSelection] ';
        this.logger = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.LOGGER).log();
    }
    BaseInPartnerSelection.prototype.init = function (swarm) {
        this.nodeInfo = swarm.nodeInfo;
    };
    BaseInPartnerSelection.prototype.updateIn = function (inSlots, partners, candidates) {
        try {
            var membersToAdd = [];
            var partnersToRemove = [];
            // Calculate the number of partners that need to be removed and the number of partners that need to be added
            var substituteThreshold = Math.round(inSlots * (1 - PeerConstants_1.PeerConstants.Overlay.InPartnerReplacementRatio));
            var sizeToRemove = Math.max(partners.length - substituteThreshold, 0);
            var sizeToAdd = inSlots - partners.length + sizeToRemove;
            // -------------- find partners to remove
            if (sizeToRemove > 0) {
                // make a copy of the array to pick the elements to remove excluding the one currently in use
                var notInUse = partners.filter(function (partner) { return !partner.dispatcher.transport.inUse(); });
                var timeNow_1 = Framework_1.Framework.time();
                // make a copy of the partners that are not in used right now and we have established a partnership with them for more than CHOCKING_RANGE time
                var inChockingRange = notInUse.filter(function (partner) { return ((timeNow_1 - partner.partnershipStartedTs) > PeerConstants_1.PeerConstants.PartnershipConstants.CHOCKING_RANGE); });
                var actualSizeToRemove = Math.min(inChockingRange.length, sizeToRemove);
                partnersToRemove = this.selectPartnersToRemove(actualSizeToRemove, inChockingRange);
                // temp logging
                var partnerKeys_1 = [];
                var successScore_1 = [];
                partnersToRemove.forEach(function (partner) {
                    partnerKeys_1.push(partner.guid);
                    successScore_1.push(partner.scoreUpdaterIn.getSuccessScore(false));
                });
                // console.log("[" + this.type + "] Pending partners " + pending.length + " sampled members " + sampledMembers.length);
                // console.log("Partners to remove [" + sizeToRemove + "] " + partnerKeys.length + " [" + partnerKeys.join(',') + "] with values [" + successScore.join(',') + "]");
            }
            // ------------- find members to add
            if (sizeToAdd > 0) {
                membersToAdd = this.selectPartnersToAdd(sizeToAdd, candidates);
            }
            // -------------  return the update object
            this.logger.debug(this.baseLoggerId + (" ADD/REMOVE: " + sizeToAdd + "/" + sizeToRemove + " [" + membersToAdd.map(function (m) { return m.peerInfo.guid.substring(0, 8); }) + "/" + partnersToRemove.map(function (p) { return p.guid.substring(0, 8); }) + "] Parners:[" + partners.map(function (p) { return p.guid.substring(0, 8); }) + "] Members:[" + candidates.map(function (m) { return m.peerInfo.guid.substring(0, 8); }) + "]"));
            return new InPartnerUpdate_1.InPartnerUpdate(membersToAdd, partnersToRemove);
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error updating in partners', this.baseLoggerId, ErrorCodes.BASE_PARTNER_SELECTION_CODES.UPDATE_IN_PARTNERS, error);
            return new InPartnerUpdate_1.InPartnerUpdate([], []);
        }
    };
    return BaseInPartnerSelection;
}());
exports.BaseInPartnerSelection = BaseInPartnerSelection;
//# sourceMappingURL=BasePartnerSelection.js.map

/***/ }),

/***/ "../../../core/build/core/src/webrtc/partnership/policies/LocalityPartnerSelection.js":
/*!*************************************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/webrtc/partnership/policies/LocalityPartnerSelection.js ***!
  \*************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.LocalityInPartnerSelection = void 0;
var BasePartnerSelection_1 = __webpack_require__(/*! ./BasePartnerSelection */ "../../../core/build/core/src/webrtc/partnership/policies/BasePartnerSelection.js");
var PeerConstants_1 = __webpack_require__(/*! ../../PeerConstants */ "../../../core/build/core/src/webrtc/PeerConstants.js");
var ScoreComparator_1 = __webpack_require__(/*! ./ScoreComparator */ "../../../core/build/core/src/webrtc/partnership/policies/ScoreComparator.js");
var Framework_1 = __webpack_require__(/*! ../../../core/Framework */ "../../../core/build/core/src/core/Framework.js");
var ErrorCodes = __webpack_require__(/*! ../../../common/error.hive */ "../../../core/build/core/src/common/error.hive.js");
var logger_hive_1 = __webpack_require__(/*! ../../../common/logger.hive */ "../../../core/build/core/src/common/logger.hive.js");
var CustomSnapshotProvider_1 = __webpack_require__(/*! ../../../stats/CustomSnapshotProvider */ "../../../core/build/core/src/stats/CustomSnapshotProvider.js");
/**
 * In parter selection usign the Locality Score comparator.
 * We remove the in partner with the worst score
 * We add members based on their locality score
 */
var LocalityInPartnerSelection = /** @class */ (function (_super) {
    __extends(LocalityInPartnerSelection, _super);
    function LocalityInPartnerSelection() {
        var _this = _super.call(this) || this;
        _this.scoreLoggerId = '[Score Partner Selection] ';
        _this.type = 'Locality';
        return _this;
    }
    LocalityInPartnerSelection.prototype.init = function (swarm) {
        _super.prototype.init.call(this, swarm);
        this.localityScore = swarm.localityScore;
    };
    LocalityInPartnerSelection.prototype.selectPartnersToRemove = function (numberOfPartners, candidates) {
        try {
            candidates.sort(ScoreComparator_1.ScoreInComparator.myComparator);
            return candidates.slice(0, numberOfPartners);
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error selecting partners to remove', this.scoreLoggerId, ErrorCodes.SCORE_PARTNER_SELECTION_CODES.SELECT_PARTNERS_TO_REMOVE, error);
            return [];
        }
    };
    /**
     * Probabilistic selection of members to add as partners based on their locality
     * score. The higher the score, the higher the chances for a member to be selected.
     *
     * The algorithm is called Roulette Wheel Selection :
     * https://en.wikipedia.org/wiki/Fitness_proportionate_selection
     *
     * Description:
     *  - First we filter out already active or pending peers.
     *  - Calculate the sum of all members locality score, which is their relative
     *  probability to be select
     *  - Pick a uniformly random number between 0 and cumulative probability and we
     *  use that as the index of the member to be added
     *  - Repeat the picking process until we have enough are selected or no more members
     */
    LocalityInPartnerSelection.prototype.selectPartnersToAdd = function (numberOfPartners, candidates) {
        try {
            if (candidates.length > 0) {
                // update the locality score view
                this.localityScore.updateView();
                // recompute locality score for all the members
                this.localityScore.computeBatchLocalityScores(candidates);
                var membersToAdd = [];
                // find the sum of all locality scores
                var totalScores_1 = 0;
                var nonZeroScores_1 = 0;
                candidates.forEach(function (m) {
                    totalScores_1 += m.getLocalityScore().getValue();
                    if (m.getLocalityScore().getValue() > 0)
                        nonZeroScores_1++;
                });
                if (nonZeroScores_1 === 0) {
                    this.logger.warn('All candidates have probability zero to be picked for partnership');
                }
                // TODO UNIT TESTS
                // try to fill up the membersToAdd
                while (candidates.length > 0 && membersToAdd.length < numberOfPartners) {
                    // pick a random number between 0 and the total score and
                    // then find which member does it correspond to
                    var rndPick = Framework_1.Framework.random() * totalScores_1;
                    var cumulativeScore = 0;
                    for (var i = 0; i < candidates.length; i++) {
                        var currentMember = candidates[i];
                        if (cumulativeScore <= rndPick && rndPick <= cumulativeScore + currentMember.getLocalityScore().getValue()) {
                            // found the member we pick him out and update the totalScore
                            membersToAdd.push(currentMember);
                            totalScores_1 -= currentMember.getLocalityScore().getValue();
                            candidates.splice(i, 1);
                            break;
                        }
                        // increase the cumulative score for the next member
                        cumulativeScore += currentMember.getLocalityScore().getValue();
                    }
                }
                if (PeerConstants_1.PeerConstants.CustomSnaps.LOCAL_SCORE) {
                    // send custom snapshot containing the number of members to pick from,
                    // the scores of the picked ones and those of the non picked ones
                    // sort the filtered members by descending locality score for simplicity
                    candidates.sort(function (a, b) {
                        return b.getLocalityScore().getValue() - a.getLocalityScore().getValue();
                    });
                    var customData = {
                        'timestamp': Framework_1.Framework.time(),
                        'membersToAdd': membersToAdd.map(function (m) { return [m.peerInfo.guid, m.getLocalityScore().getValue(), m.getLocalityScore().getNetworkRange()]; }),
                        'candidates': candidates.map(function (m) { return [m.peerInfo.guid, m.getLocalityScore().getValue(), m.getLocalityScore().getNetworkRange()]; })
                    };
                    CustomSnapshotProvider_1.CustomSnapshotProvider.appendAndFlush(null, null, 'local_score', this.nodeInfo.getReportingGuid(), customData, 6);
                }
                return membersToAdd;
            }
            else {
                return [];
            }
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error selecting partners to add', this.scoreLoggerId, ErrorCodes.SCORE_PARTNER_SELECTION_CODES.SELECT_PARTNERS_TO_ADD, error);
            return [];
        }
    };
    return LocalityInPartnerSelection;
}(BasePartnerSelection_1.BaseInPartnerSelection));
exports.LocalityInPartnerSelection = LocalityInPartnerSelection;
//# sourceMappingURL=LocalityPartnerSelection.js.map

/***/ }),

/***/ "../../../core/build/core/src/webrtc/partnership/policies/PrefetcherPartnerSelection.js":
/*!***************************************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/webrtc/partnership/policies/PrefetcherPartnerSelection.js ***!
  \***************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ThroughputPartnerSelection = exports.DeltaPartnerSelection = void 0;
__webpack_require__(/*! hivejs-protocol/services/new_tracker_types */ "../../../protocol/services/new_tracker_types.js");
var HashMap = __webpack_require__(/*! @hivestreaming/collections/map */ "../../../node_modules/@hivestreaming/collections/map.js");
var InPartnerUpdate_1 = __webpack_require__(/*! ../InPartnerUpdate */ "../../../core/build/core/src/webrtc/partnership/InPartnerUpdate.js");
var PeerConstants_1 = __webpack_require__(/*! ../../PeerConstants */ "../../../core/build/core/src/webrtc/PeerConstants.js");
var Framework_1 = __webpack_require__(/*! ../../../core/Framework */ "../../../core/build/core/src/core/Framework.js");
var Utils = __webpack_require__(/*! ../../../core/Utils */ "../../../core/build/core/src/core/Utils.js");
var ScoreComparator_1 = __webpack_require__(/*! ./ScoreComparator */ "../../../core/build/core/src/webrtc/partnership/policies/ScoreComparator.js");
var ErrorCodes = __webpack_require__(/*! ../../../common/error.hive */ "../../../core/build/core/src/common/error.hive.js");
var logger_hive_1 = __webpack_require__(/*! ../../../common/logger.hive */ "../../../core/build/core/src/common/logger.hive.js");
var NOT_USEFUL_PARTNER_TAG = 'NOT_USEFUL_PARTNER';
var DeltaPartnerSelection = /** @class */ (function () {
    function DeltaPartnerSelection() {
        this.deltaLoggerId = '[Delta Partner Selection] ';
    }
    DeltaPartnerSelection.prototype.init = function (swarm) {
        this.connectivityInfo = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.PEER_CONNECTIVITY_INFO);
        this.nodeInfo = swarm.nodeInfo;
    };
    /**
     * This function selects the partners that need to be removed and the members that need to be added.
     * Selection process is based on the delta value of each peer.
     * This function is applied only for the FIRST or SECOND TIER PREFETCHER peers.
     * @param inSlots
     * @param partners
     * @param candidates
     * @returns {InPartnerUpdate}
     */
    DeltaPartnerSelection.prototype.updateIn = function (inSlots, partners, candidates) {
        try {
            var membersToAdd = [];
            var partnersToRemove = [];
            // Calculate the number of partners that need to be removed and the number of partners that need to be added
            var substituteThreshold = Math.round(inSlots * (1 - PeerConstants_1.PeerConstants.Overlay.InPartnerReplacementRatio));
            var sizeToRemove = Math.max(partners.length - substituteThreshold, 0);
            var sizeToAdd = inSlots - partners.length + sizeToRemove;
            // find partners to remove
            if (sizeToRemove > 0) {
                // make a copy of the array to pick the elements to remove excluding the one currently in use
                var notInUse = partners.filter(function (partner) { return !partner.dispatcher.transport.inUse(); });
                var timeNow_1 = Framework_1.Framework.time();
                // make a copy of the partners that are not in used right now and we have established a partnership with them for more than CHOCKING_RANGE time
                var inChockingRange = notInUse.filter(function (partner) { return ((timeNow_1 - partner.partnershipStartedTs) > PeerConstants_1.PeerConstants.PartnershipConstants.CHOCKING_RANGE); });
                var actualSizeToRemove = Math.min(inChockingRange.length, sizeToRemove);
                // We select partners that have really low score.
                // Moreover, we select partners that are FIRST/SECOND TIER PREFETCHERS but
                // their delta is lower than mine, which means that the fragments that they are prefetching
                // are behind my prefetching ones. As such, I cannot prefetch from them because they prefetch from me.
                partnersToRemove = this.selectPartnersToRemove(actualSizeToRemove, inChockingRange);
                // Since we also select to remove partners that are prefetching slower than me,
                // we need to update the number of partners that we need to add.
                if (partnersToRemove.length > actualSizeToRemove) {
                    sizeToAdd += (partnersToRemove.length - actualSizeToRemove);
                }
                var partnerKeys_1 = [];
                var successScore_1 = [];
                partnersToRemove.forEach(function (partner) {
                    partnerKeys_1.push(partner.guid);
                    successScore_1.push(partner.scoreUpdaterIn.getSuccessScore(false));
                });
            }
            // find members to add
            if (sizeToAdd > 0) {
                membersToAdd = this.selectPartnersToAdd(sizeToAdd, partners, candidates);
            }
            return new InPartnerUpdate_1.InPartnerUpdate(membersToAdd, partnersToRemove);
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error updating in partners', this.deltaLoggerId, ErrorCodes.DELTA_PARTNER_SELECTION_CODES.UPDATE_IN_PARTNERS, error);
            return new InPartnerUpdate_1.InPartnerUpdate([], []);
        }
    };
    DeltaPartnerSelection.prototype.selectPartnersToRemove = function (numberOfPartners, candidates) {
        var _this = this;
        try {
            // TODO: FIRST WE SHOULD REMOVE THE BEHINDORNOTRETRIEVING QUALITY LEVEL partners and if we need more we should go based on the comparator.
            // Sort my currently not in use partners based on their in-partner score.
            candidates.sort(ScoreComparator_1.ScoreInComparator.myComparator);
            // Remove the K worst partners
            var toRemove_1 = candidates.slice(0, numberOfPartners);
            // Get the remaining partners
            var remaining = candidates.slice(numberOfPartners, candidates.length);
            // Identify the partners that either they are not prefetching my watching quality level or
            // they are prefetching my quality level but they are behind me
            remaining.forEach(function (partner) {
                if (_this.behindOrNotRetrievingQualityLevel(partner.member)) {
                    toRemove_1.push(partner);
                }
            });
            return toRemove_1;
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error selecting partners to remove', this.deltaLoggerId, ErrorCodes.DELTA_PARTNER_SELECTION_CODES.SELECT_PARTNERS_TO_REMOVE, error);
            return [];
        }
    };
    DeltaPartnerSelection.prototype.selectPartnersToAdd = function (numberOfPartners, partners, candidates) {
        var _this = this;
        try {
            // This is a set of peers that are leaders and present the same inAs as mine
            var localLeaderSet_1 = [];
            // This is a set of peers that are leaders but have different internalAs
            var leaderSet_1 = [];
            // This is a set of peers that prefetch faster than me and they are not too much ahead of me. Less than a defined threshold
            var closestSet_1 = [];
            // This is a set of peers that are prefetching slower than me or not prefetching my watching quality level at all.
            var furtherSet_1 = [];
            // I have no information about these members
            var dunnoSet_1 = [];
            var partnerGuids_1 = [];
            partners.forEach(function (partner) {
                partnerGuids_1.push(partner.guid);
            });
            // Calculate the number of wanted closest that we may need to add.
            var wantedClosest = Math.floor(numberOfPartners * PeerConstants_1.PeerConstants.PartnershipConstants.CLOSEST_RATIO);
            var myStreamsMap_1 = this.nodeInfo.getPrefetchingQualityLevels();
            // We check for each candidate on which set we should add him based on his properties.
            candidates.forEach(function (candidate) {
                var streamCharacteristics = candidate.peerInfo.streams;
                if (streamCharacteristics) {
                    var leaderDecision = _this.isLeader(candidate, streamCharacteristics, myStreamsMap_1);
                    if (leaderDecision.leader) {
                        if (leaderDecision.local)
                            localLeaderSet_1.push(candidate);
                        else
                            leaderSet_1.push(candidate);
                    }
                    else {
                        // The candidate is prefetching in front of me but he didn't reach the threshold.
                        if (!_this.aheadButBehindDelta(candidate, PeerConstants_1.PeerConstants.PartnershipConstants.STREAM_POINT_BIASED_MEMBERSIP_TOLERANCE))
                            closestSet_1.push(candidate);
                        // The candidate is prefetching slower than me or his is not prefetching my watching quality level at all.
                        // TODO: IF HE IS NOT PREFETCHING MY QUALITY LEVEL AT ALL WHY HE IS ON THE FURTHER SET?
                        // TODO: We are mixing the watching quality level and the prefetching quality levels. What if peer A is prefetcing quality levels different
                        // than my watching quality levels but i still need him in order to prefetch a quality level for a peer B in my LAN?
                        else if (!_this.behindOrNotRetrievingQualityLevel(candidate))
                            furtherSet_1.push(candidate);
                        else
                            dunnoSet_1.push(candidate);
                    }
                }
                else {
                    dunnoSet_1.push(candidate);
                }
            });
            var nonPartnerMembers = this.selectPartners(localLeaderSet_1, leaderSet_1, closestSet_1, furtherSet_1, dunnoSet_1, numberOfPartners, numberOfPartners, wantedClosest);
            return nonPartnerMembers.slice(0, Math.min(nonPartnerMembers.length, numberOfPartners));
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error selecting partners to add', this.deltaLoggerId, ErrorCodes.DELTA_PARTNER_SELECTION_CODES.SELECT_PARTNERS_TO_ADD, error);
            return [];
        }
    };
    /**
     * This function creates a list of members that will be used to create partnership. The size of the list is bigger than the actual number of members that will be selected as Partners.
     * The members are inserted in the list using topological and operational (prefetching) properties :
     * 1. First we add the members that are FIRST/Second tier prefetchers and present the same internal As with us.
     * 2. Second we add the members that are First/Second tier prefetchers but present different site definition.
     * 3. Third we add members that are not first/second tier prefetchers but they are prefetching in front of us and not too far from us (threshold defined)
     * 4. Fourth we add members that are prefetching slower than us or they are not prefetching the same quality level with us
     * 5. Fifth we add members that we could not understand their topological or operational (prefetching) properties.
     * @param localLeaderSet
     * @param leaderSet
     * @param closestSet
     * @param furtherSet
     * @param dunnoSet
     * @param numberOfPartners
     * @param fwanted
     * @param wantedClosest
     * @returns {Array<Member>}
     */
    DeltaPartnerSelection.prototype.selectPartners = function (localLeaderSet, leaderSet, closestSet, furtherSet, dunnoSet, numberOfPartners, fwanted, wantedClosest) {
        try {
            var nonPartnerMembers = [];
            // We select leaders with the same internal AS with high probability.
            var sLL = [];
            if (localLeaderSet.length > 0 && Framework_1.Framework.random() < PeerConstants_1.PeerConstants.PartnershipConstants.PARTNER_SHIP_SAME_AS_PROBABILITY) {
                localLeaderSet = Utils.shuffleArray(localLeaderSet);
                sLL = localLeaderSet.slice(0, Math.min(localLeaderSet.length, wantedClosest));
                nonPartnerMembers.push.apply(nonPartnerMembers, sLL);
                fwanted = numberOfPartners - sLL.length;
            }
            var sl = [];
            if (leaderSet.length > 0) {
                leaderSet = Utils.shuffleArray(leaderSet);
                sl = leaderSet.slice(0, Math.min(leaderSet.length, wantedClosest));
                nonPartnerMembers.push.apply(nonPartnerMembers, sl);
                fwanted = numberOfPartners - sl.length;
            }
            var sc = [];
            if (closestSet.length > 0) {
                closestSet = Utils.shuffleArray(closestSet);
                sc = closestSet.slice(0, Math.min(closestSet.length, wantedClosest));
                nonPartnerMembers.push.apply(nonPartnerMembers, sc);
                fwanted = numberOfPartners - sc.length;
            }
            var sf = null;
            if (furtherSet.length > 0) {
                furtherSet = Utils.shuffleArray(furtherSet);
                sf = furtherSet.slice(0, Math.min(furtherSet.length, fwanted));
                var num = (sc.length > 0 ? sc.length : 0) - sf.length;
                fwanted = numberOfPartners - num;
            }
            var sd = [];
            if (fwanted > 0 && dunnoSet.length > 0) {
                dunnoSet = Utils.shuffleArray(dunnoSet);
                sd = dunnoSet.slice(0, Math.min(dunnoSet.length, fwanted));
                nonPartnerMembers.push.apply(nonPartnerMembers, sd);
            }
            return nonPartnerMembers;
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error grouping partners', this.deltaLoggerId, ErrorCodes.DELTA_PARTNER_SELECTION_CODES.GROUP_PARTNERS, error);
            return [];
        }
    };
    /**
     * This function identifies if a candidate member is a leader and more particularly if
     * he has the same internal As with me.
     * @param candidate
     * @param streamCharacteristics
     * @param myStreamsMap
     * @returns {{leader: boolean, local: boolean}}
     */
    DeltaPartnerSelection.prototype.isLeader = function (candidate, streamCharacteristics, myStreamsMap) {
        try {
            var leader = false;
            var local_1 = false;
            var myInAs_1 = this.connectivityInfo.getNetworkInfo().getSiteId();
            var myExAs_1 = this.connectivityInfo.getNetworkInfo().getExternalAsId();
            var candidateStreamChars_1 = new HashMap();
            // Create a map of the candidates stream characteristics.
            streamCharacteristics.forEach(function (stream) {
                candidateStreamChars_1.set(stream.qualityLevel, stream);
            });
            // Filter out the quality levels that we don't have in common.
            var commonQualityLevels_1 = new HashMap();
            candidateStreamChars_1.forEach(function (stream, qualityLevel) {
                if (myStreamsMap.has(qualityLevel)) {
                    commonQualityLevels_1.set(qualityLevel, stream);
                }
            });
            // If we have any common quality levels.
            if (commonQualityLevels_1.keys().length > 0) {
                // We check if the candidate is prefetching at least one common quality level as a FIRST/SECOND TIER prefetcher
                // and we have the same internal AS (or external AS if no inAs)
                commonQualityLevels_1.forEach(function (stream, qualityLevel) {
                    var mySession = myStreamsMap.get(qualityLevel);
                    // TODO: This may be the same property. We need to merge it.
                    // It is too difficult to understand in the future if we use numbers.
                    if (mySession && stream.state >= 2 && mySession.type >= 1) {
                        var candidateInAs = candidate.peerInfo.internalAs;
                        var candidateExAs = candidate.peerInfo.externalAs;
                        if (myInAs_1 > 0) {
                            local_1 = myInAs_1 === candidateInAs;
                        }
                        else
                            local_1 = myExAs_1 > 0 && myExAs_1 === candidateExAs;
                    }
                });
            }
            return {
                leader: leader,
                local: local_1
            };
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error identifying if member is leader or same site', this.deltaLoggerId, ErrorCodes.DELTA_PARTNER_SELECTION_CODES.IDENTIFY_MEMBER_AS_LEADER_OR_SAME_SITE, {
                detailedError: error,
                otherGuid: candidate.peerInfo.guid
            });
            return { leader: false, local: false };
        }
    };
    DeltaPartnerSelection.prototype.aheadButBehindDelta = function (member, deltaAhead) {
        try {
            var myDelta = this.nodeInfo.getDelta();
            var myWatchingQualityLevel = this.nodeInfo.getWatchingQualityLevel();
            var otherDelta = this.getDeltaForQualityLevel(member, myWatchingQualityLevel);
            if (myDelta == 0 && otherDelta == 0)
                return false;
            if (myDelta < otherDelta) {
                return myDelta > otherDelta + deltaAhead;
            }
            return false;
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error identifying if member is ahead or behind delta', this.deltaLoggerId, ErrorCodes.DELTA_PARTNER_SELECTION_CODES.AHEAD_BUT_BEHIND_DELTA, {
                detailedError: error,
                otherGuid: member.peerInfo.guid
            });
            return false;
        }
    };
    DeltaPartnerSelection.prototype.behindOrNotRetrievingQualityLevel = function (member) {
        try {
            var myDelta = this.nodeInfo.getDelta();
            var myWatchingQualityLevel = this.nodeInfo.getWatchingQualityLevel();
            var otherDelta = this.getDeltaForQualityLevel(member, myWatchingQualityLevel);
            // TODO: CHECK WITH RICC. WHY && AND NOT ||?
            if (myDelta == 0 && otherDelta == 0) {
                return true;
            }
            // I am prefetching faster than the other partner (member).
            // So I cannot prefetch from him
            return myDelta > otherDelta;
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error identifying if member is behind or not retrieveing the same quality level', this.deltaLoggerId, ErrorCodes.DELTA_PARTNER_SELECTION_CODES.BEHIND_OR_NOT_RETRIEVING_QUALITY_LEVEL, {
                detailedError: error,
                otherGuid: member.peerInfo.guid
            });
            return false;
        }
    };
    /**
     * Get the delta of the member for a specific quality level.
     * Delta should be already reported by either the same partner or the tracker.
     * @param member
     * @returns {number}
     */
    DeltaPartnerSelection.prototype.getDeltaForQualityLevel = function (member, qualityLevel) {
        try {
            var otherStreams = member.peerInfo.streams;
            var returnDelta_1 = 0;
            if (otherStreams) {
                otherStreams.forEach(function (stream) {
                    if (stream.qualityLevel === qualityLevel.id) {
                        returnDelta_1 = stream.delta;
                    }
                });
            }
            return returnDelta_1;
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError("Error retrieving delta for member's quality level", this.deltaLoggerId, ErrorCodes.DELTA_PARTNER_SELECTION_CODES.GET_DELTA_FOR_QUALITY_LEVEL, {
                detailedError: error,
                otherGuid: member.peerInfo.guid
            });
            return 0;
        }
    };
    return DeltaPartnerSelection;
}());
exports.DeltaPartnerSelection = DeltaPartnerSelection;
var ThroughputPartnerSelection = /** @class */ (function () {
    function ThroughputPartnerSelection() {
        this.loggerId = '[Throughput Partner Selection] ';
        this.logger = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.LOGGER).log();
    }
    /**
     * This function returns the partner that we should close partnership.
     * Since this operation is applied by FIRST/SECOND Tier prefetchers we
     * want to remove partners that we are not useful for and add a new Partner instead
     * @param myPeerInfo
     * @param otherPeerInfo
     * @param outPartners
     * @returns {any}
     */
    ThroughputPartnerSelection.prototype.updateOut = function (myPeerInfo, otherPeerInfo, outPartners) {
        var _this = this;
        try {
            this.nodeInfo = myPeerInfo;
            var myPrefetchStreamsMap_1 = this.nodeInfo.getPrefetchingQualityLevels();
            var otherStreamChars = otherPeerInfo.streams;
            if (otherStreamChars) {
                // make a copy of the array to pick the elements to remove excluding the one currently in use
                var notInUse = outPartners.filter(function (partner) { return !partner.dispatcher.transport.inUse(); });
                var timeNow_2 = Framework_1.Framework.time();
                // make a copy of the partners that are not in used right now and we have established a partnership with them for more than CHOCKING_RANGE time
                var inChockingRange = notInUse.filter(function (partner) { return ((timeNow_2 - partner.partnershipStartedTs) > PeerConstants_1.PeerConstants.PartnershipConstants.CHOCKING_RANGE); });
                // Calculate the stream characteristics that I have in common with the new peer info
                var intersectedStreams = otherStreamChars.filter(function (stream) {
                    return myPrefetchStreamsMap_1.has(stream.qualityLevel);
                });
                // If we have no common stream characteristic then we should not allow
                // to add him and we don't need to remove any existing partner
                if (intersectedStreams.length == 0) {
                    return null;
                }
                // We index our current partners based on the quality level that each partner is watching
                var indexPartners_1 = this.indexPartners(inChockingRange);
                // Get a Partner who is watching a quality level and I am not prefetching it.
                var foundFromNonUseful = this.getWorstPartnerFromUnknownQualityLevel(myPrefetchStreamsMap_1, indexPartners_1);
                if (foundFromNonUseful) {
                    return foundFromNonUseful;
                }
                // We calculate the maximum number of partners that we should maintain per quality level
                var numberOfPrefetchedStreams = myPrefetchStreamsMap_1.keys().length;
                var maxSize = inChockingRange.length;
                var maxPerQualityLevel = Math.round(maxSize / numberOfPrefetchedStreams);
                // We calculate the quality levels and their relevant partners that we are also prefetching.
                var usefulQualityLevelKeys = indexPartners_1.keys().filter(function (qualityLevel) {
                    return myPrefetchStreamsMap_1.has(qualityLevel);
                });
                var usefulQualityLevels_1 = new HashMap();
                usefulQualityLevelKeys.forEach(function (qualityLevel) {
                    usefulQualityLevels_1.set(qualityLevel, indexPartners_1.get(qualityLevel));
                });
                var candidateToRemove_1 = null;
                // We return the partner of the quality level with the most partners (that exceeds the maxPerQualityLevel)
                candidateToRemove_1 = this.getPeerForQualityLevelInExcess(usefulQualityLevels_1, maxPerQualityLevel);
                if (candidateToRemove_1 != null) {
                    return candidateToRemove_1;
                }
                // No quality level has more partners than the maxPerQualityLevel threshold.
                // As such we iterate on each stream to find the partner who we didn't contribute at all.
                otherStreamChars.forEach(function (stream) {
                    var partners = usefulQualityLevels_1.get(stream.qualityLevel);
                    if (partners != null) {
                        // We get the partners who we didn't contribute at all.
                        var nonUsedPartners = _this.filterOutUsed(partners);
                        // TODO: SORT partners based on their bandwidth
                        // If we don't have any partner we move to the next quality level
                        if (nonUsedPartners.length > 0 && (!PeerConstants_1.PeerConstants.PartnershipConstants.CHOKING_PREFETCH_USE_BW))
                            candidateToRemove_1 = nonUsedPartners[0];
                    }
                });
                if (candidateToRemove_1 != null) {
                    return candidateToRemove_1;
                }
                // We were unable to find someone to choke
                return null;
            }
            else {
                return null;
            }
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error selecting partner to update out', this.loggerId, ErrorCodes.THROUGHPUT_PARTNER_SELECTION_CODES.UPDATE_OUT_PARTNERS, error);
            return null;
        }
    };
    /**
     * We create a hashmap with quality level as key and a list of partners for each quality level as value
     * @param outPartners
     * @returns {HashMap<number, Partner[]>}
     */
    ThroughputPartnerSelection.prototype.indexPartners = function (outPartners) {
        var indexPartners = new HashMap();
        outPartners.forEach(function (partner) {
            // We grab the watching quality level for each partner.
            var watchingQualityLevel = partner.member.peerInfo.watchingQualityLevel;
            var qualityLevel = watchingQualityLevel ? watchingQualityLevel.id : null;
            if (!qualityLevel) {
                qualityLevel = NOT_USEFUL_PARTNER_TAG;
            }
            if (indexPartners.has(qualityLevel)) {
                var partnerList = indexPartners.get(qualityLevel);
                partnerList.push(partner);
                indexPartners.set(qualityLevel, partnerList);
            }
            else {
                indexPartners.set(qualityLevel, [partner]);
            }
        });
        return indexPartners;
    };
    /**
     * We create a list of partners that we never sent them any fragment.
     * Poor guys. We were useless for them. :)
     * @param partnerList
     * @returns {Partner[]}
     */
    ThroughputPartnerSelection.prototype.filterOutUsed = function (partnerList) {
        return partnerList.filter(function (partner) {
            var amountTransfered = partner.scoreUpdaterOut.getAmountTransfered(PeerConstants_1.PeerConstants.PerfMetrics.TRANSFER_OBSERVATION_WINDOW);
            if (amountTransfered == 0) {
                return partner;
            }
        });
    };
    ThroughputPartnerSelection.prototype.getPeerForQualityLevelInExcess = function (indexPartners, maxPerQualityLevel) {
        var entryList = [];
        indexPartners.forEach(function (partnerList, qualityLevel) {
            entryList.push({ qualityLevel: qualityLevel, count: partnerList.length });
        });
        entryList.sort(function (e1, e2) {
            return e1.count > e2.count ? 1 : e1.count < e2.count ? 0 : -1;
        });
        var peerInExcess = null;
        entryList.forEach(function (entry) {
            var count = indexPartners.get(entry.qualityLevel).length;
            if (count > maxPerQualityLevel) {
                var list = indexPartners.get(entry.qualityLevel);
                if (list.length > 0) {
                    list.sort(ScoreComparator_1.ScoreOutComparator.myComparator);
                    peerInExcess = list[0];
                }
            }
        });
        return peerInExcess;
    };
    /**
     * This function identifies the partner which is watching a quality level that we are not prefetching.
     * Moreover, it selects the partner which we didn't contribute at all.
     * @param myPrefetchStreams
     * @param indexPartners
     * @returns {null}
     */
    ThroughputPartnerSelection.prototype.getWorstPartnerFromUnknownQualityLevel = function (myPrefetchStreams, indexPartners) {
        var _this = this;
        var nonUsefulPartner = null;
        // We check if we have any partner that we don't know his watching quality level.
        // If we have partners with quality level NOT_USEFUL_PARTNER_TAG we remove one of them.
        if (indexPartners.has(NOT_USEFUL_PARTNER_TAG)) {
            nonUsefulPartner = indexPartners.get(NOT_USEFUL_PARTNER_TAG)[0];
        }
        else {
            // If we know the watching quality level for all of our partners,
            // we try to identify peers that changed their quality level and we don't prefetch this quality level
            var nonPrefetchingQualityLevelsMap = indexPartners.filter(function (partnerList, qualityLevel) {
                return !myPrefetchStreams.has(qualityLevel);
            });
            // If we have quality levels taht we do not prefetch we try to find the partner which we did not contribute at all
            nonPrefetchingQualityLevelsMap.forEach(function (partnerList, qualityLevel) {
                // We filter the partners that we have contributed at least with one fragment.
                var partnerNonUsed = _this.filterOutUsed(partnerList);
                if (partnerNonUsed.length > 0) {
                    // TODO: SORT THEM BASED ON BANDWIDTH
                    nonUsefulPartner = partnerNonUsed[0];
                    return;
                }
            });
        }
        return nonUsefulPartner;
    };
    return ThroughputPartnerSelection;
}());
exports.ThroughputPartnerSelection = ThroughputPartnerSelection;
//# sourceMappingURL=PrefetcherPartnerSelection.js.map

/***/ }),

/***/ "../../../core/build/core/src/webrtc/partnership/policies/ScoreComparator.js":
/*!****************************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/webrtc/partnership/policies/ScoreComparator.js ***!
  \****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ScoreOutComparator = exports.ScoreInComparator = void 0;
var ScoreInComparator = /** @class */ (function () {
    function ScoreInComparator() {
    }
    ScoreInComparator.myComparator = function (o1, o2) {
        var successScoreO1 = o1.scoreUpdaterIn.getSuccessScore(false);
        var successScore02 = o2.scoreUpdaterIn.getSuccessScore(false);
        return successScoreO1 - successScore02;
    };
    return ScoreInComparator;
}());
exports.ScoreInComparator = ScoreInComparator;
var ScoreOutComparator = /** @class */ (function () {
    function ScoreOutComparator() {
    }
    ScoreOutComparator.myComparator = function (o1, o2) {
        var successScoreO1 = o1.scoreUpdaterOut.getSuccessScore(false);
        var successScore02 = o2.scoreUpdaterOut.getSuccessScore(false);
        return successScoreO1 - successScore02;
    };
    return ScoreOutComparator;
}());
exports.ScoreOutComparator = ScoreOutComparator;
//# sourceMappingURL=ScoreComparator.js.map

/***/ }),

/***/ "../../../core/build/core/src/webrtc/partnership/policies/ScorePartnerSelection.js":
/*!**********************************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/webrtc/partnership/policies/ScorePartnerSelection.js ***!
  \**********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.ScoreOutPartnerSelection = exports.ScoreInPartnerSelection = void 0;
var BasePartnerSelection_1 = __webpack_require__(/*! ./BasePartnerSelection */ "../../../core/build/core/src/webrtc/partnership/policies/BasePartnerSelection.js");
var PeerConstants_1 = __webpack_require__(/*! ../../PeerConstants */ "../../../core/build/core/src/webrtc/PeerConstants.js");
var ScoreComparator_1 = __webpack_require__(/*! ./ScoreComparator */ "../../../core/build/core/src/webrtc/partnership/policies/ScoreComparator.js");
var Framework_1 = __webpack_require__(/*! ../../../core/Framework */ "../../../core/build/core/src/core/Framework.js");
var ErrorCodes = __webpack_require__(/*! ../../../common/error.hive */ "../../../core/build/core/src/common/error.hive.js");
var logger_hive_1 = __webpack_require__(/*! ../../../common/logger.hive */ "../../../core/build/core/src/common/logger.hive.js");
// ----------------------------------------- IN ------------------------------------------
/**
 * In parter selection usign the scoreUpdateIn comparator.
 * We remove the in partner with the worst score
 * We add members based on their locality score
 */
var ScoreInPartnerSelection = /** @class */ (function (_super) {
    __extends(ScoreInPartnerSelection, _super);
    function ScoreInPartnerSelection() {
        var _this = _super.call(this) || this;
        _this.scoreLoggerId = '[Score Partner Selection] ';
        _this.type = 'Score';
        return _this;
    }
    ScoreInPartnerSelection.prototype.selectPartnersToRemove = function (numberOfPartners, candidates) {
        try {
            candidates.sort(ScoreComparator_1.ScoreInComparator.myComparator);
            return candidates.slice(0, numberOfPartners);
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error selecting partners to remove', this.scoreLoggerId, ErrorCodes.SCORE_PARTNER_SELECTION_CODES.SELECT_PARTNERS_TO_REMOVE, error);
            return [];
        }
    };
    /**
     * pick the first random peer which is not already a partner or
     * is not pending
     */
    ScoreInPartnerSelection.prototype.selectPartnersToAdd = function (numberOfPartners, candidates) {
        try {
            // pick only the right amount
            return candidates.slice(0, numberOfPartners);
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error selecting partners to add', this.scoreLoggerId, ErrorCodes.SCORE_PARTNER_SELECTION_CODES.SELECT_PARTNERS_TO_ADD, error);
            return [];
        }
    };
    return ScoreInPartnerSelection;
}(BasePartnerSelection_1.BaseInPartnerSelection));
exports.ScoreInPartnerSelection = ScoreInPartnerSelection;
// ----------------------------------------- OUT -----------------------------------------
/**
 * Out Partner selection to be removed based on the amount of transfer sent in the last 10 seconds
 * Pick the partner to whom we sent the lowest amount
 */
var ScoreOutPartnerSelection = /** @class */ (function () {
    function ScoreOutPartnerSelection() {
        this.scoreLoggerId = '[Score Partner Selection] ';
    }
    ScoreOutPartnerSelection.prototype.updateOut = function (partners) {
        try {
            var notInUse = partners.filter(function (partner) { return !partner.dispatcher.transport.inUse(); });
            var timeNow_1 = Framework_1.Framework.time();
            // make a copy of the partners that are not in used right now and we have established a partnership with them for more than CHOCKING_RANGE time
            var inChockingRange = notInUse.filter(function (partner) { return ((timeNow_1 - partner.partnershipStartedTs) > PeerConstants_1.PeerConstants.PartnershipConstants.CHOCKING_RANGE); });
            if (inChockingRange.length > 0) {
                inChockingRange.sort(ScoreComparator_1.ScoreOutComparator.myComparator);
                // console.log(Framework.getPeerContext().id + " [OUT] [" + notInUse.map((p) => p.guid.substring(0, 8) + "(" + p.scoreUpdaterOut.getAmountTransfered(PeerConstants.PerfMetrics.TRANSFER_OBSERVATION_WINDOW) + ")") + "]")
                return inChockingRange.slice(0, 1)[0];
            }
            return null;
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error updating partners out', this.scoreLoggerId, ErrorCodes.SCORE_PARTNER_SELECTION_CODES.SELECT_UPDATE_OUT, error);
            return null;
        }
    };
    return ScoreOutPartnerSelection;
}());
exports.ScoreOutPartnerSelection = ScoreOutPartnerSelection;
//# sourceMappingURL=ScorePartnerSelection.js.map

/***/ }),

/***/ "../../../core/build/core/src/webrtc/prefetch/PrefetchRequest.js":
/*!****************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/webrtc/prefetch/PrefetchRequest.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.PrefetchRequest = void 0;
var PlayerRequest_1 = __webpack_require__(/*! ../requests/PlayerRequest */ "../../../core/build/core/src/webrtc/requests/PlayerRequest.js");
var PrefetchRequest = /** @class */ (function (_super) {
    __extends(PrefetchRequest, _super);
    function PrefetchRequest() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.internal = true;
        return _this;
    }
    return PrefetchRequest;
}(PlayerRequest_1.PlayerRequest));
exports.PrefetchRequest = PrefetchRequest;
//# sourceMappingURL=PrefetchRequest.js.map

/***/ }),

/***/ "../../../core/build/core/src/webrtc/prefetch/Prefetcher.js":
/*!***********************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/webrtc/prefetch/Prefetcher.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.VideoPrefetcher = exports.PrefetchSession = exports.PrefetchType = void 0;
var SortedArraySet = __webpack_require__(/*! @hivestreaming/collections/sorted-array-set */ "../../../node_modules/@hivestreaming/collections/sorted-array-set.js");
var HashMap = __webpack_require__(/*! @hivestreaming/collections/map */ "../../../node_modules/@hivestreaming/collections/map.js");
var HiveInternalRequest_1 = __webpack_require__(/*! ../HiveInternalRequest */ "../../../core/build/core/src/webrtc/HiveInternalRequest.js");
var Framework_1 = __webpack_require__(/*! ../../core/Framework */ "../../../core/build/core/src/core/Framework.js");
var PeerConstants_1 = __webpack_require__(/*! ../PeerConstants */ "../../../core/build/core/src/webrtc/PeerConstants.js");
var EntityType_1 = __webpack_require__(/*! ../../core/entity/EntityType */ "../../../core/build/core/src/core/entity/EntityType.js");
var DiscoveryInfo_1 = __webpack_require__(/*! ../discovery/DiscoveryInfo */ "../../../core/build/core/src/webrtc/discovery/DiscoveryInfo.js");
var logger_hive_1 = __webpack_require__(/*! ../../common/logger.hive */ "../../../core/build/core/src/common/logger.hive.js");
var ErrorCodes = __webpack_require__(/*! ../../common/error.hive */ "../../../core/build/core/src/common/error.hive.js");
var PrefetchRequest_1 = __webpack_require__(/*! ./PrefetchRequest */ "../../../core/build/core/src/webrtc/prefetch/PrefetchRequest.js");
var PrefetchType;
(function (PrefetchType) {
    // DEFAULT PrefetchType. A peer that belongs to a LAN but it is not a LAN LEADER
    PrefetchType[PrefetchType["PLAYER"] = 0] = "PLAYER";
    // SET BY THE UDPLeaderElection. A peer with PrefetchType.LAN is a LAN LEADER
    PrefetchType[PrefetchType["LAN"] = 1] = "LAN";
    // SET BY THE TRACKER
    PrefetchType[PrefetchType["SITE"] = 2] = "SITE";
})(PrefetchType = exports.PrefetchType || (exports.PrefetchType = {}));
/**
 * locality groups for partners that sent haves
 */
var HaveLocality;
(function (HaveLocality) {
    HaveLocality[HaveLocality["LAN"] = 0] = "LAN";
    HaveLocality[HaveLocality["SITE"] = 1] = "SITE";
    HaveLocality[HaveLocality["AS"] = 2] = "AS";
    HaveLocality[HaveLocality["OTHER"] = 3] = "OTHER"; // 3
})(HaveLocality || (HaveLocality = {}));
/**
 * information for each quality level prefetch task
 */
var PrefetchSession = /** @class */ (function () {
    function PrefetchSession() {
        this.missingMetadata = false;
        // This entity contains either the last downloaded entity or the last requested entity (prefetch)
        this.entity = null;
        this.prefetchDelay = -1;
        this.prefetchReward = 0;
        // If we requested an entity and we wait to be downloaded this flag is true.
        // We need this flag in order to prune prefetch attempts that will end up to the same exact entity.
        // active: boolean = false;
    }
    return PrefetchSession;
}());
exports.PrefetchSession = PrefetchSession;
var VideoPrefetcher = /** @class */ (function () {
    function VideoPrefetcher() {
        this.loggerId = '[Prefetcher] ';
        this.detailedLog = false;
        this.prefetchCounter = 0;
        this.isActive = true;
        this.delayedPrefetch = new HashMap();
        // Wantedcontent is a hashmap that contains a PrefetchSession for each quality level that we download
        // TODO: remove this from here and use the one from nodeInfo??
        this.wantedContent = new HashMap();
    }
    VideoPrefetcher.prototype.init = function (swarm) {
        this.logger = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.LOGGER).log(swarm.sessionId);
        this.connectivityInfo = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.PEER_CONNECTIVITY_INFO);
        this.objIdx = swarm.objectIndex;
        this.hiveCache = swarm.hiveCache;
        this.p2pRequester = swarm.p2pRequester;
        this.cache = swarm.cache;
        this.pluginId = swarm.reportingInstance.ticket.pluginId;
        this.nodeInfo = swarm.nodeInfo;
        this.partnership = swarm.partnership;
        this.prefetchManager = swarm.prefetchManager;
        this.chunkHandler = swarm.chunkHandler;
    };
    VideoPrefetcher.prototype.activate = function () {
        this.isActive = true;
    };
    /**
     * his function is used by the VideoContextBase when the videocontext is initialized.
     * This means that we have all the proper video context information, like manifest, quality level etc and we are able to prefetch
     * when needed and only when prefetcherManager configures the proper quality levels that we need to prefetch
     * @param context
     * @param videoContext
     */
    VideoPrefetcher.prototype.initContext = function (context, videoContext) {
        this.context = context;
        this.videoContext = videoContext;
        this.prefetchManager.initContext(videoContext);
    };
    /**
     * check whether we have a prefetch session for a certain quality level or not
     */
    VideoPrefetcher.prototype.hasQualityLevelAssigned = function (qualityLevel) {
        return this.wantedContent.has(qualityLevel.id);
    };
    VideoPrefetcher.prototype.getVideoContext = function () {
        return this.videoContext;
    };
    /**
     * This function receives an array from the PrefetchManager with the quality levels that the peer is allowed to prefetch and the prefetch type for each quality level.
     * First, we make sure that we will prefetch the current player's quality level.
     * Then we exclude the quality levels that we were prefetching but we don't currently need them.
     * We update the wantedContent with the appropriate PrefetchSessions
     * @param qualityLevelsToPretetch
     * @param prefetchType
     */
    VideoPrefetcher.prototype.updatePrefetchSessions = function (qualityLevelsToPretetch, prefetchType, keepSiteQualityLevels) {
        var _this = this;
        try {
            // collect all the current prefetch quality levels
            var currentActiveQualityLevels_1 = new SortedArraySet();
            this.wantedContent.forEach(function (session, qualityLevel) {
                currentActiveQualityLevels_1.hiveAdd(qualityLevel);
            });
            // Create a sortedArraySet. Just for comparison reasons.
            var wantedPrefetchQualityLevels_1 = new SortedArraySet();
            wantedPrefetchQualityLevels_1.hiveAddEach(qualityLevelsToPretetch.keys());
            // We do this check explicitly for the AMP. When we have AMP  + UDP leader election enabled
            // we have a race condition where we try to prefetch from another guy without even having information...
            // TODO: check with Riccardo about this. Could we be a little bit more clever? Not so important though
            if (this.videoContext.lastPlayerRequest()) {
                var playerQualityLevel = this.videoContext.lastPlayerRequest().getQualityLevel();
                wantedPrefetchQualityLevels_1.hiveAdd(playerQualityLevel.id);
                // Calculate the quality levels that we probably want to exclude for the prefetch
                // by removing the quality levels that were defined by the qualityLevelsToPrefetch parameter
                // that we definitely need to keep.
                // For the remaining quality levels we will decide if we need to keep prefetching them depends on
                // the keepSiteQualityLevels parameter and their prefetch type reason (SITE ONLY)
                wantedPrefetchQualityLevels_1.forEach(function (qualityLevel) {
                    currentActiveQualityLevels_1.delete(qualityLevel);
                });
                if (keepSiteQualityLevels) {
                    var qualityLevelsToInclude_1 = [];
                    // We check each of the remaining quality levels if they are of prefetch type reason SITE.
                    // If the prefetch type reason is SITE we include them in the wantedPrefetchQualityLevels
                    currentActiveQualityLevels_1.forEach(function (qualityLevel) {
                        if (_this.wantedContent.has(qualityLevel) && (_this.wantedContent.get(qualityLevel).peerTypeRequested == PrefetchType.SITE)) {
                            qualityLevelsToInclude_1.push(qualityLevel);
                            wantedPrefetchQualityLevels_1.hiveAdd(qualityLevel);
                        }
                    });
                    qualityLevelsToInclude_1.forEach(function (qualityLevel) {
                        currentActiveQualityLevels_1.delete(qualityLevel);
                    });
                }
                var finalWantedPrefetchQualityLevels_1 = new HashMap();
                wantedPrefetchQualityLevels_1.forEach(function (qualityLevel) {
                    if (_this.wantedContent.has(qualityLevel)) {
                        if (_this.wantedContent.get(qualityLevel).peerTypeRequested == PrefetchType.SITE) {
                            finalWantedPrefetchQualityLevels_1.set(qualityLevel, PrefetchType.SITE);
                        }
                        else {
                            finalWantedPrefetchQualityLevels_1.set(qualityLevel, qualityLevelsToPretetch.get(qualityLevel));
                        }
                    }
                    else {
                        finalWantedPrefetchQualityLevels_1.set(qualityLevel, qualityLevelsToPretetch.get(qualityLevel));
                    }
                });
                this.removeUnWantedSessions(currentActiveQualityLevels_1);
                this.updateWantedSessions(finalWantedPrefetchQualityLevels_1, prefetchType);
            }
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error updating the prefetch sessions', this.loggerId, ErrorCodes.PREFETCHER_CODES.UPDATE_WANTED_SESSIONS, error);
        }
    };
    /**
     * This function sets the prefetching for the wanted quality levels
     * @param wantedPrefetchQualityLevels
     * @param prefetchType
     */
    VideoPrefetcher.prototype.updateWantedSessions = function (wantedPrefetchQualityLevels, prefetchType) {
        var _this = this;
        wantedPrefetchQualityLevels.forEach(function (peerRequestedType, qualityLevelId) {
            var qualityLevel = _this.videoContext.getQualityLevelTracker().get(qualityLevelId);
            if (qualityLevel) {
                _this.setPrefetchQualityLevel(qualityLevel, peerRequestedType, prefetchType);
            }
        });
    };
    /**
     * This function removes the unwanted quality levels from the wantedContent
     * @param unwantedQualityLevels
     */
    VideoPrefetcher.prototype.removeUnWantedSessions = function (unwantedQualityLevels) {
        var _this = this;
        unwantedQualityLevels.forEach(function (qualityLevelId) {
            var qualityLevel = _this.wantedContent.get(qualityLevelId).qualityLevel;
            _this.nodeInfo.removePrefetchingQualityLevel(qualityLevel);
            _this.logger.debug(_this.loggerId + 'Remove unwanted quality level ' + qualityLevelId);
            _this.wantedContent.delete(qualityLevelId);
            // TODO: make sure that a session is not readded at the end of an active download
        });
    };
    /**
     * This function checks if we have any information regarding the quality level.
     * If we already know the quality level, we update the information. Probably needed change of prefetchType
     * Otherwise we set the new quality level to the wantedContent
     * @param qualityLevel
     * @param type
     */
    VideoPrefetcher.prototype.setPrefetchQualityLevel = function (qualityLevel, peerRequestedType, type) {
        if (this.wantedContent.has(qualityLevel.id)) {
            this.configurePrefetching(qualityLevel, type);
        }
        else if (!this.wantedContent.has(qualityLevel.id)) {
            this.startPrefetching(qualityLevel, peerRequestedType, type);
        }
    };
    /**
     * This function updates the type of the prefetchSession. We only need to update
     * the prefetch type
     * @param qualityLevel
     * @param type
     */
    VideoPrefetcher.prototype.configurePrefetching = function (qualityLevel, type) {
        try {
            var session = this.wantedContent.get(qualityLevel.id);
            session.type = type;
            if (session.type != PrefetchType.SITE) {
                session.prefetchDelay = -1;
            }
            this.nodeInfo.addPrefetchingQualityLevel(qualityLevel, session);
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error configuring already existing prefetch sessions', this.loggerId, ErrorCodes.PREFETCHER_CODES.CONFIGURE_PREFETCHING, error);
        }
    };
    /**
     * This function initializes a new PrefetchSession and sets it to the wantedContent
     * @param qualityLevel
     * @param type
     */
    VideoPrefetcher.prototype.startPrefetching = function (qualityLevel, peerRequestedType, type) {
        var _this = this;
        try {
            var session = new PrefetchSession();
            session.entity = null;
            session.type = type;
            session.qualityLevel = qualityLevel;
            // session.active = false;
            session.peerTypeRequested = peerRequestedType;
            this.wantedContent.set(qualityLevel.id, session);
            this.wantedContent.forEach(function (session, qualityLevel) {
                _this.logger.debug(_this.loggerId + ' Quality Level ' + qualityLevel + ' session type ' + PrefetchType[session.type] + ' PREF reason ' + PrefetchType[session.peerTypeRequested]);
            });
            this.nodeInfo.addPrefetchingQualityLevel(qualityLevel, session);
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error constructing a new prefetch session', this.loggerId, ErrorCodes.PREFETCHER_CODES.START_PREFETCHING, error);
        }
    };
    /**
     * This function is called by the Context when a new fragment is retrieved and it tries to prefetch if possible.
     * If we receive a new fragment that we don't know its quality level, we set the prefetch quality level.
     * This is should never happen.
     * @param entity
     */
    VideoPrefetcher.prototype.fragmentRetrieved = function (entity) {
        var _this = this;
        if (this.wantedContent.has(entity.getQualityLevel().id)) {
            var wanted = this.wantedContent.get(entity.getQualityLevel().id);
            if (wanted.prefetchDelay > 0 && wanted.startReqTs) {
                // calculate the delay as fragment duration - the time it took to prefetch the last fragment
                // minus the "reward"
                wanted.prefetchDelay = entity.getDuration() - (Framework_1.Framework.time() - wanted.startReqTs) - wanted.prefetchReward;
                wanted.prefetchReward = 50;
            }
            wanted.entity = entity;
            this.initiateAttemptPrefetch(entity.getQualityLevel());
            // trigger a check for all other quality levels
            this.wantedContent.forEach(function (session, qualityLevel) {
                if (session && (session.type != PrefetchType.PLAYER) && (qualityLevel != entity.getQualityLevel().id)) {
                    _this.checkOnSession(session, _this.wantedContent.get(qualityLevel).qualityLevel);
                }
            });
        }
    };
    /**
     * This function checks if we can prefetch for this quality level.
     * If we have no entity information we request for metadata prefetch
     * Otherwise we attempt to prefetch
     * @param session
     * @param qualityLevel
     */
    VideoPrefetcher.prototype.checkOnSession = function (session, qualityLevel) {
        if (session.type != PrefetchType.PLAYER) {
            var entity = this.videoContext.lastPlayerRequest();
            if (entity != null) {
                var nextEntity = this.videoContext.getEntity(entity.getSegmentId(), qualityLevel, EntityType_1.EntityType.VIDEO);
                if (nextEntity == null) {
                    // this can happen when initiating a new prefetch session for an unknown quality level
                    this.logger.debug(this.loggerId + 'PREFETCHING ' + qualityLevel + ' MISSING METADATA ');
                    this.missingMetadata(qualityLevel);
                }
                else {
                    session.entity = nextEntity;
                    this.initiateAttemptPrefetch(nextEntity.getQualityLevel());
                }
            }
            else {
                this.logger.debug(this.loggerId + 'PLAYER NOT PLAYING ');
                this.missingMetadata(qualityLevel);
            }
        }
    };
    VideoPrefetcher.prototype.metadataForQualityLevelAvailable = function (qualityLevel) {
        var session = this.wantedContent.get(qualityLevel.id);
        if (session && session.missingMetadata) {
            if (session.entity != null) {
                this.logger.debug(this.loggerId + 'RESTART PREFETCHING ON AVAILABLE METADATA');
                session.missingMetadata = false;
                this.initiateAttemptPrefetch(session.qualityLevel);
            }
            else {
                session.missingMetadata = false;
                this.checkOnSession(session, qualityLevel);
            }
        }
    };
    /**
     * This function is triggered when the metadata are prefetched.
     * It triggers a new attempt prefetch
     * @param qualityLevel
     */
    VideoPrefetcher.prototype.metadataAvailable = function (qualityLevel) {
        var _this = this;
        if (qualityLevel) {
            this.metadataForQualityLevelAvailable(qualityLevel);
        }
        else {
            this.wantedContent.forEach(function (session, qualityLevel) {
                _this.metadataForQualityLevelAvailable(_this.wantedContent.get(qualityLevel).qualityLevel);
            });
        }
    };
    /**
     * This function checks if we have a PrefetchSession for this quality level and, if it's not active, attempts a prefetch
     * @param qualityLevel
     */
    VideoPrefetcher.prototype.initiateAttemptPrefetch = function (qualityLevel) {
        var entity = this.videoContext.lastPlayerRequest();
        if (entity) {
            var wanted = this.wantedContent.get(qualityLevel.id);
            if (wanted) {
                // We calculate the delta only for our watching quality level
                if (wanted.entity && entity.getQualityLevel().id === qualityLevel.id) {
                    var delta = this.distanceFromPlayerNumber(wanted.entity.getSegmentId(), qualityLevel);
                    this.nodeInfo.setDelta(delta);
                }
                this.attemptPrefetching(wanted);
            }
        }
        else {
            // do not warn on audio only
            var isAudioOnly = this.videoContext.availableQualityLevels(EntityType_1.EntityType.AUDIO).length > 0 && this.videoContext.availableQualityLevels(EntityType_1.EntityType.VIDEO).length === 0;
            if (!isAudioOnly) {
                logger_hive_1.ErrorMonitor.getInstance().logError('Error attempting prefetch before having a player request', this.loggerId, ErrorCodes.PREFETCHER_CODES.ATTEMPT_PREFETCH_BEFORE_PLAYER_REQUEST);
            }
        }
    };
    /**
     * This function identifies the entity that is not currently stored in the cache and we need to prefetch and
     * starts the prefetch process
     * @param wanted
     */
    VideoPrefetcher.prototype.attemptPrefetching = function (wanted) {
        if (wanted.entity) {
            var toPrefetch = this.forwardIfNecessary(wanted.entity);
            if (toPrefetch != null) {
                this.prefetch(toPrefetch, wanted);
            }
            else {
                var qualityLevel = wanted.qualityLevel;
                if (this.wantedContent.get(qualityLevel.id)) {
                    this.logger.debug(this.loggerId + 'PREFETCHING ' + qualityLevel.id + ' STOPPED BECAUSE OF MISSING METADATA ');
                }
                this.wantedContent.get(qualityLevel.id).missingMetadata = true;
                this.missingMetadata(qualityLevel);
            }
        }
        else {
            wanted.missingMetadata = true;
            this.missingMetadata(wanted.qualityLevel);
        }
    };
    /**
     * This function checks if we are allowed to prefetch.
     * If we are allowed to prefetch we calculate the required delay based on the prefetch type and call the HiveCache to proceed with the wanted fragment and HiveRequest.
     * @param toPrefetch
     * @param leader
     */
    VideoPrefetcher.prototype.prefetch = function (toPrefetch, session) {
        var _this = this;
        var ret = this.isAllowedToPrefetch(toPrefetch, session.type);
        if (ret.allowed) {
            try {
                // it can happen that we delayed a cdn prefetch and and p2p prefetch should take over
                // so we delete the pending cdn prefetch
                if (this.delayedPrefetch.has(toPrefetch.getEntityId())) {
                    Framework_1.Framework.clearTimeout(this.delayedPrefetch.get(toPrefetch.getEntityId()));
                }
                var cdnPrefefetch = (ret.type == HiveInternalRequest_1.RequestType.CDN_PREFETCH) ? true : false;
                var delay = 1;
                // p2p requests are either allowed or not, never delayed
                if (cdnPrefefetch) {
                    var aggressivePrefetchDelay = Math.max(0, session.prefetchDelay);
                    delay = this.prefetchManager.calculateDelay(session.type, toPrefetch.getQualityLevel(), toPrefetch.getSegmentId(), aggressivePrefetchDelay);
                }
                this.logger.debug(this.loggerId + 'PREFETCHING ' + toPrefetch.getUrl() + ' CDN PREFETCH ' + cdnPrefefetch + ' IN ' + delay + ' MSECS');
                // perform the request for this wanted content and the specified delay
                var wantedContent_1 = this.wantedContent.get(toPrefetch.getQualityLevel().id);
                wantedContent_1.entity = toPrefetch;
                var timeout = Framework_1.Framework.setTimeout(function () {
                    _this.delayedPrefetch.delete(toPrefetch.getEntityId());
                    var hiveRequest = new PrefetchRequest_1.PrefetchRequest(_this.pluginId);
                    hiveRequest.url = toPrefetch.getUrl();
                    wantedContent_1.startReqTs = Framework_1.Framework.time();
                    _this.prefetchCounter = 0;
                    var request = _this.hiveCache.retrieve(hiveRequest, toPrefetch, _this.context, ret.type);
                    if (request) {
                        // this is for later stats accounting
                        request.generatedByLeader = (session.type == PrefetchType.SITE) || (session.type == PrefetchType.LAN) ? true : false;
                        // handle a failure in cdn prefetch
                        hiveRequest.onerror = hiveRequest.onload = function () {
                            if (request.getRequestType() == HiveInternalRequest_1.RequestType.CDN_PREFETCH) {
                                if (!hiveRequest.status || (hiveRequest.status < 200 || hiveRequest.status > 299)) {
                                    var wantedNow = _this.wantedContent.get(toPrefetch.getQualityLevel().id);
                                    hiveRequest = null;
                                    var min = wantedNow.entity.getDuration();
                                    var max = wantedNow.entity.getDuration() + PeerConstants_1.PeerConstants.Prefetching.AGGRESSIVE_RANDOM_VALUE;
                                    var randomDelay = Math.floor(Framework_1.Framework.random() * (max - min)) + min;
                                    // on CDN error we generate a new random prefetchDelay!
                                    wantedNow.prefetchDelay = randomDelay - (Framework_1.Framework.time() - wantedNow.startReqTs);
                                    // and we reset the reward on the first request
                                    wantedNow.prefetchReward = 0;
                                    _this.initiateAttemptPrefetch(wantedNow.entity.getQualityLevel());
                                }
                            }
                        };
                    }
                }, delay);
                this.delayedPrefetch.set(toPrefetch.getEntityId(), timeout);
            }
            catch (error) {
                logger_hive_1.ErrorMonitor.getInstance().logError('Error requesting for prefetch', this.loggerId, ErrorCodes.PREFETCHER_CODES.PREFETCH_PROCESS, error);
            }
        }
    };
    /**
     * This function should be called ONLY by the PrefetcherManager.
     *
     * In this function we clear all the pending prefetches that we have scheduled and they are delayed.
     * We need to delete the delayed prefetch since it may be the following two scenarios:
     * 1.
     *  a. Prefetcher realizes that we should proceed as a P2P_PREFETCH since we have a HAVE inside the ObjectIndex.
     *  b. We add a delay to this prefetch because we exceed the limit
     *  c. We change the state of the client, so we flush the objectIndex.
     *  d. The delayed prefetch proceeds to the HiveCache and the HiveCache complains since it is a P2P_PREFETCH but we have nothing
     *    inside our ObjectIndex.
     * 2.
     *  a. We received a change state of the client from PLAY->IDLE
     *  b. Delayed request proceeds and immediately changes the state from IDLE->PLAY because the final request goes through the Peer.request
     *     and resets the request timeout.
     */
    VideoPrefetcher.prototype.clearPendingPrefetches = function () {
        var _this = this;
        this.delayedPrefetch.forEach(function (value, key) {
            _this.logger.debug(_this.loggerId + 'Clearing delayed prefetch timer id ' + value);
            Framework_1.Framework.clearTimeout(value);
            _this.delayedPrefetch.delete(key);
        });
        this.isActive = false;
    };
    /**
     * This function updates the PrefetchSession that it has missing metadata and requests for metadata prefetch
     * @param qualityLevel
     */
    VideoPrefetcher.prototype.missingMetadata = function (qualityLevel) {
        if (this.wantedContent.has(qualityLevel.id)) {
            this.wantedContent.get(qualityLevel.id).missingMetadata = true;
            this.videoContext.requestMetadata(qualityLevel);
        }
    };
    /**
     * This function forwards the wanted entity until we find the next entity to prefetch.
     * The finalSegment can be the same with the current wantedContent.entity iff
     * we attempted to prefetch and we received a 412 error.
     * @param wantedSegment
     * @returns {VideoEntityCharacteristics}
     */
    VideoPrefetcher.prototype.forwardIfNecessary = function (wantedSegment) {
        try {
            // var deferred = Q.defer<VideoEntityCharacteristics>();
            var wantedContent = this.wantedContent.get(wantedSegment.getQualityLevel().id);
            var wantedNext = wantedSegment;
            var nextSegment = null;
            var finalSegment = this.checkIfContains(wantedNext);
            if (finalSegment && finalSegment.getEntityId() != wantedSegment.getEntityId()) {
                nextSegment = finalSegment;
                return nextSegment;
            }
            else if (finalSegment && finalSegment.getEntityId() == wantedContent.entity.getEntityId()) {
                nextSegment = wantedSegment;
                return nextSegment;
            }
            else {
                return null;
            }
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error forwarding to next segment', this.loggerId, ErrorCodes.PREFETCHER_CODES.FORWARD_IF_NECESSARY, error);
            return null;
        }
    };
    /**
     * This function retrieves all the entityIds from the cache and identifies what is the next fragment that need to be prefetched.
     *
     * @param wantedSegment
     * @returns {Promise<VideoEntityCharacteristics>} the next missing segment
     */
    VideoPrefetcher.prototype.checkIfContains = function (wantedSegment) {
        if (wantedSegment == null) {
            return null;
        }
        var keys = this.cache.getKeys();
        var next = wantedSegment;
        if (keys) {
            // loop until you don't have a fragment or don't know about the next one
            while ((next != null) && (keys.indexOf(next.getEntityId()) != -1)) {
                next = this.videoContext.getNextEntity(next);
                if (!next) {
                    return next;
                }
            }
        }
        return next;
    };
    /**
     * This function checks the haves, the ReqType, the buffering property and the player distance
     * and decides if we are allowed to prefetch or not
     * @param toPrefetch
     * @param prefetchType
     * @returns {{allowed: boolean, type: RequestType}}
     */
    VideoPrefetcher.prototype.isAllowedToPrefetch = function (toPrefetch, prefetchType) {
        try {
            // 1) Available HAVEs. Check for locality
            var hasHaves = this.checkHaves(toPrefetch);
            var type = hasHaves ? HiveInternalRequest_1.RequestType.P2P_PREFETCH : HiveInternalRequest_1.RequestType.CDN_PREFETCH;
            var isAllowedByType = false;
            // We check if we already have requested to prefetch the same fragment but it is delayed.
            // In case that we have a delayed prefetch attempt from CDN we do not allow another CDN_PREFETCH attempt.
            // However, we allow to proceed if the new attempt prefetch is of type P2P_PREFETCH
            if (prefetchType != PrefetchType.PLAYER) {
                // I'm a lan/site leader, allow cdn -> p2p but not the opposite
                if (this.delayedPrefetch.has(toPrefetch.getEntityId()) && type == HiveInternalRequest_1.RequestType.CDN_PREFETCH) {
                    isAllowedByType = false;
                }
                else {
                    isAllowedByType = true;
                }
            }
            else {
                // I'm not a leader, allow only p2p prefetch
                if (type == HiveInternalRequest_1.RequestType.P2P_PREFETCH) {
                    isAllowedByType = true;
                }
                else {
                    isAllowedByType = false;
                }
            }
            // 2) not buffering
            var notBuffering = this.videoContext.canPrefetch();
            // // 3) Error Levels and Parallel requests
            // int parallelPartners = id.getType() == ContentType.VIDEO ? numSufficientParallelPartners
            //    : CacheConstants.AGENT_NUM_SUFFICIENT_PARALLEL_PARTNERS_AUDIO;
            // boolean enoughGoodPartners = notBuffering ? hasLittleError(checkHaves, parallelPartners) : false;
            // 4) Check if we are not too far ahead
            var notTooDistantFromPlayer = this.checkPlayerDistance(toPrefetch.getSegmentId(), toPrefetch.getQualityLevel(), type);
            var allowed = PeerConstants_1.PeerConstants.Prefetching.PREFETCH_ENABLED && isAllowedByType && notBuffering && notTooDistantFromPlayer.valid && this.isActive;
            // log it
            var siteLeader = (prefetchType == PrefetchType.SITE) ? true : false;
            this.logger.debug(this.loggerId + 'Check prefetch for ' + toPrefetch.getSegmentId() + ' - allowed ' + allowed + ' type ' + HiveInternalRequest_1.RequestType[type] +
                ' [HAVES:' + hasHaves + ' NOTBUFFERING:' + notBuffering + ' DISTANCE:' + notTooDistantFromPlayer.valid + '(' + notTooDistantFromPlayer.distance + ')' +
                ' LAN LEADER: ' + this.nodeInfo.isLanLeader() + ' SITE LEADER: ' + siteLeader + ']');
            // return if allowed and the type of request allowed
            return {
                allowed: allowed,
                type: type
            };
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error checking if allowed to prefetch', this.loggerId, ErrorCodes.PREFETCHER_CODES.IS_ALLOWED_TO_PREFETCH, error);
            return { allowed: false, type: HiveInternalRequest_1.RequestType.CDN_PREFETCH };
        }
    };
    /**
     * This function checks the player distance. The distance is calculated based on the number of fragments. Not msecs
     * @param segmentId
     * @param requestQualityLevel
     * @param prefetchType
     * @returns {{distance: number, valid: boolean}}
     */
    VideoPrefetcher.prototype.checkPlayerDistance = function (segmentId, requestQualityLevel, type) {
        try {
            var distance = this.videoContext.getDistanceDuration(segmentId, requestQualityLevel);
            // cdn prefetch always because we will postpone it later
            // p2p prefetch valid based on maximum prefetch distance
            if (distance <= this.videoContext.getMaximumPrefetchDistance()) {
                return { distance: distance, valid: true };
            }
            return { distance: distance, valid: false };
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error checking the player distance', this.loggerId, ErrorCodes.PREFETCHER_CODES.CHECK_PLAYER_DISTANCE, error);
            return { distance: 0, valid: false };
        }
    };
    /**
     * This function calculates the distance between the prefetch segment and the current player's segment.
     * It calculates number of fragments and not msecs.
     * @param segmentId
     * @param requestQualityLevel
     * @returns {number}
     */
    // TODO Tracker uses this function. Should this be here?
    // We have quite a few distance from player functions around the code.
    VideoPrefetcher.prototype.distanceFromPlayerNumber = function (segmentId, requestQualityLevel) {
        var lastSegmentCharacteristics = this.videoContext.lastPlayerRequest();
        if (lastSegmentCharacteristics != null) {
            var lastId = lastSegmentCharacteristics.getSegmentId();
            var distance = this.videoContext.segmentDistance(lastId, requestQualityLevel, segmentId, requestQualityLevel);
            return distance;
        }
        else {
            return -1;
        }
    };
    /**
     * This function checks if we received useful haves.
     * First divide the received haves based on locality (LAN, SITE, AS, OTHER)
     * We prefetch from a locality group only if we don't have other partners
     * in the closer locality groups.
     *
     * If enabled, it might also check that any of the partners have
     * good enough throughput to send the fragment in good time
     *
     * @param entity VideoEntityCharacteristics
     * @returns {boolean}
     */
    VideoPrefetcher.prototype.checkHaves = function (entity) {
        var entityId = entity.getEntityId();
        var duration = entity.getDuration();
        var segmentId = entity.getSegmentId();
        var qualityLevel = entity.getQualityLevel();
        if (this.objIdx.contains(entityId)) {
            var element = this.objIdx.getElement(entityId);
            var partners = this.objIdx.getPartners(entityId);
            if (partners.length >= PeerConstants_1.PeerConstants.Prefetching.MINIMUM_PARTNERS_HAVES) {
                if (PeerConstants_1.PeerConstants.Prefetching.SECOND_TIER_AGENT_ENABLED) {
                    // split the partners into locality groups
                    var haves_1 = [];
                    haves_1[HaveLocality.LAN] = [];
                    haves_1[HaveLocality.SITE] = [];
                    haves_1[HaveLocality.AS] = [];
                    haves_1[HaveLocality.OTHER] = [];
                    var mySiteId_1 = this.connectivityInfo.getNetworkInfo().getSiteId();
                    var myAsId_1 = this.connectivityInfo.getNetworkInfo().getExternalAsId();
                    partners.forEach(function (partner) {
                        if (partner.member.peerInfo.type == DiscoveryInfo_1.DiscoveryType.UDP) {
                            haves_1[HaveLocality.LAN].push(partner);
                            return;
                        }
                        var partnerSiteId = partner.member.peerInfo.internalAs;
                        if ((mySiteId_1 != 0) && partnerSiteId && (mySiteId_1 == partnerSiteId)) {
                            haves_1[HaveLocality.SITE].push(partner);
                            return;
                        }
                        if (PeerConstants_1.PeerConstants.Prefetching.EXTERNAL_AS_PREFERENCE) {
                            var partnerAsId = partner.member.peerInfo.externalAs;
                            if ((myAsId_1 != 0) && myAsId_1 === partnerAsId) {
                                haves_1[HaveLocality.AS].push(partner);
                                return;
                            }
                        }
                        if (partner.member.peerInfo.type == DiscoveryInfo_1.DiscoveryType.TRACKER) {
                            haves_1[HaveLocality.OTHER].push(partner);
                        }
                    });
                    // verify that we allow prefetch from closest partner group
                    var prefetchType = null;
                    var allowPrefetch = false;
                    var fastEnoughDownload = true;
                    // we always prefetch when HAVEs from the LAN
                    if (haves_1[HaveLocality.LAN].length > 0) {
                        prefetchType = HaveLocality.LAN;
                        allowPrefetch = true;
                    }
                    // prefetch from the same site only if LAN leader or there are no LAN partners
                    if (this.nodeInfo.isLanLeader() || !this.nodeInfo.haveLanPartners()) {
                        if (haves_1[HaveLocality.SITE].length > 0) {
                            prefetchType = HaveLocality.SITE;
                            allowPrefetch = true;
                        }
                    }
                    // prefetch from the same AS only if we don't have same site partners
                    if (!this.nodeInfo.haveSitePartners() && this.nodeInfo.haveAsPartners()) {
                        if (haves_1[HaveLocality.AS].length > 0) {
                            prefetchType = HaveLocality.AS;
                            allowPrefetch = true;
                        }
                    }
                    // prefetch from wherever only if SITE leader or there are no SITE partners.
                    // if EXTERNAL_AS_PREFERENCE is active, then there should not be AS partners either
                    if (haves_1[HaveLocality.OTHER].length > 0 && (this.nodeInfo.amISiteLeader() ||
                        (!this.nodeInfo.haveSitePartners() && (!this.nodeInfo.haveAsPartners() || !PeerConstants_1.PeerConstants.Prefetching.EXTERNAL_AS_PREFERENCE)))) {
                        prefetchType = HaveLocality.OTHER;
                        allowPrefetch = true;
                    }
                    // verify if we need to check the download time
                    if (allowPrefetch && prefetchType >= PeerConstants_1.PeerConstants.Prefetching.PREFETCH_DOWNLOAD_CHECK_MIN_LOCALITY) {
                        fastEnoughDownload = this.checkDownloadSpeed(haves_1[prefetchType], element, duration, segmentId, qualityLevel);
                    }
                    // return true only if we allow the prefetch and it's also fast enough
                    if (allowPrefetch && fastEnoughDownload) {
                        this.logger.debug('down from ' + HaveLocality[prefetchType] + ' with haves : ' + haves_1[HaveLocality.LAN].length + ' ' +
                            haves_1[HaveLocality.SITE].length + ' ' + haves_1[HaveLocality.AS].length + ' ' + haves_1[HaveLocality.OTHER].length);
                        return true;
                    }
                    else
                        return false;
                }
                return true;
            }
        }
        return false;
    };
    /**
     * verify that any of the partners can send a fragment before we go to compensation.
     * If the prefetch request is quite close to the player request, then we need to make sure that we will not compensate (downTime <= distance * 1.5)
     * Otherwise, we check if we can download the fragment in less than fragmentSize *times* 1.5
     *
     */
    // TODO: we need to improve the logic when we are close to the
    VideoPrefetcher.prototype.checkDownloadSpeed = function (partners, entity, duration, segmentId, qualityLevel) {
        var _this = this;
        return partners.some(function (p) {
            var rate = p.getRcvRatesAvg();
            if (rate > 0) {
                // measure the time in millisecond to download the fragment at the measured throughput
                // NOTE rate is already in KBps, so downtime is in milliseconds
                var downTime = (entity.size / rate);
                var distance = _this.videoContext.getDistanceDuration(segmentId, qualityLevel);
                var lessThanOneFragment = distance < duration;
                var fastEnoughDownload = false;
                if (lessThanOneFragment) {
                    fastEnoughDownload = downTime <= distance * PeerConstants_1.PeerConstants.Prefetching.PREFETCH_DOWNLOAD_CHECK_DURATION_MULTIPLIER;
                    if (_this.detailedLog) {
                        _this.logger.debug('can download from ' + p.guid + ' size: ' + entity.size + ' rate: ' + rate + ' dTime: ' + downTime + ' fDistance: ' + (distance * PeerConstants_1.PeerConstants.Prefetching.PREFETCH_DOWNLOAD_CHECK_DURATION_MULTIPLIER));
                    }
                }
                else {
                    fastEnoughDownload = downTime <= duration * PeerConstants_1.PeerConstants.Prefetching.PREFETCH_DOWNLOAD_CHECK_DURATION_MULTIPLIER;
                    if (_this.detailedLog) {
                        _this.logger.debug('can download from ' + p.guid + ' size: ' + entity.size + ' rate: ' + rate + ' dTime: ' + downTime + ' fDuration: ' + (duration * PeerConstants_1.PeerConstants.Prefetching.PREFETCH_DOWNLOAD_CHECK_DURATION_MULTIPLIER));
                    }
                }
                return fastEnoughDownload;
            }
        });
    };
    /**
     * this function upgrades a prefetch request.
     * We were prefetching a fragment (p2p or CDN), and we received a player request for that fragment.
     * So we are gonna update the reqType and, in case of p2p, add a timer for performing the rest of the transfer
     * cdn prefetch transfers already have a timer, so it's enough to upgrade the req type!
     * @param request
     * @param original
     */
    VideoPrefetcher.prototype.upgradePrefetch = function (request, original) {
        try {
            // save the reference of the previous Prefetch Hive Request so we can clean up its reference
            request.previousRequestId = request.originalRequest.id;
            // upgrade the reference of the original request of this internal request
            request.originalRequest = original;
            this.logger.debug(this.loggerId + 'UPGRADE ' + HiveInternalRequest_1.RequestType[request.getRequestType()] + ' REQ ' + request.requestNumber + ' FOR ' + request.entityCharacteristics.getEntityId());
            if (request.getRequestType() == HiveInternalRequest_1.RequestType.P2P_PREFETCH) {
                // We calculate the amount of data that we managed to retrieve as a P2P_PREFETCH in order to use it for the
                // snapshot accounting
                request.requestStats.p2pAgenTrafficSuccessQt = request.rcvMesgLength;
                // We check if the P2P_Prefetch request generation is completed and the transfer started since the initialization
                // is async due to promises check on the cache.
                // If p2pPrefetchGenerated equals true then we setTimeout of the P2PRequest and change the request type.
                // Otherwise we know that the P2P_PREFETCH request has not arrived yet at the HiveCache.p2pRequest function, and when it
                // will arrive we need to make sure it will be upgraded.
                // So as a workaround we set its type to UPPER_LAYER, so the HiveCache.p2pRequest will transform it to a normal p2p request
                // with timers and all the rest
                if (request.p2pPrefetchGenerated) {
                    request.type = HiveInternalRequest_1.RequestType.P2P;
                    // If the setRequestTimeout is false, this means that the time that we tried to set is 0 and as such we
                    // need to proceed with the CDN_COMPENSATION
                    if (!this.p2pRequester.setRequestTimeout(request)) {
                        this.p2pRequester.requestFailed(request.transferNum, 'TIMED-OUT');
                    }
                }
                else {
                    request.type = HiveInternalRequest_1.RequestType.UPPER_LAYER;
                    this.logger.debug(this.loggerId + 'THE HIVE REQ ' + request.getEntityId() + ' ARRIVED BEFORE THE P2P_PREFETCH INITIALIZED. CHANGE REQUEST TYPE TO ' + HiveInternalRequest_1.RequestType[request.getRequestType()]);
                }
            }
            else if (request.getRequestType() == HiveInternalRequest_1.RequestType.CDN_PREFETCH) {
                // upgrading a cdn prefetch
                request.type = HiveInternalRequest_1.RequestType.UPPER_LAYER;
            }
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error upgrading prefetch', this.loggerId, ErrorCodes.PREFETCHER_CODES.UPGRADE_PREFETCH, error);
        }
    };
    return VideoPrefetcher;
}());
exports.VideoPrefetcher = VideoPrefetcher;
//# sourceMappingURL=Prefetcher.js.map

/***/ }),

/***/ "../../../core/build/core/src/webrtc/prefetch/PrefetcherManager.js":
/*!******************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/webrtc/prefetch/PrefetcherManager.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.PrefetcherManager = void 0;
var Prefetcher_1 = __webpack_require__(/*! ./Prefetcher */ "../../../core/build/core/src/webrtc/prefetch/Prefetcher.js");
var HashMap = __webpack_require__(/*! @hivestreaming/collections/map */ "../../../node_modules/@hivestreaming/collections/map.js");
var SortedArraySet = __webpack_require__(/*! @hivestreaming/collections/sorted-array-set */ "../../../node_modules/@hivestreaming/collections/sorted-array-set.js");
var Utils = __webpack_require__(/*! ../../core/Utils */ "../../../core/build/core/src/core/Utils.js");
var PeerConstants_1 = __webpack_require__(/*! ../PeerConstants */ "../../../core/build/core/src/webrtc/PeerConstants.js");
var Framework_1 = __webpack_require__(/*! ../../core/Framework */ "../../../core/build/core/src/core/Framework.js");
var LocalityMode_1 = __webpack_require__(/*! ../discovery/tracker/LocalityMode */ "../../../core/build/core/src/webrtc/discovery/tracker/LocalityMode.js");
var PrefetcherManager = /** @class */ (function () {
    function PrefetcherManager() {
        this.downgradeNext = false;
    }
    PrefetcherManager.prototype.init = function (swarm) {
        this.logger = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.LOGGER).log(swarm.sessionId);
        this.connectivityInfo = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.PEER_CONNECTIVITY_INFO);
        this.nodeInfo = swarm.nodeInfo;
        this.trackerClient = swarm.trackerClient;
        this.membership = swarm.membership;
        this.prefetcher = swarm.prefetcher;
    };
    /**
     * This function is called by the Prefetcher when the videoContext has been set
     */
    PrefetcherManager.prototype.initContext = function (videoContext) {
        this.videoContext = videoContext;
    };
    /* ----------------------------------------- REMOTE ELECTION PROCESS ------------------------------------------*/
    /**
     * This function is called by the TrackerClient. When the connection to the tracker has been
     * established we are able to evaluate our prefetch status, set the proper locality mode
     * and manage the site election if we are eligible (LAN Leaders)
     */
    PrefetcherManager.prototype.initEvaluation = function () {
        this.startPeriodicPrefetchEval();
    };
    /**
     * We trigger the prefetch evaluation for all the peers.
     * If we don't have leader election enabled then every peer is equal and requests remote election
     */
    PrefetcherManager.prototype.triggerPrefetchEvaluation = function () {
        this.requestRemoteElection();
    };
    /**
     * Remote election request ONLY THE LAN LEADER OR THE PEER THAT HAS NO OTHER PEERS IN THE LAN
     * We change the locality mode for the next tracker request
     */
    PrefetcherManager.prototype.requestRemoteElection = function () {
        var siteId = this.connectivityInfo.getNetworkInfo().getSiteId();
        var localityMode = (!siteId || siteId == 0) ? LocalityMode_1.LocalityMode.AS : LocalityMode_1.LocalityMode.SITE;
        this.trackerClient.setTrackerElectionLocalityMode(localityMode);
    };
    /**
     * The Peers that are no lan leaders but they have a lan leader change their locality mode to ALL
     */
    PrefetcherManager.prototype.removeRemoteElection = function () {
        this.trackerClient.setTrackerElectionLocalityMode(LocalityMode_1.LocalityMode.ALL);
    };
    PrefetcherManager.prototype.startPeriodicPrefetchEval = function () {
        var _this = this;
        this.stopPeriodicPrefetchEval();
        this.prefetchEvaltimer = Framework_1.Framework.setInterval(function () {
            _this.triggerPrefetchEvaluation();
        }, PeerConstants_1.PeerConstants.Prefetching.FALL_AGENT_RE_EVALUATION_TIMER);
        // if the prefetcher was paused, this will restore it to active
        this.prefetcher.activate();
        this.triggerPrefetchEvaluation();
    };
    PrefetcherManager.prototype.stopPeriodicPrefetchEval = function () {
        if (this.prefetchEvaltimer)
            Framework_1.Framework.clearInterval(this.prefetchEvaltimer);
    };
    PrefetcherManager.prototype.stopScheduledPrefetches = function () {
        this.prefetcher.clearPendingPrefetches();
        this.videoContext.clearPendingRequestMetadata();
    };
    /* ------------------------------------- END OF REMOTE ELECTION PROCESS ----------------------------------------*/
    /**
     * This function is called by the UDPLeaderElection when we become LAN leaders or we step down.
     * We need this function in order to start acting as leaders or non-leaders immediately.
     * Otherwise we should wait the tracker to response in order to understand what type of
     * prefetcher are we.
     * @param isLeader
     */
    PrefetcherManager.prototype.prefetchAsLeader = function (isLeader) {
        var finalWatchedQualityLevels = new HashMap();
        if (isLeader) {
            var wantedWatchedQualityLevels = this.calculateLanQualityLevels();
            wantedWatchedQualityLevels.forEach(function (qualityLevel) {
                finalWatchedQualityLevels.set(qualityLevel, Prefetcher_1.PrefetchType.LAN);
            });
            var keepSiteQualityLevels = false;
            var prefetchType = Prefetcher_1.PrefetchType.LAN;
            if (this.nodeInfo.amISiteLeader()) {
                prefetchType = Prefetcher_1.PrefetchType.SITE;
                keepSiteQualityLevels = true;
            }
            this.prefetcher.updatePrefetchSessions(finalWatchedQualityLevels, prefetchType, keepSiteQualityLevels);
        }
        else {
            // We use an empty array of wanted quality levels since we need to prefetch ONLY
            // the quality level that our player is watching
            this.prefetcher.updatePrefetchSessions(finalWatchedQualityLevels, Prefetcher_1.PrefetchType.PLAYER, false);
        }
    };
    /**
     * This method is called by the trackerClient when we need to check if we are site/open internet leaders
     * We self manage the election only for the lan leaders;
     * In case that we have udp leader election switched off, every peer manages election and can be site leader.
     * @param rankings
     * @param infos
     */
    PrefetcherManager.prototype.manageElection = function (rankings, infos) {
        var _this = this;
        var watchedQualityLevels = this.watchedQualityLevelsFromInfos(infos);
        var isLive = this.prefetcher.getVideoContext().hasBeenLive();
        // the tracker might report some ranking fields that will help in performing tracker leader election
        if (rankings && (rankings.length > 0)) {
            var setA = new SortedArraySet();
            setA.hiveAddEach(rankings);
            // we check from the ranking info I should be leader (or I forcefully become one)
            var doElect = PeerConstants_1.PeerConstants.Prefetching.ELECTION_FORCED || setA.some(function (ranking) {
                // this.nodeInfo.setCurrentScore(ranking.ranking);
                var rankString = Utils.getEnumString(hive.services.protocol.tracker.TrackerRankType, ranking.key.rankType);
                _this.logger.debug('LEADER ELECTION GOT RANKING ' + rankString + ',CRV ' + ranking.cumulatedRankValue + ',RV ' + ranking.ranking + ',GS ' + ranking.groupSize);
                return _this.amILeader(ranking);
            });
            if (PeerConstants_1.PeerConstants.Prefetching.SMOOTH_LEADER_SWITCH)
                doElect = this.smoothLeaderSwitch(doElect);
            var watchedQualityLevelsNotZero = watchedQualityLevels != null && watchedQualityLevels.length != 0;
            this.logger.debug('Tracker reports quality levels' + '[' + watchedQualityLevels.keys().join(', ') + '] ISLive ' + isLive + ' DoElect ' + doElect);
            if (PeerConstants_1.PeerConstants.Prefetching.ELECTION_ENABLED) {
                // VOD SITE LEADERSHIP IS DISABLED
                if (isLive) {
                    var lanQualityLevels = this.calculateLanQualityLevels();
                    if (watchedQualityLevelsNotZero && doElect) {
                        this.nodeInfo.setSiteLeader(true);
                        this.logger.info('BECOMING SITE LEADER');
                        // This property will have the quality level as Key and the PrefetchType reason
                        // why we download this. The prefetch type reason is either LAN or SITE
                        // for the site leader. When a quality level is a prefetch type reason LAN, this means
                        // that we prefetch this quality level because someone in our LAN is watching it.
                        // Prefetch type reason SITE is set to the quality level that we prefetch for someone
                        // that in our SITE is watching it.
                        var desiredPrefetchQualityLevels_1 = new HashMap();
                        lanQualityLevels.forEach(function (qualityLevel) {
                            desiredPrefetchQualityLevels_1.set(qualityLevel, Prefetcher_1.PrefetchType.LAN);
                        });
                        // We double check the quality levels that the tracker reports us.
                        // If we already prefetch a quality level for a member in our lan
                        // but the tracker reports the same quality level for a peer that is not in our lan
                        // but he is in our site, we change the prefetch type reason on SITE.
                        // We do this because we don't want to stop prefetching this quality level in case noone
                        // in our lan is watching this quality level any more. We still need to prefetch this quality level
                        // for the peer in our site.
                        watchedQualityLevels.forEach(function (uuid, qualityLevel) {
                            if (!_this.membership.hasMember(uuid)) {
                                desiredPrefetchQualityLevels_1.set(qualityLevel, Prefetcher_1.PrefetchType.SITE);
                            }
                        });
                        this.prefetcher.updatePrefetchSessions(desiredPrefetchQualityLevels_1, Prefetcher_1.PrefetchType.SITE, false);
                    }
                    else {
                        this.nodeInfo.setSiteLeader(false);
                        var prefetchType = Prefetcher_1.PrefetchType.PLAYER;
                        var desiredPrefetchQualityLevels_2 = new HashMap();
                        // if I'm a lan leader, but not a site leader anymore, I should keep prefetching my lan quality levels,
                        // otherwise I'll stop all other prefetch sessions (except my playing one)
                        if (this.nodeInfo.haveLanPartners() && this.nodeInfo.isLanLeader()) {
                            prefetchType = Prefetcher_1.PrefetchType.LAN;
                            lanQualityLevels.forEach(function (qualityLevel) {
                                desiredPrefetchQualityLevels_2.set(qualityLevel, Prefetcher_1.PrefetchType.LAN);
                            });
                        }
                        this.prefetcher.updatePrefetchSessions(desiredPrefetchQualityLevels_2, prefetchType, false);
                    }
                }
            }
        }
        else {
            // In case that I don't have rankings, we check if the peer is a lan leader. Then he is able to act as a prefetcher second tier
            // In theory this should never happen
            if (isLive) {
                if (PeerConstants_1.PeerConstants.Prefetching.ELECTION_FORCED)
                    this.nodeInfo.setSiteLeader(true);
                else
                    this.nodeInfo.setSiteLeader(false);
                var finalWatchedQualityLevels_1 = new HashMap();
                var prefetchType = Prefetcher_1.PrefetchType.PLAYER;
                if (this.nodeInfo.haveLanPartners() && this.nodeInfo.isLanLeader()) {
                    var wantedWatchedQualityLevels = this.calculateLanQualityLevels();
                    wantedWatchedQualityLevels.forEach(function (qualityLevel) {
                        finalWatchedQualityLevels_1.set(qualityLevel, Prefetcher_1.PrefetchType.LAN);
                    });
                    prefetchType = Prefetcher_1.PrefetchType.LAN;
                }
                if (PeerConstants_1.PeerConstants.Prefetching.ELECTION_FORCED)
                    prefetchType = Prefetcher_1.PrefetchType.SITE;
                this.prefetcher.updatePrefetchSessions(finalWatchedQualityLevels_1, prefetchType, false);
            }
        }
    };
    /**
     * Smoothen out the leadership downgrade.
     * If a peer is leader, wait two tracker announce periods where it's suggested
     * to downgrade before actually downgrading
     */
    PrefetcherManager.prototype.smoothLeaderSwitch = function (doElect) {
        if (doElect) {
            this.downgradeNext = false;
            return true;
        }
        else if (this.nodeInfo.amISiteLeader()) {
            if (!this.downgradeNext) {
                this.downgradeNext = true;
                return true;
            }
            else {
                this.downgradeNext = false;
                return false;
            }
        }
    };
    /**
     * This function is called by the partnership whenever we receive an
     * information regarding a new watching quality level inside our lan
     *
     */
    PrefetcherManager.prototype.updateLanWatchedQualityLevels = function () {
        var lanQualityLevels = this.calculateLanQualityLevels();
        var desiredPrefetchQualityLevels = new HashMap();
        lanQualityLevels.forEach(function (qualityLevel) {
            desiredPrefetchQualityLevels.set(qualityLevel, Prefetcher_1.PrefetchType.LAN);
        });
        var keepSiteQualityLevels = false;
        var prefetchType = Prefetcher_1.PrefetchType.LAN;
        if (this.nodeInfo.amISiteLeader()) {
            prefetchType = Prefetcher_1.PrefetchType.SITE;
            keepSiteQualityLevels = true;
        }
        this.prefetcher.updatePrefetchSessions(desiredPrefetchQualityLevels, prefetchType, keepSiteQualityLevels);
    };
    /**
     * We calculate the quality levels that our lan members reported.
     * This should be performed only by the LAN LEADER
     * We return the quality levels that our lan members watch.
     * @returns {Array<number>}
     */
    PrefetcherManager.prototype.calculateLanQualityLevels = function () {
        var qualityLevels = new SortedArraySet();
        this.membership.allMembers().forEach(function (member) {
            if (member.peerInfo.watchingQualityLevel && !qualityLevels.has(member.peerInfo.watchingQualityLevel.id)) {
                qualityLevels.hiveAdd(member.peerInfo.watchingQualityLevel.id);
            }
        });
        return qualityLevels.toArray();
    };
    /**
     * We parse the returned watched quality levels from the TRACKER and
     * we add only the watching quality level from the peers in my site
     * @param infos
     * @returns {number[]}
     */
    PrefetcherManager.prototype.watchedQualityLevelsFromInfos = function (infos) {
        var watchedQualityLevels = new HashMap();
        var myInAs = this.connectivityInfo.getNetworkInfo().getSiteId();
        infos.forEach(function (info) {
            if (info.watchingQualityLevel != null) {
                if (myInAs > 0) {
                    if (myInAs === info.internalAs)
                        watchedQualityLevels.set(info.watchingQualityLevel, info.guid);
                }
                else {
                    watchedQualityLevels.set(info.watchingQualityLevel, info.guid);
                }
            }
        });
        return watchedQualityLevels;
    };
    /**
     * We calculate if the peer is a leader. In case the udp leader election ONLY the lan leader can become site leader
     * @param ranking
     * @returns {any}
     */
    PrefetcherManager.prototype.amILeader = function (ranking) {
        if (ranking.groupSize < 2)
            return false;
        var threshold = Math.max(PeerConstants_1.PeerConstants.Prefetching.MIN_PREFETCHERS, Math.round(ranking.groupSize * PeerConstants_1.PeerConstants.Prefetching.PERCENTAGE_OF_PREFETCHERS));
        return (ranking.ranking < threshold);
    };
    /**
     * The delay is added to prevent prefetching content that is too far ahead from what the player is actually downloading.
     * Based on the prefetchType of each peer we calculate the appropriate delay before performing a prefetch attempt of any kind.
     *
     * - PrefetchType.SITE prefetch immediately if we are less than 30000 msecs ahead.
     * - PrefetchType.LAN prefetch immediately at least <minimum prefetchDistance> ahead (for HLS AND DASH is 10000 msecs)
     * - PrefetchType.Player this should never happen
     *
     * @param prefetchType
     * @param qualityLevel
     * @param segmentId
     * @returns {number}
     */
    PrefetcherManager.prototype.calculateDelay = function (prefetchType, qualityLevel, segmentId, pacingPrefetchDelay) {
        var delay = 1;
        var distance = this.videoContext.getDistanceDuration(segmentId, qualityLevel);
        var randomDelay = PeerConstants_1.PeerConstants.Prefetching.FALL_AGENT_RETRY_DELAY_RND_MAX * Framework_1.Framework.random();
        if (prefetchType == Prefetcher_1.PrefetchType.LAN) {
            var secondTierDistance = this.videoContext.getMinimumPrefetchDistance();
            var minDistance = secondTierDistance - randomDelay;
            delay = Math.max(1, distance - minDistance);
        }
        else if (prefetchType == Prefetcher_1.PrefetchType.SITE) {
            var maxDistance = PeerConstants_1.PeerConstants.Prefetching.FIRST_TIER_MAX_DISTANCE - randomDelay;
            delay = Math.max(1, distance - maxDistance) + pacingPrefetchDelay;
        }
        delay = Math.round(delay);
        return delay;
    };
    return PrefetcherManager;
}());
exports.PrefetcherManager = PrefetcherManager;
//# sourceMappingURL=PrefetcherManager.js.map

/***/ }),

/***/ "../../../core/build/core/src/webrtc/remote-config/DefaultRemoteConfigManager.js":
/*!********************************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/webrtc/remote-config/DefaultRemoteConfigManager.js ***!
  \********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.DefaultRemoteConfigManager = void 0;
__webpack_require__(/*! hivejs-protocol/services/remote_config_types */ "../../../protocol/services/remote_config_types.js");
var Framework_1 = __webpack_require__(/*! ../../core/Framework */ "../../../core/build/core/src/core/Framework.js");
var HiveServices_1 = __webpack_require__(/*! ../../core/HiveServices */ "../../../core/build/core/src/core/HiveServices.js");
var Utils_1 = __webpack_require__(/*! ../../core/Utils */ "../../../core/build/core/src/core/Utils.js");
var ConnectivityInfoProvider_1 = __webpack_require__(/*! ../../core/connectivity/ConnectivityInfoProvider */ "../../../core/build/core/src/core/connectivity/ConnectivityInfoProvider.js");
var Q = __webpack_require__(/*! @hivestreaming/q */ "../../../node_modules/@hivestreaming/q/q.js");
/**
 * this components manages the flow of remote configuration requests/response
 * it will keep track of the last request scope and return a promise resolved
 * when the response returns.
 * If the scope of a new request doesn't change, it returns the same promise.
 * If the scope changes, it creates a new request and returns the pending promise,
 * or a new one.
 * This means that for example:
 * t1 -> request1 without scope -> promise1
 * t2 -> request2 with privateIp scope -> promise1
 * t3 -> response1 returns -> nothing happens, we wait for response2
 * t4 -> response2 returns -> resolve promise1
 *
 * Note: this component doesn't handle timeouts, so they need to be handled
 * outside the scope. Also it doesn't reject the promise in case of communication
 * errors
 */
var DefaultRemoteConfigManager = /** @class */ (function () {
    function DefaultRemoteConfigManager() {
        this.loggerId = '[DefaultRemoteConfigManager] ';
        // tracking requests/responses/latency
        this.startLatency = 0;
        this.pendingRequests = new Utils_1.Counter();
        this.thriftSerializer = new Utils_1.ThriftSerializer();
    }
    DefaultRemoteConfigManager.prototype.init = function (serviceClient) {
        this.logger = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.LOGGER).log();
        this.configStore = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.CONFIG_STORE);
        this.connInfoProvider = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.CONNECTIVITY_INFO_PROVIDER);
        this.serviceClient = serviceClient;
        this.setHandlerConfigsResponse();
        // on ticket resolution we already expect one remote config response for the generic deployment
        this.pendingRequests.increment();
        this.lastResponsePromise = Q.defer();
    };
    /**
     * called on ticket initialization
     */
    DefaultRemoteConfigManager.prototype.onConnected = function (ticket, statsStore) {
        this.statsStore = statsStore;
        this.ticket = ticket;
    };
    /**
     * request a new remote config only if the scope changed, otherwise return the previously returned promise.
     * If the scope changed, create a new request and append it.
     * The promise will resolve only when the last requested configuration returns.
     */
    DefaultRemoteConfigManager.prototype.requestRemoteConfigs = function (siteScopeOptions) {
        var _this = this;
        // don't re-request if the scope didn't change or the ticket was not set yet
        if (!this.ticket) {
            return Q.resolve();
        }
        if (!this.isScopeChanged(siteScopeOptions)) {
            return this.lastResponsePromise.promise;
        }
        // reuse the same promise if still pending, or create a new one if it was already fulfilled
        var defer = this.lastResponsePromise.promise.isPending() ? this.lastResponsePromise : Q.defer();
        // update the scope
        this.siteScopeOptions = siteScopeOptions;
        // prepare the request and updates its scope
        var request = new hive.services.protocol.remoteconfig.RemoteConfigRequest({
            partnerId: this.ticket.getPartnerId(),
            customerId: this.ticket.getCustomerId()
        });
        if ((siteScopeOptions === null || siteScopeOptions === void 0 ? void 0 : siteScopeOptions.siteId) && (siteScopeOptions === null || siteScopeOptions === void 0 ? void 0 : siteScopeOptions.siteId) !== 0)
            request.siteId = siteScopeOptions.siteId;
        if (siteScopeOptions === null || siteScopeOptions === void 0 ? void 0 : siteScopeOptions.privateIps)
            request.privateIps = siteScopeOptions.privateIps;
        var payload;
        try {
            payload = this.thriftSerializer.serialize(request, 'REMOTE_CONFIG_REQUEST', 0);
        }
        catch (error) {
            this.logger.warn(this.loggerId + 'error serializing remote config request');
            defer.resolve();
        }
        if (payload) {
            // track the new pending response and the timers
            this.lastResponsePromise = defer;
            this.pendingRequests.increment();
            this.startLatency = Framework_1.Framework.time();
            // send the message over WSS
            var message = new HiveServices_1.Message(HiveStreamingServices.REMOTE_CONFIG_SERVICE, 0, payload);
            var sendPromise = this.serviceClient.getConnection().send(message);
            sendPromise.then(function () {
                _this.logger.debug(_this.loggerId + 'remote configs requested', payload);
            });
            sendPromise.fail(function (error) {
                // in case of send failure, resolve immediateluy the pending response
                _this.logger.debug(_this.loggerId + 'failed requesting remote configs: ' + error);
                _this.pendingRequests.decrement();
                defer.resolve();
            });
        }
        return defer.promise;
    };
    /**
     * Check whether siteScopeOptions value changed from before
     */
    DefaultRemoteConfigManager.prototype.isScopeChanged = function (updateSiteScope) {
        var _a, _b, _c;
        if (((updateSiteScope === null || updateSiteScope === void 0 ? void 0 : updateSiteScope.siteId) && (updateSiteScope === null || updateSiteScope === void 0 ? void 0 : updateSiteScope.siteId) !== 0) || ((_a = updateSiteScope === null || updateSiteScope === void 0 ? void 0 : updateSiteScope.privateIps) === null || _a === void 0 ? void 0 : _a.length) > 0) {
            if (((_b = this.siteScopeOptions) === null || _b === void 0 ? void 0 : _b.siteId) !== (updateSiteScope === null || updateSiteScope === void 0 ? void 0 : updateSiteScope.siteId) || !Utils_1.sameArray((_c = this.siteScopeOptions) === null || _c === void 0 ? void 0 : _c.privateIps, updateSiteScope === null || updateSiteScope === void 0 ? void 0 : updateSiteScope.privateIps)) {
                return true;
            }
        }
        return false;
    };
    DefaultRemoteConfigManager.prototype.setHandlerConfigsResponse = function () {
        var _this = this;
        if (this.serviceClient && this.serviceClient.getConnection()) {
            this.serviceClient.getConnection().on(HiveStreamingServices.REMOTE_CONFIG_SERVICE, 0, function (message) {
                _this.endLatencyTracking();
                _this.deserializeMessage(message.msg);
            });
        }
        else {
            this.logger.error(this.loggerId + 'error getting active services connection');
        }
    };
    DefaultRemoteConfigManager.prototype.deserializeMessage = function (message) {
        try {
            var response = this.thriftSerializer.deserialize(message, 'REMOTE_CONFIG_RESPONSE', 1, hive.services.protocol.remoteconfig.RemoteConfigResponse);
            var configs = JSON.parse(response.configs);
            var siteId = response.siteId;
            var privateIp = response.privateIp;
            var isVpn = response.isVpn;
            this.logger.debug("RECEIVED REMOTE CONFIGS (site: " + siteId + ", privateIP: " + privateIp + ", vpn: " + isVpn + ") (pending: " + this.pendingRequests.get() + "): ", configs);
            this.configStore.storeConfigs(configs);
            if (siteId) {
                this.connInfoProvider.handleServiceResponse(ConnectivityInfoProvider_1.ServiceResponse.REMOTE_CONFIG, privateIp, siteId, isVpn, null, null);
            }
        }
        catch (error) {
            this.logger.error(this.loggerId + 'error deserializing remote config response. ', error);
        }
        finally {
            // check if we have other queue requests and only resolve if it's the last response pending
            if (this.pendingRequests.decrement() == 0) {
                this.lastResponsePromise.resolve();
            }
        }
    };
    DefaultRemoteConfigManager.prototype.endLatencyTracking = function () {
        if (this.startLatency > 0 && this.statsStore) {
            var latency = Framework_1.Framework.time() - this.startLatency;
            this.statsStore.updateRemoteConfigLatency(latency);
            this.startLatency = 0;
        }
    };
    return DefaultRemoteConfigManager;
}());
exports.DefaultRemoteConfigManager = DefaultRemoteConfigManager;
//# sourceMappingURL=DefaultRemoteConfigManager.js.map

/***/ }),

/***/ "../../../core/build/core/src/webrtc/requests/PlayerManifestRequest.js":
/*!**********************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/webrtc/requests/PlayerManifestRequest.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.PlayerManifestRequest = void 0;
var Utils = __webpack_require__(/*! ../../core/Utils */ "../../../core/build/core/src/core/Utils.js");
var PlayerRequest_1 = __webpack_require__(/*! ./PlayerRequest */ "../../../core/build/core/src/webrtc/requests/PlayerRequest.js");
var logger_hive_1 = __webpack_require__(/*! ../../common/logger.hive */ "../../../core/build/core/src/common/logger.hive.js");
var SessionRegistry_1 = __webpack_require__(/*! ../../common/session/SessionRegistry */ "../../../core/build/core/src/common/session/SessionRegistry.js");
var SessionActivator_1 = __webpack_require__(/*! ../../common/session/SessionActivator */ "../../../core/build/core/src/common/session/SessionActivator.js");
var PlayerManifestRequest = /** @class */ (function (_super) {
    __extends(PlayerManifestRequest, _super);
    function PlayerManifestRequest() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    PlayerManifestRequest.prototype.send = function () {
        var _this = this;
        if (!this.pluginId) {
            this.pluginId = SessionRegistry_1.SessionRegistry.getInstance().getDefaultPluginId();
        }
        var initialized = SessionActivator_1.SessionActivator.getInstance().activate(this.pluginId, this.url, function (session) {
            session.tech.setManifestRequest(_this);
        });
        if (!initialized) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Failed to initialize session on player request', this.loggerId);
            this.resolve();
        }
    };
    /**
     * internally request the manifest through a normal XMLHttpRequest.
     * called if HiveJS cannot handle the protocol requested on his own
     */
    PlayerManifestRequest.prototype.resolve = function () {
        var _this = this;
        var req = new XMLHttpRequest();
        req.open('GET', this.url);
        req.onreadystatechange = function () {
            if (req.readyState !== 4)
                return;
            _this.response = req.responseText;
            _this.responseText = req.responseText;
            _this.readyState = 4;
            _this.status = req.status;
            _this.dispatchEvent(Utils.createEvent(Event, 'readystatechange', { currentTarget: _this }));
            _this.dispatchEvent(Utils.createEvent(ProgressEvent, 'load', { currentTarget: _this }));
            console.debug('Returned Manifest Request ' + _this.url);
        };
        req.send();
    };
    return PlayerManifestRequest;
}(PlayerRequest_1.PlayerRequest));
exports.PlayerManifestRequest = PlayerManifestRequest;
//# sourceMappingURL=PlayerManifestRequest.js.map

/***/ }),

/***/ "../../../core/build/core/src/webrtc/requests/PlayerRequest.js":
/*!**************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/webrtc/requests/PlayerRequest.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.PlayerRequest = void 0;
var __1 = __webpack_require__(/*! .. */ "../../../core/build/core/src/webrtc/index.js");
var HiveXHR_1 = __webpack_require__(/*! ../HiveXHR */ "../../../core/build/core/src/webrtc/HiveXHR.js");
var PlayerRequest = /** @class */ (function (_super) {
    __extends(PlayerRequest, _super);
    function PlayerRequest(pluginId) {
        var _this = _super.call(this, pluginId) || this;
        _this.DONE = 4;
        _this.LOADING = 3;
        _this.HEADERS_RECEIVED = 2;
        _this.OPENED = 1;
        _this.UNSENT = 0;
        /** This value it is a shortcut to understand if the request is a playerRequest (false) or a prefetchRequest (true)
         *  in case of prefetchRequest, the metadata downloaded will not be trimmed/regenerated
         *  @type {boolean}
         *  @readonly
         */
        _this.internal = false;
        _this.id = PlayerRequest.counter++;
        return _this;
    }
    PlayerRequest.prototype.send = function () {
        if (this.readyState !== this.OPENED)
            throw new Error("The object's state must be OPENED.");
        if (!this.pluginId) {
            var keys = Object.keys(PlayerRequest.playerPluginMap);
            if (keys.length > 0)
                this.pluginId = PlayerRequest.playerPluginMap[keys[0]];
        }
        __1.default.getInstance().request(this, this.pluginId);
    };
    PlayerRequest.prototype.abort = function () {
        __1.default.getInstance().abort(this, this.pluginId);
    };
    PlayerRequest.prototype.copyTo = function (request) {
        this.requestHeaders.forEach(function (header) {
            if (header.key.toLowerCase() === 'range')
                return;
            request.setRequestHeader(header.key, header.value);
        });
        if (this.async && this.timeout > 0)
            request.timeout = this.timeout;
        if (this.mimeType)
            request.overrideMimeType(this.mimeType);
        if (this.withCredentials)
            request.withCredentials = this.withCredentials;
    };
    PlayerRequest.counter = 0;
    return PlayerRequest;
}(HiveXHR_1.HiveXHR));
exports.PlayerRequest = PlayerRequest;
//# sourceMappingURL=PlayerRequest.js.map

/***/ }),

/***/ "../../../core/build/core/src/webrtc/transport/P2PDispatcher.js":
/*!***************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/webrtc/transport/P2PDispatcher.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.P2PDispatcher = void 0;
var Q = __webpack_require__(/*! @hivestreaming/q */ "../../../node_modules/@hivestreaming/q/q.js");
var Framework_1 = __webpack_require__(/*! ../../core/Framework */ "../../../core/build/core/src/core/Framework.js");
var P2PTransport_1 = __webpack_require__(/*! ./P2PTransport */ "../../../core/build/core/src/webrtc/transport/P2PTransport.js");
var P2PFragmentRequester_1 = __webpack_require__(/*! ../p2ptransfer/P2PFragmentRequester */ "../../../core/build/core/src/webrtc/p2ptransfer/P2PFragmentRequester.js");
var P2PFragmentSender_1 = __webpack_require__(/*! ../p2ptransfer/P2PFragmentSender */ "../../../core/build/core/src/webrtc/p2ptransfer/P2PFragmentSender.js");
var build_defaults_1 = __webpack_require__(/*! ../../common/build.defaults */ "../../../core/build/core/src/common/build.defaults.js");
var logger_hive_1 = __webpack_require__(/*! ../../common/logger.hive */ "../../../core/build/core/src/common/logger.hive.js");
var ErrorCodes = __webpack_require__(/*! ../../common/error.hive */ "../../../core/build/core/src/common/error.hive.js");
var P2PDispatcherLog = build_defaults_1.BuildParameters.P2PDispatcherLog;
/**
 * Wonderful class that forwards messages from the app to the shared peer transport
 * and dispatches all the received messages to the proper component that is supposed to
 * handle them
 */
var P2PDispatcher = /** @class */ (function () {
    function P2PDispatcher(swarm, myGuid, otherGuid, transport) {
        this.loggerId = '[P2PDispatcher] ';
        this.logger = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.LOGGER).log(swarm.sessionId);
        // this.loggerId = `S[${swarm.sessionId}]`;
        this.myGuid = myGuid;
        this.otherGuid = otherGuid;
        this.swarmId = swarm.swarmId;
        this.transport = transport;
        // each dispatcher has his own chunk-ack manager
        this.receiver = new P2PFragmentRequester_1.FragmentRequester(myGuid, otherGuid, swarm);
        this.sender = new P2PFragmentSender_1.FragmentSender(myGuid, otherGuid, swarm, this);
        // all dispatcher share the swarm-app components
        this.requester = swarm.p2pRequester;
        this.partnership = swarm.partnership;
        this.responder = swarm.responder;
    }
    P2PDispatcher.prototype.inUse = function () {
        return this.sender.inUse() || this.receiver.inUse();
    };
    P2PDispatcher.prototype.close = function () {
        var _this = this;
        var deferred = Q.defer();
        // return this.sender.closeWhenFinished()
        //                 .then(this.receiver.close)
        //            .then(this.sendClose)
        //            .then(this.transport.close)
        // We should revert to the commented version. For some reason this doesn't work on simulation.
        // TODO investigate why
        this.sender.closeWhenFinished().then(function (myStr) {
            return _this.receiver.close(myStr).then(function (myNum) {
                return _this.sendClose(myNum).then(function (myStr2) {
                    return _this.transport.close(myStr2).then(function (myResult) {
                        deferred.resolve(myResult);
                    });
                });
            });
        }).catch(function (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error closing connection to peer', _this.loggerId, ErrorCodes.P2P_DISPATCHER_CODES.CLOSE_CONNECTION, {
                detailedError: error,
                otherGuid: _this.otherGuid
            });
            deferred.reject('Close partnership failed');
        });
        return deferred.promise;
    };
    P2PDispatcher.prototype.sendClose = function (type) {
        this.logger.debug(this.loggerId + 'SEND CLOSE TO ' + this.otherGuid);
        var close = new P2PTransport_1.P2PTransport.msgBuilder.Close();
        close.setType(type);
        this.sendMessage(P2PTransport_1.P2PMsgTypes.Close, close);
        return Q(this.swarmId);
    };
    // TODO rename all the messages receiver methods into handler<MSGNAME>
    P2PDispatcher.prototype.dispatch = function (message) {
        try {
            if (P2PDispatcherLog)
                this.logger.debug(this.loggerId + 'DISPATCH ' + message.messageId);
            switch (message.messageId) {
                case P2PTransport_1.P2PMsgTypes.Chunk:
                    var chunk = P2PTransport_1.P2PTransport.msgBuilder.Chunk.decode(message.receivedData);
                    this.receiver.receiveChunk(chunk);
                    break;
                case P2PTransport_1.P2PMsgTypes.Ack:
                    var ack = P2PTransport_1.P2PTransport.msgBuilder.Ack.decode(message.receivedData);
                    this.sender.ackReceived(ack.transferId);
                    break;
                case P2PTransport_1.P2PMsgTypes.Cancel:
                    var cancel = P2PTransport_1.P2PTransport.msgBuilder.Cancel.decode(message.receivedData);
                    this.sender.cancelReceived(cancel.transferId);
                    break;
                case P2PTransport_1.P2PMsgTypes.OutPartRequest:
                    if (P2PDispatcherLog)
                        this.logger.debug(this.loggerId + 'RECEIVED OUT PART,DECODING ');
                    var outPartRequest = P2PTransport_1.P2PTransport.msgBuilder.OutPartnershipRequest.decode(message.receivedData);
                    if (P2PDispatcherLog)
                        this.logger.debug(this.loggerId + 'RECEIVED OUT PART FROM ' + outPartRequest.guid);
                    this.partnership.outPartRequestReceived(outPartRequest, this.transport);
                    break;
                case P2PTransport_1.P2PMsgTypes.OutPartResp:
                    if (P2PDispatcherLog)
                        this.logger.debug(this.loggerId + 'RECEIVED OUT PART RESP ');
                    var outPartResp = P2PTransport_1.P2PTransport.msgBuilder.OutPartnershipResponse.decode(message.receivedData);
                    if (P2PDispatcherLog)
                        this.logger.debug(this.loggerId + 'RECEIVED OUT PART RESP FROM ' + outPartResp.accept);
                    this.partnership.outPartRespReceived(outPartResp, this.transport);
                    break;
                case P2PTransport_1.P2PMsgTypes.Have:
                    var have = P2PTransport_1.P2PTransport.msgBuilder.Have.decode(message.receivedData);
                    if (P2PDispatcherLog)
                        this.logger.debug(this.loggerId + 'RECEIVED HAVE FOR ' + have.fragmentId + ' FROM ' + this.otherGuid);
                    this.partnership.haveReceived(this.otherGuid, have);
                    break;
                case P2PTransport_1.P2PMsgTypes.Close:
                    var close_1 = P2PTransport_1.P2PTransport.msgBuilder.Close.decode(message.receivedData);
                    if (P2PDispatcherLog)
                        this.logger.debug(this.loggerId + 'RECEIVED CLOSE FROM ' + this.otherGuid);
                    this.partnership.closeReceived(this.otherGuid, close_1);
                    break;
                case P2PTransport_1.P2PMsgTypes.Request:
                    var request = P2PTransport_1.P2PTransport.msgBuilder.Request.decode(message.receivedData);
                    if (P2PDispatcherLog)
                        this.logger.debug(this.loggerId + 'RECEIVED REQUEST FOR ' + request.fragmentId + ' FROM ' + this.otherGuid);
                    this.responder.requestReceived(this.otherGuid, request, this);
                    break;
                case P2PTransport_1.P2PMsgTypes.DoNotHave:
                    var doNotHave = P2PTransport_1.P2PTransport.msgBuilder.DoNotHave.decode(message.receivedData);
                    if (P2PDispatcherLog)
                        this.logger.debug(this.loggerId + 'DoNotHave ' + doNotHave.transferId);
                    this.requester.doNotHaveReceived(doNotHave);
                    break;
                case P2PTransport_1.P2PMsgTypes.QualityLevelMessage:
                    var qualityLevelMsg = P2PTransport_1.P2PTransport.msgBuilder.QualityLevelMessage.decode(message.receivedData);
                    if (P2PDispatcherLog)
                        this.logger.debug(this.loggerId + 'QUALITY LEVEL INFO ' + qualityLevelMsg.qualityLevel.id + ' FROM ' + qualityLevelMsg.guid);
                    this.partnership.qualityLevelInfoReceived(qualityLevelMsg);
                    break;
                case P2PTransport_1.P2PMsgTypes.Haves:
                    var haves = P2PTransport_1.P2PTransport.msgBuilder.Haves.decode(message.receivedData);
                    if (P2PDispatcherLog)
                        this.logger.debug(this.loggerId + 'RECEIVED BATCH HAVES FOR FROM ' + this.otherGuid);
                    this.partnership.havesReceived(this.otherGuid, haves);
                    break;
                case P2PTransport_1.P2PMsgTypes.PeerInfo:
                    var peerInfo = P2PTransport_1.P2PTransport.msgBuilder.PeerInfoMessage.decode(message.receivedData);
                    if (P2PDispatcherLog)
                        this.logger.debug(this.loggerId + 'RECEIVED PEER INFO FROM ' + this.otherGuid);
                    this.partnership.peerInfoReceived(peerInfo);
                    break;
                case P2PTransport_1.P2PMsgTypes.Ping:
                    var pingMessage = P2PTransport_1.P2PTransport.msgBuilder.Ping.decode(message.receivedData);
                    if (P2PDispatcherLog)
                        this.logger.debug(this.loggerId + 'RECEIVED PING FROM ' + this.otherGuid);
                    this.partnership.receivePingRequest(pingMessage);
                    break;
                case P2PTransport_1.P2PMsgTypes.Pong:
                    var pongMessage = P2PTransport_1.P2PTransport.msgBuilder.Pong.decode(message.receivedData);
                    if (P2PDispatcherLog)
                        this.logger.debug(this.loggerId + 'RECEIVED PONG FROM ' + this.otherGuid);
                    this.partnership.receivePong(pongMessage);
                    break;
                case P2PTransport_1.P2PMsgTypes.NoPartnerResp:
                    var nonPartnerMsg = P2PTransport_1.P2PTransport.msgBuilder.NoPartners.decode(message.receivedData);
                    if (P2PDispatcherLog)
                        this.logger.debug(this.loggerId + 'RECEIVED NON PARTNER MESSAGE FROM ' + this.otherGuid);
                    this.requester.requestedToNonPartner(this.otherGuid, nonPartnerMsg);
                    break;
                default:
                    this.logger.warn(this.loggerId + 'UNKNOWN MESSAGE TYPE ' + message.messageId);
            }
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error dispatching message', this.loggerId, error, ErrorCodes.P2P_DISPATCHER_CODES.P2P_DISPATCHER_ERROR, error);
        }
    };
    P2PDispatcher.prototype.sendMessage = function (messageId, message) {
        return this.transport.sendMessage(messageId, this.swarmId, message);
    };
    P2PDispatcher.prototype.onBufferedAmountLow = function () {
        this.sender.onBufferedAmountLow();
    };
    return P2PDispatcher;
}());
exports.P2PDispatcher = P2PDispatcher;
//# sourceMappingURL=P2PDispatcher.js.map

/***/ }),

/***/ "../../../core/build/core/src/webrtc/transport/P2PTransport.js":
/*!**************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/build/core/src/webrtc/transport/P2PTransport.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.P2PTransport = exports.P2PDispatcherManager = exports.P2PMsgTypes = exports.netLogging = void 0;
var Q = __webpack_require__(/*! @hivestreaming/q */ "../../../node_modules/@hivestreaming/q/q.js");
var ProtoBuf = __webpack_require__(/*! protobufjs */ "../../../node_modules/protobufjs/dist/ProtoBuf.js");
var ByteBuffer = __webpack_require__(/*! bytebuffer */ "../../../core/node_modules/bytebuffer/dist/bytebuffer.js");
var HashMap = __webpack_require__(/*! @hivestreaming/collections/map */ "../../../node_modules/@hivestreaming/collections/map.js");
var jsrsasign_1 = __webpack_require__(/*! @hivestreaming/jsrsasign */ "../../../node_modules/@hivestreaming/jsrsasign/lib/jsrsasign.js");
var Framework_1 = __webpack_require__(/*! ../../core/Framework */ "../../../core/build/core/src/core/Framework.js");
var P2PDispatcher_1 = __webpack_require__(/*! ./P2PDispatcher */ "../../../core/build/core/src/webrtc/transport/P2PDispatcher.js");
var P2PMessage_1 = __webpack_require__(/*! ../msgs/P2PMessage */ "../../../core/build/core/src/webrtc/msgs/P2PMessage.js");
var PeerConstants_1 = __webpack_require__(/*! ../PeerConstants */ "../../../core/build/core/src/webrtc/PeerConstants.js");
var Utils = __webpack_require__(/*! ../../core/Utils */ "../../../core/build/core/src/core/Utils.js");
var logger_hive_1 = __webpack_require__(/*! ../../common/logger.hive */ "../../../core/build/core/src/common/logger.hive.js");
var ErrorCodes = __webpack_require__(/*! ../../common/error.hive */ "../../../core/build/core/src/common/error.hive.js");
exports.netLogging = false;
/**
 * NOTE: when changing this update the received max message id
 */
var P2PMsgTypes;
(function (P2PMsgTypes) {
    P2PMsgTypes[P2PMsgTypes["Have"] = 1] = "Have";
    P2PMsgTypes[P2PMsgTypes["Chunk"] = 2] = "Chunk";
    P2PMsgTypes[P2PMsgTypes["Request"] = 3] = "Request";
    P2PMsgTypes[P2PMsgTypes["Cancel"] = 4] = "Cancel";
    P2PMsgTypes[P2PMsgTypes["Ack"] = 5] = "Ack";
    P2PMsgTypes[P2PMsgTypes["Close"] = 6] = "Close";
    P2PMsgTypes[P2PMsgTypes["DoNotHave"] = 7] = "DoNotHave";
    P2PMsgTypes[P2PMsgTypes["OutPartRequest"] = 8] = "OutPartRequest";
    P2PMsgTypes[P2PMsgTypes["OutPartResp"] = 9] = "OutPartResp";
    P2PMsgTypes[P2PMsgTypes["UDPHandshakeReq"] = 10] = "UDPHandshakeReq";
    P2PMsgTypes[P2PMsgTypes["UDPHandshakeResponse"] = 11] = "UDPHandshakeResponse";
    P2PMsgTypes[P2PMsgTypes["UDPSwitchLeadershipRequest"] = 12] = "UDPSwitchLeadershipRequest";
    P2PMsgTypes[P2PMsgTypes["UDPSwitchAck"] = 13] = "UDPSwitchAck";
    P2PMsgTypes[P2PMsgTypes["QualityLevelMessage"] = 14] = "QualityLevelMessage";
    P2PMsgTypes[P2PMsgTypes["Haves"] = 15] = "Haves";
    P2PMsgTypes[P2PMsgTypes["PeerInfo"] = 16] = "PeerInfo";
    P2PMsgTypes[P2PMsgTypes["Ping"] = 17] = "Ping";
    P2PMsgTypes[P2PMsgTypes["Pong"] = 18] = "Pong";
    P2PMsgTypes[P2PMsgTypes["NoPartnerResp"] = 19] = "NoPartnerResp";
})(P2PMsgTypes = exports.P2PMsgTypes || (exports.P2PMsgTypes = {}));
/**
 * utility class that helps for multiplexing
 * received messages to the peer dispatcher of the
 * correct swarm
 */
var P2PDispatcherManager = /** @class */ (function () {
    function P2PDispatcherManager(transport) {
        this.loggerId = '[DispatcherManager] ';
        this.dispatcherMap = new HashMap();
        this.logger = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.LOGGER).log();
        this.transport = transport;
    }
    P2PDispatcherManager.prototype.create = function (swarmId) {
        try {
            var dispatcher = null;
            var peer = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.PEER);
            var swarm = peer.getSwarm(swarmId);
            if (swarm == null) {
                this.logger.warn('MSG RECEIVED FROM UNKNOWN SWARM');
                return null;
            }
            else {
                dispatcher = new P2PDispatcher_1.P2PDispatcher(swarm, this.transport.myGuid, this.transport.otherGuid, this.transport);
            }
            if (!this.dispatcherMap.has(swarmId)) {
                this.dispatcherMap.set(swarmId, dispatcher);
            }
            return this.dispatcherMap.get(swarmId);
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error creating new dispatcher', this.loggerId, ErrorCodes.DISPATCHER_MANAGER_CODES.NEW_DISPATCHER, error);
        }
    };
    P2PDispatcherManager.prototype.remove = function (swarmId) {
        this.dispatcherMap.delete(swarmId);
    };
    P2PDispatcherManager.prototype.get = function (swarmId) {
        return this.dispatcherMap.get(swarmId);
    };
    return P2PDispatcherManager;
}());
exports.P2PDispatcherManager = P2PDispatcherManager;
/**
 * There is one Transport per peer connection and it's generated
 * when the channel is initialized. This transport handles the
 * protobuffer serialization and the multiplexing with different swarms
 */
var P2PTransport = /** @class */ (function () {
    function P2PTransport() {
        this.loggerId = '[Transport] ';
        this.message = null;
        this.loggerInt = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.LOGGER);
        this.dispatcherManager = new P2PDispatcherManager(this);
        this.instance = P2PTransport.counter++;
        this.lastUsed = Framework_1.Framework.time();
    }
    P2PTransport.prototype.init = function (myGuid, otherGuid) {
        this.myGuid = myGuid;
        this.otherGuid = otherGuid;
        this.networkManager = Framework_1.Framework.resolve(Framework_1.Framework.Definitions.RTC_MANAGER);
    };
    /**
     * check if the channel is used by any swarm
     * @returns {boolean}
     */
    P2PTransport.prototype.inUse = function () {
        var inUses = false;
        this.dispatcherManager.dispatcherMap.forEach(function (v, k) {
            if (v.sender.inUse() || v.receiver.inUse()) {
                inUses = true;
            }
            return;
        });
        return inUses;
    };
    P2PTransport.prototype.reset = function () {
        this.dispatcherManager.dispatcherMap.forEach(function (v, k) {
            v.sender.resetSendState();
        });
    };
    P2PTransport.prototype.close = function (swarmId) {
        this.dispatcherManager.remove(swarmId);
        if (this.dispatcherManager.dispatcherMap.length == 0) {
            this.networkManager.disconnect(this.otherGuid);
        }
        return Q('ok');
    };
    /**
     * final step before sending a message from the application down to webrtc
     * @param messageId
     * @param swarmId
     * @param message
     */
    P2PTransport.prototype.sendMessage = function (messageId, swarmId, message) {
        var dataToSend;
        var dataToSendLength;
        try {
            this.lastUsed = Framework_1.Framework.time();
            // protobuf serialization!
            var encodedFragmentArray = message.toArrayBuffer();
            var encodedFragmentArrayLength = encodedFragmentArray.byteLength;
            // generate md5 checksum (skip simulation for performance)
            var hashedKey = !Framework_1.Framework.isSimulated() ? jsrsasign_1.CryptoJS.MD5(jsrsasign_1.CryptoJS.lib.WordArray.create(encodedFragmentArray)) : '';
            // wrap the protobuf message with headers for deserialization
            // multiplexing and checksum validation
            var bytebuffer = new ByteBuffer();
            bytebuffer.writeInt(messageId);
            bytebuffer.writeCString(swarmId);
            bytebuffer.writeInt(encodedFragmentArrayLength);
            bytebuffer.writeCString(hashedKey.toString());
            bytebuffer.append(encodedFragmentArray);
            bytebuffer.flip();
            // calculate the size of the final buffer to send (mostly for simulation)
            dataToSend = bytebuffer.toArrayBuffer();
            dataToSendLength = (messageId === P2PMsgTypes.Chunk && Framework_1.Framework.isSimulated()) ? dataToSend.byteLength + PeerConstants_1.PeerConstants.Transport.ChunkSize :
                dataToSend.byteLength;
            if (exports.netLogging) {
                this.loggerInt.log(swarmId).debug(this.instance + ' SEND MSG ID ' + messageId + ',' + dataToSendLength + ' HASH ' + hashedKey.toString() + ' TO ' + this.otherGuid);
            }
        }
        catch (err) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error constructing message', this.loggerId, ErrorCodes.P2P_TRASNSPORT_CODES.CONSTRUCT_MESSAGE, { detailedError: err, msgType: P2PMsgTypes[messageId] });
        }
        try {
            var succeeded = this.networkManager.send(this.otherGuid, dataToSend, dataToSendLength);
            if (!succeeded) {
                logger_hive_1.ErrorMonitor.getInstance().logError('Error message dropped', this.loggerId, ErrorCodes.P2P_TRASNSPORT_CODES.DROPPED_MESSAGE, {
                    msgType: P2PMsgTypes[messageId],
                    otherGuid: this.otherGuid
                });
            }
            return succeeded;
        }
        catch (error) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error sending message', this.loggerId, ErrorCodes.P2P_TRASNSPORT_CODES.SEND_MESSAGE, {
                msgType: P2PMsgTypes[messageId],
                otherGuid: this.otherGuid
            });
            this.loggerInt.log(swarmId).warn('ERROR SENDING MESSAGE TO ' + this.otherGuid + ' ' + error.stack);
        }
    };
    /**
     * this method is triggered when the correspondent buffer is below the minimum threshold
     * so we tell all the dispatcher that they can continue to send data
     */
    P2PTransport.prototype.onBufferedAmountLow = function () {
        this.dispatcherManager.dispatcherMap.forEach(function (disp) { return disp.onBufferedAmountLow(); });
    };
    /**
     * first step when we receive a message from webrtc.
     * read the buffer, unwrap it, verify the checksum,
     * find the right dispatcher, DISPATCH!
     *
     * @param payload
     */
    P2PTransport.prototype.receiveMessage = function (payload) {
        var _this = this;
        if (exports.netLogging) {
            this.loggerInt.log().debug(this.instance + ' GOT MSG ' + payload.byteLength);
        }
        try {
            var startTime_1 = Framework_1.Framework.time();
            this.lastUsed = startTime_1;
            this.readBuffer(payload).then(function (payloadProc) {
                if (exports.netLogging) {
                    _this.loggerInt.log().debug(_this.instance + ' RECEIVING ' + payloadProc.byteLength + ' after ' + (Framework_1.Framework.time() - startTime_1));
                }
                if (payloadProc.byteLength > P2PTransport.MAX_LENGTH) {
                    throw new RangeError('P2P Message too big to be processed');
                }
                /*
                 * application level messages can be split up into multiple
                 * messages, so we need to reconstruct them in case.
                 *
                 * this.message keeps track of a partial message received so far
                 * NOTE: we are assuming that partial messages are not mixed up!!!
                 */
                var message = _this.message;
                if (message === null) {
                    // we have no previous partial, so this is a new
                    // message, or at least the head of it...
                    var buffer = ByteBuffer.wrap(payloadProc);
                    // this it the type of the p2pMessage (chunk, have...)
                    var messageId = buffer.readInt();
                    if (exports.netLogging) {
                        _this.loggerInt.log().debug('MSG ID ' + messageId);
                    }
                    // check if the message type is recognized
                    if (messageId > Object.keys(P2PMsgTypes).length) {
                        _this.loggerInt.log().warn('MSG OF WRONG ID RECEIVED: ' + messageId);
                        _this.message = null;
                        return;
                    }
                    message = _this.message = new P2PMessage_1.P2PMessage();
                    message.messageId = messageId;
                    message.swarmId = buffer.readCString();
                    message.length = buffer.readInt();
                    message.hash = buffer.readCString();
                    message.receivedData = buffer.toArrayBuffer();
                    if (message.length > P2PTransport.MAX_LENGTH) {
                        throw new RangeError('P2P Message too big to be processed');
                    }
                    if (exports.netLogging) {
                        _this.loggerInt.log(message.swarmId).debug('MSG ID ' + message.messageId + ' L ' + message.length + ' SWID ' + message.swarmId + ' H ' + message.hash + ' TR ' + message.receivedData.byteLength);
                    }
                }
                else {
                    // here we are receiving the rest of a partial message
                    if (exports.netLogging) {
                        _this.loggerInt.log().debug('APPENDING TO P2P MESSAGE ' + message.messageId);
                    }
                    if (message.receivedData.byteLength != null && message.receivedData.byteLength > P2PTransport.MAX_LENGTH) {
                        throw new RangeError('P2P Message too big to be processed');
                    }
                    message.receivedData = Utils.appendBuffer(message.receivedData, payload);
                }
                /*
                 * here we check if the message is complete, so we can verify the integrity
                 * and dispatch it! :D
                 */
                if (message.receivedData.byteLength === message.length) {
                    if (!Framework_1.Framework.isSimulated()) {
                        var wordArrayRec = jsrsasign_1.CryptoJS.lib.WordArray.create(message.receivedData);
                        var hashKey = jsrsasign_1.CryptoJS.MD5(wordArrayRec);
                        if (hashKey.toString() !== message.hash) {
                            var err = ' INTEGRITY CHECK FAILED ';
                            // TODO increase warn to error to catch it in atatus?
                            _this.loggerInt.log(message.swarmId).warn(err);
                            // TODO do we need to notify the app or we just let the timer run out?
                            // this.fragmentDownloadError(err);
                            return;
                        }
                    }
                    // the checksum is verified, we find the right dispatcher and dispatch
                    // NOTE: the dispatcher might need to be there yet if I was not the connection
                    // initiator
                    var dispatcher = _this.dispatcherManager.get(message.swarmId);
                    if (!dispatcher) {
                        dispatcher = _this.dispatcherManager.create(message.swarmId);
                    }
                    if (dispatcher) {
                        // we dispatch the message. This operation MUST be syncronous and
                        // MUST use the received buffer
                        dispatcher.dispatch(message);
                    }
                    // now we can safely free up this buffer
                    message.receivedData = null;
                    // since the message is complete we can remove the partial reference
                    // and start receiving a new message
                    // TODO can we move this immediately after we realize that the message is now complete?
                    _this.message = null;
                }
            });
        }
        catch (err) {
            logger_hive_1.ErrorMonitor.getInstance().logError('Error receiving message', this.loggerId, ErrorCodes.P2P_TRASNSPORT_CODES.RECEIVE_MESSAGE, err);
            this.message = null;
        }
    };
    /**
     * utility for firefox for reading correctly a payload
     * @param payload
     * @returns {Promise<T>}
     */
    P2PTransport.prototype.readBuffer = function (payload) {
        var is_firefox = Framework_1.Framework.isSimulated() ? false : navigator.userAgent.toLowerCase().indexOf('firefox') > -1;
        var deferred = Q.defer();
        if (is_firefox) {
            var fileReader = new FileReader();
            fileReader.onload = function (progressEvent) {
                payload = this.result;
                deferred.resolve(payload);
            };
            fileReader.onerror = deferred.reject;
            fileReader.readAsArrayBuffer(payload);
        }
        else {
            deferred.resolve(payload);
        }
        return deferred.promise;
    };
    P2PTransport.prototype.getLastUsed = function () {
        return this.lastUsed;
    };
    /**
     * The msgBuilder is generated from the compiled hive-messages.proto (in json)
     * if the proto changed, run 'gulp buildProto' to regenerate both definitions and json definitions
     */
    P2PTransport.msgBuilder = ProtoBuf.loadJson(__webpack_require__(/*! hivejs-protocol */ "../../../protocol/build/index.json")).build('HiveMsgs');
    P2PTransport.counter = 0;
    /**
     * max allowed p2p fragment size is
     * int4 (messageId) + int4 (fragmentArrayLength) + 128 (hashString) + size(largest message) * a bit more to account other generic message fields
     * @type {number}
     */
    // TODO move this to P2PConstants
    P2PTransport.MAX_LENGTH = 4 + 4 + 128 + Math.ceil(PeerConstants_1.PeerConstants.Transport.ChunkSize * 1.2);
    return P2PTransport;
}());
exports.P2PTransport = P2PTransport;
//# sourceMappingURL=P2PTransport.js.map

/***/ }),

/***/ "../../../core/node_modules/bytebuffer/dist/bytebuffer.js":
/*!*********************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/node_modules/bytebuffer/dist/bytebuffer.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
 Copyright 2013-2014 Daniel Wirtz <dcode@dcode.io>

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
 */

/**
 * @license bytebuffer.js (c) 2015 Daniel Wirtz <dcode@dcode.io>
 * Backing buffer: ArrayBuffer, Accessor: Uint8Array
 * Released under the Apache License, Version 2.0
 * see: https://github.com/dcodeIO/bytebuffer.js for details
 */
(function(global, factory) {

    /* AMD */ if (true)
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! long */ "../../../core/node_modules/long/dist/long.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    /* CommonJS */ else {}

})(this, function(Long) {
    "use strict";

    /**
     * Constructs a new ByteBuffer.
     * @class The swiss army knife for binary data in JavaScript.
     * @exports ByteBuffer
     * @constructor
     * @param {number=} capacity Initial capacity. Defaults to {@link ByteBuffer.DEFAULT_CAPACITY}.
     * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to
     *  {@link ByteBuffer.DEFAULT_ENDIAN}.
     * @param {boolean=} noAssert Whether to skip assertions of offsets and values. Defaults to
     *  {@link ByteBuffer.DEFAULT_NOASSERT}.
     * @expose
     */
    var ByteBuffer = function(capacity, littleEndian, noAssert) {
        if (typeof capacity === 'undefined')
            capacity = ByteBuffer.DEFAULT_CAPACITY;
        if (typeof littleEndian === 'undefined')
            littleEndian = ByteBuffer.DEFAULT_ENDIAN;
        if (typeof noAssert === 'undefined')
            noAssert = ByteBuffer.DEFAULT_NOASSERT;
        if (!noAssert) {
            capacity = capacity | 0;
            if (capacity < 0)
                throw RangeError("Illegal capacity");
            littleEndian = !!littleEndian;
            noAssert = !!noAssert;
        }

        /**
         * Backing ArrayBuffer.
         * @type {!ArrayBuffer}
         * @expose
         */
        this.buffer = capacity === 0 ? EMPTY_BUFFER : new ArrayBuffer(capacity);

        /**
         * Uint8Array utilized to manipulate the backing buffer. Becomes `null` if the backing buffer has a capacity of `0`.
         * @type {?Uint8Array}
         * @expose
         */
        this.view = capacity === 0 ? null : new Uint8Array(this.buffer);

        /**
         * Absolute read/write offset.
         * @type {number}
         * @expose
         * @see ByteBuffer#flip
         * @see ByteBuffer#clear
         */
        this.offset = 0;

        /**
         * Marked offset.
         * @type {number}
         * @expose
         * @see ByteBuffer#mark
         * @see ByteBuffer#reset
         */
        this.markedOffset = -1;

        /**
         * Absolute limit of the contained data. Set to the backing buffer's capacity upon allocation.
         * @type {number}
         * @expose
         * @see ByteBuffer#flip
         * @see ByteBuffer#clear
         */
        this.limit = capacity;

        /**
         * Whether to use little endian byte order, defaults to `false` for big endian.
         * @type {boolean}
         * @expose
         */
        this.littleEndian = littleEndian;

        /**
         * Whether to skip assertions of offsets and values, defaults to `false`.
         * @type {boolean}
         * @expose
         */
        this.noAssert = noAssert;
    };

    /**
     * ByteBuffer version.
     * @type {string}
     * @const
     * @expose
     */
    ByteBuffer.VERSION = "5.0.1";

    /**
     * Little endian constant that can be used instead of its boolean value. Evaluates to `true`.
     * @type {boolean}
     * @const
     * @expose
     */
    ByteBuffer.LITTLE_ENDIAN = true;

    /**
     * Big endian constant that can be used instead of its boolean value. Evaluates to `false`.
     * @type {boolean}
     * @const
     * @expose
     */
    ByteBuffer.BIG_ENDIAN = false;

    /**
     * Default initial capacity of `16`.
     * @type {number}
     * @expose
     */
    ByteBuffer.DEFAULT_CAPACITY = 16;

    /**
     * Default endianess of `false` for big endian.
     * @type {boolean}
     * @expose
     */
    ByteBuffer.DEFAULT_ENDIAN = ByteBuffer.BIG_ENDIAN;

    /**
     * Default no assertions flag of `false`.
     * @type {boolean}
     * @expose
     */
    ByteBuffer.DEFAULT_NOASSERT = false;

    /**
     * A `Long` class for representing a 64-bit two's-complement integer value. May be `null` if Long.js has not been loaded
     *  and int64 support is not available.
     * @type {?Long}
     * @const
     * @see https://github.com/dcodeIO/long.js
     * @expose
     */
    ByteBuffer.Long = Long || null;

    /**
     * @alias ByteBuffer.prototype
     * @inner
     */
    var ByteBufferPrototype = ByteBuffer.prototype;

    /**
     * An indicator used to reliably determine if an object is a ByteBuffer or not.
     * @type {boolean}
     * @const
     * @expose
     * @private
     */
    ByteBufferPrototype.__isByteBuffer__;

    Object.defineProperty(ByteBufferPrototype, "__isByteBuffer__", {
        value: true,
        enumerable: false,
        configurable: false
    });

    // helpers

    /**
     * @type {!ArrayBuffer}
     * @inner
     */
    var EMPTY_BUFFER = new ArrayBuffer(0);

    /**
     * String.fromCharCode reference for compile-time renaming.
     * @type {function(...number):string}
     * @inner
     */
    var stringFromCharCode = String.fromCharCode;

    /**
     * Creates a source function for a string.
     * @param {string} s String to read from
     * @returns {function():number|null} Source function returning the next char code respectively `null` if there are
     *  no more characters left.
     * @throws {TypeError} If the argument is invalid
     * @inner
     */
    function stringSource(s) {
        var i=0; return function() {
            return i < s.length ? s.charCodeAt(i++) : null;
        };
    }

    /**
     * Creates a destination function for a string.
     * @returns {function(number=):undefined|string} Destination function successively called with the next char code.
     *  Returns the final string when called without arguments.
     * @inner
     */
    function stringDestination() {
        var cs = [], ps = []; return function() {
            if (arguments.length === 0)
                return ps.join('')+stringFromCharCode.apply(String, cs);
            if (cs.length + arguments.length > 1024)
                ps.push(stringFromCharCode.apply(String, cs)),
                    cs.length = 0;
            Array.prototype.push.apply(cs, arguments);
        };
    }

    /**
     * Gets the accessor type.
     * @returns {Function} `Buffer` under node.js, `Uint8Array` respectively `DataView` in the browser (classes)
     * @expose
     */
    ByteBuffer.accessor = function() {
        return Uint8Array;
    };
    /**
     * Allocates a new ByteBuffer backed by a buffer of the specified capacity.
     * @param {number=} capacity Initial capacity. Defaults to {@link ByteBuffer.DEFAULT_CAPACITY}.
     * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to
     *  {@link ByteBuffer.DEFAULT_ENDIAN}.
     * @param {boolean=} noAssert Whether to skip assertions of offsets and values. Defaults to
     *  {@link ByteBuffer.DEFAULT_NOASSERT}.
     * @returns {!ByteBuffer}
     * @expose
     */
    ByteBuffer.allocate = function(capacity, littleEndian, noAssert) {
        return new ByteBuffer(capacity, littleEndian, noAssert);
    };

    /**
     * Concatenates multiple ByteBuffers into one.
     * @param {!Array.<!ByteBuffer|!ArrayBuffer|!Uint8Array|string>} buffers Buffers to concatenate
     * @param {(string|boolean)=} encoding String encoding if `buffers` contains a string ("base64", "hex", "binary",
     *  defaults to "utf8")
     * @param {boolean=} littleEndian Whether to use little or big endian byte order for the resulting ByteBuffer. Defaults
     *  to {@link ByteBuffer.DEFAULT_ENDIAN}.
     * @param {boolean=} noAssert Whether to skip assertions of offsets and values for the resulting ByteBuffer. Defaults to
     *  {@link ByteBuffer.DEFAULT_NOASSERT}.
     * @returns {!ByteBuffer} Concatenated ByteBuffer
     * @expose
     */
    ByteBuffer.concat = function(buffers, encoding, littleEndian, noAssert) {
        if (typeof encoding === 'boolean' || typeof encoding !== 'string') {
            noAssert = littleEndian;
            littleEndian = encoding;
            encoding = undefined;
        }
        var capacity = 0;
        for (var i=0, k=buffers.length, length; i<k; ++i) {
            if (!ByteBuffer.isByteBuffer(buffers[i]))
                buffers[i] = ByteBuffer.wrap(buffers[i], encoding);
            length = buffers[i].limit - buffers[i].offset;
            if (length > 0) capacity += length;
        }
        if (capacity === 0)
            return new ByteBuffer(0, littleEndian, noAssert);
        var bb = new ByteBuffer(capacity, littleEndian, noAssert),
            bi;
        i=0; while (i<k) {
            bi = buffers[i++];
            length = bi.limit - bi.offset;
            if (length <= 0) continue;
            bb.view.set(bi.view.subarray(bi.offset, bi.limit), bb.offset);
            bb.offset += length;
        }
        bb.limit = bb.offset;
        bb.offset = 0;
        return bb;
    };

    /**
     * Tests if the specified type is a ByteBuffer.
     * @param {*} bb ByteBuffer to test
     * @returns {boolean} `true` if it is a ByteBuffer, otherwise `false`
     * @expose
     */
    ByteBuffer.isByteBuffer = function(bb) {
        return (bb && bb["__isByteBuffer__"]) === true;
    };
    /**
     * Gets the backing buffer type.
     * @returns {Function} `Buffer` under node.js, `ArrayBuffer` in the browser (classes)
     * @expose
     */
    ByteBuffer.type = function() {
        return ArrayBuffer;
    };
    /**
     * Wraps a buffer or a string. Sets the allocated ByteBuffer's {@link ByteBuffer#offset} to `0` and its
     *  {@link ByteBuffer#limit} to the length of the wrapped data.
     * @param {!ByteBuffer|!ArrayBuffer|!Uint8Array|string|!Array.<number>} buffer Anything that can be wrapped
     * @param {(string|boolean)=} encoding String encoding if `buffer` is a string ("base64", "hex", "binary", defaults to
     *  "utf8")
     * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to
     *  {@link ByteBuffer.DEFAULT_ENDIAN}.
     * @param {boolean=} noAssert Whether to skip assertions of offsets and values. Defaults to
     *  {@link ByteBuffer.DEFAULT_NOASSERT}.
     * @returns {!ByteBuffer} A ByteBuffer wrapping `buffer`
     * @expose
     */
    ByteBuffer.wrap = function(buffer, encoding, littleEndian, noAssert) {
        if (typeof encoding !== 'string') {
            noAssert = littleEndian;
            littleEndian = encoding;
            encoding = undefined;
        }
        if (typeof buffer === 'string') {
            if (typeof encoding === 'undefined')
                encoding = "utf8";
            switch (encoding) {
                case "base64":
                    return ByteBuffer.fromBase64(buffer, littleEndian);
                case "hex":
                    return ByteBuffer.fromHex(buffer, littleEndian);
                case "binary":
                    return ByteBuffer.fromBinary(buffer, littleEndian);
                case "utf8":
                    return ByteBuffer.fromUTF8(buffer, littleEndian);
                case "debug":
                    return ByteBuffer.fromDebug(buffer, littleEndian);
                default:
                    throw Error("Unsupported encoding: "+encoding);
            }
        }
        if (buffer === null || typeof buffer !== 'object')
            throw TypeError("Illegal buffer");
        var bb;
        if (ByteBuffer.isByteBuffer(buffer)) {
            bb = ByteBufferPrototype.clone.call(buffer);
            bb.markedOffset = -1;
            return bb;
        }
        if (buffer instanceof Uint8Array) { // Extract ArrayBuffer from Uint8Array
            bb = new ByteBuffer(0, littleEndian, noAssert);
            if (buffer.length > 0) { // Avoid references to more than one EMPTY_BUFFER
                bb.buffer = buffer.buffer;
                bb.offset = buffer.byteOffset;
                bb.limit = buffer.byteOffset + buffer.byteLength;
                bb.view = new Uint8Array(buffer.buffer);
            }
        } else if (buffer instanceof ArrayBuffer) { // Reuse ArrayBuffer
            bb = new ByteBuffer(0, littleEndian, noAssert);
            if (buffer.byteLength > 0) {
                bb.buffer = buffer;
                bb.offset = 0;
                bb.limit = buffer.byteLength;
                bb.view = buffer.byteLength > 0 ? new Uint8Array(buffer) : null;
            }
        } else if (Object.prototype.toString.call(buffer) === "[object Array]") { // Create from octets
            bb = new ByteBuffer(buffer.length, littleEndian, noAssert);
            bb.limit = buffer.length;
            for (var i=0; i<buffer.length; ++i)
                bb.view[i] = buffer[i];
        } else
            throw TypeError("Illegal buffer"); // Otherwise fail
        return bb;
    };

    /**
     * Writes the array as a bitset.
     * @param {Array<boolean>} value Array of booleans to write
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `length` if omitted.
     * @returns {!ByteBuffer}
     * @expose
     */
    ByteBufferPrototype.writeBitSet = function(value, offset) {
      var relative = typeof offset === 'undefined';
      if (relative) offset = this.offset;
      if (!this.noAssert) {
        if (!(value instanceof Array))
          throw TypeError("Illegal BitSet: Not an array");
        if (typeof offset !== 'number' || offset % 1 !== 0)
            throw TypeError("Illegal offset: "+offset+" (not an integer)");
        offset >>>= 0;
        if (offset < 0 || offset + 0 > this.buffer.byteLength)
            throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
      }

      var start = offset,
          bits = value.length,
          bytes = (bits >> 3),
          bit = 0,
          k;

      offset += this.writeVarint32(bits,offset);

      while(bytes--) {
        k = (!!value[bit++] & 1) |
            ((!!value[bit++] & 1) << 1) |
            ((!!value[bit++] & 1) << 2) |
            ((!!value[bit++] & 1) << 3) |
            ((!!value[bit++] & 1) << 4) |
            ((!!value[bit++] & 1) << 5) |
            ((!!value[bit++] & 1) << 6) |
            ((!!value[bit++] & 1) << 7);
        this.writeByte(k,offset++);
      }

      if(bit < bits) {
        var m = 0; k = 0;
        while(bit < bits) k = k | ((!!value[bit++] & 1) << (m++));
        this.writeByte(k,offset++);
      }

      if (relative) {
        this.offset = offset;
        return this;
      }
      return offset - start;
    }

    /**
     * Reads a BitSet as an array of booleans.
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `length` if omitted.
     * @returns {Array<boolean>
     * @expose
     */
    ByteBufferPrototype.readBitSet = function(offset) {
      var relative = typeof offset === 'undefined';
      if (relative) offset = this.offset;

      var ret = this.readVarint32(offset),
          bits = ret.value,
          bytes = (bits >> 3),
          bit = 0,
          value = [],
          k;

      offset += ret.length;

      while(bytes--) {
        k = this.readByte(offset++);
        value[bit++] = !!(k & 0x01);
        value[bit++] = !!(k & 0x02);
        value[bit++] = !!(k & 0x04);
        value[bit++] = !!(k & 0x08);
        value[bit++] = !!(k & 0x10);
        value[bit++] = !!(k & 0x20);
        value[bit++] = !!(k & 0x40);
        value[bit++] = !!(k & 0x80);
      }

      if(bit < bits) {
        var m = 0;
        k = this.readByte(offset++);
        while(bit < bits) value[bit++] = !!((k >> (m++)) & 1);
      }

      if (relative) {
        this.offset = offset;
      }
      return value;
    }
    /**
     * Reads the specified number of bytes.
     * @param {number} length Number of bytes to read
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `length` if omitted.
     * @returns {!ByteBuffer}
     * @expose
     */
    ByteBufferPrototype.readBytes = function(length, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + length > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+length+") <= "+this.buffer.byteLength);
        }
        var slice = this.slice(offset, offset + length);
        if (relative) this.offset += length;
        return slice;
    };

    /**
     * Writes a payload of bytes. This is an alias of {@link ByteBuffer#append}.
     * @function
     * @param {!ByteBuffer|!ArrayBuffer|!Uint8Array|string} source Data to write. If `source` is a ByteBuffer, its offsets
     *  will be modified according to the performed read operation.
     * @param {(string|number)=} encoding Encoding if `data` is a string ("base64", "hex", "binary", defaults to "utf8")
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  written if omitted.
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.writeBytes = ByteBufferPrototype.append;

    // types/ints/int8

    /**
     * Writes an 8bit signed integer.
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.writeInt8 = function(value, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof value !== 'number' || value % 1 !== 0)
                throw TypeError("Illegal value: "+value+" (not an integer)");
            value |= 0;
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        offset += 1;
        var capacity0 = this.buffer.byteLength;
        if (offset > capacity0)
            this.resize((capacity0 *= 2) > offset ? capacity0 : offset);
        offset -= 1;
        this.view[offset] = value;
        if (relative) this.offset += 1;
        return this;
    };

    /**
     * Writes an 8bit signed integer. This is an alias of {@link ByteBuffer#writeInt8}.
     * @function
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.writeByte = ByteBufferPrototype.writeInt8;

    /**
     * Reads an 8bit signed integer.
     * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.
     * @returns {number} Value read
     * @expose
     */
    ByteBufferPrototype.readInt8 = function(offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 1 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+1+") <= "+this.buffer.byteLength);
        }
        var value = this.view[offset];
        if ((value & 0x80) === 0x80) value = -(0xFF - value + 1); // Cast to signed
        if (relative) this.offset += 1;
        return value;
    };

    /**
     * Reads an 8bit signed integer. This is an alias of {@link ByteBuffer#readInt8}.
     * @function
     * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.
     * @returns {number} Value read
     * @expose
     */
    ByteBufferPrototype.readByte = ByteBufferPrototype.readInt8;

    /**
     * Writes an 8bit unsigned integer.
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.writeUint8 = function(value, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof value !== 'number' || value % 1 !== 0)
                throw TypeError("Illegal value: "+value+" (not an integer)");
            value >>>= 0;
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        offset += 1;
        var capacity1 = this.buffer.byteLength;
        if (offset > capacity1)
            this.resize((capacity1 *= 2) > offset ? capacity1 : offset);
        offset -= 1;
        this.view[offset] = value;
        if (relative) this.offset += 1;
        return this;
    };

    /**
     * Writes an 8bit unsigned integer. This is an alias of {@link ByteBuffer#writeUint8}.
     * @function
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.writeUInt8 = ByteBufferPrototype.writeUint8;

    /**
     * Reads an 8bit unsigned integer.
     * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.
     * @returns {number} Value read
     * @expose
     */
    ByteBufferPrototype.readUint8 = function(offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 1 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+1+") <= "+this.buffer.byteLength);
        }
        var value = this.view[offset];
        if (relative) this.offset += 1;
        return value;
    };

    /**
     * Reads an 8bit unsigned integer. This is an alias of {@link ByteBuffer#readUint8}.
     * @function
     * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.
     * @returns {number} Value read
     * @expose
     */
    ByteBufferPrototype.readUInt8 = ByteBufferPrototype.readUint8;

    // types/ints/int16

    /**
     * Writes a 16bit signed integer.
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.
     * @throws {TypeError} If `offset` or `value` is not a valid number
     * @throws {RangeError} If `offset` is out of bounds
     * @expose
     */
    ByteBufferPrototype.writeInt16 = function(value, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof value !== 'number' || value % 1 !== 0)
                throw TypeError("Illegal value: "+value+" (not an integer)");
            value |= 0;
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        offset += 2;
        var capacity2 = this.buffer.byteLength;
        if (offset > capacity2)
            this.resize((capacity2 *= 2) > offset ? capacity2 : offset);
        offset -= 2;
        if (this.littleEndian) {
            this.view[offset+1] = (value & 0xFF00) >>> 8;
            this.view[offset  ] =  value & 0x00FF;
        } else {
            this.view[offset]   = (value & 0xFF00) >>> 8;
            this.view[offset+1] =  value & 0x00FF;
        }
        if (relative) this.offset += 2;
        return this;
    };

    /**
     * Writes a 16bit signed integer. This is an alias of {@link ByteBuffer#writeInt16}.
     * @function
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.
     * @throws {TypeError} If `offset` or `value` is not a valid number
     * @throws {RangeError} If `offset` is out of bounds
     * @expose
     */
    ByteBufferPrototype.writeShort = ByteBufferPrototype.writeInt16;

    /**
     * Reads a 16bit signed integer.
     * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.
     * @returns {number} Value read
     * @throws {TypeError} If `offset` is not a valid number
     * @throws {RangeError} If `offset` is out of bounds
     * @expose
     */
    ByteBufferPrototype.readInt16 = function(offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 2 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+2+") <= "+this.buffer.byteLength);
        }
        var value = 0;
        if (this.littleEndian) {
            value  = this.view[offset  ];
            value |= this.view[offset+1] << 8;
        } else {
            value  = this.view[offset  ] << 8;
            value |= this.view[offset+1];
        }
        if ((value & 0x8000) === 0x8000) value = -(0xFFFF - value + 1); // Cast to signed
        if (relative) this.offset += 2;
        return value;
    };

    /**
     * Reads a 16bit signed integer. This is an alias of {@link ByteBuffer#readInt16}.
     * @function
     * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.
     * @returns {number} Value read
     * @throws {TypeError} If `offset` is not a valid number
     * @throws {RangeError} If `offset` is out of bounds
     * @expose
     */
    ByteBufferPrototype.readShort = ByteBufferPrototype.readInt16;

    /**
     * Writes a 16bit unsigned integer.
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.
     * @throws {TypeError} If `offset` or `value` is not a valid number
     * @throws {RangeError} If `offset` is out of bounds
     * @expose
     */
    ByteBufferPrototype.writeUint16 = function(value, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof value !== 'number' || value % 1 !== 0)
                throw TypeError("Illegal value: "+value+" (not an integer)");
            value >>>= 0;
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        offset += 2;
        var capacity3 = this.buffer.byteLength;
        if (offset > capacity3)
            this.resize((capacity3 *= 2) > offset ? capacity3 : offset);
        offset -= 2;
        if (this.littleEndian) {
            this.view[offset+1] = (value & 0xFF00) >>> 8;
            this.view[offset  ] =  value & 0x00FF;
        } else {
            this.view[offset]   = (value & 0xFF00) >>> 8;
            this.view[offset+1] =  value & 0x00FF;
        }
        if (relative) this.offset += 2;
        return this;
    };

    /**
     * Writes a 16bit unsigned integer. This is an alias of {@link ByteBuffer#writeUint16}.
     * @function
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.
     * @throws {TypeError} If `offset` or `value` is not a valid number
     * @throws {RangeError} If `offset` is out of bounds
     * @expose
     */
    ByteBufferPrototype.writeUInt16 = ByteBufferPrototype.writeUint16;

    /**
     * Reads a 16bit unsigned integer.
     * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.
     * @returns {number} Value read
     * @throws {TypeError} If `offset` is not a valid number
     * @throws {RangeError} If `offset` is out of bounds
     * @expose
     */
    ByteBufferPrototype.readUint16 = function(offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 2 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+2+") <= "+this.buffer.byteLength);
        }
        var value = 0;
        if (this.littleEndian) {
            value  = this.view[offset  ];
            value |= this.view[offset+1] << 8;
        } else {
            value  = this.view[offset  ] << 8;
            value |= this.view[offset+1];
        }
        if (relative) this.offset += 2;
        return value;
    };

    /**
     * Reads a 16bit unsigned integer. This is an alias of {@link ByteBuffer#readUint16}.
     * @function
     * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.
     * @returns {number} Value read
     * @throws {TypeError} If `offset` is not a valid number
     * @throws {RangeError} If `offset` is out of bounds
     * @expose
     */
    ByteBufferPrototype.readUInt16 = ByteBufferPrototype.readUint16;

    // types/ints/int32

    /**
     * Writes a 32bit signed integer.
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
     * @expose
     */
    ByteBufferPrototype.writeInt32 = function(value, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof value !== 'number' || value % 1 !== 0)
                throw TypeError("Illegal value: "+value+" (not an integer)");
            value |= 0;
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        offset += 4;
        var capacity4 = this.buffer.byteLength;
        if (offset > capacity4)
            this.resize((capacity4 *= 2) > offset ? capacity4 : offset);
        offset -= 4;
        if (this.littleEndian) {
            this.view[offset+3] = (value >>> 24) & 0xFF;
            this.view[offset+2] = (value >>> 16) & 0xFF;
            this.view[offset+1] = (value >>>  8) & 0xFF;
            this.view[offset  ] =  value         & 0xFF;
        } else {
            this.view[offset  ] = (value >>> 24) & 0xFF;
            this.view[offset+1] = (value >>> 16) & 0xFF;
            this.view[offset+2] = (value >>>  8) & 0xFF;
            this.view[offset+3] =  value         & 0xFF;
        }
        if (relative) this.offset += 4;
        return this;
    };

    /**
     * Writes a 32bit signed integer. This is an alias of {@link ByteBuffer#writeInt32}.
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
     * @expose
     */
    ByteBufferPrototype.writeInt = ByteBufferPrototype.writeInt32;

    /**
     * Reads a 32bit signed integer.
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
     * @returns {number} Value read
     * @expose
     */
    ByteBufferPrototype.readInt32 = function(offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 4 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+4+") <= "+this.buffer.byteLength);
        }
        var value = 0;
        if (this.littleEndian) {
            value  = this.view[offset+2] << 16;
            value |= this.view[offset+1] <<  8;
            value |= this.view[offset  ];
            value += this.view[offset+3] << 24 >>> 0;
        } else {
            value  = this.view[offset+1] << 16;
            value |= this.view[offset+2] <<  8;
            value |= this.view[offset+3];
            value += this.view[offset  ] << 24 >>> 0;
        }
        value |= 0; // Cast to signed
        if (relative) this.offset += 4;
        return value;
    };

    /**
     * Reads a 32bit signed integer. This is an alias of {@link ByteBuffer#readInt32}.
     * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `4` if omitted.
     * @returns {number} Value read
     * @expose
     */
    ByteBufferPrototype.readInt = ByteBufferPrototype.readInt32;

    /**
     * Writes a 32bit unsigned integer.
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
     * @expose
     */
    ByteBufferPrototype.writeUint32 = function(value, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof value !== 'number' || value % 1 !== 0)
                throw TypeError("Illegal value: "+value+" (not an integer)");
            value >>>= 0;
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        offset += 4;
        var capacity5 = this.buffer.byteLength;
        if (offset > capacity5)
            this.resize((capacity5 *= 2) > offset ? capacity5 : offset);
        offset -= 4;
        if (this.littleEndian) {
            this.view[offset+3] = (value >>> 24) & 0xFF;
            this.view[offset+2] = (value >>> 16) & 0xFF;
            this.view[offset+1] = (value >>>  8) & 0xFF;
            this.view[offset  ] =  value         & 0xFF;
        } else {
            this.view[offset  ] = (value >>> 24) & 0xFF;
            this.view[offset+1] = (value >>> 16) & 0xFF;
            this.view[offset+2] = (value >>>  8) & 0xFF;
            this.view[offset+3] =  value         & 0xFF;
        }
        if (relative) this.offset += 4;
        return this;
    };

    /**
     * Writes a 32bit unsigned integer. This is an alias of {@link ByteBuffer#writeUint32}.
     * @function
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
     * @expose
     */
    ByteBufferPrototype.writeUInt32 = ByteBufferPrototype.writeUint32;

    /**
     * Reads a 32bit unsigned integer.
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
     * @returns {number} Value read
     * @expose
     */
    ByteBufferPrototype.readUint32 = function(offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 4 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+4+") <= "+this.buffer.byteLength);
        }
        var value = 0;
        if (this.littleEndian) {
            value  = this.view[offset+2] << 16;
            value |= this.view[offset+1] <<  8;
            value |= this.view[offset  ];
            value += this.view[offset+3] << 24 >>> 0;
        } else {
            value  = this.view[offset+1] << 16;
            value |= this.view[offset+2] <<  8;
            value |= this.view[offset+3];
            value += this.view[offset  ] << 24 >>> 0;
        }
        if (relative) this.offset += 4;
        return value;
    };

    /**
     * Reads a 32bit unsigned integer. This is an alias of {@link ByteBuffer#readUint32}.
     * @function
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
     * @returns {number} Value read
     * @expose
     */
    ByteBufferPrototype.readUInt32 = ByteBufferPrototype.readUint32;

    // types/ints/int64

    if (Long) {

        /**
         * Writes a 64bit signed integer.
         * @param {number|!Long} value Value to write
         * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
         * @returns {!ByteBuffer} this
         * @expose
         */
        ByteBufferPrototype.writeInt64 = function(value, offset) {
            var relative = typeof offset === 'undefined';
            if (relative) offset = this.offset;
            if (!this.noAssert) {
                if (typeof value === 'number')
                    value = Long.fromNumber(value);
                else if (typeof value === 'string')
                    value = Long.fromString(value);
                else if (!(value && value instanceof Long))
                    throw TypeError("Illegal value: "+value+" (not an integer or Long)");
                if (typeof offset !== 'number' || offset % 1 !== 0)
                    throw TypeError("Illegal offset: "+offset+" (not an integer)");
                offset >>>= 0;
                if (offset < 0 || offset + 0 > this.buffer.byteLength)
                    throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
            }
            if (typeof value === 'number')
                value = Long.fromNumber(value);
            else if (typeof value === 'string')
                value = Long.fromString(value);
            offset += 8;
            var capacity6 = this.buffer.byteLength;
            if (offset > capacity6)
                this.resize((capacity6 *= 2) > offset ? capacity6 : offset);
            offset -= 8;
            var lo = value.low,
                hi = value.high;
            if (this.littleEndian) {
                this.view[offset+3] = (lo >>> 24) & 0xFF;
                this.view[offset+2] = (lo >>> 16) & 0xFF;
                this.view[offset+1] = (lo >>>  8) & 0xFF;
                this.view[offset  ] =  lo         & 0xFF;
                offset += 4;
                this.view[offset+3] = (hi >>> 24) & 0xFF;
                this.view[offset+2] = (hi >>> 16) & 0xFF;
                this.view[offset+1] = (hi >>>  8) & 0xFF;
                this.view[offset  ] =  hi         & 0xFF;
            } else {
                this.view[offset  ] = (hi >>> 24) & 0xFF;
                this.view[offset+1] = (hi >>> 16) & 0xFF;
                this.view[offset+2] = (hi >>>  8) & 0xFF;
                this.view[offset+3] =  hi         & 0xFF;
                offset += 4;
                this.view[offset  ] = (lo >>> 24) & 0xFF;
                this.view[offset+1] = (lo >>> 16) & 0xFF;
                this.view[offset+2] = (lo >>>  8) & 0xFF;
                this.view[offset+3] =  lo         & 0xFF;
            }
            if (relative) this.offset += 8;
            return this;
        };

        /**
         * Writes a 64bit signed integer. This is an alias of {@link ByteBuffer#writeInt64}.
         * @param {number|!Long} value Value to write
         * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
         * @returns {!ByteBuffer} this
         * @expose
         */
        ByteBufferPrototype.writeLong = ByteBufferPrototype.writeInt64;

        /**
         * Reads a 64bit signed integer.
         * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
         * @returns {!Long}
         * @expose
         */
        ByteBufferPrototype.readInt64 = function(offset) {
            var relative = typeof offset === 'undefined';
            if (relative) offset = this.offset;
            if (!this.noAssert) {
                if (typeof offset !== 'number' || offset % 1 !== 0)
                    throw TypeError("Illegal offset: "+offset+" (not an integer)");
                offset >>>= 0;
                if (offset < 0 || offset + 8 > this.buffer.byteLength)
                    throw RangeError("Illegal offset: 0 <= "+offset+" (+"+8+") <= "+this.buffer.byteLength);
            }
            var lo = 0,
                hi = 0;
            if (this.littleEndian) {
                lo  = this.view[offset+2] << 16;
                lo |= this.view[offset+1] <<  8;
                lo |= this.view[offset  ];
                lo += this.view[offset+3] << 24 >>> 0;
                offset += 4;
                hi  = this.view[offset+2] << 16;
                hi |= this.view[offset+1] <<  8;
                hi |= this.view[offset  ];
                hi += this.view[offset+3] << 24 >>> 0;
            } else {
                hi  = this.view[offset+1] << 16;
                hi |= this.view[offset+2] <<  8;
                hi |= this.view[offset+3];
                hi += this.view[offset  ] << 24 >>> 0;
                offset += 4;
                lo  = this.view[offset+1] << 16;
                lo |= this.view[offset+2] <<  8;
                lo |= this.view[offset+3];
                lo += this.view[offset  ] << 24 >>> 0;
            }
            var value = new Long(lo, hi, false);
            if (relative) this.offset += 8;
            return value;
        };

        /**
         * Reads a 64bit signed integer. This is an alias of {@link ByteBuffer#readInt64}.
         * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
         * @returns {!Long}
         * @expose
         */
        ByteBufferPrototype.readLong = ByteBufferPrototype.readInt64;

        /**
         * Writes a 64bit unsigned integer.
         * @param {number|!Long} value Value to write
         * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
         * @returns {!ByteBuffer} this
         * @expose
         */
        ByteBufferPrototype.writeUint64 = function(value, offset) {
            var relative = typeof offset === 'undefined';
            if (relative) offset = this.offset;
            if (!this.noAssert) {
                if (typeof value === 'number')
                    value = Long.fromNumber(value);
                else if (typeof value === 'string')
                    value = Long.fromString(value);
                else if (!(value && value instanceof Long))
                    throw TypeError("Illegal value: "+value+" (not an integer or Long)");
                if (typeof offset !== 'number' || offset % 1 !== 0)
                    throw TypeError("Illegal offset: "+offset+" (not an integer)");
                offset >>>= 0;
                if (offset < 0 || offset + 0 > this.buffer.byteLength)
                    throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
            }
            if (typeof value === 'number')
                value = Long.fromNumber(value);
            else if (typeof value === 'string')
                value = Long.fromString(value);
            offset += 8;
            var capacity7 = this.buffer.byteLength;
            if (offset > capacity7)
                this.resize((capacity7 *= 2) > offset ? capacity7 : offset);
            offset -= 8;
            var lo = value.low,
                hi = value.high;
            if (this.littleEndian) {
                this.view[offset+3] = (lo >>> 24) & 0xFF;
                this.view[offset+2] = (lo >>> 16) & 0xFF;
                this.view[offset+1] = (lo >>>  8) & 0xFF;
                this.view[offset  ] =  lo         & 0xFF;
                offset += 4;
                this.view[offset+3] = (hi >>> 24) & 0xFF;
                this.view[offset+2] = (hi >>> 16) & 0xFF;
                this.view[offset+1] = (hi >>>  8) & 0xFF;
                this.view[offset  ] =  hi         & 0xFF;
            } else {
                this.view[offset  ] = (hi >>> 24) & 0xFF;
                this.view[offset+1] = (hi >>> 16) & 0xFF;
                this.view[offset+2] = (hi >>>  8) & 0xFF;
                this.view[offset+3] =  hi         & 0xFF;
                offset += 4;
                this.view[offset  ] = (lo >>> 24) & 0xFF;
                this.view[offset+1] = (lo >>> 16) & 0xFF;
                this.view[offset+2] = (lo >>>  8) & 0xFF;
                this.view[offset+3] =  lo         & 0xFF;
            }
            if (relative) this.offset += 8;
            return this;
        };

        /**
         * Writes a 64bit unsigned integer. This is an alias of {@link ByteBuffer#writeUint64}.
         * @function
         * @param {number|!Long} value Value to write
         * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
         * @returns {!ByteBuffer} this
         * @expose
         */
        ByteBufferPrototype.writeUInt64 = ByteBufferPrototype.writeUint64;

        /**
         * Reads a 64bit unsigned integer.
         * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
         * @returns {!Long}
         * @expose
         */
        ByteBufferPrototype.readUint64 = function(offset) {
            var relative = typeof offset === 'undefined';
            if (relative) offset = this.offset;
            if (!this.noAssert) {
                if (typeof offset !== 'number' || offset % 1 !== 0)
                    throw TypeError("Illegal offset: "+offset+" (not an integer)");
                offset >>>= 0;
                if (offset < 0 || offset + 8 > this.buffer.byteLength)
                    throw RangeError("Illegal offset: 0 <= "+offset+" (+"+8+") <= "+this.buffer.byteLength);
            }
            var lo = 0,
                hi = 0;
            if (this.littleEndian) {
                lo  = this.view[offset+2] << 16;
                lo |= this.view[offset+1] <<  8;
                lo |= this.view[offset  ];
                lo += this.view[offset+3] << 24 >>> 0;
                offset += 4;
                hi  = this.view[offset+2] << 16;
                hi |= this.view[offset+1] <<  8;
                hi |= this.view[offset  ];
                hi += this.view[offset+3] << 24 >>> 0;
            } else {
                hi  = this.view[offset+1] << 16;
                hi |= this.view[offset+2] <<  8;
                hi |= this.view[offset+3];
                hi += this.view[offset  ] << 24 >>> 0;
                offset += 4;
                lo  = this.view[offset+1] << 16;
                lo |= this.view[offset+2] <<  8;
                lo |= this.view[offset+3];
                lo += this.view[offset  ] << 24 >>> 0;
            }
            var value = new Long(lo, hi, true);
            if (relative) this.offset += 8;
            return value;
        };

        /**
         * Reads a 64bit unsigned integer. This is an alias of {@link ByteBuffer#readUint64}.
         * @function
         * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
         * @returns {!Long}
         * @expose
         */
        ByteBufferPrototype.readUInt64 = ByteBufferPrototype.readUint64;

    } // Long


    // types/floats/float32

    /*
     ieee754 - https://github.com/feross/ieee754

     The MIT License (MIT)

     Copyright (c) Feross Aboukhadijeh

     Permission is hereby granted, free of charge, to any person obtaining a copy
     of this software and associated documentation files (the "Software"), to deal
     in the Software without restriction, including without limitation the rights
     to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     copies of the Software, and to permit persons to whom the Software is
     furnished to do so, subject to the following conditions:

     The above copyright notice and this permission notice shall be included in
     all copies or substantial portions of the Software.

     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     THE SOFTWARE.
    */

    /**
     * Reads an IEEE754 float from a byte array.
     * @param {!Array} buffer
     * @param {number} offset
     * @param {boolean} isLE
     * @param {number} mLen
     * @param {number} nBytes
     * @returns {number}
     * @inner
     */
    function ieee754_read(buffer, offset, isLE, mLen, nBytes) {
        var e, m,
            eLen = nBytes * 8 - mLen - 1,
            eMax = (1 << eLen) - 1,
            eBias = eMax >> 1,
            nBits = -7,
            i = isLE ? (nBytes - 1) : 0,
            d = isLE ? -1 : 1,
            s = buffer[offset + i];

        i += d;

        e = s & ((1 << (-nBits)) - 1);
        s >>= (-nBits);
        nBits += eLen;
        for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

        m = e & ((1 << (-nBits)) - 1);
        e >>= (-nBits);
        nBits += mLen;
        for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

        if (e === 0) {
            e = 1 - eBias;
        } else if (e === eMax) {
            return m ? NaN : ((s ? -1 : 1) * Infinity);
        } else {
            m = m + Math.pow(2, mLen);
            e = e - eBias;
        }
        return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
    }

    /**
     * Writes an IEEE754 float to a byte array.
     * @param {!Array} buffer
     * @param {number} value
     * @param {number} offset
     * @param {boolean} isLE
     * @param {number} mLen
     * @param {number} nBytes
     * @inner
     */
    function ieee754_write(buffer, value, offset, isLE, mLen, nBytes) {
        var e, m, c,
            eLen = nBytes * 8 - mLen - 1,
            eMax = (1 << eLen) - 1,
            eBias = eMax >> 1,
            rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
            i = isLE ? 0 : (nBytes - 1),
            d = isLE ? 1 : -1,
            s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

        value = Math.abs(value);

        if (isNaN(value) || value === Infinity) {
            m = isNaN(value) ? 1 : 0;
            e = eMax;
        } else {
            e = Math.floor(Math.log(value) / Math.LN2);
            if (value * (c = Math.pow(2, -e)) < 1) {
                e--;
                c *= 2;
            }
            if (e + eBias >= 1) {
                value += rt / c;
            } else {
                value += rt * Math.pow(2, 1 - eBias);
            }
            if (value * c >= 2) {
                e++;
                c /= 2;
            }

            if (e + eBias >= eMax) {
                m = 0;
                e = eMax;
            } else if (e + eBias >= 1) {
                m = (value * c - 1) * Math.pow(2, mLen);
                e = e + eBias;
            } else {
                m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
                e = 0;
            }
        }

        for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

        e = (e << mLen) | m;
        eLen += mLen;
        for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

        buffer[offset + i - d] |= s * 128;
    }

    /**
     * Writes a 32bit float.
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.writeFloat32 = function(value, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof value !== 'number')
                throw TypeError("Illegal value: "+value+" (not a number)");
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        offset += 4;
        var capacity8 = this.buffer.byteLength;
        if (offset > capacity8)
            this.resize((capacity8 *= 2) > offset ? capacity8 : offset);
        offset -= 4;
        ieee754_write(this.view, value, offset, this.littleEndian, 23, 4);
        if (relative) this.offset += 4;
        return this;
    };

    /**
     * Writes a 32bit float. This is an alias of {@link ByteBuffer#writeFloat32}.
     * @function
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.writeFloat = ByteBufferPrototype.writeFloat32;

    /**
     * Reads a 32bit float.
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
     * @returns {number}
     * @expose
     */
    ByteBufferPrototype.readFloat32 = function(offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 4 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+4+") <= "+this.buffer.byteLength);
        }
        var value = ieee754_read(this.view, offset, this.littleEndian, 23, 4);
        if (relative) this.offset += 4;
        return value;
    };

    /**
     * Reads a 32bit float. This is an alias of {@link ByteBuffer#readFloat32}.
     * @function
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
     * @returns {number}
     * @expose
     */
    ByteBufferPrototype.readFloat = ByteBufferPrototype.readFloat32;

    // types/floats/float64

    /**
     * Writes a 64bit float.
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.writeFloat64 = function(value, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof value !== 'number')
                throw TypeError("Illegal value: "+value+" (not a number)");
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        offset += 8;
        var capacity9 = this.buffer.byteLength;
        if (offset > capacity9)
            this.resize((capacity9 *= 2) > offset ? capacity9 : offset);
        offset -= 8;
        ieee754_write(this.view, value, offset, this.littleEndian, 52, 8);
        if (relative) this.offset += 8;
        return this;
    };

    /**
     * Writes a 64bit float. This is an alias of {@link ByteBuffer#writeFloat64}.
     * @function
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.writeDouble = ByteBufferPrototype.writeFloat64;

    /**
     * Reads a 64bit float.
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
     * @returns {number}
     * @expose
     */
    ByteBufferPrototype.readFloat64 = function(offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 8 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+8+") <= "+this.buffer.byteLength);
        }
        var value = ieee754_read(this.view, offset, this.littleEndian, 52, 8);
        if (relative) this.offset += 8;
        return value;
    };

    /**
     * Reads a 64bit float. This is an alias of {@link ByteBuffer#readFloat64}.
     * @function
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
     * @returns {number}
     * @expose
     */
    ByteBufferPrototype.readDouble = ByteBufferPrototype.readFloat64;


    // types/varints/varint32

    /**
     * Maximum number of bytes required to store a 32bit base 128 variable-length integer.
     * @type {number}
     * @const
     * @expose
     */
    ByteBuffer.MAX_VARINT32_BYTES = 5;

    /**
     * Calculates the actual number of bytes required to store a 32bit base 128 variable-length integer.
     * @param {number} value Value to encode
     * @returns {number} Number of bytes required. Capped to {@link ByteBuffer.MAX_VARINT32_BYTES}
     * @expose
     */
    ByteBuffer.calculateVarint32 = function(value) {
        // ref: src/google/protobuf/io/coded_stream.cc
        value = value >>> 0;
             if (value < 1 << 7 ) return 1;
        else if (value < 1 << 14) return 2;
        else if (value < 1 << 21) return 3;
        else if (value < 1 << 28) return 4;
        else                      return 5;
    };

    /**
     * Zigzag encodes a signed 32bit integer so that it can be effectively used with varint encoding.
     * @param {number} n Signed 32bit integer
     * @returns {number} Unsigned zigzag encoded 32bit integer
     * @expose
     */
    ByteBuffer.zigZagEncode32 = function(n) {
        return (((n |= 0) << 1) ^ (n >> 31)) >>> 0; // ref: src/google/protobuf/wire_format_lite.h
    };

    /**
     * Decodes a zigzag encoded signed 32bit integer.
     * @param {number} n Unsigned zigzag encoded 32bit integer
     * @returns {number} Signed 32bit integer
     * @expose
     */
    ByteBuffer.zigZagDecode32 = function(n) {
        return ((n >>> 1) ^ -(n & 1)) | 0; // // ref: src/google/protobuf/wire_format_lite.h
    };

    /**
     * Writes a 32bit base 128 variable-length integer.
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  written if omitted.
     * @returns {!ByteBuffer|number} this if `offset` is omitted, else the actual number of bytes written
     * @expose
     */
    ByteBufferPrototype.writeVarint32 = function(value, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof value !== 'number' || value % 1 !== 0)
                throw TypeError("Illegal value: "+value+" (not an integer)");
            value |= 0;
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        var size = ByteBuffer.calculateVarint32(value),
            b;
        offset += size;
        var capacity10 = this.buffer.byteLength;
        if (offset > capacity10)
            this.resize((capacity10 *= 2) > offset ? capacity10 : offset);
        offset -= size;
        value >>>= 0;
        while (value >= 0x80) {
            b = (value & 0x7f) | 0x80;
            this.view[offset++] = b;
            value >>>= 7;
        }
        this.view[offset++] = value;
        if (relative) {
            this.offset = offset;
            return this;
        }
        return size;
    };

    /**
     * Writes a zig-zag encoded (signed) 32bit base 128 variable-length integer.
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  written if omitted.
     * @returns {!ByteBuffer|number} this if `offset` is omitted, else the actual number of bytes written
     * @expose
     */
    ByteBufferPrototype.writeVarint32ZigZag = function(value, offset) {
        return this.writeVarint32(ByteBuffer.zigZagEncode32(value), offset);
    };

    /**
     * Reads a 32bit base 128 variable-length integer.
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  written if omitted.
     * @returns {number|!{value: number, length: number}} The value read if offset is omitted, else the value read
     *  and the actual number of bytes read.
     * @throws {Error} If it's not a valid varint. Has a property `truncated = true` if there is not enough data available
     *  to fully decode the varint.
     * @expose
     */
    ByteBufferPrototype.readVarint32 = function(offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 1 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+1+") <= "+this.buffer.byteLength);
        }
        var c = 0,
            value = 0 >>> 0,
            b;
        do {
            if (!this.noAssert && offset > this.limit) {
                var err = Error("Truncated");
                err['truncated'] = true;
                throw err;
            }
            b = this.view[offset++];
            if (c < 5)
                value |= (b & 0x7f) << (7*c);
            ++c;
        } while ((b & 0x80) !== 0);
        value |= 0;
        if (relative) {
            this.offset = offset;
            return value;
        }
        return {
            "value": value,
            "length": c
        };
    };

    /**
     * Reads a zig-zag encoded (signed) 32bit base 128 variable-length integer.
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  written if omitted.
     * @returns {number|!{value: number, length: number}} The value read if offset is omitted, else the value read
     *  and the actual number of bytes read.
     * @throws {Error} If it's not a valid varint
     * @expose
     */
    ByteBufferPrototype.readVarint32ZigZag = function(offset) {
        var val = this.readVarint32(offset);
        if (typeof val === 'object')
            val["value"] = ByteBuffer.zigZagDecode32(val["value"]);
        else
            val = ByteBuffer.zigZagDecode32(val);
        return val;
    };

    // types/varints/varint64

    if (Long) {

        /**
         * Maximum number of bytes required to store a 64bit base 128 variable-length integer.
         * @type {number}
         * @const
         * @expose
         */
        ByteBuffer.MAX_VARINT64_BYTES = 10;

        /**
         * Calculates the actual number of bytes required to store a 64bit base 128 variable-length integer.
         * @param {number|!Long} value Value to encode
         * @returns {number} Number of bytes required. Capped to {@link ByteBuffer.MAX_VARINT64_BYTES}
         * @expose
         */
        ByteBuffer.calculateVarint64 = function(value) {
            if (typeof value === 'number')
                value = Long.fromNumber(value);
            else if (typeof value === 'string')
                value = Long.fromString(value);
            // ref: src/google/protobuf/io/coded_stream.cc
            var part0 = value.toInt() >>> 0,
                part1 = value.shiftRightUnsigned(28).toInt() >>> 0,
                part2 = value.shiftRightUnsigned(56).toInt() >>> 0;
            if (part2 == 0) {
                if (part1 == 0) {
                    if (part0 < 1 << 14)
                        return part0 < 1 << 7 ? 1 : 2;
                    else
                        return part0 < 1 << 21 ? 3 : 4;
                } else {
                    if (part1 < 1 << 14)
                        return part1 < 1 << 7 ? 5 : 6;
                    else
                        return part1 < 1 << 21 ? 7 : 8;
                }
            } else
                return part2 < 1 << 7 ? 9 : 10;
        };

        /**
         * Zigzag encodes a signed 64bit integer so that it can be effectively used with varint encoding.
         * @param {number|!Long} value Signed long
         * @returns {!Long} Unsigned zigzag encoded long
         * @expose
         */
        ByteBuffer.zigZagEncode64 = function(value) {
            if (typeof value === 'number')
                value = Long.fromNumber(value, false);
            else if (typeof value === 'string')
                value = Long.fromString(value, false);
            else if (value.unsigned !== false) value = value.toSigned();
            // ref: src/google/protobuf/wire_format_lite.h
            return value.shiftLeft(1).xor(value.shiftRight(63)).toUnsigned();
        };

        /**
         * Decodes a zigzag encoded signed 64bit integer.
         * @param {!Long|number} value Unsigned zigzag encoded long or JavaScript number
         * @returns {!Long} Signed long
         * @expose
         */
        ByteBuffer.zigZagDecode64 = function(value) {
            if (typeof value === 'number')
                value = Long.fromNumber(value, false);
            else if (typeof value === 'string')
                value = Long.fromString(value, false);
            else if (value.unsigned !== false) value = value.toSigned();
            // ref: src/google/protobuf/wire_format_lite.h
            return value.shiftRightUnsigned(1).xor(value.and(Long.ONE).toSigned().negate()).toSigned();
        };

        /**
         * Writes a 64bit base 128 variable-length integer.
         * @param {number|Long} value Value to write
         * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
         *  written if omitted.
         * @returns {!ByteBuffer|number} `this` if offset is omitted, else the actual number of bytes written.
         * @expose
         */
        ByteBufferPrototype.writeVarint64 = function(value, offset) {
            var relative = typeof offset === 'undefined';
            if (relative) offset = this.offset;
            if (!this.noAssert) {
                if (typeof value === 'number')
                    value = Long.fromNumber(value);
                else if (typeof value === 'string')
                    value = Long.fromString(value);
                else if (!(value && value instanceof Long))
                    throw TypeError("Illegal value: "+value+" (not an integer or Long)");
                if (typeof offset !== 'number' || offset % 1 !== 0)
                    throw TypeError("Illegal offset: "+offset+" (not an integer)");
                offset >>>= 0;
                if (offset < 0 || offset + 0 > this.buffer.byteLength)
                    throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
            }
            if (typeof value === 'number')
                value = Long.fromNumber(value, false);
            else if (typeof value === 'string')
                value = Long.fromString(value, false);
            else if (value.unsigned !== false) value = value.toSigned();
            var size = ByteBuffer.calculateVarint64(value),
                part0 = value.toInt() >>> 0,
                part1 = value.shiftRightUnsigned(28).toInt() >>> 0,
                part2 = value.shiftRightUnsigned(56).toInt() >>> 0;
            offset += size;
            var capacity11 = this.buffer.byteLength;
            if (offset > capacity11)
                this.resize((capacity11 *= 2) > offset ? capacity11 : offset);
            offset -= size;
            switch (size) {
                case 10: this.view[offset+9] = (part2 >>>  7) & 0x01;
                case 9 : this.view[offset+8] = size !== 9 ? (part2       ) | 0x80 : (part2       ) & 0x7F;
                case 8 : this.view[offset+7] = size !== 8 ? (part1 >>> 21) | 0x80 : (part1 >>> 21) & 0x7F;
                case 7 : this.view[offset+6] = size !== 7 ? (part1 >>> 14) | 0x80 : (part1 >>> 14) & 0x7F;
                case 6 : this.view[offset+5] = size !== 6 ? (part1 >>>  7) | 0x80 : (part1 >>>  7) & 0x7F;
                case 5 : this.view[offset+4] = size !== 5 ? (part1       ) | 0x80 : (part1       ) & 0x7F;
                case 4 : this.view[offset+3] = size !== 4 ? (part0 >>> 21) | 0x80 : (part0 >>> 21) & 0x7F;
                case 3 : this.view[offset+2] = size !== 3 ? (part0 >>> 14) | 0x80 : (part0 >>> 14) & 0x7F;
                case 2 : this.view[offset+1] = size !== 2 ? (part0 >>>  7) | 0x80 : (part0 >>>  7) & 0x7F;
                case 1 : this.view[offset  ] = size !== 1 ? (part0       ) | 0x80 : (part0       ) & 0x7F;
            }
            if (relative) {
                this.offset += size;
                return this;
            } else {
                return size;
            }
        };

        /**
         * Writes a zig-zag encoded 64bit base 128 variable-length integer.
         * @param {number|Long} value Value to write
         * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
         *  written if omitted.
         * @returns {!ByteBuffer|number} `this` if offset is omitted, else the actual number of bytes written.
         * @expose
         */
        ByteBufferPrototype.writeVarint64ZigZag = function(value, offset) {
            return this.writeVarint64(ByteBuffer.zigZagEncode64(value), offset);
        };

        /**
         * Reads a 64bit base 128 variable-length integer. Requires Long.js.
         * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
         *  read if omitted.
         * @returns {!Long|!{value: Long, length: number}} The value read if offset is omitted, else the value read and
         *  the actual number of bytes read.
         * @throws {Error} If it's not a valid varint
         * @expose
         */
        ByteBufferPrototype.readVarint64 = function(offset) {
            var relative = typeof offset === 'undefined';
            if (relative) offset = this.offset;
            if (!this.noAssert) {
                if (typeof offset !== 'number' || offset % 1 !== 0)
                    throw TypeError("Illegal offset: "+offset+" (not an integer)");
                offset >>>= 0;
                if (offset < 0 || offset + 1 > this.buffer.byteLength)
                    throw RangeError("Illegal offset: 0 <= "+offset+" (+"+1+") <= "+this.buffer.byteLength);
            }
            // ref: src/google/protobuf/io/coded_stream.cc
            var start = offset,
                part0 = 0,
                part1 = 0,
                part2 = 0,
                b  = 0;
            b = this.view[offset++]; part0  = (b & 0x7F)      ; if ( b & 0x80                                                   ) {
            b = this.view[offset++]; part0 |= (b & 0x7F) <<  7; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) {
            b = this.view[offset++]; part0 |= (b & 0x7F) << 14; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) {
            b = this.view[offset++]; part0 |= (b & 0x7F) << 21; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) {
            b = this.view[offset++]; part1  = (b & 0x7F)      ; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) {
            b = this.view[offset++]; part1 |= (b & 0x7F) <<  7; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) {
            b = this.view[offset++]; part1 |= (b & 0x7F) << 14; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) {
            b = this.view[offset++]; part1 |= (b & 0x7F) << 21; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) {
            b = this.view[offset++]; part2  = (b & 0x7F)      ; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) {
            b = this.view[offset++]; part2 |= (b & 0x7F) <<  7; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) {
            throw Error("Buffer overrun"); }}}}}}}}}}
            var value = Long.fromBits(part0 | (part1 << 28), (part1 >>> 4) | (part2) << 24, false);
            if (relative) {
                this.offset = offset;
                return value;
            } else {
                return {
                    'value': value,
                    'length': offset-start
                };
            }
        };

        /**
         * Reads a zig-zag encoded 64bit base 128 variable-length integer. Requires Long.js.
         * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
         *  read if omitted.
         * @returns {!Long|!{value: Long, length: number}} The value read if offset is omitted, else the value read and
         *  the actual number of bytes read.
         * @throws {Error} If it's not a valid varint
         * @expose
         */
        ByteBufferPrototype.readVarint64ZigZag = function(offset) {
            var val = this.readVarint64(offset);
            if (val && val['value'] instanceof Long)
                val["value"] = ByteBuffer.zigZagDecode64(val["value"]);
            else
                val = ByteBuffer.zigZagDecode64(val);
            return val;
        };

    } // Long


    // types/strings/cstring

    /**
     * Writes a NULL-terminated UTF8 encoded string. For this to work the specified string must not contain any NULL
     *  characters itself.
     * @param {string} str String to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  contained in `str` + 1 if omitted.
     * @returns {!ByteBuffer|number} this if offset is omitted, else the actual number of bytes written
     * @expose
     */
    ByteBufferPrototype.writeCString = function(str, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        var i,
            k = str.length;
        if (!this.noAssert) {
            if (typeof str !== 'string')
                throw TypeError("Illegal str: Not a string");
            for (i=0; i<k; ++i) {
                if (str.charCodeAt(i) === 0)
                    throw RangeError("Illegal str: Contains NULL-characters");
            }
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        // UTF8 strings do not contain zero bytes in between except for the zero character, so:
        k = utfx.calculateUTF16asUTF8(stringSource(str))[1];
        offset += k+1;
        var capacity12 = this.buffer.byteLength;
        if (offset > capacity12)
            this.resize((capacity12 *= 2) > offset ? capacity12 : offset);
        offset -= k+1;
        utfx.encodeUTF16toUTF8(stringSource(str), function(b) {
            this.view[offset++] = b;
        }.bind(this));
        this.view[offset++] = 0;
        if (relative) {
            this.offset = offset;
            return this;
        }
        return k;
    };

    /**
     * Reads a NULL-terminated UTF8 encoded string. For this to work the string read must not contain any NULL characters
     *  itself.
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  read if omitted.
     * @returns {string|!{string: string, length: number}} The string read if offset is omitted, else the string
     *  read and the actual number of bytes read.
     * @expose
     */
    ByteBufferPrototype.readCString = function(offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 1 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+1+") <= "+this.buffer.byteLength);
        }
        var start = offset,
            temp;
        // UTF8 strings do not contain zero bytes in between except for the zero character itself, so:
        var sd, b = -1;
        utfx.decodeUTF8toUTF16(function() {
            if (b === 0) return null;
            if (offset >= this.limit)
                throw RangeError("Illegal range: Truncated data, "+offset+" < "+this.limit);
            b = this.view[offset++];
            return b === 0 ? null : b;
        }.bind(this), sd = stringDestination(), true);
        if (relative) {
            this.offset = offset;
            return sd();
        } else {
            return {
                "string": sd(),
                "length": offset - start
            };
        }
    };

    // types/strings/istring

    /**
     * Writes a length as uint32 prefixed UTF8 encoded string.
     * @param {string} str String to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  written if omitted.
     * @returns {!ByteBuffer|number} `this` if `offset` is omitted, else the actual number of bytes written
     * @expose
     * @see ByteBuffer#writeVarint32
     */
    ByteBufferPrototype.writeIString = function(str, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof str !== 'string')
                throw TypeError("Illegal str: Not a string");
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        var start = offset,
            k;
        k = utfx.calculateUTF16asUTF8(stringSource(str), this.noAssert)[1];
        offset += 4+k;
        var capacity13 = this.buffer.byteLength;
        if (offset > capacity13)
            this.resize((capacity13 *= 2) > offset ? capacity13 : offset);
        offset -= 4+k;
        if (this.littleEndian) {
            this.view[offset+3] = (k >>> 24) & 0xFF;
            this.view[offset+2] = (k >>> 16) & 0xFF;
            this.view[offset+1] = (k >>>  8) & 0xFF;
            this.view[offset  ] =  k         & 0xFF;
        } else {
            this.view[offset  ] = (k >>> 24) & 0xFF;
            this.view[offset+1] = (k >>> 16) & 0xFF;
            this.view[offset+2] = (k >>>  8) & 0xFF;
            this.view[offset+3] =  k         & 0xFF;
        }
        offset += 4;
        utfx.encodeUTF16toUTF8(stringSource(str), function(b) {
            this.view[offset++] = b;
        }.bind(this));
        if (offset !== start + 4 + k)
            throw RangeError("Illegal range: Truncated data, "+offset+" == "+(offset+4+k));
        if (relative) {
            this.offset = offset;
            return this;
        }
        return offset - start;
    };

    /**
     * Reads a length as uint32 prefixed UTF8 encoded string.
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  read if omitted.
     * @returns {string|!{string: string, length: number}} The string read if offset is omitted, else the string
     *  read and the actual number of bytes read.
     * @expose
     * @see ByteBuffer#readVarint32
     */
    ByteBufferPrototype.readIString = function(offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 4 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+4+") <= "+this.buffer.byteLength);
        }
        var start = offset;
        var len = this.readUint32(offset);
        var str = this.readUTF8String(len, ByteBuffer.METRICS_BYTES, offset += 4);
        offset += str['length'];
        if (relative) {
            this.offset = offset;
            return str['string'];
        } else {
            return {
                'string': str['string'],
                'length': offset - start
            };
        }
    };

    // types/strings/utf8string

    /**
     * Metrics representing number of UTF8 characters. Evaluates to `c`.
     * @type {string}
     * @const
     * @expose
     */
    ByteBuffer.METRICS_CHARS = 'c';

    /**
     * Metrics representing number of bytes. Evaluates to `b`.
     * @type {string}
     * @const
     * @expose
     */
    ByteBuffer.METRICS_BYTES = 'b';

    /**
     * Writes an UTF8 encoded string.
     * @param {string} str String to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} if omitted.
     * @returns {!ByteBuffer|number} this if offset is omitted, else the actual number of bytes written.
     * @expose
     */
    ByteBufferPrototype.writeUTF8String = function(str, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        var k;
        var start = offset;
        k = utfx.calculateUTF16asUTF8(stringSource(str))[1];
        offset += k;
        var capacity14 = this.buffer.byteLength;
        if (offset > capacity14)
            this.resize((capacity14 *= 2) > offset ? capacity14 : offset);
        offset -= k;
        utfx.encodeUTF16toUTF8(stringSource(str), function(b) {
            this.view[offset++] = b;
        }.bind(this));
        if (relative) {
            this.offset = offset;
            return this;
        }
        return offset - start;
    };

    /**
     * Writes an UTF8 encoded string. This is an alias of {@link ByteBuffer#writeUTF8String}.
     * @function
     * @param {string} str String to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} if omitted.
     * @returns {!ByteBuffer|number} this if offset is omitted, else the actual number of bytes written.
     * @expose
     */
    ByteBufferPrototype.writeString = ByteBufferPrototype.writeUTF8String;

    /**
     * Calculates the number of UTF8 characters of a string. JavaScript itself uses UTF-16, so that a string's
     *  `length` property does not reflect its actual UTF8 size if it contains code points larger than 0xFFFF.
     * @param {string} str String to calculate
     * @returns {number} Number of UTF8 characters
     * @expose
     */
    ByteBuffer.calculateUTF8Chars = function(str) {
        return utfx.calculateUTF16asUTF8(stringSource(str))[0];
    };

    /**
     * Calculates the number of UTF8 bytes of a string.
     * @param {string} str String to calculate
     * @returns {number} Number of UTF8 bytes
     * @expose
     */
    ByteBuffer.calculateUTF8Bytes = function(str) {
        return utfx.calculateUTF16asUTF8(stringSource(str))[1];
    };

    /**
     * Calculates the number of UTF8 bytes of a string. This is an alias of {@link ByteBuffer.calculateUTF8Bytes}.
     * @function
     * @param {string} str String to calculate
     * @returns {number} Number of UTF8 bytes
     * @expose
     */
    ByteBuffer.calculateString = ByteBuffer.calculateUTF8Bytes;

    /**
     * Reads an UTF8 encoded string.
     * @param {number} length Number of characters or bytes to read.
     * @param {string=} metrics Metrics specifying what `length` is meant to count. Defaults to
     *  {@link ByteBuffer.METRICS_CHARS}.
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  read if omitted.
     * @returns {string|!{string: string, length: number}} The string read if offset is omitted, else the string
     *  read and the actual number of bytes read.
     * @expose
     */
    ByteBufferPrototype.readUTF8String = function(length, metrics, offset) {
        if (typeof metrics === 'number') {
            offset = metrics;
            metrics = undefined;
        }
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (typeof metrics === 'undefined') metrics = ByteBuffer.METRICS_CHARS;
        if (!this.noAssert) {
            if (typeof length !== 'number' || length % 1 !== 0)
                throw TypeError("Illegal length: "+length+" (not an integer)");
            length |= 0;
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        var i = 0,
            start = offset,
            sd;
        if (metrics === ByteBuffer.METRICS_CHARS) { // The same for node and the browser
            sd = stringDestination();
            utfx.decodeUTF8(function() {
                return i < length && offset < this.limit ? this.view[offset++] : null;
            }.bind(this), function(cp) {
                ++i; utfx.UTF8toUTF16(cp, sd);
            });
            if (i !== length)
                throw RangeError("Illegal range: Truncated data, "+i+" == "+length);
            if (relative) {
                this.offset = offset;
                return sd();
            } else {
                return {
                    "string": sd(),
                    "length": offset - start
                };
            }
        } else if (metrics === ByteBuffer.METRICS_BYTES) {
            if (!this.noAssert) {
                if (typeof offset !== 'number' || offset % 1 !== 0)
                    throw TypeError("Illegal offset: "+offset+" (not an integer)");
                offset >>>= 0;
                if (offset < 0 || offset + length > this.buffer.byteLength)
                    throw RangeError("Illegal offset: 0 <= "+offset+" (+"+length+") <= "+this.buffer.byteLength);
            }
            var k = offset + length;
            utfx.decodeUTF8toUTF16(function() {
                return offset < k ? this.view[offset++] : null;
            }.bind(this), sd = stringDestination(), this.noAssert);
            if (offset !== k)
                throw RangeError("Illegal range: Truncated data, "+offset+" == "+k);
            if (relative) {
                this.offset = offset;
                return sd();
            } else {
                return {
                    'string': sd(),
                    'length': offset - start
                };
            }
        } else
            throw TypeError("Unsupported metrics: "+metrics);
    };

    /**
     * Reads an UTF8 encoded string. This is an alias of {@link ByteBuffer#readUTF8String}.
     * @function
     * @param {number} length Number of characters or bytes to read
     * @param {number=} metrics Metrics specifying what `n` is meant to count. Defaults to
     *  {@link ByteBuffer.METRICS_CHARS}.
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  read if omitted.
     * @returns {string|!{string: string, length: number}} The string read if offset is omitted, else the string
     *  read and the actual number of bytes read.
     * @expose
     */
    ByteBufferPrototype.readString = ByteBufferPrototype.readUTF8String;

    // types/strings/vstring

    /**
     * Writes a length as varint32 prefixed UTF8 encoded string.
     * @param {string} str String to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  written if omitted.
     * @returns {!ByteBuffer|number} `this` if `offset` is omitted, else the actual number of bytes written
     * @expose
     * @see ByteBuffer#writeVarint32
     */
    ByteBufferPrototype.writeVString = function(str, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof str !== 'string')
                throw TypeError("Illegal str: Not a string");
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        var start = offset,
            k, l;
        k = utfx.calculateUTF16asUTF8(stringSource(str), this.noAssert)[1];
        l = ByteBuffer.calculateVarint32(k);
        offset += l+k;
        var capacity15 = this.buffer.byteLength;
        if (offset > capacity15)
            this.resize((capacity15 *= 2) > offset ? capacity15 : offset);
        offset -= l+k;
        offset += this.writeVarint32(k, offset);
        utfx.encodeUTF16toUTF8(stringSource(str), function(b) {
            this.view[offset++] = b;
        }.bind(this));
        if (offset !== start+k+l)
            throw RangeError("Illegal range: Truncated data, "+offset+" == "+(offset+k+l));
        if (relative) {
            this.offset = offset;
            return this;
        }
        return offset - start;
    };

    /**
     * Reads a length as varint32 prefixed UTF8 encoded string.
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  read if omitted.
     * @returns {string|!{string: string, length: number}} The string read if offset is omitted, else the string
     *  read and the actual number of bytes read.
     * @expose
     * @see ByteBuffer#readVarint32
     */
    ByteBufferPrototype.readVString = function(offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 1 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+1+") <= "+this.buffer.byteLength);
        }
        var start = offset;
        var len = this.readVarint32(offset);
        var str = this.readUTF8String(len['value'], ByteBuffer.METRICS_BYTES, offset += len['length']);
        offset += str['length'];
        if (relative) {
            this.offset = offset;
            return str['string'];
        } else {
            return {
                'string': str['string'],
                'length': offset - start
            };
        }
    };


    /**
     * Appends some data to this ByteBuffer. This will overwrite any contents behind the specified offset up to the appended
     *  data's length.
     * @param {!ByteBuffer|!ArrayBuffer|!Uint8Array|string} source Data to append. If `source` is a ByteBuffer, its offsets
     *  will be modified according to the performed read operation.
     * @param {(string|number)=} encoding Encoding if `data` is a string ("base64", "hex", "binary", defaults to "utf8")
     * @param {number=} offset Offset to append at. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  written if omitted.
     * @returns {!ByteBuffer} this
     * @expose
     * @example A relative `<01 02>03.append(<04 05>)` will result in `<01 02 04 05>, 04 05|`
     * @example An absolute `<01 02>03.append(04 05>, 1)` will result in `<01 04>05, 04 05|`
     */
    ByteBufferPrototype.append = function(source, encoding, offset) {
        if (typeof encoding === 'number' || typeof encoding !== 'string') {
            offset = encoding;
            encoding = undefined;
        }
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        if (!(source instanceof ByteBuffer))
            source = ByteBuffer.wrap(source, encoding);
        var length = source.limit - source.offset;
        if (length <= 0) return this; // Nothing to append
        offset += length;
        var capacity16 = this.buffer.byteLength;
        if (offset > capacity16)
            this.resize((capacity16 *= 2) > offset ? capacity16 : offset);
        offset -= length;
        this.view.set(source.view.subarray(source.offset, source.limit), offset);
        source.offset += length;
        if (relative) this.offset += length;
        return this;
    };

    /**
     * Appends this ByteBuffer's contents to another ByteBuffer. This will overwrite any contents at and after the
        specified offset up to the length of this ByteBuffer's data.
     * @param {!ByteBuffer} target Target ByteBuffer
     * @param {number=} offset Offset to append to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  read if omitted.
     * @returns {!ByteBuffer} this
     * @expose
     * @see ByteBuffer#append
     */
    ByteBufferPrototype.appendTo = function(target, offset) {
        target.append(this, offset);
        return this;
    };

    /**
     * Enables or disables assertions of argument types and offsets. Assertions are enabled by default but you can opt to
     *  disable them if your code already makes sure that everything is valid.
     * @param {boolean} assert `true` to enable assertions, otherwise `false`
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.assert = function(assert) {
        this.noAssert = !assert;
        return this;
    };

    /**
     * Gets the capacity of this ByteBuffer's backing buffer.
     * @returns {number} Capacity of the backing buffer
     * @expose
     */
    ByteBufferPrototype.capacity = function() {
        return this.buffer.byteLength;
    };
    /**
     * Clears this ByteBuffer's offsets by setting {@link ByteBuffer#offset} to `0` and {@link ByteBuffer#limit} to the
     *  backing buffer's capacity. Discards {@link ByteBuffer#markedOffset}.
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.clear = function() {
        this.offset = 0;
        this.limit = this.buffer.byteLength;
        this.markedOffset = -1;
        return this;
    };

    /**
     * Creates a cloned instance of this ByteBuffer, preset with this ByteBuffer's values for {@link ByteBuffer#offset},
     *  {@link ByteBuffer#markedOffset} and {@link ByteBuffer#limit}.
     * @param {boolean=} copy Whether to copy the backing buffer or to return another view on the same, defaults to `false`
     * @returns {!ByteBuffer} Cloned instance
     * @expose
     */
    ByteBufferPrototype.clone = function(copy) {
        var bb = new ByteBuffer(0, this.littleEndian, this.noAssert);
        if (copy) {
            bb.buffer = new ArrayBuffer(this.buffer.byteLength);
            bb.view = new Uint8Array(bb.buffer);
        } else {
            bb.buffer = this.buffer;
            bb.view = this.view;
        }
        bb.offset = this.offset;
        bb.markedOffset = this.markedOffset;
        bb.limit = this.limit;
        return bb;
    };

    /**
     * Compacts this ByteBuffer to be backed by a {@link ByteBuffer#buffer} of its contents' length. Contents are the bytes
     *  between {@link ByteBuffer#offset} and {@link ByteBuffer#limit}. Will set `offset = 0` and `limit = capacity` and
     *  adapt {@link ByteBuffer#markedOffset} to the same relative position if set.
     * @param {number=} begin Offset to start at, defaults to {@link ByteBuffer#offset}
     * @param {number=} end Offset to end at, defaults to {@link ByteBuffer#limit}
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.compact = function(begin, end) {
        if (typeof begin === 'undefined') begin = this.offset;
        if (typeof end === 'undefined') end = this.limit;
        if (!this.noAssert) {
            if (typeof begin !== 'number' || begin % 1 !== 0)
                throw TypeError("Illegal begin: Not an integer");
            begin >>>= 0;
            if (typeof end !== 'number' || end % 1 !== 0)
                throw TypeError("Illegal end: Not an integer");
            end >>>= 0;
            if (begin < 0 || begin > end || end > this.buffer.byteLength)
                throw RangeError("Illegal range: 0 <= "+begin+" <= "+end+" <= "+this.buffer.byteLength);
        }
        if (begin === 0 && end === this.buffer.byteLength)
            return this; // Already compacted
        var len = end - begin;
        if (len === 0) {
            this.buffer = EMPTY_BUFFER;
            this.view = null;
            if (this.markedOffset >= 0) this.markedOffset -= begin;
            this.offset = 0;
            this.limit = 0;
            return this;
        }
        var buffer = new ArrayBuffer(len);
        var view = new Uint8Array(buffer);
        view.set(this.view.subarray(begin, end));
        this.buffer = buffer;
        this.view = view;
        if (this.markedOffset >= 0) this.markedOffset -= begin;
        this.offset = 0;
        this.limit = len;
        return this;
    };

    /**
     * Creates a copy of this ByteBuffer's contents. Contents are the bytes between {@link ByteBuffer#offset} and
     *  {@link ByteBuffer#limit}.
     * @param {number=} begin Begin offset, defaults to {@link ByteBuffer#offset}.
     * @param {number=} end End offset, defaults to {@link ByteBuffer#limit}.
     * @returns {!ByteBuffer} Copy
     * @expose
     */
    ByteBufferPrototype.copy = function(begin, end) {
        if (typeof begin === 'undefined') begin = this.offset;
        if (typeof end === 'undefined') end = this.limit;
        if (!this.noAssert) {
            if (typeof begin !== 'number' || begin % 1 !== 0)
                throw TypeError("Illegal begin: Not an integer");
            begin >>>= 0;
            if (typeof end !== 'number' || end % 1 !== 0)
                throw TypeError("Illegal end: Not an integer");
            end >>>= 0;
            if (begin < 0 || begin > end || end > this.buffer.byteLength)
                throw RangeError("Illegal range: 0 <= "+begin+" <= "+end+" <= "+this.buffer.byteLength);
        }
        if (begin === end)
            return new ByteBuffer(0, this.littleEndian, this.noAssert);
        var capacity = end - begin,
            bb = new ByteBuffer(capacity, this.littleEndian, this.noAssert);
        bb.offset = 0;
        bb.limit = capacity;
        if (bb.markedOffset >= 0) bb.markedOffset -= begin;
        this.copyTo(bb, 0, begin, end);
        return bb;
    };

    /**
     * Copies this ByteBuffer's contents to another ByteBuffer. Contents are the bytes between {@link ByteBuffer#offset} and
     *  {@link ByteBuffer#limit}.
     * @param {!ByteBuffer} target Target ByteBuffer
     * @param {number=} targetOffset Offset to copy to. Will use and increase the target's {@link ByteBuffer#offset}
     *  by the number of bytes copied if omitted.
     * @param {number=} sourceOffset Offset to start copying from. Will use and increase {@link ByteBuffer#offset} by the
     *  number of bytes copied if omitted.
     * @param {number=} sourceLimit Offset to end copying from, defaults to {@link ByteBuffer#limit}
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.copyTo = function(target, targetOffset, sourceOffset, sourceLimit) {
        var relative,
            targetRelative;
        if (!this.noAssert) {
            if (!ByteBuffer.isByteBuffer(target))
                throw TypeError("Illegal target: Not a ByteBuffer");
        }
        targetOffset = (targetRelative = typeof targetOffset === 'undefined') ? target.offset : targetOffset | 0;
        sourceOffset = (relative = typeof sourceOffset === 'undefined') ? this.offset : sourceOffset | 0;
        sourceLimit = typeof sourceLimit === 'undefined' ? this.limit : sourceLimit | 0;

        if (targetOffset < 0 || targetOffset > target.buffer.byteLength)
            throw RangeError("Illegal target range: 0 <= "+targetOffset+" <= "+target.buffer.byteLength);
        if (sourceOffset < 0 || sourceLimit > this.buffer.byteLength)
            throw RangeError("Illegal source range: 0 <= "+sourceOffset+" <= "+this.buffer.byteLength);

        var len = sourceLimit - sourceOffset;
        if (len === 0)
            return target; // Nothing to copy

        target.ensureCapacity(targetOffset + len);

        target.view.set(this.view.subarray(sourceOffset, sourceLimit), targetOffset);

        if (relative) this.offset += len;
        if (targetRelative) target.offset += len;

        return this;
    };

    /**
     * Makes sure that this ByteBuffer is backed by a {@link ByteBuffer#buffer} of at least the specified capacity. If the
     *  current capacity is exceeded, it will be doubled. If double the current capacity is less than the required capacity,
     *  the required capacity will be used instead.
     * @param {number} capacity Required capacity
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.ensureCapacity = function(capacity) {
        var current = this.buffer.byteLength;
        if (current < capacity)
            return this.resize((current *= 2) > capacity ? current : capacity);
        return this;
    };

    /**
     * Overwrites this ByteBuffer's contents with the specified value. Contents are the bytes between
     *  {@link ByteBuffer#offset} and {@link ByteBuffer#limit}.
     * @param {number|string} value Byte value to fill with. If given as a string, the first character is used.
     * @param {number=} begin Begin offset. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  written if omitted. defaults to {@link ByteBuffer#offset}.
     * @param {number=} end End offset, defaults to {@link ByteBuffer#limit}.
     * @returns {!ByteBuffer} this
     * @expose
     * @example `someByteBuffer.clear().fill(0)` fills the entire backing buffer with zeroes
     */
    ByteBufferPrototype.fill = function(value, begin, end) {
        var relative = typeof begin === 'undefined';
        if (relative) begin = this.offset;
        if (typeof value === 'string' && value.length > 0)
            value = value.charCodeAt(0);
        if (typeof begin === 'undefined') begin = this.offset;
        if (typeof end === 'undefined') end = this.limit;
        if (!this.noAssert) {
            if (typeof value !== 'number' || value % 1 !== 0)
                throw TypeError("Illegal value: "+value+" (not an integer)");
            value |= 0;
            if (typeof begin !== 'number' || begin % 1 !== 0)
                throw TypeError("Illegal begin: Not an integer");
            begin >>>= 0;
            if (typeof end !== 'number' || end % 1 !== 0)
                throw TypeError("Illegal end: Not an integer");
            end >>>= 0;
            if (begin < 0 || begin > end || end > this.buffer.byteLength)
                throw RangeError("Illegal range: 0 <= "+begin+" <= "+end+" <= "+this.buffer.byteLength);
        }
        if (begin >= end)
            return this; // Nothing to fill
        while (begin < end) this.view[begin++] = value;
        if (relative) this.offset = begin;
        return this;
    };

    /**
     * Makes this ByteBuffer ready for a new sequence of write or relative read operations. Sets `limit = offset` and
     *  `offset = 0`. Make sure always to flip a ByteBuffer when all relative read or write operations are complete.
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.flip = function() {
        this.limit = this.offset;
        this.offset = 0;
        return this;
    };
    /**
     * Marks an offset on this ByteBuffer to be used later.
     * @param {number=} offset Offset to mark. Defaults to {@link ByteBuffer#offset}.
     * @returns {!ByteBuffer} this
     * @throws {TypeError} If `offset` is not a valid number
     * @throws {RangeError} If `offset` is out of bounds
     * @see ByteBuffer#reset
     * @expose
     */
    ByteBufferPrototype.mark = function(offset) {
        offset = typeof offset === 'undefined' ? this.offset : offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        this.markedOffset = offset;
        return this;
    };
    /**
     * Sets the byte order.
     * @param {boolean} littleEndian `true` for little endian byte order, `false` for big endian
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.order = function(littleEndian) {
        if (!this.noAssert) {
            if (typeof littleEndian !== 'boolean')
                throw TypeError("Illegal littleEndian: Not a boolean");
        }
        this.littleEndian = !!littleEndian;
        return this;
    };

    /**
     * Switches (to) little endian byte order.
     * @param {boolean=} littleEndian Defaults to `true`, otherwise uses big endian
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.LE = function(littleEndian) {
        this.littleEndian = typeof littleEndian !== 'undefined' ? !!littleEndian : true;
        return this;
    };

    /**
     * Switches (to) big endian byte order.
     * @param {boolean=} bigEndian Defaults to `true`, otherwise uses little endian
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.BE = function(bigEndian) {
        this.littleEndian = typeof bigEndian !== 'undefined' ? !bigEndian : false;
        return this;
    };
    /**
     * Prepends some data to this ByteBuffer. This will overwrite any contents before the specified offset up to the
     *  prepended data's length. If there is not enough space available before the specified `offset`, the backing buffer
     *  will be resized and its contents moved accordingly.
     * @param {!ByteBuffer|string|!ArrayBuffer} source Data to prepend. If `source` is a ByteBuffer, its offset will be
     *  modified according to the performed read operation.
     * @param {(string|number)=} encoding Encoding if `data` is a string ("base64", "hex", "binary", defaults to "utf8")
     * @param {number=} offset Offset to prepend at. Will use and decrease {@link ByteBuffer#offset} by the number of bytes
     *  prepended if omitted.
     * @returns {!ByteBuffer} this
     * @expose
     * @example A relative `00<01 02 03>.prepend(<04 05>)` results in `<04 05 01 02 03>, 04 05|`
     * @example An absolute `00<01 02 03>.prepend(<04 05>, 2)` results in `04<05 02 03>, 04 05|`
     */
    ByteBufferPrototype.prepend = function(source, encoding, offset) {
        if (typeof encoding === 'number' || typeof encoding !== 'string') {
            offset = encoding;
            encoding = undefined;
        }
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        if (!(source instanceof ByteBuffer))
            source = ByteBuffer.wrap(source, encoding);
        var len = source.limit - source.offset;
        if (len <= 0) return this; // Nothing to prepend
        var diff = len - offset;
        if (diff > 0) { // Not enough space before offset, so resize + move
            var buffer = new ArrayBuffer(this.buffer.byteLength + diff);
            var view = new Uint8Array(buffer);
            view.set(this.view.subarray(offset, this.buffer.byteLength), len);
            this.buffer = buffer;
            this.view = view;
            this.offset += diff;
            if (this.markedOffset >= 0) this.markedOffset += diff;
            this.limit += diff;
            offset += diff;
        } else {
            var arrayView = new Uint8Array(this.buffer);
        }
        this.view.set(source.view.subarray(source.offset, source.limit), offset - len);

        source.offset = source.limit;
        if (relative)
            this.offset -= len;
        return this;
    };

    /**
     * Prepends this ByteBuffer to another ByteBuffer. This will overwrite any contents before the specified offset up to the
     *  prepended data's length. If there is not enough space available before the specified `offset`, the backing buffer
     *  will be resized and its contents moved accordingly.
     * @param {!ByteBuffer} target Target ByteBuffer
     * @param {number=} offset Offset to prepend at. Will use and decrease {@link ByteBuffer#offset} by the number of bytes
     *  prepended if omitted.
     * @returns {!ByteBuffer} this
     * @expose
     * @see ByteBuffer#prepend
     */
    ByteBufferPrototype.prependTo = function(target, offset) {
        target.prepend(this, offset);
        return this;
    };
    /**
     * Prints debug information about this ByteBuffer's contents.
     * @param {function(string)=} out Output function to call, defaults to console.log
     * @expose
     */
    ByteBufferPrototype.printDebug = function(out) {
        if (typeof out !== 'function') out = console.log.bind(console);
        out(
            this.toString()+"\n"+
            "-------------------------------------------------------------------\n"+
            this.toDebug(/* columns */ true)
        );
    };

    /**
     * Gets the number of remaining readable bytes. Contents are the bytes between {@link ByteBuffer#offset} and
     *  {@link ByteBuffer#limit}, so this returns `limit - offset`.
     * @returns {number} Remaining readable bytes. May be negative if `offset > limit`.
     * @expose
     */
    ByteBufferPrototype.remaining = function() {
        return this.limit - this.offset;
    };
    /**
     * Resets this ByteBuffer's {@link ByteBuffer#offset}. If an offset has been marked through {@link ByteBuffer#mark}
     *  before, `offset` will be set to {@link ByteBuffer#markedOffset}, which will then be discarded. If no offset has been
     *  marked, sets `offset = 0`.
     * @returns {!ByteBuffer} this
     * @see ByteBuffer#mark
     * @expose
     */
    ByteBufferPrototype.reset = function() {
        if (this.markedOffset >= 0) {
            this.offset = this.markedOffset;
            this.markedOffset = -1;
        } else {
            this.offset = 0;
        }
        return this;
    };
    /**
     * Resizes this ByteBuffer to be backed by a buffer of at least the given capacity. Will do nothing if already that
     *  large or larger.
     * @param {number} capacity Capacity required
     * @returns {!ByteBuffer} this
     * @throws {TypeError} If `capacity` is not a number
     * @throws {RangeError} If `capacity < 0`
     * @expose
     */
    ByteBufferPrototype.resize = function(capacity) {
        if (!this.noAssert) {
            if (typeof capacity !== 'number' || capacity % 1 !== 0)
                throw TypeError("Illegal capacity: "+capacity+" (not an integer)");
            capacity |= 0;
            if (capacity < 0)
                throw RangeError("Illegal capacity: 0 <= "+capacity);
        }
        if (this.buffer.byteLength < capacity) {
            var buffer = new ArrayBuffer(capacity);
            var view = new Uint8Array(buffer);
            view.set(this.view);
            this.buffer = buffer;
            this.view = view;
        }
        return this;
    };
    /**
     * Reverses this ByteBuffer's contents.
     * @param {number=} begin Offset to start at, defaults to {@link ByteBuffer#offset}
     * @param {number=} end Offset to end at, defaults to {@link ByteBuffer#limit}
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.reverse = function(begin, end) {
        if (typeof begin === 'undefined') begin = this.offset;
        if (typeof end === 'undefined') end = this.limit;
        if (!this.noAssert) {
            if (typeof begin !== 'number' || begin % 1 !== 0)
                throw TypeError("Illegal begin: Not an integer");
            begin >>>= 0;
            if (typeof end !== 'number' || end % 1 !== 0)
                throw TypeError("Illegal end: Not an integer");
            end >>>= 0;
            if (begin < 0 || begin > end || end > this.buffer.byteLength)
                throw RangeError("Illegal range: 0 <= "+begin+" <= "+end+" <= "+this.buffer.byteLength);
        }
        if (begin === end)
            return this; // Nothing to reverse
        Array.prototype.reverse.call(this.view.subarray(begin, end));
        return this;
    };
    /**
     * Skips the next `length` bytes. This will just advance
     * @param {number} length Number of bytes to skip. May also be negative to move the offset back.
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.skip = function(length) {
        if (!this.noAssert) {
            if (typeof length !== 'number' || length % 1 !== 0)
                throw TypeError("Illegal length: "+length+" (not an integer)");
            length |= 0;
        }
        var offset = this.offset + length;
        if (!this.noAssert) {
            if (offset < 0 || offset > this.buffer.byteLength)
                throw RangeError("Illegal length: 0 <= "+this.offset+" + "+length+" <= "+this.buffer.byteLength);
        }
        this.offset = offset;
        return this;
    };

    /**
     * Slices this ByteBuffer by creating a cloned instance with `offset = begin` and `limit = end`.
     * @param {number=} begin Begin offset, defaults to {@link ByteBuffer#offset}.
     * @param {number=} end End offset, defaults to {@link ByteBuffer#limit}.
     * @returns {!ByteBuffer} Clone of this ByteBuffer with slicing applied, backed by the same {@link ByteBuffer#buffer}
     * @expose
     */
    ByteBufferPrototype.slice = function(begin, end) {
        if (typeof begin === 'undefined') begin = this.offset;
        if (typeof end === 'undefined') end = this.limit;
        if (!this.noAssert) {
            if (typeof begin !== 'number' || begin % 1 !== 0)
                throw TypeError("Illegal begin: Not an integer");
            begin >>>= 0;
            if (typeof end !== 'number' || end % 1 !== 0)
                throw TypeError("Illegal end: Not an integer");
            end >>>= 0;
            if (begin < 0 || begin > end || end > this.buffer.byteLength)
                throw RangeError("Illegal range: 0 <= "+begin+" <= "+end+" <= "+this.buffer.byteLength);
        }
        var bb = this.clone();
        bb.offset = begin;
        bb.limit = end;
        return bb;
    };
    /**
     * Returns a copy of the backing buffer that contains this ByteBuffer's contents. Contents are the bytes between
     *  {@link ByteBuffer#offset} and {@link ByteBuffer#limit}.
     * @param {boolean=} forceCopy If `true` returns a copy, otherwise returns a view referencing the same memory if
     *  possible. Defaults to `false`
     * @returns {!ArrayBuffer} Contents as an ArrayBuffer
     * @expose
     */
    ByteBufferPrototype.toBuffer = function(forceCopy) {
        var offset = this.offset,
            limit = this.limit;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: Not an integer");
            offset >>>= 0;
            if (typeof limit !== 'number' || limit % 1 !== 0)
                throw TypeError("Illegal limit: Not an integer");
            limit >>>= 0;
            if (offset < 0 || offset > limit || limit > this.buffer.byteLength)
                throw RangeError("Illegal range: 0 <= "+offset+" <= "+limit+" <= "+this.buffer.byteLength);
        }
        // NOTE: It's not possible to have another ArrayBuffer reference the same memory as the backing buffer. This is
        // possible with Uint8Array#subarray only, but we have to return an ArrayBuffer by contract. So:
        if (!forceCopy && offset === 0 && limit === this.buffer.byteLength)
            return this.buffer;
        if (offset === limit)
            return EMPTY_BUFFER;
        var buffer = new ArrayBuffer(limit - offset);
        new Uint8Array(buffer).set(new Uint8Array(this.buffer).subarray(offset, limit), 0);
        return buffer;
    };

    /**
     * Returns a raw buffer compacted to contain this ByteBuffer's contents. Contents are the bytes between
     *  {@link ByteBuffer#offset} and {@link ByteBuffer#limit}. This is an alias of {@link ByteBuffer#toBuffer}.
     * @function
     * @param {boolean=} forceCopy If `true` returns a copy, otherwise returns a view referencing the same memory.
     *  Defaults to `false`
     * @returns {!ArrayBuffer} Contents as an ArrayBuffer
     * @expose
     */
    ByteBufferPrototype.toArrayBuffer = ByteBufferPrototype.toBuffer;

    /**
     * Converts the ByteBuffer's contents to a string.
     * @param {string=} encoding Output encoding. Returns an informative string representation if omitted but also allows
     *  direct conversion to "utf8", "hex", "base64" and "binary" encoding. "debug" returns a hex representation with
     *  highlighted offsets.
     * @param {number=} begin Offset to begin at, defaults to {@link ByteBuffer#offset}
     * @param {number=} end Offset to end at, defaults to {@link ByteBuffer#limit}
     * @returns {string} String representation
     * @throws {Error} If `encoding` is invalid
     * @expose
     */
    ByteBufferPrototype.toString = function(encoding, begin, end) {
        if (typeof encoding === 'undefined')
            return "ByteBufferAB(offset="+this.offset+",markedOffset="+this.markedOffset+",limit="+this.limit+",capacity="+this.capacity()+")";
        if (typeof encoding === 'number')
            encoding = "utf8",
            begin = encoding,
            end = begin;
        switch (encoding) {
            case "utf8":
                return this.toUTF8(begin, end);
            case "base64":
                return this.toBase64(begin, end);
            case "hex":
                return this.toHex(begin, end);
            case "binary":
                return this.toBinary(begin, end);
            case "debug":
                return this.toDebug();
            case "columns":
                return this.toColumns();
            default:
                throw Error("Unsupported encoding: "+encoding);
        }
    };

    // lxiv-embeddable

    /**
     * lxiv-embeddable (c) 2014 Daniel Wirtz <dcode@dcode.io>
     * Released under the Apache License, Version 2.0
     * see: https://github.com/dcodeIO/lxiv for details
     */
    var lxiv = function() {
        "use strict";

        /**
         * lxiv namespace.
         * @type {!Object.<string,*>}
         * @exports lxiv
         */
        var lxiv = {};

        /**
         * Character codes for output.
         * @type {!Array.<number>}
         * @inner
         */
        var aout = [
            65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80,
            81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 97, 98, 99, 100, 101, 102,
            103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118,
            119, 120, 121, 122, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 43, 47
        ];

        /**
         * Character codes for input.
         * @type {!Array.<number>}
         * @inner
         */
        var ain = [];
        for (var i=0, k=aout.length; i<k; ++i)
            ain[aout[i]] = i;

        /**
         * Encodes bytes to base64 char codes.
         * @param {!function():number|null} src Bytes source as a function returning the next byte respectively `null` if
         *  there are no more bytes left.
         * @param {!function(number)} dst Characters destination as a function successively called with each encoded char
         *  code.
         */
        lxiv.encode = function(src, dst) {
            var b, t;
            while ((b = src()) !== null) {
                dst(aout[(b>>2)&0x3f]);
                t = (b&0x3)<<4;
                if ((b = src()) !== null) {
                    t |= (b>>4)&0xf;
                    dst(aout[(t|((b>>4)&0xf))&0x3f]);
                    t = (b&0xf)<<2;
                    if ((b = src()) !== null)
                        dst(aout[(t|((b>>6)&0x3))&0x3f]),
                        dst(aout[b&0x3f]);
                    else
                        dst(aout[t&0x3f]),
                        dst(61);
                } else
                    dst(aout[t&0x3f]),
                    dst(61),
                    dst(61);
            }
        };

        /**
         * Decodes base64 char codes to bytes.
         * @param {!function():number|null} src Characters source as a function returning the next char code respectively
         *  `null` if there are no more characters left.
         * @param {!function(number)} dst Bytes destination as a function successively called with the next byte.
         * @throws {Error} If a character code is invalid
         */
        lxiv.decode = function(src, dst) {
            var c, t1, t2;
            function fail(c) {
                throw Error("Illegal character code: "+c);
            }
            while ((c = src()) !== null) {
                t1 = ain[c];
                if (typeof t1 === 'undefined') fail(c);
                if ((c = src()) !== null) {
                    t2 = ain[c];
                    if (typeof t2 === 'undefined') fail(c);
                    dst((t1<<2)>>>0|(t2&0x30)>>4);
                    if ((c = src()) !== null) {
                        t1 = ain[c];
                        if (typeof t1 === 'undefined')
                            if (c === 61) break; else fail(c);
                        dst(((t2&0xf)<<4)>>>0|(t1&0x3c)>>2);
                        if ((c = src()) !== null) {
                            t2 = ain[c];
                            if (typeof t2 === 'undefined')
                                if (c === 61) break; else fail(c);
                            dst(((t1&0x3)<<6)>>>0|t2);
                        }
                    }
                }
            }
        };

        /**
         * Tests if a string is valid base64.
         * @param {string} str String to test
         * @returns {boolean} `true` if valid, otherwise `false`
         */
        lxiv.test = function(str) {
            return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(str);
        };

        return lxiv;
    }();

    // encodings/base64

    /**
     * Encodes this ByteBuffer's contents to a base64 encoded string.
     * @param {number=} begin Offset to begin at, defaults to {@link ByteBuffer#offset}.
     * @param {number=} end Offset to end at, defaults to {@link ByteBuffer#limit}.
     * @returns {string} Base64 encoded string
     * @throws {RangeError} If `begin` or `end` is out of bounds
     * @expose
     */
    ByteBufferPrototype.toBase64 = function(begin, end) {
        if (typeof begin === 'undefined')
            begin = this.offset;
        if (typeof end === 'undefined')
            end = this.limit;
        begin = begin | 0; end = end | 0;
        if (begin < 0 || end > this.capacity || begin > end)
            throw RangeError("begin, end");
        var sd; lxiv.encode(function() {
            return begin < end ? this.view[begin++] : null;
        }.bind(this), sd = stringDestination());
        return sd();
    };

    /**
     * Decodes a base64 encoded string to a ByteBuffer.
     * @param {string} str String to decode
     * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to
     *  {@link ByteBuffer.DEFAULT_ENDIAN}.
     * @returns {!ByteBuffer} ByteBuffer
     * @expose
     */
    ByteBuffer.fromBase64 = function(str, littleEndian) {
        if (typeof str !== 'string')
            throw TypeError("str");
        var bb = new ByteBuffer(str.length/4*3, littleEndian),
            i = 0;
        lxiv.decode(stringSource(str), function(b) {
            bb.view[i++] = b;
        });
        bb.limit = i;
        return bb;
    };

    /**
     * Encodes a binary string to base64 like `window.btoa` does.
     * @param {string} str Binary string
     * @returns {string} Base64 encoded string
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Window.btoa
     * @expose
     */
    ByteBuffer.btoa = function(str) {
        return ByteBuffer.fromBinary(str).toBase64();
    };

    /**
     * Decodes a base64 encoded string to binary like `window.atob` does.
     * @param {string} b64 Base64 encoded string
     * @returns {string} Binary string
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Window.atob
     * @expose
     */
    ByteBuffer.atob = function(b64) {
        return ByteBuffer.fromBase64(b64).toBinary();
    };

    // encodings/binary

    /**
     * Encodes this ByteBuffer to a binary encoded string, that is using only characters 0x00-0xFF as bytes.
     * @param {number=} begin Offset to begin at. Defaults to {@link ByteBuffer#offset}.
     * @param {number=} end Offset to end at. Defaults to {@link ByteBuffer#limit}.
     * @returns {string} Binary encoded string
     * @throws {RangeError} If `offset > limit`
     * @expose
     */
    ByteBufferPrototype.toBinary = function(begin, end) {
        if (typeof begin === 'undefined')
            begin = this.offset;
        if (typeof end === 'undefined')
            end = this.limit;
        begin |= 0; end |= 0;
        if (begin < 0 || end > this.capacity() || begin > end)
            throw RangeError("begin, end");
        if (begin === end)
            return "";
        var chars = [],
            parts = [];
        while (begin < end) {
            chars.push(this.view[begin++]);
            if (chars.length >= 1024)
                parts.push(String.fromCharCode.apply(String, chars)),
                chars = [];
        }
        return parts.join('') + String.fromCharCode.apply(String, chars);
    };

    /**
     * Decodes a binary encoded string, that is using only characters 0x00-0xFF as bytes, to a ByteBuffer.
     * @param {string} str String to decode
     * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to
     *  {@link ByteBuffer.DEFAULT_ENDIAN}.
     * @returns {!ByteBuffer} ByteBuffer
     * @expose
     */
    ByteBuffer.fromBinary = function(str, littleEndian) {
        if (typeof str !== 'string')
            throw TypeError("str");
        var i = 0,
            k = str.length,
            charCode,
            bb = new ByteBuffer(k, littleEndian);
        while (i<k) {
            charCode = str.charCodeAt(i);
            if (charCode > 0xff)
                throw RangeError("illegal char code: "+charCode);
            bb.view[i++] = charCode;
        }
        bb.limit = k;
        return bb;
    };

    // encodings/debug

    /**
     * Encodes this ByteBuffer to a hex encoded string with marked offsets. Offset symbols are:
     * * `<` : offset,
     * * `'` : markedOffset,
     * * `>` : limit,
     * * `|` : offset and limit,
     * * `[` : offset and markedOffset,
     * * `]` : markedOffset and limit,
     * * `!` : offset, markedOffset and limit
     * @param {boolean=} columns If `true` returns two columns hex + ascii, defaults to `false`
     * @returns {string|!Array.<string>} Debug string or array of lines if `asArray = true`
     * @expose
     * @example `>00'01 02<03` contains four bytes with `limit=0, markedOffset=1, offset=3`
     * @example `00[01 02 03>` contains four bytes with `offset=markedOffset=1, limit=4`
     * @example `00|01 02 03` contains four bytes with `offset=limit=1, markedOffset=-1`
     * @example `|` contains zero bytes with `offset=limit=0, markedOffset=-1`
     */
    ByteBufferPrototype.toDebug = function(columns) {
        var i = -1,
            k = this.buffer.byteLength,
            b,
            hex = "",
            asc = "",
            out = "";
        while (i<k) {
            if (i !== -1) {
                b = this.view[i];
                if (b < 0x10) hex += "0"+b.toString(16).toUpperCase();
                else hex += b.toString(16).toUpperCase();
                if (columns)
                    asc += b > 32 && b < 127 ? String.fromCharCode(b) : '.';
            }
            ++i;
            if (columns) {
                if (i > 0 && i % 16 === 0 && i !== k) {
                    while (hex.length < 3*16+3) hex += " ";
                    out += hex+asc+"\n";
                    hex = asc = "";
                }
            }
            if (i === this.offset && i === this.limit)
                hex += i === this.markedOffset ? "!" : "|";
            else if (i === this.offset)
                hex += i === this.markedOffset ? "[" : "<";
            else if (i === this.limit)
                hex += i === this.markedOffset ? "]" : ">";
            else
                hex += i === this.markedOffset ? "'" : (columns || (i !== 0 && i !== k) ? " " : "");
        }
        if (columns && hex !== " ") {
            while (hex.length < 3*16+3)
                hex += " ";
            out += hex + asc + "\n";
        }
        return columns ? out : hex;
    };

    /**
     * Decodes a hex encoded string with marked offsets to a ByteBuffer.
     * @param {string} str Debug string to decode (not be generated with `columns = true`)
     * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to
     *  {@link ByteBuffer.DEFAULT_ENDIAN}.
     * @param {boolean=} noAssert Whether to skip assertions of offsets and values. Defaults to
     *  {@link ByteBuffer.DEFAULT_NOASSERT}.
     * @returns {!ByteBuffer} ByteBuffer
     * @expose
     * @see ByteBuffer#toDebug
     */
    ByteBuffer.fromDebug = function(str, littleEndian, noAssert) {
        var k = str.length,
            bb = new ByteBuffer(((k+1)/3)|0, littleEndian, noAssert);
        var i = 0, j = 0, ch, b,
            rs = false, // Require symbol next
            ho = false, hm = false, hl = false, // Already has offset (ho), markedOffset (hm), limit (hl)?
            fail = false;
        while (i<k) {
            switch (ch = str.charAt(i++)) {
                case '!':
                    if (!noAssert) {
                        if (ho || hm || hl) {
                            fail = true;
                            break;
                        }
                        ho = hm = hl = true;
                    }
                    bb.offset = bb.markedOffset = bb.limit = j;
                    rs = false;
                    break;
                case '|':
                    if (!noAssert) {
                        if (ho || hl) {
                            fail = true;
                            break;
                        }
                        ho = hl = true;
                    }
                    bb.offset = bb.limit = j;
                    rs = false;
                    break;
                case '[':
                    if (!noAssert) {
                        if (ho || hm) {
                            fail = true;
                            break;
                        }
                        ho = hm = true;
                    }
                    bb.offset = bb.markedOffset = j;
                    rs = false;
                    break;
                case '<':
                    if (!noAssert) {
                        if (ho) {
                            fail = true;
                            break;
                        }
                        ho = true;
                    }
                    bb.offset = j;
                    rs = false;
                    break;
                case ']':
                    if (!noAssert) {
                        if (hl || hm) {
                            fail = true;
                            break;
                        }
                        hl = hm = true;
                    }
                    bb.limit = bb.markedOffset = j;
                    rs = false;
                    break;
                case '>':
                    if (!noAssert) {
                        if (hl) {
                            fail = true;
                            break;
                        }
                        hl = true;
                    }
                    bb.limit = j;
                    rs = false;
                    break;
                case "'":
                    if (!noAssert) {
                        if (hm) {
                            fail = true;
                            break;
                        }
                        hm = true;
                    }
                    bb.markedOffset = j;
                    rs = false;
                    break;
                case ' ':
                    rs = false;
                    break;
                default:
                    if (!noAssert) {
                        if (rs) {
                            fail = true;
                            break;
                        }
                    }
                    b = parseInt(ch+str.charAt(i++), 16);
                    if (!noAssert) {
                        if (isNaN(b) || b < 0 || b > 255)
                            throw TypeError("Illegal str: Not a debug encoded string");
                    }
                    bb.view[j++] = b;
                    rs = true;
            }
            if (fail)
                throw TypeError("Illegal str: Invalid symbol at "+i);
        }
        if (!noAssert) {
            if (!ho || !hl)
                throw TypeError("Illegal str: Missing offset or limit");
            if (j<bb.buffer.byteLength)
                throw TypeError("Illegal str: Not a debug encoded string (is it hex?) "+j+" < "+k);
        }
        return bb;
    };

    // encodings/hex

    /**
     * Encodes this ByteBuffer's contents to a hex encoded string.
     * @param {number=} begin Offset to begin at. Defaults to {@link ByteBuffer#offset}.
     * @param {number=} end Offset to end at. Defaults to {@link ByteBuffer#limit}.
     * @returns {string} Hex encoded string
     * @expose
     */
    ByteBufferPrototype.toHex = function(begin, end) {
        begin = typeof begin === 'undefined' ? this.offset : begin;
        end = typeof end === 'undefined' ? this.limit : end;
        if (!this.noAssert) {
            if (typeof begin !== 'number' || begin % 1 !== 0)
                throw TypeError("Illegal begin: Not an integer");
            begin >>>= 0;
            if (typeof end !== 'number' || end % 1 !== 0)
                throw TypeError("Illegal end: Not an integer");
            end >>>= 0;
            if (begin < 0 || begin > end || end > this.buffer.byteLength)
                throw RangeError("Illegal range: 0 <= "+begin+" <= "+end+" <= "+this.buffer.byteLength);
        }
        var out = new Array(end - begin),
            b;
        while (begin < end) {
            b = this.view[begin++];
            if (b < 0x10)
                out.push("0", b.toString(16));
            else out.push(b.toString(16));
        }
        return out.join('');
    };

    /**
     * Decodes a hex encoded string to a ByteBuffer.
     * @param {string} str String to decode
     * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to
     *  {@link ByteBuffer.DEFAULT_ENDIAN}.
     * @param {boolean=} noAssert Whether to skip assertions of offsets and values. Defaults to
     *  {@link ByteBuffer.DEFAULT_NOASSERT}.
     * @returns {!ByteBuffer} ByteBuffer
     * @expose
     */
    ByteBuffer.fromHex = function(str, littleEndian, noAssert) {
        if (!noAssert) {
            if (typeof str !== 'string')
                throw TypeError("Illegal str: Not a string");
            if (str.length % 2 !== 0)
                throw TypeError("Illegal str: Length not a multiple of 2");
        }
        var k = str.length,
            bb = new ByteBuffer((k / 2) | 0, littleEndian),
            b;
        for (var i=0, j=0; i<k; i+=2) {
            b = parseInt(str.substring(i, i+2), 16);
            if (!noAssert)
                if (!isFinite(b) || b < 0 || b > 255)
                    throw TypeError("Illegal str: Contains non-hex characters");
            bb.view[j++] = b;
        }
        bb.limit = j;
        return bb;
    };

    // utfx-embeddable

    /**
     * utfx-embeddable (c) 2014 Daniel Wirtz <dcode@dcode.io>
     * Released under the Apache License, Version 2.0
     * see: https://github.com/dcodeIO/utfx for details
     */
    var utfx = function() {
        "use strict";

        /**
         * utfx namespace.
         * @inner
         * @type {!Object.<string,*>}
         */
        var utfx = {};

        /**
         * Maximum valid code point.
         * @type {number}
         * @const
         */
        utfx.MAX_CODEPOINT = 0x10FFFF;

        /**
         * Encodes UTF8 code points to UTF8 bytes.
         * @param {(!function():number|null) | number} src Code points source, either as a function returning the next code point
         *  respectively `null` if there are no more code points left or a single numeric code point.
         * @param {!function(number)} dst Bytes destination as a function successively called with the next byte
         */
        utfx.encodeUTF8 = function(src, dst) {
            var cp = null;
            if (typeof src === 'number')
                cp = src,
                src = function() { return null; };
            while (cp !== null || (cp = src()) !== null) {
                if (cp < 0x80)
                    dst(cp&0x7F);
                else if (cp < 0x800)
                    dst(((cp>>6)&0x1F)|0xC0),
                    dst((cp&0x3F)|0x80);
                else if (cp < 0x10000)
                    dst(((cp>>12)&0x0F)|0xE0),
                    dst(((cp>>6)&0x3F)|0x80),
                    dst((cp&0x3F)|0x80);
                else
                    dst(((cp>>18)&0x07)|0xF0),
                    dst(((cp>>12)&0x3F)|0x80),
                    dst(((cp>>6)&0x3F)|0x80),
                    dst((cp&0x3F)|0x80);
                cp = null;
            }
        };

        /**
         * Decodes UTF8 bytes to UTF8 code points.
         * @param {!function():number|null} src Bytes source as a function returning the next byte respectively `null` if there
         *  are no more bytes left.
         * @param {!function(number)} dst Code points destination as a function successively called with each decoded code point.
         * @throws {RangeError} If a starting byte is invalid in UTF8
         * @throws {Error} If the last sequence is truncated. Has an array property `bytes` holding the
         *  remaining bytes.
         */
        utfx.decodeUTF8 = function(src, dst) {
            var a, b, c, d, fail = function(b) {
                b = b.slice(0, b.indexOf(null));
                var err = Error(b.toString());
                err.name = "TruncatedError";
                err['bytes'] = b;
                throw err;
            };
            while ((a = src()) !== null) {
                if ((a&0x80) === 0)
                    dst(a);
                else if ((a&0xE0) === 0xC0)
                    ((b = src()) === null) && fail([a, b]),
                    dst(((a&0x1F)<<6) | (b&0x3F));
                else if ((a&0xF0) === 0xE0)
                    ((b=src()) === null || (c=src()) === null) && fail([a, b, c]),
                    dst(((a&0x0F)<<12) | ((b&0x3F)<<6) | (c&0x3F));
                else if ((a&0xF8) === 0xF0)
                    ((b=src()) === null || (c=src()) === null || (d=src()) === null) && fail([a, b, c ,d]),
                    dst(((a&0x07)<<18) | ((b&0x3F)<<12) | ((c&0x3F)<<6) | (d&0x3F));
                else throw RangeError("Illegal starting byte: "+a);
            }
        };

        /**
         * Converts UTF16 characters to UTF8 code points.
         * @param {!function():number|null} src Characters source as a function returning the next char code respectively
         *  `null` if there are no more characters left.
         * @param {!function(number)} dst Code points destination as a function successively called with each converted code
         *  point.
         */
        utfx.UTF16toUTF8 = function(src, dst) {
            var c1, c2 = null;
            while (true) {
                if ((c1 = c2 !== null ? c2 : src()) === null)
                    break;
                if (c1 >= 0xD800 && c1 <= 0xDFFF) {
                    if ((c2 = src()) !== null) {
                        if (c2 >= 0xDC00 && c2 <= 0xDFFF) {
                            dst((c1-0xD800)*0x400+c2-0xDC00+0x10000);
                            c2 = null; continue;
                        }
                    }
                }
                dst(c1);
            }
            if (c2 !== null) dst(c2);
        };

        /**
         * Converts UTF8 code points to UTF16 characters.
         * @param {(!function():number|null) | number} src Code points source, either as a function returning the next code point
         *  respectively `null` if there are no more code points left or a single numeric code point.
         * @param {!function(number)} dst Characters destination as a function successively called with each converted char code.
         * @throws {RangeError} If a code point is out of range
         */
        utfx.UTF8toUTF16 = function(src, dst) {
            var cp = null;
            if (typeof src === 'number')
                cp = src, src = function() { return null; };
            while (cp !== null || (cp = src()) !== null) {
                if (cp <= 0xFFFF)
                    dst(cp);
                else
                    cp -= 0x10000,
                    dst((cp>>10)+0xD800),
                    dst((cp%0x400)+0xDC00);
                cp = null;
            }
        };

        /**
         * Converts and encodes UTF16 characters to UTF8 bytes.
         * @param {!function():number|null} src Characters source as a function returning the next char code respectively `null`
         *  if there are no more characters left.
         * @param {!function(number)} dst Bytes destination as a function successively called with the next byte.
         */
        utfx.encodeUTF16toUTF8 = function(src, dst) {
            utfx.UTF16toUTF8(src, function(cp) {
                utfx.encodeUTF8(cp, dst);
            });
        };

        /**
         * Decodes and converts UTF8 bytes to UTF16 characters.
         * @param {!function():number|null} src Bytes source as a function returning the next byte respectively `null` if there
         *  are no more bytes left.
         * @param {!function(number)} dst Characters destination as a function successively called with each converted char code.
         * @throws {RangeError} If a starting byte is invalid in UTF8
         * @throws {Error} If the last sequence is truncated. Has an array property `bytes` holding the remaining bytes.
         */
        utfx.decodeUTF8toUTF16 = function(src, dst) {
            utfx.decodeUTF8(src, function(cp) {
                utfx.UTF8toUTF16(cp, dst);
            });
        };

        /**
         * Calculates the byte length of an UTF8 code point.
         * @param {number} cp UTF8 code point
         * @returns {number} Byte length
         */
        utfx.calculateCodePoint = function(cp) {
            return (cp < 0x80) ? 1 : (cp < 0x800) ? 2 : (cp < 0x10000) ? 3 : 4;
        };

        /**
         * Calculates the number of UTF8 bytes required to store UTF8 code points.
         * @param {(!function():number|null)} src Code points source as a function returning the next code point respectively
         *  `null` if there are no more code points left.
         * @returns {number} The number of UTF8 bytes required
         */
        utfx.calculateUTF8 = function(src) {
            var cp, l=0;
            while ((cp = src()) !== null)
                l += (cp < 0x80) ? 1 : (cp < 0x800) ? 2 : (cp < 0x10000) ? 3 : 4;
            return l;
        };

        /**
         * Calculates the number of UTF8 code points respectively UTF8 bytes required to store UTF16 char codes.
         * @param {(!function():number|null)} src Characters source as a function returning the next char code respectively
         *  `null` if there are no more characters left.
         * @returns {!Array.<number>} The number of UTF8 code points at index 0 and the number of UTF8 bytes required at index 1.
         */
        utfx.calculateUTF16asUTF8 = function(src) {
            var n=0, l=0;
            utfx.UTF16toUTF8(src, function(cp) {
                ++n; l += (cp < 0x80) ? 1 : (cp < 0x800) ? 2 : (cp < 0x10000) ? 3 : 4;
            });
            return [n,l];
        };

        return utfx;
    }();

    // encodings/utf8

    /**
     * Encodes this ByteBuffer's contents between {@link ByteBuffer#offset} and {@link ByteBuffer#limit} to an UTF8 encoded
     *  string.
     * @returns {string} Hex encoded string
     * @throws {RangeError} If `offset > limit`
     * @expose
     */
    ByteBufferPrototype.toUTF8 = function(begin, end) {
        if (typeof begin === 'undefined') begin = this.offset;
        if (typeof end === 'undefined') end = this.limit;
        if (!this.noAssert) {
            if (typeof begin !== 'number' || begin % 1 !== 0)
                throw TypeError("Illegal begin: Not an integer");
            begin >>>= 0;
            if (typeof end !== 'number' || end % 1 !== 0)
                throw TypeError("Illegal end: Not an integer");
            end >>>= 0;
            if (begin < 0 || begin > end || end > this.buffer.byteLength)
                throw RangeError("Illegal range: 0 <= "+begin+" <= "+end+" <= "+this.buffer.byteLength);
        }
        var sd; try {
            utfx.decodeUTF8toUTF16(function() {
                return begin < end ? this.view[begin++] : null;
            }.bind(this), sd = stringDestination());
        } catch (e) {
            if (begin !== end)
                throw RangeError("Illegal range: Truncated data, "+begin+" != "+end);
        }
        return sd();
    };

    /**
     * Decodes an UTF8 encoded string to a ByteBuffer.
     * @param {string} str String to decode
     * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to
     *  {@link ByteBuffer.DEFAULT_ENDIAN}.
     * @param {boolean=} noAssert Whether to skip assertions of offsets and values. Defaults to
     *  {@link ByteBuffer.DEFAULT_NOASSERT}.
     * @returns {!ByteBuffer} ByteBuffer
     * @expose
     */
    ByteBuffer.fromUTF8 = function(str, littleEndian, noAssert) {
        if (!noAssert)
            if (typeof str !== 'string')
                throw TypeError("Illegal str: Not a string");
        var bb = new ByteBuffer(utfx.calculateUTF16asUTF8(stringSource(str), true)[1], littleEndian, noAssert),
            i = 0;
        utfx.encodeUTF16toUTF8(stringSource(str), function(b) {
            bb.view[i++] = b;
        });
        bb.limit = i;
        return bb;
    };

    return ByteBuffer;
});


/***/ }),

/***/ "../../../core/node_modules/long/dist/long.js":
/*!*********************************************************************!*\
  !*** /home/omar/Desktop/hivejs/core/node_modules/long/dist/long.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
 Copyright 2013 Daniel Wirtz <dcode@dcode.io>
 Copyright 2009 The Closure Library Authors. All Rights Reserved.

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS-IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
 */

/**
 * @license long.js (c) 2013 Daniel Wirtz <dcode@dcode.io>
 * Released under the Apache License, Version 2.0
 * see: https://github.com/dcodeIO/long.js for details
 */
(function(global, factory) {

    /* AMD */ if (true)
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    /* CommonJS */ else {}

})(this, function() {
    "use strict";

    /**
     * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.
     *  See the from* functions below for more convenient ways of constructing Longs.
     * @exports Long
     * @class A Long class for representing a 64 bit two's-complement integer value.
     * @param {number} low The low (signed) 32 bits of the long
     * @param {number} high The high (signed) 32 bits of the long
     * @param {boolean=} unsigned Whether unsigned or not, defaults to `false` for signed
     * @constructor
     */
    function Long(low, high, unsigned) {

        /**
         * The low 32 bits as a signed value.
         * @type {number}
         */
        this.low = low | 0;

        /**
         * The high 32 bits as a signed value.
         * @type {number}
         */
        this.high = high | 0;

        /**
         * Whether unsigned or not.
         * @type {boolean}
         */
        this.unsigned = !!unsigned;
    }

    // The internal representation of a long is the two given signed, 32-bit values.
    // We use 32-bit pieces because these are the size of integers on which
    // Javascript performs bit-operations.  For operations like addition and
    // multiplication, we split each number into 16 bit pieces, which can easily be
    // multiplied within Javascript's floating-point representation without overflow
    // or change in sign.
    //
    // In the algorithms below, we frequently reduce the negative case to the
    // positive case by negating the input(s) and then post-processing the result.
    // Note that we must ALWAYS check specially whether those values are MIN_VALUE
    // (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as
    // a positive number, it overflows back into a negative).  Not handling this
    // case would often result in infinite recursion.
    //
    // Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*
    // methods on which they depend.

    /**
     * An indicator used to reliably determine if an object is a Long or not.
     * @type {boolean}
     * @const
     * @private
     */
    Long.prototype.__isLong__;

    Object.defineProperty(Long.prototype, "__isLong__", {
        value: true,
        enumerable: false,
        configurable: false
    });

    /**
     * @function
     * @param {*} obj Object
     * @returns {boolean}
     * @inner
     */
    function isLong(obj) {
        return (obj && obj["__isLong__"]) === true;
    }

    /**
     * Tests if the specified object is a Long.
     * @function
     * @param {*} obj Object
     * @returns {boolean}
     */
    Long.isLong = isLong;

    /**
     * A cache of the Long representations of small integer values.
     * @type {!Object}
     * @inner
     */
    var INT_CACHE = {};

    /**
     * A cache of the Long representations of small unsigned integer values.
     * @type {!Object}
     * @inner
     */
    var UINT_CACHE = {};

    /**
     * @param {number} value
     * @param {boolean=} unsigned
     * @returns {!Long}
     * @inner
     */
    function fromInt(value, unsigned) {
        var obj, cachedObj, cache;
        if (unsigned) {
            value >>>= 0;
            if (cache = (0 <= value && value < 256)) {
                cachedObj = UINT_CACHE[value];
                if (cachedObj)
                    return cachedObj;
            }
            obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);
            if (cache)
                UINT_CACHE[value] = obj;
            return obj;
        } else {
            value |= 0;
            if (cache = (-128 <= value && value < 128)) {
                cachedObj = INT_CACHE[value];
                if (cachedObj)
                    return cachedObj;
            }
            obj = fromBits(value, value < 0 ? -1 : 0, false);
            if (cache)
                INT_CACHE[value] = obj;
            return obj;
        }
    }

    /**
     * Returns a Long representing the given 32 bit integer value.
     * @function
     * @param {number} value The 32 bit integer in question
     * @param {boolean=} unsigned Whether unsigned or not, defaults to `false` for signed
     * @returns {!Long} The corresponding Long value
     */
    Long.fromInt = fromInt;

    /**
     * @param {number} value
     * @param {boolean=} unsigned
     * @returns {!Long}
     * @inner
     */
    function fromNumber(value, unsigned) {
        if (isNaN(value) || !isFinite(value))
            return unsigned ? UZERO : ZERO;
        if (unsigned) {
            if (value < 0)
                return UZERO;
            if (value >= TWO_PWR_64_DBL)
                return MAX_UNSIGNED_VALUE;
        } else {
            if (value <= -TWO_PWR_63_DBL)
                return MIN_VALUE;
            if (value + 1 >= TWO_PWR_63_DBL)
                return MAX_VALUE;
        }
        if (value < 0)
            return fromNumber(-value, unsigned).neg();
        return fromBits((value % TWO_PWR_32_DBL) | 0, (value / TWO_PWR_32_DBL) | 0, unsigned);
    }

    /**
     * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.
     * @function
     * @param {number} value The number in question
     * @param {boolean=} unsigned Whether unsigned or not, defaults to `false` for signed
     * @returns {!Long} The corresponding Long value
     */
    Long.fromNumber = fromNumber;

    /**
     * @param {number} lowBits
     * @param {number} highBits
     * @param {boolean=} unsigned
     * @returns {!Long}
     * @inner
     */
    function fromBits(lowBits, highBits, unsigned) {
        return new Long(lowBits, highBits, unsigned);
    }

    /**
     * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is
     *  assumed to use 32 bits.
     * @function
     * @param {number} lowBits The low 32 bits
     * @param {number} highBits The high 32 bits
     * @param {boolean=} unsigned Whether unsigned or not, defaults to `false` for signed
     * @returns {!Long} The corresponding Long value
     */
    Long.fromBits = fromBits;

    /**
     * @function
     * @param {number} base
     * @param {number} exponent
     * @returns {number}
     * @inner
     */
    var pow_dbl = Math.pow; // Used 4 times (4*8 to 15+4)

    /**
     * @param {string} str
     * @param {(boolean|number)=} unsigned
     * @param {number=} radix
     * @returns {!Long}
     * @inner
     */
    function fromString(str, unsigned, radix) {
        if (str.length === 0)
            throw Error('empty string');
        if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity")
            return ZERO;
        if (typeof unsigned === 'number') {
            // For goog.math.long compatibility
            radix = unsigned,
            unsigned = false;
        } else {
            unsigned = !! unsigned;
        }
        radix = radix || 10;
        if (radix < 2 || 36 < radix)
            throw RangeError('radix');

        var p;
        if ((p = str.indexOf('-')) > 0)
            throw Error('interior hyphen');
        else if (p === 0) {
            return fromString(str.substring(1), unsigned, radix).neg();
        }

        // Do several (8) digits each time through the loop, so as to
        // minimize the calls to the very expensive emulated div.
        var radixToPower = fromNumber(pow_dbl(radix, 8));

        var result = ZERO;
        for (var i = 0; i < str.length; i += 8) {
            var size = Math.min(8, str.length - i),
                value = parseInt(str.substring(i, i + size), radix);
            if (size < 8) {
                var power = fromNumber(pow_dbl(radix, size));
                result = result.mul(power).add(fromNumber(value));
            } else {
                result = result.mul(radixToPower);
                result = result.add(fromNumber(value));
            }
        }
        result.unsigned = unsigned;
        return result;
    }

    /**
     * Returns a Long representation of the given string, written using the specified radix.
     * @function
     * @param {string} str The textual representation of the Long
     * @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to `false` for signed
     * @param {number=} radix The radix in which the text is written (2-36), defaults to 10
     * @returns {!Long} The corresponding Long value
     */
    Long.fromString = fromString;

    /**
     * @function
     * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val
     * @returns {!Long}
     * @inner
     */
    function fromValue(val) {
        if (val /* is compatible */ instanceof Long)
            return val;
        if (typeof val === 'number')
            return fromNumber(val);
        if (typeof val === 'string')
            return fromString(val);
        // Throws for non-objects, converts non-instanceof Long:
        return fromBits(val.low, val.high, val.unsigned);
    }

    /**
     * Converts the specified value to a Long.
     * @function
     * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val Value
     * @returns {!Long}
     */
    Long.fromValue = fromValue;

    // NOTE: the compiler should inline these constant values below and then remove these variables, so there should be
    // no runtime penalty for these.

    /**
     * @type {number}
     * @const
     * @inner
     */
    var TWO_PWR_16_DBL = 1 << 16;

    /**
     * @type {number}
     * @const
     * @inner
     */
    var TWO_PWR_24_DBL = 1 << 24;

    /**
     * @type {number}
     * @const
     * @inner
     */
    var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;

    /**
     * @type {number}
     * @const
     * @inner
     */
    var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;

    /**
     * @type {number}
     * @const
     * @inner
     */
    var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;

    /**
     * @type {!Long}
     * @const
     * @inner
     */
    var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);

    /**
     * @type {!Long}
     * @inner
     */
    var ZERO = fromInt(0);

    /**
     * Signed zero.
     * @type {!Long}
     */
    Long.ZERO = ZERO;

    /**
     * @type {!Long}
     * @inner
     */
    var UZERO = fromInt(0, true);

    /**
     * Unsigned zero.
     * @type {!Long}
     */
    Long.UZERO = UZERO;

    /**
     * @type {!Long}
     * @inner
     */
    var ONE = fromInt(1);

    /**
     * Signed one.
     * @type {!Long}
     */
    Long.ONE = ONE;

    /**
     * @type {!Long}
     * @inner
     */
    var UONE = fromInt(1, true);

    /**
     * Unsigned one.
     * @type {!Long}
     */
    Long.UONE = UONE;

    /**
     * @type {!Long}
     * @inner
     */
    var NEG_ONE = fromInt(-1);

    /**
     * Signed negative one.
     * @type {!Long}
     */
    Long.NEG_ONE = NEG_ONE;

    /**
     * @type {!Long}
     * @inner
     */
    var MAX_VALUE = fromBits(0xFFFFFFFF|0, 0x7FFFFFFF|0, false);

    /**
     * Maximum signed value.
     * @type {!Long}
     */
    Long.MAX_VALUE = MAX_VALUE;

    /**
     * @type {!Long}
     * @inner
     */
    var MAX_UNSIGNED_VALUE = fromBits(0xFFFFFFFF|0, 0xFFFFFFFF|0, true);

    /**
     * Maximum unsigned value.
     * @type {!Long}
     */
    Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;

    /**
     * @type {!Long}
     * @inner
     */
    var MIN_VALUE = fromBits(0, 0x80000000|0, false);

    /**
     * Minimum signed value.
     * @type {!Long}
     */
    Long.MIN_VALUE = MIN_VALUE;

    /**
     * @alias Long.prototype
     * @inner
     */
    var LongPrototype = Long.prototype;

    /**
     * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.
     * @returns {number}
     */
    LongPrototype.toInt = function toInt() {
        return this.unsigned ? this.low >>> 0 : this.low;
    };

    /**
     * Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).
     * @returns {number}
     */
    LongPrototype.toNumber = function toNumber() {
        if (this.unsigned)
            return ((this.high >>> 0) * TWO_PWR_32_DBL) + (this.low >>> 0);
        return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
    };

    /**
     * Converts the Long to a string written in the specified radix.
     * @param {number=} radix Radix (2-36), defaults to 10
     * @returns {string}
     * @override
     * @throws {RangeError} If `radix` is out of range
     */
    LongPrototype.toString = function toString(radix) {
        radix = radix || 10;
        if (radix < 2 || 36 < radix)
            throw RangeError('radix');
        if (this.isZero())
            return '0';
        if (this.isNegative()) { // Unsigned Longs are never negative
            if (this.eq(MIN_VALUE)) {
                // We need to change the Long value before it can be negated, so we remove
                // the bottom-most digit in this base and then recurse to do the rest.
                var radixLong = fromNumber(radix),
                    div = this.div(radixLong),
                    rem1 = div.mul(radixLong).sub(this);
                return div.toString(radix) + rem1.toInt().toString(radix);
            } else
                return '-' + this.neg().toString(radix);
        }

        // Do several (6) digits each time through the loop, so as to
        // minimize the calls to the very expensive emulated div.
        var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned),
            rem = this;
        var result = '';
        while (true) {
            var remDiv = rem.div(radixToPower),
                intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0,
                digits = intval.toString(radix);
            rem = remDiv;
            if (rem.isZero())
                return digits + result;
            else {
                while (digits.length < 6)
                    digits = '0' + digits;
                result = '' + digits + result;
            }
        }
    };

    /**
     * Gets the high 32 bits as a signed integer.
     * @returns {number} Signed high bits
     */
    LongPrototype.getHighBits = function getHighBits() {
        return this.high;
    };

    /**
     * Gets the high 32 bits as an unsigned integer.
     * @returns {number} Unsigned high bits
     */
    LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
        return this.high >>> 0;
    };

    /**
     * Gets the low 32 bits as a signed integer.
     * @returns {number} Signed low bits
     */
    LongPrototype.getLowBits = function getLowBits() {
        return this.low;
    };

    /**
     * Gets the low 32 bits as an unsigned integer.
     * @returns {number} Unsigned low bits
     */
    LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
        return this.low >>> 0;
    };

    /**
     * Gets the number of bits needed to represent the absolute value of this Long.
     * @returns {number}
     */
    LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
        if (this.isNegative()) // Unsigned Longs are never negative
            return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
        var val = this.high != 0 ? this.high : this.low;
        for (var bit = 31; bit > 0; bit--)
            if ((val & (1 << bit)) != 0)
                break;
        return this.high != 0 ? bit + 33 : bit + 1;
    };

    /**
     * Tests if this Long's value equals zero.
     * @returns {boolean}
     */
    LongPrototype.isZero = function isZero() {
        return this.high === 0 && this.low === 0;
    };

    /**
     * Tests if this Long's value is negative.
     * @returns {boolean}
     */
    LongPrototype.isNegative = function isNegative() {
        return !this.unsigned && this.high < 0;
    };

    /**
     * Tests if this Long's value is positive.
     * @returns {boolean}
     */
    LongPrototype.isPositive = function isPositive() {
        return this.unsigned || this.high >= 0;
    };

    /**
     * Tests if this Long's value is odd.
     * @returns {boolean}
     */
    LongPrototype.isOdd = function isOdd() {
        return (this.low & 1) === 1;
    };

    /**
     * Tests if this Long's value is even.
     * @returns {boolean}
     */
    LongPrototype.isEven = function isEven() {
        return (this.low & 1) === 0;
    };

    /**
     * Tests if this Long's value equals the specified's.
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.equals = function equals(other) {
        if (!isLong(other))
            other = fromValue(other);
        if (this.unsigned !== other.unsigned && (this.high >>> 31) === 1 && (other.high >>> 31) === 1)
            return false;
        return this.high === other.high && this.low === other.low;
    };

    /**
     * Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.
     * @function
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.eq = LongPrototype.equals;

    /**
     * Tests if this Long's value differs from the specified's.
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.notEquals = function notEquals(other) {
        return !this.eq(/* validates */ other);
    };

    /**
     * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
     * @function
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.neq = LongPrototype.notEquals;

    /**
     * Tests if this Long's value is less than the specified's.
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.lessThan = function lessThan(other) {
        return this.comp(/* validates */ other) < 0;
    };

    /**
     * Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.
     * @function
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.lt = LongPrototype.lessThan;

    /**
     * Tests if this Long's value is less than or equal the specified's.
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
        return this.comp(/* validates */ other) <= 0;
    };

    /**
     * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
     * @function
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.lte = LongPrototype.lessThanOrEqual;

    /**
     * Tests if this Long's value is greater than the specified's.
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.greaterThan = function greaterThan(other) {
        return this.comp(/* validates */ other) > 0;
    };

    /**
     * Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.
     * @function
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.gt = LongPrototype.greaterThan;

    /**
     * Tests if this Long's value is greater than or equal the specified's.
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
        return this.comp(/* validates */ other) >= 0;
    };

    /**
     * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
     * @function
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.gte = LongPrototype.greaterThanOrEqual;

    /**
     * Compares this Long's value with the specified's.
     * @param {!Long|number|string} other Other value
     * @returns {number} 0 if they are the same, 1 if the this is greater and -1
     *  if the given one is greater
     */
    LongPrototype.compare = function compare(other) {
        if (!isLong(other))
            other = fromValue(other);
        if (this.eq(other))
            return 0;
        var thisNeg = this.isNegative(),
            otherNeg = other.isNegative();
        if (thisNeg && !otherNeg)
            return -1;
        if (!thisNeg && otherNeg)
            return 1;
        // At this point the sign bits are the same
        if (!this.unsigned)
            return this.sub(other).isNegative() ? -1 : 1;
        // Both are positive if at least one is unsigned
        return (other.high >>> 0) > (this.high >>> 0) || (other.high === this.high && (other.low >>> 0) > (this.low >>> 0)) ? -1 : 1;
    };

    /**
     * Compares this Long's value with the specified's. This is an alias of {@link Long#compare}.
     * @function
     * @param {!Long|number|string} other Other value
     * @returns {number} 0 if they are the same, 1 if the this is greater and -1
     *  if the given one is greater
     */
    LongPrototype.comp = LongPrototype.compare;

    /**
     * Negates this Long's value.
     * @returns {!Long} Negated Long
     */
    LongPrototype.negate = function negate() {
        if (!this.unsigned && this.eq(MIN_VALUE))
            return MIN_VALUE;
        return this.not().add(ONE);
    };

    /**
     * Negates this Long's value. This is an alias of {@link Long#negate}.
     * @function
     * @returns {!Long} Negated Long
     */
    LongPrototype.neg = LongPrototype.negate;

    /**
     * Returns the sum of this and the specified Long.
     * @param {!Long|number|string} addend Addend
     * @returns {!Long} Sum
     */
    LongPrototype.add = function add(addend) {
        if (!isLong(addend))
            addend = fromValue(addend);

        // Divide each number into 4 chunks of 16 bits, and then sum the chunks.

        var a48 = this.high >>> 16;
        var a32 = this.high & 0xFFFF;
        var a16 = this.low >>> 16;
        var a00 = this.low & 0xFFFF;

        var b48 = addend.high >>> 16;
        var b32 = addend.high & 0xFFFF;
        var b16 = addend.low >>> 16;
        var b00 = addend.low & 0xFFFF;

        var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
        c00 += a00 + b00;
        c16 += c00 >>> 16;
        c00 &= 0xFFFF;
        c16 += a16 + b16;
        c32 += c16 >>> 16;
        c16 &= 0xFFFF;
        c32 += a32 + b32;
        c48 += c32 >>> 16;
        c32 &= 0xFFFF;
        c48 += a48 + b48;
        c48 &= 0xFFFF;
        return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);
    };

    /**
     * Returns the difference of this and the specified Long.
     * @param {!Long|number|string} subtrahend Subtrahend
     * @returns {!Long} Difference
     */
    LongPrototype.subtract = function subtract(subtrahend) {
        if (!isLong(subtrahend))
            subtrahend = fromValue(subtrahend);
        return this.add(subtrahend.neg());
    };

    /**
     * Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.
     * @function
     * @param {!Long|number|string} subtrahend Subtrahend
     * @returns {!Long} Difference
     */
    LongPrototype.sub = LongPrototype.subtract;

    /**
     * Returns the product of this and the specified Long.
     * @param {!Long|number|string} multiplier Multiplier
     * @returns {!Long} Product
     */
    LongPrototype.multiply = function multiply(multiplier) {
        if (this.isZero())
            return ZERO;
        if (!isLong(multiplier))
            multiplier = fromValue(multiplier);
        if (multiplier.isZero())
            return ZERO;
        if (this.eq(MIN_VALUE))
            return multiplier.isOdd() ? MIN_VALUE : ZERO;
        if (multiplier.eq(MIN_VALUE))
            return this.isOdd() ? MIN_VALUE : ZERO;

        if (this.isNegative()) {
            if (multiplier.isNegative())
                return this.neg().mul(multiplier.neg());
            else
                return this.neg().mul(multiplier).neg();
        } else if (multiplier.isNegative())
            return this.mul(multiplier.neg()).neg();

        // If both longs are small, use float multiplication
        if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))
            return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);

        // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.
        // We can skip products that would overflow.

        var a48 = this.high >>> 16;
        var a32 = this.high & 0xFFFF;
        var a16 = this.low >>> 16;
        var a00 = this.low & 0xFFFF;

        var b48 = multiplier.high >>> 16;
        var b32 = multiplier.high & 0xFFFF;
        var b16 = multiplier.low >>> 16;
        var b00 = multiplier.low & 0xFFFF;

        var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
        c00 += a00 * b00;
        c16 += c00 >>> 16;
        c00 &= 0xFFFF;
        c16 += a16 * b00;
        c32 += c16 >>> 16;
        c16 &= 0xFFFF;
        c16 += a00 * b16;
        c32 += c16 >>> 16;
        c16 &= 0xFFFF;
        c32 += a32 * b00;
        c48 += c32 >>> 16;
        c32 &= 0xFFFF;
        c32 += a16 * b16;
        c48 += c32 >>> 16;
        c32 &= 0xFFFF;
        c32 += a00 * b32;
        c48 += c32 >>> 16;
        c32 &= 0xFFFF;
        c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
        c48 &= 0xFFFF;
        return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);
    };

    /**
     * Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.
     * @function
     * @param {!Long|number|string} multiplier Multiplier
     * @returns {!Long} Product
     */
    LongPrototype.mul = LongPrototype.multiply;

    /**
     * Returns this Long divided by the specified. The result is signed if this Long is signed or
     *  unsigned if this Long is unsigned.
     * @param {!Long|number|string} divisor Divisor
     * @returns {!Long} Quotient
     */
    LongPrototype.divide = function divide(divisor) {
        if (!isLong(divisor))
            divisor = fromValue(divisor);
        if (divisor.isZero())
            throw Error('division by zero');
        if (this.isZero())
            return this.unsigned ? UZERO : ZERO;
        var approx, rem, res;
        if (!this.unsigned) {
            // This section is only relevant for signed longs and is derived from the
            // closure library as a whole.
            if (this.eq(MIN_VALUE)) {
                if (divisor.eq(ONE) || divisor.eq(NEG_ONE))
                    return MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE
                else if (divisor.eq(MIN_VALUE))
                    return ONE;
                else {
                    // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.
                    var halfThis = this.shr(1);
                    approx = halfThis.div(divisor).shl(1);
                    if (approx.eq(ZERO)) {
                        return divisor.isNegative() ? ONE : NEG_ONE;
                    } else {
                        rem = this.sub(divisor.mul(approx));
                        res = approx.add(rem.div(divisor));
                        return res;
                    }
                }
            } else if (divisor.eq(MIN_VALUE))
                return this.unsigned ? UZERO : ZERO;
            if (this.isNegative()) {
                if (divisor.isNegative())
                    return this.neg().div(divisor.neg());
                return this.neg().div(divisor).neg();
            } else if (divisor.isNegative())
                return this.div(divisor.neg()).neg();
            res = ZERO;
        } else {
            // The algorithm below has not been made for unsigned longs. It's therefore
            // required to take special care of the MSB prior to running it.
            if (!divisor.unsigned)
                divisor = divisor.toUnsigned();
            if (divisor.gt(this))
                return UZERO;
            if (divisor.gt(this.shru(1))) // 15 >>> 1 = 7 ; with divisor = 8 ; true
                return UONE;
            res = UZERO;
        }

        // Repeat the following until the remainder is less than other:  find a
        // floating-point that approximates remainder / other *from below*, add this
        // into the result, and subtract it from the remainder.  It is critical that
        // the approximate value is less than or equal to the real value so that the
        // remainder never becomes negative.
        rem = this;
        while (rem.gte(divisor)) {
            // Approximate the result of division. This may be a little greater or
            // smaller than the actual value.
            approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));

            // We will tweak the approximate result by changing it in the 48-th digit or
            // the smallest non-fractional digit, whichever is larger.
            var log2 = Math.ceil(Math.log(approx) / Math.LN2),
                delta = (log2 <= 48) ? 1 : pow_dbl(2, log2 - 48),

            // Decrease the approximation until it is smaller than the remainder.  Note
            // that if it is too large, the product overflows and is negative.
                approxRes = fromNumber(approx),
                approxRem = approxRes.mul(divisor);
            while (approxRem.isNegative() || approxRem.gt(rem)) {
                approx -= delta;
                approxRes = fromNumber(approx, this.unsigned);
                approxRem = approxRes.mul(divisor);
            }

            // We know the answer can't be zero... and actually, zero would cause
            // infinite recursion since we would make no progress.
            if (approxRes.isZero())
                approxRes = ONE;

            res = res.add(approxRes);
            rem = rem.sub(approxRem);
        }
        return res;
    };

    /**
     * Returns this Long divided by the specified. This is an alias of {@link Long#divide}.
     * @function
     * @param {!Long|number|string} divisor Divisor
     * @returns {!Long} Quotient
     */
    LongPrototype.div = LongPrototype.divide;

    /**
     * Returns this Long modulo the specified.
     * @param {!Long|number|string} divisor Divisor
     * @returns {!Long} Remainder
     */
    LongPrototype.modulo = function modulo(divisor) {
        if (!isLong(divisor))
            divisor = fromValue(divisor);
        return this.sub(this.div(divisor).mul(divisor));
    };

    /**
     * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
     * @function
     * @param {!Long|number|string} divisor Divisor
     * @returns {!Long} Remainder
     */
    LongPrototype.mod = LongPrototype.modulo;

    /**
     * Returns the bitwise NOT of this Long.
     * @returns {!Long}
     */
    LongPrototype.not = function not() {
        return fromBits(~this.low, ~this.high, this.unsigned);
    };

    /**
     * Returns the bitwise AND of this Long and the specified.
     * @param {!Long|number|string} other Other Long
     * @returns {!Long}
     */
    LongPrototype.and = function and(other) {
        if (!isLong(other))
            other = fromValue(other);
        return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
    };

    /**
     * Returns the bitwise OR of this Long and the specified.
     * @param {!Long|number|string} other Other Long
     * @returns {!Long}
     */
    LongPrototype.or = function or(other) {
        if (!isLong(other))
            other = fromValue(other);
        return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
    };

    /**
     * Returns the bitwise XOR of this Long and the given one.
     * @param {!Long|number|string} other Other Long
     * @returns {!Long}
     */
    LongPrototype.xor = function xor(other) {
        if (!isLong(other))
            other = fromValue(other);
        return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
    };

    /**
     * Returns this Long with bits shifted to the left by the given amount.
     * @param {number|!Long} numBits Number of bits
     * @returns {!Long} Shifted Long
     */
    LongPrototype.shiftLeft = function shiftLeft(numBits) {
        if (isLong(numBits))
            numBits = numBits.toInt();
        if ((numBits &= 63) === 0)
            return this;
        else if (numBits < 32)
            return fromBits(this.low << numBits, (this.high << numBits) | (this.low >>> (32 - numBits)), this.unsigned);
        else
            return fromBits(0, this.low << (numBits - 32), this.unsigned);
    };

    /**
     * Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.
     * @function
     * @param {number|!Long} numBits Number of bits
     * @returns {!Long} Shifted Long
     */
    LongPrototype.shl = LongPrototype.shiftLeft;

    /**
     * Returns this Long with bits arithmetically shifted to the right by the given amount.
     * @param {number|!Long} numBits Number of bits
     * @returns {!Long} Shifted Long
     */
    LongPrototype.shiftRight = function shiftRight(numBits) {
        if (isLong(numBits))
            numBits = numBits.toInt();
        if ((numBits &= 63) === 0)
            return this;
        else if (numBits < 32)
            return fromBits((this.low >>> numBits) | (this.high << (32 - numBits)), this.high >> numBits, this.unsigned);
        else
            return fromBits(this.high >> (numBits - 32), this.high >= 0 ? 0 : -1, this.unsigned);
    };

    /**
     * Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.
     * @function
     * @param {number|!Long} numBits Number of bits
     * @returns {!Long} Shifted Long
     */
    LongPrototype.shr = LongPrototype.shiftRight;

    /**
     * Returns this Long with bits logically shifted to the right by the given amount.
     * @param {number|!Long} numBits Number of bits
     * @returns {!Long} Shifted Long
     */
    LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
        if (isLong(numBits))
            numBits = numBits.toInt();
        numBits &= 63;
        if (numBits === 0)
            return this;
        else {
            var high = this.high;
            if (numBits < 32) {
                var low = this.low;
                return fromBits((low >>> numBits) | (high << (32 - numBits)), high >>> numBits, this.unsigned);
            } else if (numBits === 32)
                return fromBits(high, 0, this.unsigned);
            else
                return fromBits(high >>> (numBits - 32), 0, this.unsigned);
        }
    };

    /**
     * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
     * @function
     * @param {number|!Long} numBits Number of bits
     * @returns {!Long} Shifted Long
     */
    LongPrototype.shru = LongPrototype.shiftRightUnsigned;

    /**
     * Converts this Long to signed.
     * @returns {!Long} Signed long
     */
    LongPrototype.toSigned = function toSigned() {
        if (!this.unsigned)
            return this;
        return fromBits(this.low, this.high, false);
    };

    /**
     * Converts this Long to unsigned.
     * @returns {!Long} Unsigned long
     */
    LongPrototype.toUnsigned = function toUnsigned() {
        if (this.unsigned)
            return this;
        return fromBits(this.low, this.high, true);
    };

    /**
     * Converts this Long to its byte representation.
     * @param {boolean=} le Whether little or big endian, defaults to big endian
     * @returns {!Array.<number>} Byte representation
     */
    LongPrototype.toBytes = function(le) {
        return le ? this.toBytesLE() : this.toBytesBE();
    }

    /**
     * Converts this Long to its little endian byte representation.
     * @returns {!Array.<number>} Little endian byte representation
     */
    LongPrototype.toBytesLE = function() {
        var hi = this.high,
            lo = this.low;
        return [
             lo         & 0xff,
            (lo >>>  8) & 0xff,
            (lo >>> 16) & 0xff,
            (lo >>> 24) & 0xff,
             hi         & 0xff,
            (hi >>>  8) & 0xff,
            (hi >>> 16) & 0xff,
            (hi >>> 24) & 0xff
        ];
    }

    /**
     * Converts this Long to its big endian byte representation.
     * @returns {!Array.<number>} Big endian byte representation
     */
    LongPrototype.toBytesBE = function() {
        var hi = this.high,
            lo = this.low;
        return [
            (hi >>> 24) & 0xff,
            (hi >>> 16) & 0xff,
            (hi >>>  8) & 0xff,
             hi         & 0xff,
            (lo >>> 24) & 0xff,
            (lo >>> 16) & 0xff,
            (lo >>>  8) & 0xff,
             lo         & 0xff
        ];
    }

    return Long;
});


/***/ }),

/***/ "../../../node_modules/@hivestreaming/codem-isoboxer/dist/iso_boxer.js":
/*!**********************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/node_modules/@hivestreaming/codem-isoboxer/dist/iso_boxer.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*! codem-isoboxer v0.2.2 https://github.com/madebyhiro/codem-isoboxer/blob/master/LICENSE.txt */
if (typeof ISOBoxer === 'undefined') {
  var ISOBoxer = {};
}

ISOBoxer.parseBuffer = function(arrayBuffer) {
  return new ISOFile(arrayBuffer).parse();
};

ISOBoxer.Utils = {};
ISOBoxer.Utils.dataViewToString = function(dataView, encoding) {
  var impliedEncoding = encoding || 'utf-8'
  if (typeof TextDecoder !== 'undefined') {
    return new TextDecoder(impliedEncoding).decode(dataView);
  }
  var a = [];
  var i = 0;
  
  if (impliedEncoding === 'utf-8') {
    /* The following algorithm is essentially a rewrite of the UTF8.decode at 
    http://bannister.us/weblog/2007/simple-base64-encodedecode-javascript/
    */
  
    while (i < dataView.byteLength) {
      var c = dataView.getUint8(i++);
      if (c < 0x80) {
        // 1-byte character (7 bits)
      } else if (c < 0xe0) {
        // 2-byte character (11 bits)
        c = (c & 0x1f) << 6;
        c |= (dataView.getUint8(i++) & 0x3f);
      } else if (c < 0xf0) {
        // 3-byte character (16 bits)
        c = (c & 0xf) << 12;
        c |= (dataView.getUint8(i++) & 0x3f) << 6;
        c |= (dataView.getUint8(i++) & 0x3f);
      } else {
        // 4-byte character (21 bits)
        c = (c & 0x7) << 18;
        c |= (dataView.getUint8(i++) & 0x3f) << 12;
        c |= (dataView.getUint8(i++) & 0x3f) << 6;
        c |= (dataView.getUint8(i++) & 0x3f);
      }
      a.push(String.fromCharCode(c));
    }
  } else { // Just map byte-by-byte (probably wrong)
    while (i < dataView.byteLength) {
      a.push(String.fromCharCode(dataView.getUint8(i++)));
    }
  }
  return a.join('');  
};

if (true) {
  exports.parseBuffer = ISOBoxer.parseBuffer;
  exports.Utils       = ISOBoxer.Utils;
};
ISOBoxer.Cursor = function(initialOffset) {
  this.offset = (typeof initialOffset == 'undefined' ? 0 : initialOffset);
};
var ISOFile = function(arrayBuffer) {
  this._raw = new DataView(arrayBuffer);
  this._cursor = new ISOBoxer.Cursor();
  this.boxes = [];
}

ISOFile.prototype.fetch = function(type) {
  var result = this.fetchAll(type, true);
  return (result.length ? result[0] : null);
}

ISOFile.prototype.fetchAll = function(type, returnEarly) {
  var result = [];
  ISOFile._sweep.call(this, type, result, returnEarly);
  return result;
}

ISOFile.prototype.parse = function() {
  this._cursor.offset = 0;
  this.boxes = [];
  while (this._cursor.offset < this._raw.byteLength) {
    var box = ISOBox.parse(this);

    // Box could not be parsed
    if (typeof box.type === 'undefined') break;

    this.boxes.push(box);
  }
  return this;
}

ISOFile._sweep = function(type, result, returnEarly) {
  if (this.type && this.type == type) result.push(this);
  for (var box in this.boxes) {
    if (result.length && returnEarly) return;
    ISOFile._sweep.call(this.boxes[box], type, result, returnEarly);
  }
};
var ISOBox = function() {
  this._cursor = new ISOBoxer.Cursor();
}

ISOBox.parse = function(parent) {
  var newBox = new ISOBox();
  newBox._offset = parent._cursor.offset;
  newBox._root = (parent._root ? parent._root : parent);
  newBox._raw = parent._raw;
  newBox._parent = parent;
  newBox._parseBox();
  parent._cursor.offset = newBox._raw.byteOffset + newBox._raw.byteLength;
  return newBox;
}

ISOBox.prototype._readInt = function(size) {
  var result = null;
  switch(size) {
  case 8:
    result = this._raw.getInt8(this._cursor.offset - this._raw.byteOffset);
    break;
  case 16:
    result = this._raw.getInt16(this._cursor.offset - this._raw.byteOffset);
    break;
  case 32:
    result = this._raw.getInt32(this._cursor.offset - this._raw.byteOffset);
    break;
  case 64:
    // Warning: JavaScript cannot handle 64-bit integers natively.
    // This will give unexpected results for integers >= 2^53
    var s1 = this._raw.getInt32(this._cursor.offset - this._raw.byteOffset);
    var s2 = this._raw.getInt32(this._cursor.offset - this._raw.byteOffset + 4);
    result = (s1 * Math.pow(2,32)) + s2;
    break;
  }
  this._cursor.offset += (size >> 3);
  return result;        
}

ISOBox.prototype._readUint = function(size) {
  var result = null;
  switch(size) {
  case 8:
    result = this._raw.getUint8(this._cursor.offset - this._raw.byteOffset);
    break;
  case 16:
    result = this._raw.getUint16(this._cursor.offset - this._raw.byteOffset);
    break;
  case 24:
    var s1 = this._raw.getUint16(this._cursor.offset - this._raw.byteOffset);
    var s2 = this._raw.getUint8(this._cursor.offset - this._raw.byteOffset + 2);
    result = (s1 << 8) + s2;
    break;
  case 32:
    result = this._raw.getUint32(this._cursor.offset - this._raw.byteOffset);
    break;
  case 64:
    // Warning: JavaScript cannot handle 64-bit integers natively.
    // This will give unexpected results for integers >= 2^53
    var s1 = this._raw.getUint32(this._cursor.offset - this._raw.byteOffset);
    var s2 = this._raw.getUint32(this._cursor.offset - this._raw.byteOffset + 4);
    result = (s1 * Math.pow(2,32)) + s2;
    break;
  }
  this._cursor.offset += (size >> 3);
  return result;        
}

ISOBox.prototype._readString = function(length) {
  var str = '';
  for (var c = 0; c < length; c++) {
    var char = this._readUint(8);
    str += String.fromCharCode(char);
  }
  return str;    
}

ISOBox.prototype._readTerminatedString = function() {
  var str = '';
  while (true) {
    var char = this._readUint(8);
    if (char == 0) break;
    str += String.fromCharCode(char);
  }
  return str;
}

ISOBox.prototype._readTemplate = function(size) {
  var pre = this._readUint(size / 2);
  var post = this._readUint(size / 2);
  return pre + (post / Math.pow(2, size / 2));
}

ISOBox.prototype._parseBox = function() {
  this._cursor.offset = this._offset;
  
  // return immediately if there are not enough bytes to read the header
  if (this._offset + 8 > this._raw.buffer.byteLength) {
    this._root._incomplete = true;
    return;
  }
  
  this.size = this._readUint(32);
  this.type = this._readString(4);

  if (this.size == 1)      { this.largesize = this._readUint(64); }
  if (this.type == 'uuid') { this.usertype = this._readString(16); }

  switch(this.size) {
  case 0:
    this._raw = new DataView(this._raw.buffer, this._offset, (this._raw.byteLength - this._cursor.offset));
    break;
  case 1:
    if (this._offset + this.size > this._raw.buffer.byteLength) {
      this._incomplete = true;
      this._root._incomplete = true;
    } else {
      this._raw = new DataView(this._raw.buffer, this._offset, this.largesize);      
    }
    break;
  default:
    if (this._offset + this.size > this._raw.buffer.byteLength) {
      this._incomplete = true;
      this._root._incomplete = true;
    } else {
      this._raw = new DataView(this._raw.buffer, this._offset, this.size);      
    }
  }

  // additional parsing
  if (!this._incomplete && this._boxParsers[this.type]) this._boxParsers[this.type].call(this);    
}

ISOBox.prototype._parseFullBox = function() {
  this.version = this._readUint(8);
  this.flags = this._readUint(24);
}

ISOBox.prototype._boxParsers = {};;
// Simple container boxes, all from ISO/IEC 14496-12:2012 except vttc which is from 14496-30.
[
  'moov', 'trak', 'tref', 'mdia', 'minf', 'stbl', 'edts', 'dinf',
  'mvex', 'moof', 'traf', 'mfra', 'udta', 'meco', 'strk', 'vttc'
].forEach(function(boxType) {
  ISOBox.prototype._boxParsers[boxType] = function() {
    this.boxes = [];
    while (this._cursor.offset - this._raw.byteOffset < this._raw.byteLength) {
      this.boxes.push(ISOBox.parse(this));
    }  
  }  
})
;
// ISO/IEC 14496-12:2012 - 8.6.6 Edit List Box
ISOBox.prototype._boxParsers['elst'] = function() {
  this._parseFullBox();
  this.entry_count = this._readUint(32);
  this.entries = [];
  
  for (var i=1; i <= this.entry_count; i++) {
    var entry = {};
    if (this.version == 1) {
      entry.segment_duration  = this._readUint(64);
      entry.media_time        = this._readInt(64);
    } else {
      entry.segment_duration  = this._readUint(32);
      entry.media_time        = this._readInt(32);
    }
    entry.media_rate_integer  = this._readInt(16);
    entry.media_rate_fraction = this._readInt(16);
    this.entries.push(entry);
  }
};
// ISO/IEC 23009-1:2014 - 5.10.3.3 Event Message Box
ISOBox.prototype._boxParsers['emsg'] = function() {
  this._parseFullBox();
  this.scheme_id_uri           = this._readTerminatedString();
  this.value                   = this._readTerminatedString();
  this.timescale               = this._readUint(32);
  this.presentation_time_delta = this._readUint(32);
  this.event_duration          = this._readUint(32);
  this.id                      = this._readUint(32);
  this.message_data            = new DataView(this._raw.buffer, this._cursor.offset, this._raw.byteLength - (this._cursor.offset - this._offset));
};
// ISO/IEC 14496-12:2012 - 8.1.2 Free Space Box
ISOBox.prototype._boxParsers['free'] = ISOBox.prototype._boxParsers['skip'] = function() {
  this.data = new DataView(this._raw.buffer, this._cursor.offset, this._raw.byteLength - (this._cursor.offset - this._offset));
};
// ISO/IEC 14496-12:2012 - 4.3 File Type Box / 8.16.2 Segment Type Box
ISOBox.prototype._boxParsers['ftyp'] = ISOBox.prototype._boxParsers['styp'] = function() {
  this.major_brand = this._readString(4);
  this.minor_versions = this._readUint(32);
  this.compatible_brands = [];
  
  while (this._cursor.offset - this._raw.byteOffset < this._raw.byteLength) {
    this.compatible_brands.push(this._readString(4));
  }
};
// ISO/IEC 14496-12:2012 - 8.4.3 Handler Reference Box
ISOBox.prototype._boxParsers['hdlr'] = function() {
  this._parseFullBox();
  this.pre_defined = this._readUint(32);
  this.handler_type = this._readString(4);
  this.reserved = [this._readUint(32), this._readUint(32), this._readUint(32)]
  this.name = this._readTerminatedString()
};
// ISO/IEC 14496-12:2012 - 8.1.1 Media Data Box
ISOBox.prototype._boxParsers['mdat'] = function() {
  this.data = new DataView(this._raw.buffer, this._cursor.offset, this._raw.byteLength - (this._cursor.offset - this._offset));
};
// ISO/IEC 14496-12:2012 - 8.4.2 Media Header Box
ISOBox.prototype._boxParsers['mdhd'] = function() {
  this._parseFullBox();
  if (this.version == 1) {
    this.creation_time = this._readUint(64);
    this.modification_time = this._readUint(64);
    this.timescale = this._readUint(32);
    this.duration = this._readUint(64);
  } else {
    this.creation_time = this._readUint(32);
    this.modification_time = this._readUint(32);
    this.timescale = this._readUint(32);
    this.duration = this._readUint(32);
  }
  var language = this._readUint(16);
  this.pad = (language >> 15);
  this.language = String.fromCharCode(
    ((language >> 10) & 0x1F) + 0x60,
    ((language >> 5) & 0x1F) + 0x60,
    (language & 0x1F) + 0x60
  );
  this.pre_defined = this._readUint(16);
};
// ISO/IEC 14496-12:2012 - 8.8.5 Movie Fragment Header Box
ISOBox.prototype._boxParsers['mfhd'] = function() {
  this._parseFullBox();
  this.sequence_number = this._readUint(32);
};
// ISO/IEC 14496-12:2012 - 8.2.2 Movie Header Box
ISOBox.prototype._boxParsers['mvhd'] = function() {
  this._parseFullBox();
  
  if (this.version == 1) {
    this.creation_time     = this._readUint(64);
    this.modification_time = this._readUint(64);
    this.timescale         = this._readUint(32);
    this.duration          = this._readUint(64);
  } else {
    this.creation_time     = this._readUint(32);
    this.modification_time = this._readUint(32);
    this.timescale         = this._readUint(32);
    this.duration          = this._readUint(32);      
  }
  
  this.rate      = this._readTemplate(32);
  this.volume    = this._readTemplate(16);
  this.reserved1 = this._readUint(16);
  this.reserved2 = [ this._readUint(32), this._readUint(32) ];
  this.matrix = [];
  for (var i=0; i<9; i++) {
    this.matrix.push(this._readTemplate(32));
  }
  this.pre_defined = [];
  for (var i=0; i<6; i++) {
    this.pre_defined.push(this._readUint(32));
  }
  this.next_track_ID = this._readUint(32);
};
// ISO/IEC 14496-30:2014 - WebVTT Cue Payload Box.
ISOBox.prototype._boxParsers['payl'] = function() {
  var cue_text_raw = new DataView(this._raw.buffer, this._cursor.offset, this._raw.byteLength - (this._cursor.offset - this._offset));
  this.cue_text = ISOBoxer.Utils.dataViewToString(cue_text_raw);
}
;
// ISO/IEC 14496-12:2012 - 8.16.3 Segment Index Box
ISOBox.prototype._boxParsers['sidx'] = function() {
  this._parseFullBox();
  this.reference_ID = this._readUint(32);
  this.timescale = this._readUint(32);
  if (this.version == 0) {
    this.earliest_presentation_time = this._readUint(32);
    this.first_offset = this._readUint(32);
  } else {
    this.earliest_presentation_time = this._readUint(64);
    this.first_offset = this._readUint(64);    
  }
  this.reserved = this._readUint(16);
  this.reference_count = this._readUint(16);
  this.references = [];
  for (var i=0; i<this.reference_count; i++) {
    var ref = {};
    var reference = this._readUint(32);
    ref.reference_type = (reference >> 31) & 0x1;
    ref.referenced_size = reference & 0x7FFFFFFF;
    ref.subsegment_duration = this._readUint(32);
    var sap = this._readUint(32);
    ref.starts_with_SAP = (sap >> 31) & 0x1;
    ref.SAP_type = (sap >> 28) & 0x7;
    ref.SAP_delta_time = sap & 0xFFFFFFF;
    this.references.push(ref);
  }
};
// ISO/IEC 14496-12:2012 - 8.16.4 Subsegment Index Box
ISOBox.prototype._boxParsers['ssix'] = function() {
  this._parseFullBox();
  this.subsegment_count = this._readUint(32);
  this.subsegments = [];

  for (var i=0; i<this.subsegment_count; i++) {
    var subsegment = {};
    subsegment.ranges_count = this._readUint(32);
    subsegment.ranges = [];
    
    for (var j=0; j<subsegment.ranges_count; j++) {
      var range = {};
      range.level = this._readUint(8);
      range.range_size = this._readUint(24);
      subsegment.ranges.push(range);
    }
    this.subsegments.push(subsegment);
  }
};
// ISO/IEC 14496-12:2012 - 8.8.12 Track Fragmnent Decode Time
ISOBox.prototype._boxParsers['tfdt'] = function() {
  this._parseFullBox();
  if (this.version == 1) {
    this.baseMediaDecodeTime = this._readUint(64);
  } else {
    this.baseMediaDecodeTime = this._readUint(32);    
  }
};
// ISO/IEC 14496-12:2012 - 8.8.7 Track Fragment Header Box
ISOBox.prototype._boxParsers['tfhd'] = function() {
  this._parseFullBox();
  this.track_ID = this._readUint(32);
  if (this.flags & 0x1) this.base_data_offset = this._readUint(64);
  if (this.flags & 0x2) this.sample_description_offset = this._readUint(32);
  if (this.flags & 0x8) this.default_sample_duration = this._readUint(32);
  if (this.flags & 0x10) this.default_sample_size = this._readUint(32);
  if (this.flags & 0x20) this.default_sample_flags = this._readUint(32);
};
// ISO/IEC 14496-12:2012 - 8.3.2 Track Header Box
ISOBox.prototype._boxParsers['tkhd'] = function() {
  this._parseFullBox();
  
  if (this.version == 1) {
    this.creation_time     = this._readUint(64);
    this.modification_time = this._readUint(64);
    this.track_ID          = this._readUint(32);
    this.reserved1         = this._readUint(32);
    this.duration          = this._readUint(64);
  } else {
    this.creation_time     = this._readUint(32);
    this.modification_time = this._readUint(32);
    this.track_ID          = this._readUint(32);
    this.reserved1         = this._readUint(32);
    this.duration          = this._readUint(32);
  }
  
  this.reserved2 = [
    this._readUint(32),
    this._readUint(32)
  ];
  this.layer = this._readUint(16);
  this.alternate_group = this._readUint(16);
  this.volume = this._readTemplate(16);
  this.reserved3 = this._readUint(16);
  this.matrix = [];
  for (var i=0; i<9; i++) {
    this.matrix.push(this._readTemplate(32));
  }
  this.width = this._readUint(32);
  this.height = this._readUint(32);
};
// ISO/IEC 14496-12:2012 - 8.8.8 Track Run Box
// Note: the 'trun' box has a direct relation to the 'tfhd' box for defaults.
// These defaults are not set explicitly here, but are left to resolve for the user.
ISOBox.prototype._boxParsers['trun'] = function() {
  this._parseFullBox();
  this.sample_count = this._readUint(32);
  if (this.flags & 0x1) this.data_offset = this._readInt(32);
  if (this.flags & 0x4) this.first_sample_flags = this._readUint(32);
  this.samples = [];
  for (var i=0; i<this.sample_count; i++) {
    var sample = {};
    if (this.flags & 0x100) sample.sample_duration = this._readUint(32);
    if (this.flags & 0x200) sample.sample_size = this._readUint(32);
    if (this.flags & 0x400) sample.sample_flags = this._readUint(32);
    if (this.flags & 0x800) {
      if (this.version == 0) {
        sample.sample_composition_time_offset = this._readUint(32);
      } else {
        sample.sample_composition_time_offset = this._readInt(32);
      }
    }
    this.samples.push(sample);
  }
};
// ISO/IEC 14496-30:2014 - WebVTT Source Label Box
ISOBox.prototype._boxParsers['vlab'] = function() {
  var source_label_raw = new DataView(this._raw.buffer, this._cursor.offset, this._raw.byteLength - (this._cursor.offset - this._offset));
  this.source_label = ISOBoxer.Utils.dataViewToString(source_label_raw);
}
;
// ISO/IEC 14496-30:2014 - WebVTT Configuration Box
ISOBox.prototype._boxParsers['vttC'] = function() {
  var config_raw = new DataView(this._raw.buffer, this._cursor.offset, this._raw.byteLength - (this._cursor.offset - this._offset));
  this.config = ISOBoxer.Utils.dataViewToString(config_raw);
}
;
// ISO/IEC 14496-30:2014 - WebVTT Empty Sample Box
ISOBox.prototype._boxParsers['vtte'] = function() {
  // Nothing should happen here.
}


/***/ }),

/***/ "../../../node_modules/@hivestreaming/collections/dict.js":
/*!*********************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/node_modules/@hivestreaming/collections/dict.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Shim = __webpack_require__(/*! ./shim */ "../../../node_modules/@hivestreaming/collections/shim.js");
var GenericCollection = __webpack_require__(/*! ./generic-collection */ "../../../node_modules/@hivestreaming/collections/generic-collection.js");
var GenericMap = __webpack_require__(/*! ./generic-map */ "../../../node_modules/@hivestreaming/collections/generic-map.js");
var PropertyChanges = __webpack_require__(/*! ./listen/property-changes */ "../../../node_modules/@hivestreaming/collections/listen/property-changes.js");

// Burgled from https://github.com/domenic/dict

module.exports = Dict;
function Dict(values, getDefault) {
    if (!(this instanceof Dict)) {
        return new Dict(values, getDefault);
    }
    getDefault = getDefault || Function.noop;
    this.getDefault = getDefault;
    this.store = Object.create(null);
    this.length = 0;
    this.hiveAddEach(values);
}

Dict.Dict = Dict; // hack so require("dict").Dict will work in MontageJS.

Object.hiveAddEach(Dict.prototype, GenericCollection.prototype);
Object.hiveAddEach(Dict.prototype, GenericMap.prototype);
Object.hiveAddEach(Dict.prototype, PropertyChanges.prototype);

Dict.prototype.constructClone = function (values) {
    return new this.constructor(values, this.getDefault);
};

Dict.prototype.assertString = function (key) {
    if (typeof key !== "string") {
        throw new TypeError("key must be a string but Got " + key);
    }
}

Object.defineProperty(Dict.prototype,"$__proto__",{writable:true});
Object.defineProperty(Dict.prototype,"_hasProto",{
    get:function() {
        return this.hasOwnProperty("$__proto__") && typeof this._protoValue !== "undefined";
    }
});
Object.defineProperty(Dict.prototype,"_protoValue",{
    get:function() {
        return this["$__proto__"];
    },
    set: function(value) {
        this["$__proto__"] = value;
    }
});

Dict.prototype.get = function (key, defaultValue) {
    this.assertString(key);
    if (key === "__proto__") {
        if (this._hasProto) {
            return this._protoValue;
        } else if (arguments.length > 1) {
            return defaultValue;
        } else {
            return this.getDefault(key);
        }
    }
    else {
        if (key in this.store) {
            return this.store[key];
        } else if (arguments.length > 1) {
            return defaultValue;
        } else {
            return this.getDefault(key);
        }
    }
};

Dict.prototype.set = function (key, value) {
    this.assertString(key);
    var isProtoKey = (key === "__proto__");

    if (isProtoKey ? this._hasProto : key in this.store) { // update
        if (this.dispatchesMapChanges) {
            this.dispatchBeforeMapChange(key, isProtoKey ? this._protoValue : this.store[key]);
        }

        isProtoKey
            ? this._protoValue = value
            : this.store[key] = value;

        if (this.dispatchesMapChanges) {
            this.dispatchMapChange(key, value);
        }
        return false;
    } else { // create
        if (this.dispatchesMapChanges) {
            this.dispatchBeforeMapChange(key, undefined);
        }
        this.length++;

        isProtoKey
            ? this._protoValue = value
            : this.store[key] = value;

        if (this.dispatchesMapChanges) {
            this.dispatchMapChange(key, value);
        }
        return true;
    }
};

Dict.prototype.has = function (key) {
    this.assertString(key);
    return key === "__proto__" ? this._hasProto : key in this.store;
};

Dict.prototype["delete"] = function (key) {
    this.assertString(key);
    if (key === "__proto__") {
        if (this._hasProto) {
            if (this.dispatchesMapChanges) {
                this.dispatchBeforeMapChange(key, this._protoValue);
            }
            this._protoValue = undefined;
            this.length--;
            if (this.dispatchesMapChanges) {
                this.dispatchMapChange(key, undefined);
            }
            return true;
        }
        return false;
    }
    else {
        if (key in this.store) {
            if (this.dispatchesMapChanges) {
                this.dispatchBeforeMapChange(key, this.store[key]);
            }
            delete this.store[key];
            this.length--;
            if (this.dispatchesMapChanges) {
                this.dispatchMapChange(key, undefined);
            }
            return true;
        }
        return false;
    }
};

Dict.prototype.clear = function () {
    var key;
    if (this._hasProto) {
        if (this.dispatchesMapChanges) {
            this.dispatchBeforeMapChange("__proto__", this._protoValue);
        }
        this._protoValue = undefined;
        if (this.dispatchesMapChanges) {
            this.dispatchMapChange("__proto__", undefined);
        }
    }
    for (key in this.store) {
        if (this.dispatchesMapChanges) {
            this.dispatchBeforeMapChange(key, this.store[key]);
        }
        delete this.store[key];
        if (this.dispatchesMapChanges) {
            this.dispatchMapChange(key, undefined);
        }
    }
    this.length = 0;
};

Dict.prototype.reduce = function (callback, basis, thisp) {
    if(this._hasProto) {
        basis = callback.call(thisp, basis, "$__proto__", "__proto__", this);
    }
    var store = this.store;
    for (var key in this.store) {
        basis = callback.call(thisp, basis, store[key], key, this);
    }
    return basis;
};

Dict.prototype.reduceRight = function (callback, basis, thisp) {
    var self = this;
    var store = this.store;
    basis = Object.keys(this.store).reduceRight(function (basis, key) {
        return callback.call(thisp, basis, store[key], key, self);
    }, basis);

    if(this._hasProto) {
        return callback.call(thisp, basis, this._protoValue, "__proto__", self);
    }
    return basis;
};

Dict.prototype.one = function () {
    var key;
    for (key in this.store) {
        return this.store[key];
    }
    return this._protoValue;
};

Dict.prototype.toJSON = function () {
    return this.toObject();
};


/***/ }),

/***/ "../../../node_modules/@hivestreaming/collections/fast-set.js":
/*!*************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/node_modules/@hivestreaming/collections/fast-set.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Shim = __webpack_require__(/*! ./shim */ "../../../node_modules/@hivestreaming/collections/shim.js");
var Dict = __webpack_require__(/*! ./dict */ "../../../node_modules/@hivestreaming/collections/dict.js");
var List = __webpack_require__(/*! ./list */ "../../../node_modules/@hivestreaming/collections/list.js");
var GenericCollection = __webpack_require__(/*! ./generic-collection */ "../../../node_modules/@hivestreaming/collections/generic-collection.js");
var GenericSet = __webpack_require__(/*! ./generic-set */ "../../../node_modules/@hivestreaming/collections/generic-set.js");
var TreeLog = __webpack_require__(/*! ./tree-log */ "../../../node_modules/@hivestreaming/collections/tree-log.js");
var PropertyChanges = __webpack_require__(/*! ./listen/property-changes */ "../../../node_modules/@hivestreaming/collections/listen/property-changes.js");

var object_has = Object.prototype.hasOwnProperty;

module.exports = FastSet;

function FastSet(values, equals, hash, getDefault) {
    if (!(this instanceof FastSet)) {
        return new FastSet(values, equals, hash, getDefault);
    }
    equals = equals || Object.equals;
    hash = hash || Object.hash;
    getDefault = getDefault || Function.noop;
    this.contentEquals = equals;
    this.contentHash = hash;
    this.getDefault = getDefault;
    var self = this;
    this.buckets = new this.Buckets(null, function getDefaultBucket() {
        return new self.Bucket();
    });
    this.length = 0;
    this.hiveAddEach(values);
}

FastSet.FastSet = FastSet; // hack so require("fast-set").FastSet will work in MontageJS

Object.hiveAddEach(FastSet.prototype, GenericCollection.prototype);
Object.hiveAddEach(FastSet.prototype, GenericSet.prototype);
Object.hiveAddEach(FastSet.prototype, PropertyChanges.prototype);

FastSet.prototype.Buckets = Dict;
FastSet.prototype.Bucket = List;

FastSet.prototype.constructClone = function (values) {
    return new this.constructor(
        values,
        this.contentEquals,
        this.contentHash,
        this.getDefault
    );
};

FastSet.prototype.has = function (value) {
    var hash = this.contentHash(value);
    return this.buckets.get(hash).has(value);
};

FastSet.prototype.get = function (value, equals) {
    if (equals) {
        throw new Error("FastSet#get does not support second argument: equals");
    }
    var hash = this.contentHash(value);
    var buckets = this.buckets;
    if (buckets.has(hash)) {
        return buckets.get(hash).get(value);
    } else {
        return this.getDefault(value);
    }
};

FastSet.prototype["delete"] = function (value, equals) {
    if (equals) {
        throw new Error("FastSet#delete does not support second argument: equals");
    }
    var hash = this.contentHash(value);
    var buckets = this.buckets;
    if (buckets.has(hash)) {
        var bucket = buckets.get(hash);
        if (bucket["delete"](value)) {
            this.length--;
            if (bucket.length === 0) {
                buckets["delete"](hash);
            }
            return true;
        }
    }
    return false;
};

FastSet.prototype.clear = function () {
    this.buckets.clear();
    this.length = 0;
};

FastSet.prototype.hiveAdd = function (value) {
    var hash = this.contentHash(value);
    var buckets = this.buckets;
    if (!buckets.has(hash)) {
        buckets.set(hash, new this.Bucket(null, this.contentEquals));
    }
    if (!buckets.get(hash).has(value)) {
        buckets.get(hash).hiveAdd(value);
        this.length++;
        return true;
    }
    return false;
};

FastSet.prototype.reduce = function (callback, basis /*, thisp*/) {
    var thisp = arguments[2];
    var buckets = this.buckets;
    var index = 0;
    return buckets.reduce(function (basis, bucket) {
        return bucket.reduce(function (basis, value) {
            return callback.call(thisp, basis, value, index++, this);
        }, basis, this);
    }, basis, this);
};

FastSet.prototype.one = function () {
    if (this.length > 0) {
        return this.buckets.one().one();
    }
};

FastSet.prototype.iterate = function () {
    return this.buckets.values().flatten().iterate();
};

FastSet.prototype.log = function (charmap, logNode, callback, thisp) {
    charmap = charmap || TreeLog.unicodeSharp;
    logNode = logNode || this.logNode;
    if (!callback) {
        callback = console.log;
        thisp = console;
    }
    callback = callback.bind(thisp);

    var buckets = this.buckets;
    var hashes = buckets.keys();
    hashes.forEach(function (hash, index) {
        var branch;
        var leader;
        if (index === hashes.length - 1) {
            branch = charmap.fromAbove;
            leader = ' ';
        } else if (index === 0) {
            branch = charmap.branchDown;
            leader = charmap.strafe;
        } else {
            branch = charmap.fromBoth;
            leader = charmap.strafe;
        }
        var bucket = buckets.get(hash);
        callback.call(thisp, branch + charmap.through + charmap.branchDown + ' ' + hash);
        bucket.forEach(function (value, node) {
            var branch, below;
            if (node === bucket.head.prev) {
                branch = charmap.fromAbove;
                below = ' ';
            } else {
                branch = charmap.fromBoth;
                below = charmap.strafe;
            }
            var written;
            logNode(
                node,
                function (line) {
                    if (!written) {
                        callback.call(thisp, leader + ' ' + branch + charmap.through + charmap.through + line);
                        written = true;
                    } else {
                        callback.call(thisp, leader + ' ' + below + '  ' + line);
                    }
                },
                function (line) {
                    callback.call(thisp, leader + ' ' + charmap.strafe + '  ' + line);
                }
            );
        });
    });
};

FastSet.prototype.logNode = function (node, write) {
    var value = node.value;
    if (Object(value) === value) {
        JSON.stringify(value, null, 4).split("\n").forEach(function (line) {
            write(" " + line);
        });
    } else {
        write(" " + value);
    }
};



/***/ }),

/***/ "../../../node_modules/@hivestreaming/collections/generic-collection.js":
/*!***********************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/node_modules/@hivestreaming/collections/generic-collection.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = GenericCollection;
function GenericCollection() {
    throw new Error("Can't construct. GenericCollection is a mixin.");
}

GenericCollection.EmptyArray = Object.freeze([]);

GenericCollection.prototype.hiveAddEach = function (values) {
    if (values && Object(values) === values) {
        if (typeof values.forEach === "function") {
            values.forEach(this.hiveAdd, this);
        } else if (typeof values.length === "number") {
            // Array-like objects that do not implement forEach, ergo,
            // Arguments
            for (var i = 0; i < values.length; i++) {
                this.hiveAdd(values[i], i);
            }
        } else {
            Object.keys(values).forEach(function (key) {
                this.hiveAdd(values[key], key);
            }, this);
        }
    } else if (values && typeof values.length === "number") {
        // Strings
        for (var i = 0; i < values.length; i++) {
            this.hiveAdd(values[i], i);
        }
    }
    return this;
};

// This is sufficiently generic for Map (since the value may be a key)
// and ordered collections (since it forwards the equals argument)
GenericCollection.prototype.deleteEach = function (values, equals) {
    values.forEach(function (value) {
        this["delete"](value, equals);
    }, this);
    return this;
};

// all of the following functions are implemented in terms of "reduce".
// some need "constructClone".

GenericCollection.prototype.forEach = function (callback /*, thisp*/) {
    var thisp = arguments[1];
    return this.reduce(function (undefined, value, key, object, depth) {
        callback.call(thisp, value, key, object, depth);
    }, undefined);
};

GenericCollection.prototype.map = function (callback /*, thisp*/) {
    var thisp = arguments[1];
    var result = [];
    this.reduce(function (undefined, value, key, object, depth) {
        result.push(callback.call(thisp, value, key, object, depth));
    }, undefined);
    return result;
};

GenericCollection.prototype.enumerate = function (start) {
    if (start == null) {
        start = 0;
    }
    var result = [];
    this.reduce(function (undefined, value) {
        result.push([start++, value]);
    }, undefined);
    return result;
};

GenericCollection.prototype.group = function (callback, thisp, equals) {
    equals = equals || Object.equals;
    var groups = [];
    var keys = [];
    this.forEach(function (value, key, object) {
        var key = callback.call(thisp, value, key, object);
        var index = keys.indexOf(key, equals);
        var group;
        if (index === -1) {
            group = [];
            groups.push([key, group]);
            keys.push(key);
        } else {
            group = groups[index][1];
        }
        group.push(value);
    });
    return groups;
};

GenericCollection.prototype.toArray = function () {
    return this.map(Function.identity);
};

// this depends on stringable keys, which apply to Array and Iterator
// because they have numeric keys and all Maps since they may use
// strings as keys.  List, Set, and SortedSet have nodes for keys, so
// toObject would not be meaningful.
GenericCollection.prototype.toObject = function () {
    var object = {};
    this.reduce(function (undefined, value, key) {
        object[key] = value;
    }, undefined);
    return object;
};

GenericCollection.prototype.filter = function (callback /*, thisp*/) {
    var thisp = arguments[1];
    var result = this.constructClone();
    this.reduce(function (undefined, value, key, object, depth) {
        if (callback.call(thisp, value, key, object, depth)) {
            result.hiveAdd(value, key);
        }
    }, undefined);
    return result;
};

GenericCollection.prototype.every = function (callback /*, thisp*/) {
    var thisp = arguments[1];
    return this.reduce(function (result, value, key, object, depth) {
        return result && callback.call(thisp, value, key, object, depth);
    }, true);
};

GenericCollection.prototype.some = function (callback /*, thisp*/) {
    var thisp = arguments[1];
    return this.reduce(function (result, value, key, object, depth) {
        return result || callback.call(thisp, value, key, object, depth);
    }, false);
};

GenericCollection.prototype.all = function () {
    return this.every(Boolean);
};

GenericCollection.prototype.any = function () {
    return this.some(Boolean);
};

GenericCollection.prototype.min = function (compare) {
    compare = compare || this.contentCompare || Object.compare;
    var first = true;
    return this.reduce(function (result, value) {
        if (first) {
            first = false;
            return value;
        } else {
            return compare(value, result) < 0 ? value : result;
        }
    }, undefined);
};

GenericCollection.prototype.max = function (compare) {
    compare = compare || this.contentCompare || Object.compare;
    var first = true;
    return this.reduce(function (result, value) {
        if (first) {
            first = false;
            return value;
        } else {
            return compare(value, result) > 0 ? value : result;
        }
    }, undefined);
};

GenericCollection.prototype.sum = function (zero) {
    zero = zero === undefined ? 0 : zero;
    return this.reduce(function (a, b) {
        return a + b;
    }, zero);
};

GenericCollection.prototype.average = function (zero) {
    var sum = zero === undefined ? 0 : zero;
    var count = zero === undefined ? 0 : zero;
    this.reduce(function (undefined, value) {
        sum += value;
        count += 1;
    }, undefined);
    return sum / count;
};

GenericCollection.prototype.concat = function () {
    var result = this.constructClone(this);
    for (var i = 0; i < arguments.length; i++) {
        result.hiveAddEach(arguments[i]);
    }
    return result;
};

GenericCollection.prototype.flatten = function () {
    var self = this;
    return this.reduce(function (result, array) {
        array.forEach(function (value) {
            this.push(value);
        }, result, self);
        return result;
    }, []);
};

GenericCollection.prototype.zip = function () {
    var table = Array.prototype.slice.call(arguments);
    table.unshift(this);
    return Array.unzip(table);
}

GenericCollection.prototype.join = function (delimiter) {
    return this.reduce(function (result, string) {
        // work-around for reduce that does not support no-basis form
        if (result === void 0) {
            return string;
        } else {
            return result + delimiter + string;
        }
    }, void 0);
};

GenericCollection.prototype.sorted = function (compare, by, order) {
    compare = compare || this.contentCompare || Object.compare;
    // account for comparators generated by Function.by
    if (compare.by) {
        by = compare.by;
        compare = compare.compare || this.contentCompare || Object.compare;
    } else {
        by = by || Function.identity;
    }
    if (order === undefined)
        order = 1;
    return this.map(function (item) {
        return {
            by: by(item),
            value: item
        };
    })
    .sort(function (a, b) {
        return compare(a.by, b.by) * order;
    })
    .map(function (pair) {
        return pair.value;
    });
};

GenericCollection.prototype.reversed = function () {
    return this.constructClone(this).reverse();
};

GenericCollection.prototype.clone = function (depth, memo) {
    if (depth === undefined) {
        depth = Infinity;
    } else if (depth === 0) {
        return this;
    }
    var clone = this.constructClone();
    this.forEach(function (value, key) {
        clone.hiveAdd(Object.clone(value, depth - 1, memo), key);
    }, this);
    return clone;
};

GenericCollection.prototype.only = function () {
    if (this.length === 1) {
        return this.one();
    }
};

GenericCollection.prototype.iterator = function () {
    return this.iterate.apply(this, arguments);
};

GenericCollection._sizePropertyDescriptor = {
    get: function() {
        return this.length;
    },
    enumerable: false,
    configurable: true
};

Object.defineProperty(GenericCollection.prototype,"size",GenericCollection._sizePropertyDescriptor);

__webpack_require__(/*! ./shim-array */ "../../../node_modules/@hivestreaming/collections/shim-array.js");


/***/ }),

/***/ "../../../node_modules/@hivestreaming/collections/generic-map.js":
/*!****************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/node_modules/@hivestreaming/collections/generic-map.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Object = __webpack_require__(/*! ./shim-object */ "../../../node_modules/@hivestreaming/collections/shim-object.js");
var MapChanges = __webpack_require__(/*! ./listen/map-changes */ "../../../node_modules/@hivestreaming/collections/listen/map-changes.js");
var PropertyChanges = __webpack_require__(/*! ./listen/property-changes */ "../../../node_modules/@hivestreaming/collections/listen/property-changes.js");

module.exports = GenericMap;
function GenericMap() {
    throw new Error("Can't construct. GenericMap is a mixin.");
}

Object.hiveAddEach(GenericMap.prototype, MapChanges.prototype);
Object.hiveAddEach(GenericMap.prototype, PropertyChanges.prototype);

// all of these methods depend on the constructor providing a `store` set

GenericMap.prototype.isMap = true;

GenericMap.prototype.hiveAddEach = function (values) {
    if (values && Object(values) === values) {
        if (typeof values.forEach === "function") {
            // copy map-alikes
            if (values.isMap === true) {
                values.forEach(function (value, key) {
                    this.set(key, value);
                }, this);
            // iterate key value pairs of other iterables
            } else {
                values.forEach(function (pair) {
                    this.set(pair[0], pair[1]);
                }, this);
            }
        } else if (typeof values.length === "number") {
            // Array-like objects that do not implement forEach, ergo,
            // Arguments
            for (var i = 0; i < values.length; i++) {
                this.hiveAdd(values[i], i);
            }
        } else {
            // copy other objects as map-alikes
            Object.keys(values).forEach(function (key) {
                this.set(key, values[key]);
            }, this);
        }
    } else if (values && typeof values.length === "number") {
        // String
        for (var i = 0; i < values.length; i++) {
            this.hiveAdd(values[i], i);
        }
    }
    return this;
}

GenericMap.prototype.get = function (key, defaultValue) {
    var item = this.store.get(new this.Item(key));
    if (item) {
        return item.value;
    } else if (arguments.length > 1) {
        return defaultValue;
    } else {
        return this.getDefault(key);
    }
};

GenericMap.prototype.set = function (key, value) {
    var item = new this.Item(key, value);
    var found = this.store.get(item);
    var grew = false;
    if (found) { // update
        if (this.dispatchesMapChanges) {
            this.dispatchBeforeMapChange(key, found.value);
        }
        found.value = value;
        if (this.dispatchesMapChanges) {
            this.dispatchMapChange(key, value);
        }
    } else { // create
        if (this.dispatchesMapChanges) {
            this.dispatchBeforeMapChange(key, undefined);
        }
        if (this.store.hiveAdd(item)) {
            this.length++;
            grew = true;
        }
        if (this.dispatchesMapChanges) {
            this.dispatchMapChange(key, value);
        }
    }
    return grew;
};

GenericMap.prototype.hiveAdd = function (value, key) {
    return this.set(key, value);
};

GenericMap.prototype.has = function (key) {
    return this.store.has(new this.Item(key));
};

GenericMap.prototype['delete'] = function (key) {
    var item = new this.Item(key);
    if (this.store.has(item)) {
        var from = this.store.get(item).value;
        if (this.dispatchesMapChanges) {
            this.dispatchBeforeMapChange(key, from);
        }
        this.store["delete"](item);
        this.length--;
        if (this.dispatchesMapChanges) {
            this.dispatchMapChange(key, undefined);
        }
        return true;
    }
    return false;
};

GenericMap.prototype.clear = function () {
    var keys;
    if (this.dispatchesMapChanges) {
        this.forEach(function (value, key) {
            this.dispatchBeforeMapChange(key, value);
        }, this);
        keys = this.keys();
    }
    this.store.clear();
    this.length = 0;
    if (this.dispatchesMapChanges) {
        keys.forEach(function (key) {
            this.dispatchMapChange(key);
        }, this);
    }
};

GenericMap.prototype.reduce = function (callback, basis, thisp) {
    return this.store.reduce(function (basis, item) {
        return callback.call(thisp, basis, item.value, item.key, this);
    }, basis, this);
};

GenericMap.prototype.reduceRight = function (callback, basis, thisp) {
    return this.store.reduceRight(function (basis, item) {
        return callback.call(thisp, basis, item.value, item.key, this);
    }, basis, this);
};

GenericMap.prototype.keys = function () {
    return this.map(function (value, key) {
        return key;
    });
};

GenericMap.prototype.values = function () {
    return this.map(Function.identity);
};

GenericMap.prototype.entries = function () {
    return this.map(function (value, key) {
        return [key, value];
    });
};

// XXX deprecated
GenericMap.prototype.items = function () {
    return this.entries();
};

GenericMap.prototype.equals = function (that, equals) {
    equals = equals || Object.equals;
    if (this === that) {
        return true;
    } else if (that && typeof that.every === "function") {
        return that.length === this.length && that.every(function (value, key) {
            return equals(this.get(key), value);
        }, this);
    } else {
        var keys = Object.keys(that);
        return keys.length === this.length && Object.keys(that).every(function (key) {
            return equals(this.get(key), that[key]);
        }, this);
    }
};

GenericMap.prototype.toJSON = function () {
    return this.entries();
};

GenericMap.prototype.Item = Item;

function Item(key, value) {
    this.key = key;
    this.value = value;
}

Item.prototype.equals = function (that) {
    return Object.equals(this.key, that.key) && Object.equals(this.value, that.value);
};

Item.prototype.compare = function (that) {
    return Object.compare(this.key, that.key);
};



/***/ }),

/***/ "../../../node_modules/@hivestreaming/collections/generic-order.js":
/*!******************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/node_modules/@hivestreaming/collections/generic-order.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


var Object = __webpack_require__(/*! ./shim-object */ "../../../node_modules/@hivestreaming/collections/shim-object.js");

module.exports = GenericOrder;
function GenericOrder() {
    throw new Error("Can't construct. GenericOrder is a mixin.");
}

GenericOrder.prototype.equals = function (that, equals) {
    equals = equals || this.contentEquals || Object.equals;

    if (this === that) {
        return true;
    }
    if (!that) {
        return false;
    }

    var self = this;
    return (
        this.length === that.length &&
        this.zip(that).every(function (pair) {
            return equals(pair[0], pair[1]);
        })
    );
};

GenericOrder.prototype.compare = function (that, compare) {
    compare = compare || this.contentCompare || Object.compare;

    if (this === that) {
        return 0;
    }
    if (!that) {
        return 1;
    }

    var length = Math.min(this.length, that.length);
    var comparison = this.zip(that).reduce(function (comparison, pair, index) {
        if (comparison === 0) {
            if (index >= length) {
                return comparison;
            } else {
                return compare(pair[0], pair[1]);
            }
        } else {
            return comparison;
        }
    }, 0);
    if (comparison === 0) {
        return this.length - that.length;
    }
    return comparison;
};

GenericOrder.prototype.toJSON = function () {
    return this.toArray();
};


/***/ }),

/***/ "../../../node_modules/@hivestreaming/collections/generic-set.js":
/*!****************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/node_modules/@hivestreaming/collections/generic-set.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {


module.exports = GenericSet;
function GenericSet() {
    throw new Error("Can't construct. GenericSet is a mixin.");
}

GenericSet.prototype.isSet = true;

GenericSet.prototype.union = function (that) {
    var union =  this.constructClone(this);
    union.hiveAddEach(that);
    return union;
};

GenericSet.prototype.intersection = function (that) {
    return this.constructClone(this.filter(function (value) {
        return that.has(value);
    }));
};

GenericSet.prototype.difference = function (that) {
    var union =  this.constructClone(this);
    union.deleteEach(that);
    return union;
};

GenericSet.prototype.symmetricDifference = function (that) {
    var union = this.union(that);
    var intersection = this.intersection(that);
    return union.difference(intersection);
};

GenericSet.prototype.deleteAll = function (value) {
    // deleteAll is equivalent to delete for sets since they guarantee that
    // only one value exists for an equivalence class, but deleteAll returns
    // the count of deleted values instead of whether a value was deleted.
    return +this["delete"](value);
};

GenericSet.prototype.equals = function (that, equals) {
    var self = this;
    return (
        that && typeof that.reduce === "function" &&
        this.length === that.length &&
        that.reduce(function (equal, value) {
            return equal && self.has(value, equals);
        }, true)
    );
};

GenericSet.prototype.toJSON = function () {
    return this.toArray();
};

// W3C DOMTokenList API overlap (does not handle variadic arguments)

GenericSet.prototype.contains = function (value) {
    return this.has(value);
};

GenericSet.prototype.remove = function (value) {
    return this["delete"](value);
};

GenericSet.prototype.toggle = function (value) {
    if (this.has(value)) {
        this["delete"](value);
    } else {
        this.hiveAdd(value);
    }
};



/***/ }),

/***/ "../../../node_modules/@hivestreaming/collections/iterator.js":
/*!*************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/node_modules/@hivestreaming/collections/iterator.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = Iterator;

var Object = __webpack_require__(/*! ./shim-object */ "../../../node_modules/@hivestreaming/collections/shim-object.js");
var GenericCollection = __webpack_require__(/*! ./generic-collection */ "../../../node_modules/@hivestreaming/collections/generic-collection.js");

// upgrades an iterable to a Iterator
function Iterator(iterable) {

    if (!(this instanceof Iterator)) {
        return new Iterator(iterable);
    }

    if (Array.isArray(iterable) || typeof iterable === "string")
        return Iterator.iterate(iterable);

    iterable = Object(iterable);

    if (iterable instanceof Iterator) {
        return iterable;
    } else if (iterable.next) {
        this.next = function () {
            return iterable.next();
        };
    } else if (iterable.iterate) {
        var iterator = iterable.iterate();
        this.next = function () {
            return iterator.next();
        };
    } else if (Object.prototype.toString.call(iterable) === "[object Function]") {
        this.next = iterable;
    } else {
        throw new TypeError("Can't iterate " + iterable);
    }

}

Iterator.prototype.forEach = GenericCollection.prototype.forEach;
Iterator.prototype.map = GenericCollection.prototype.map;
Iterator.prototype.filter = GenericCollection.prototype.filter;
Iterator.prototype.every = GenericCollection.prototype.every;
Iterator.prototype.some = GenericCollection.prototype.some;
Iterator.prototype.any = GenericCollection.prototype.any;
Iterator.prototype.all = GenericCollection.prototype.all;
Iterator.prototype.min = GenericCollection.prototype.min;
Iterator.prototype.max = GenericCollection.prototype.max;
Iterator.prototype.sum = GenericCollection.prototype.sum;
Iterator.prototype.average = GenericCollection.prototype.average;
Iterator.prototype.flatten = GenericCollection.prototype.flatten;
Iterator.prototype.zip = GenericCollection.prototype.zip;
Iterator.prototype.enumerate = GenericCollection.prototype.enumerate;
Iterator.prototype.sorted = GenericCollection.prototype.sorted;
Iterator.prototype.group = GenericCollection.prototype.group;
Iterator.prototype.reversed = GenericCollection.prototype.reversed;
Iterator.prototype.toArray = GenericCollection.prototype.toArray;
Iterator.prototype.toObject = GenericCollection.prototype.toObject;
Iterator.prototype.iterator = GenericCollection.prototype.iterator;

Iterator.prototype.__iterationObject = null;
Object.defineProperty(Iterator.prototype,"_iterationObject", {
    get: function() {
        return this.__iterationObject || (this.__iterationObject = { done: false, value:void 0});
    }
});


// this is a bit of a cheat so flatten and such work with the generic
// reducible
Iterator.prototype.constructClone = function (values) {
    var clone = [];
    clone.hiveAddEach(values);
    return clone;
};

Iterator.prototype.mapIterator = function (callback /*, thisp*/) {
    var self = Iterator(this),
        thisp = arguments[1],
        i = 0;

    if (Object.prototype.toString.call(callback) != "[object Function]")
        throw new TypeError();

    return new self.constructor(function () {
        if(self._iterationObject.done !== true) {
            var callbackValue = callback.call(thisp, self.next().value, i++, self);
            self._iterationObject.value = callbackValue;
        }
        return self._iterationObject;
    });
};

Iterator.prototype.filterIterator = function (callback /*, thisp*/) {
    var self = Iterator(this),
        thisp = arguments[1],
        i = 0;

    if (Object.prototype.toString.call(callback) != "[object Function]")
        throw new TypeError();

    return new self.constructor(function () {
        var nextEntry;
        while (true) {
            nextEntry = self.next();
            if(nextEntry.done !== true) {
                if (callback.call(thisp, nextEntry.value, i++, self))
                    return nextEntry;
            }
            else {
                //done true and value undefined at this point
                return nextEntry;
            }
        }
    });
};

Iterator.prototype.reduce = function (callback /*, initial, thisp*/) {
    var self = Iterator(this),
        result = arguments[1],
        thisp = arguments[2],
        i = 0,
        nextEntry;

    if (Object.prototype.toString.call(callback) != "[object Function]")
        throw new TypeError();

    // first iteration unrolled
    nextEntry = self.next();
    if(nextEntry.done === true) {
        if (arguments.length > 1) {
            return arguments[1]; // initial
        } else {
            throw TypeError("cannot reduce a value from an empty iterator with no initial value");
        }
    }
    if (arguments.length > 1) {
        result = callback.call(thisp, result, nextEntry.value, i, self);
    } else {
        result = nextEntry.value;
    }
    i++;
    // remaining entries
    while (true) {
        nextEntry = self.next();
        if(nextEntry.done === true) {
            return result;
        }
        result = callback.call(thisp, result, nextEntry.value, i, self);
        i++;
    }

};

Iterator.prototype.concat = function () {
    return Iterator.concat(
        Array.prototype.concat.apply(this, arguments)
    );
};

Iterator.prototype.dropWhile = function (callback /*, thisp */) {
    var self = Iterator(this),
        thisp = arguments[1],
        stopped = false,
        stopValue,
        nextEntry,
        i = 0;

    if (Object.prototype.toString.call(callback) != "[object Function]")
        throw new TypeError();

    while (true) {
        nextEntry = self.next();
        if(nextEntry.done === true) {
            break;
        }
        if (!callback.call(thisp, nextEntry.value, i, self)) {
            stopped = true;
            stopValue = nextEntry.value;
            break;
        }
        i++;
    }

    if (stopped) {
        return self.constructor([stopValue]).concat(self);
    } else {
        return self.constructor([]);
    }
};

Iterator.prototype.takeWhile = function (callback /*, thisp*/) {
    var self = Iterator(this),
        thisp = arguments[1],
        nextEntry,
        i = 0;

    if (Object.prototype.toString.call(callback) != "[object Function]")
        throw new TypeError();

    return new self.constructor(function () {
        if(self._iterationObject.done !== true) {
            var value = self.next().value;
            if(callback.call(thisp, value, i++, self)) {
                self._iterationObject.value = value;
            }
            else {
                self._iterationObject.done = true;
                self._iterationObject.value = void 0;
            }
        }
        return self._iterationObject;
    });

};

Iterator.prototype.zipIterator = function () {
    return Iterator.unzip(
        Array.prototype.concat.apply(this, arguments)
    );
};

Iterator.prototype.enumerateIterator = function (start) {
    return Iterator.count(start).zipIterator(this);
};

// creates an iterator for Array and String
Iterator.iterate = function (iterable) {
    var start;
    start = 0;
    return new Iterator(function () {
        // advance to next owned entry
        if (typeof iterable === "object") {
            while (!(start in iterable)) {
                // deliberately late bound
                if (start >= iterable.length) {
                    this._iterationObject.done = true;
                    this._iterationObject.value = void 0;
                    break;
                }
                else start += 1;
            }
        } else if (start >= iterable.length) {
            this._iterationObject.done = true;
            this._iterationObject.value = void 0;
        }

        if(!this._iterationObject.done) {
            this._iterationObject.value = iterable[start];
            start += 1;
        }
        return this._iterationObject;
    });
};

Iterator.cycle = function (cycle, times) {
    var next;
    if (arguments.length < 2)
        times = Infinity;
    //cycle = Iterator(cycle).toArray();
    return new Iterator(function () {
        var iteration, nextEntry;

        if(next) {
            nextEntry = next();
        }

        if(!next || nextEntry.done === true) {
            if (times > 0) {
                times--;
                iteration = Iterator.iterate(cycle);
                nextEntry = (next = iteration.next.bind(iteration))();
            }
            else {
                this._iterationObject.done = true;
                nextEntry = this._iterationObject;            }
        }
        return nextEntry;
    });
};

Iterator.concat = function (iterators) {
    iterators = Iterator(iterators);
    var next;
    return new Iterator(function (){
        var iteration, nextEntry;
        if(next) nextEntry = next();
        if(!nextEntry || nextEntry.done === true) {
            nextEntry = iterators.next();
            if(nextEntry.done === false) {
                iteration = Iterator(nextEntry.value);
                next = iteration.next.bind(iteration);
                return next();
            }
            else {
                return nextEntry;
            }
        }
        else return nextEntry;
    });
};

Iterator.unzip = function (iterators) {
    iterators = Iterator(iterators).map(Iterator);
    if (iterators.length === 0)
        return new Iterator([]);
    return new Iterator(function () {
        var stopped, nextEntry;
        var result = iterators.map(function (iterator) {
            nextEntry = iterator.next();
            if (nextEntry.done === true ) {
                stopped = true;
            }
            return nextEntry.value;
        });
        if (stopped) {
            this._iterationObject.done = true;
            this._iterationObject.value = void 0;
        }
        else {
            this._iterationObject.value = result;
        }
        return this._iterationObject;
    });
};

Iterator.zip = function () {
    return Iterator.unzip(
        Array.prototype.slice.call(arguments)
    );
};

Iterator.chain = function () {
    return Iterator.concat(
        Array.prototype.slice.call(arguments)
    );
};

Iterator.range = function (start, stop, step) {
    if (arguments.length < 3) {
        step = 1;
    }
    if (arguments.length < 2) {
        stop = start;
        start = 0;
    }
    start = start || 0;
    step = step || 1;
    return new Iterator(function () {
        if (start >= stop) {
            this._iterationObject.done = true;
            this._iterationObject.value = void 0;
        }
        var result = start;
        start += step;
        this._iterationObject.value = result;

        return this._iterationObject;
    });
};

Iterator.count = function (start, step) {
    return Iterator.range(start, Infinity, step);
};

Iterator.repeat = function (value, times) {
    return new Iterator.range(times).mapIterator(function () {
        return value;
    });
};


/***/ }),

/***/ "../../../node_modules/@hivestreaming/collections/list.js":
/*!*********************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/node_modules/@hivestreaming/collections/list.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = List;

var Shim = __webpack_require__(/*! ./shim */ "../../../node_modules/@hivestreaming/collections/shim.js");
var GenericCollection = __webpack_require__(/*! ./generic-collection */ "../../../node_modules/@hivestreaming/collections/generic-collection.js");
var GenericOrder = __webpack_require__(/*! ./generic-order */ "../../../node_modules/@hivestreaming/collections/generic-order.js");
var PropertyChanges = __webpack_require__(/*! ./listen/property-changes */ "../../../node_modules/@hivestreaming/collections/listen/property-changes.js");
var RangeChanges = __webpack_require__(/*! ./listen/range-changes */ "../../../node_modules/@hivestreaming/collections/listen/range-changes.js");

function List(values, equals, getDefault) {
    if (!(this instanceof List)) {
        return new List(values, equals, getDefault);
    }
    var head = this.head = new this.Node();
    head.next = head;
    head.prev = head;
    this.contentEquals = equals || Object.equals;
    this.getDefault = getDefault || Function.noop;
    this.length = 0;
    this.hiveAddEach(values);
}

List.List = List; // hack so require("list").List will work in MontageJS

Object.hiveAddEach(List.prototype, GenericCollection.prototype);
Object.hiveAddEach(List.prototype, GenericOrder.prototype);
Object.hiveAddEach(List.prototype, PropertyChanges.prototype);
Object.hiveAddEach(List.prototype, RangeChanges.prototype);

List.prototype.constructClone = function (values) {
    return new this.constructor(values, this.contentEquals, this.getDefault);
};

List.prototype.find = function (value, equals, index) {
    equals = equals || this.contentEquals;
    var head = this.head;
    var at = this.scan(index, head.next);
    while (at !== head) {
        if (equals(at.value, value)) {
            return at;
        }
        at = at.next;
    }
};

List.prototype.findLast = function (value, equals, index) {
    equals = equals || this.contentEquals;
    var head = this.head;
    var at = this.scan(index, head.prev);
    while (at !== head) {
        if (equals(at.value, value)) {
            return at;
        }
        at = at.prev;
    }
};

List.prototype.has = function (value, equals) {
    return !!this.find(value, equals);
};

List.prototype.get = function (value, equals) {
    var found = this.find(value, equals);
    if (found) {
        return found.value;
    }
    return this.getDefault(value);
};

// LIFO (delete removes the most recently hiveAdded equivalent value)
List.prototype["delete"] = function (value, equals) {
    var found = this.findLast(value, equals);
    if (found) {
        if (this.dispatchesRangeChanges) {
            var plus = [];
            var minus = [value];
            this.dispatchBeforeRangeChange(plus, minus, found.index);
        }
        found["delete"]();
        this.length--;
        if (this.dispatchesRangeChanges) {
            this.updateIndexes(found.next, found.index);
            this.dispatchRangeChange(plus, minus, found.index);
        }
        return true;
    }
    return false;
};

List.prototype.deleteAll = function (value, equals) {
    equals = equals || this.contentEquals;
    var head = this.head;
    var at = head.next;
    var count = 0;
    while (at !== head) {
        if (equals(value, at.value)) {
            at["delete"]();
            count++;
        }
        at = at.next;
    }
    this.length -= count;
    return count;
};

List.prototype.clear = function () {
    var plus, minus;
    if (this.dispatchesRangeChanges) {
        minus = this.toArray();
        plus = [];
        this.dispatchBeforeRangeChange(plus, minus, 0);
    }
    this.head.next = this.head.prev = this.head;
    this.length = 0;
    if (this.dispatchesRangeChanges) {
        this.dispatchRangeChange(plus, minus, 0);
    }
};

List.prototype.hiveAdd = function (value) {
    var node = new this.Node(value)
    if (this.dispatchesRangeChanges) {
        node.index = this.length;
        this.dispatchBeforeRangeChange([value], [], node.index);
    }
    this.head.hiveAddBefore(node);
    this.length++;
    if (this.dispatchesRangeChanges) {
        this.dispatchRangeChange([value], [], node.index);
    }
    return true;
};

List.prototype.push = function () {
    var head = this.head;
    if (this.dispatchesRangeChanges) {
        var plus = Array.prototype.slice.call(arguments);
        var minus = []
        var index = this.length;
        this.dispatchBeforeRangeChange(plus, minus, index);
        var start = this.head.prev;
    }
    for (var i = 0; i < arguments.length; i++) {
        var value = arguments[i];
        var node = new this.Node(value);
        head.hiveAddBefore(node);
    }
    this.length += arguments.length;
    if (this.dispatchesRangeChanges) {
        this.updateIndexes(start.next, start.index === undefined ? 0 : start.index + 1);
        this.dispatchRangeChange(plus, minus, index);
    }
};

List.prototype.unshift = function () {
    if (this.dispatchesRangeChanges) {
        var plus = Array.prototype.slice.call(arguments);
        var minus = [];
        this.dispatchBeforeRangeChange(plus, minus, 0);
    }
    var at = this.head;
    for (var i = 0; i < arguments.length; i++) {
        var value = arguments[i];
        var node = new this.Node(value);
        at.hiveAddAfter(node);
        at = node;
    }
    this.length += arguments.length;
    if (this.dispatchesRangeChanges) {
        this.updateIndexes(this.head.next, 0);
        this.dispatchRangeChange(plus, minus, 0);
    }
};

List.prototype.pop = function () {
    var value;
    var head = this.head;
    if (head.prev !== head) {
        value = head.prev.value;
        if (this.dispatchesRangeChanges) {
            var plus = [];
            var minus = [value];
            var index = this.length - 1;
            this.dispatchBeforeRangeChange(plus, minus, index);
        }
        head.prev['delete']();
        this.length--;
        if (this.dispatchesRangeChanges) {
            this.dispatchRangeChange(plus, minus, index);
        }
    }
    return value;
};

List.prototype.shift = function () {
    var value;
    var head = this.head;
    if (head.prev !== head) {
        value = head.next.value;
        if (this.dispatchesRangeChanges) {
            var plus = [];
            var minus = [value];
            this.dispatchBeforeRangeChange(plus, minus, 0);
        }
        head.next['delete']();
        this.length--;
        if (this.dispatchesRangeChanges) {
            this.updateIndexes(this.head.next, 0);
            this.dispatchRangeChange(plus, minus, 0);
        }
    }
    return value;
};

List.prototype.peek = function () {
    if (this.head !== this.head.next) {
        return this.head.next.value;
    }
};

List.prototype.poke = function (value) {
    if (this.head !== this.head.next) {
        this.head.next.value = value;
    } else {
        this.push(value);
    }
};

List.prototype.one = function () {
    return this.peek();
};

// TODO
// List.prototype.indexOf = function (value) {
// };

// TODO
// List.prototype.lastIndexOf = function (value) {
// };

// an internal utility for coercing index offsets to nodes
List.prototype.scan = function (at, fallback) {
    var head = this.head;
    if (typeof at === "number") {
        var count = at;
        if (count >= 0) {
            at = head.next;
            while (count) {
                count--;
                at = at.next;
                if (at == head) {
                    break;
                }
            }
        } else {
            at = head;
            while (count < 0) {
                count++;
                at = at.prev;
                if (at == head) {
                    break;
                }
            }
        }
        return at;
    } else {
        return at || fallback;
    }
};

// at and end may both be positive or negative numbers (in which cases they
// correspond to numeric indicies, or nodes)
List.prototype.slice = function (at, end) {
    var sliced = [];
    var head = this.head;
    at = this.scan(at, head.next);
    end = this.scan(end, head);

    while (at !== end && at !== head) {
        sliced.push(at.value);
        at = at.next;
    }

    return sliced;
};

List.prototype.splice = function (at, length /*...plus*/) {
    return this.swap(at, length, Array.prototype.slice.call(arguments, 2));
};

List.prototype.swap = function (start, length, plus) {
    var initial = start;
    // start will be head if start is null or -1 (meaning from the end), but
    // will be head.next if start is 0 (meaning from the beginning)
    start = this.scan(start, this.head);
    if (length == null) {
        length = Infinity;
    }
    plus = Array.from(plus);

    // collect the minus array
    var minus = [];
    var at = start;
    while (length-- && length >= 0 && at !== this.head) {
        minus.push(at.value);
        at = at.next;
    }

    // before range change
    var index, startNode;
    if (this.dispatchesRangeChanges) {
        if (start === this.head) {
            index = this.length;
        } else if (start.prev === this.head) {
            index = 0;
        } else {
            index = start.index;
        }
        startNode = start.prev;
        this.dispatchBeforeRangeChange(plus, minus, index);
    }

    // delete minus
    var at = start;
    for (var i = 0, at = start; i < minus.length; i++, at = at.next) {
        at["delete"]();
    }
    // hiveAdd plus
    if (initial == null && at === this.head) {
        at = this.head.next;
    }
    for (var i = 0; i < plus.length; i++) {
        var node = new this.Node(plus[i]);
        at.hiveAddBefore(node);
    }
    // adjust length
    this.length += plus.length - minus.length;

    // after range change
    if (this.dispatchesRangeChanges) {
        if (start === this.head) {
            this.updateIndexes(this.head.next, 0);
        } else {
            this.updateIndexes(startNode.next, startNode.index + 1);
        }
        this.dispatchRangeChange(plus, minus, index);
    }

    return minus;
};

List.prototype.reverse = function () {
    if (this.dispatchesRangeChanges) {
        var minus = this.toArray();
        var plus = minus.reversed();
        this.dispatchBeforeRangeChange(plus, minus, 0);
    }
    var at = this.head;
    do {
        var temp = at.next;
        at.next = at.prev;
        at.prev = temp;
        at = at.next;
    } while (at !== this.head);
    if (this.dispatchesRangeChanges) {
        this.dispatchRangeChange(plus, minus, 0);
    }
    return this;
};

List.prototype.sort = function () {
    this.swap(0, this.length, this.sorted());
};

// TODO account for missing basis argument
List.prototype.reduce = function (callback, basis /*, thisp*/) {
    var thisp = arguments[2];
    var head = this.head;
    var at = head.next;
    while (at !== head) {
        basis = callback.call(thisp, basis, at.value, at, this);
        at = at.next;
    }
    return basis;
};

List.prototype.reduceRight = function (callback, basis /*, thisp*/) {
    var thisp = arguments[2];
    var head = this.head;
    var at = head.prev;
    while (at !== head) {
        basis = callback.call(thisp, basis, at.value, at, this);
        at = at.prev;
    }
    return basis;
};

List.prototype.updateIndexes = function (node, index) {
    while (node !== this.head) {
        node.index = index++;
        node = node.next;
    }
};

List.prototype.makeObservable = function () {
    this.head.index = -1;
    this.updateIndexes(this.head.next, 0);
    this.dispatchesRangeChanges = true;
};

List.prototype.iterate = function () {
    return new ListIterator(this.head);
};

function ListIterator(head) {
    this.head = head;
    this.at = head.next;
};

ListIterator.prototype.__iterationObject = null;
Object.defineProperty(ListIterator.prototype,"_iterationObject", {
    get: function() {
        return this.__iterationObject || (this.__iterationObject = { done: false, value:null});
    }
});


ListIterator.prototype.next = function () {
    if (this.at === this.head) {
        this._iterationObject.done = true;
        this._iterationObject.value = void 0;
    } else {
        var value = this.at.value;
        this.at = this.at.next;
        this._iterationObject.value = value;
    }
    return this._iterationObject;
};

List.prototype.Node = Node;

function Node(value) {
    this.value = value;
    this.prev = null;
    this.next = null;
};

Node.prototype["delete"] = function () {
    this.prev.next = this.next;
    this.next.prev = this.prev;
};

Node.prototype.hiveAddBefore = function (node) {
    var prev = this.prev;
    this.prev = node;
    node.prev = prev;
    prev.next = node;
    node.next = this;
};

Node.prototype.hiveAddAfter = function (node) {
    var next = this.next;
    this.next = node;
    node.next = next;
    next.prev = node;
    node.prev = this;
};


/***/ }),

/***/ "../../../node_modules/@hivestreaming/collections/listen/map-changes.js":
/*!***********************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/node_modules/@hivestreaming/collections/listen/map-changes.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var WeakMap = __webpack_require__(/*! weak-map */ "../../../node_modules/weak-map/weak-map.js");
var List = __webpack_require__(/*! ../list */ "../../../node_modules/@hivestreaming/collections/list.js");

module.exports = MapChanges;
function MapChanges() {
    throw new Error("Can't construct. MapChanges is a mixin.");
}

var object_owns = Object.prototype.hasOwnProperty;

/*
    Object map change descriptors carry information necessary for hiveAdding,
    removing, dispatching, and shorting events to listeners for map changes
    for a particular key on a particular object.  These descriptors are used
    here for shallow map changes.

    {
        willChangeListeners:Array(Function)
        changeListeners:Array(Function)
    }
*/

var mapChangeDescriptors = new WeakMap();
var Dict = null;

MapChanges.prototype.getAllMapChangeDescriptors = function () {
    if (!mapChangeDescriptors.has(this)) {
        if (!Dict) {
            Dict = __webpack_require__(/*! ../dict */ "../../../node_modules/@hivestreaming/collections/dict.js");
        }
        mapChangeDescriptors.set(this, Dict());
    }
    return mapChangeDescriptors.get(this);
};

MapChanges.prototype.getMapChangeDescriptor = function (token) {
    var tokenChangeDescriptors = this.getAllMapChangeDescriptors();
    token = token || "";
    if (!tokenChangeDescriptors.has(token)) {
        tokenChangeDescriptors.set(token, {
            willChangeListeners: new List(),
            changeListeners: new List()
        });
    }
    return tokenChangeDescriptors.get(token);
};

MapChanges.prototype.hiveAddMapChangeListener = function (listener, token, beforeChange) {
    if (!this.isObservable && this.makeObservable) {
        // for Array
        this.makeObservable();
    }
    var descriptor = this.getMapChangeDescriptor(token);
    var listeners;
    if (beforeChange) {
        listeners = descriptor.willChangeListeners;
    } else {
        listeners = descriptor.changeListeners;
    }
    listeners.push(listener);
    Object.defineProperty(this, "dispatchesMapChanges", {
        value: true,
        writable: true,
        configurable: true,
        enumerable: false
    });

    var self = this;
    return function cancelMapChangeListener() {
        if (!self) {
            // TODO throw new Error("Can't remove map change listener again");
            return;
        }
        self.removeMapChangeListener(listener, token, beforeChange);
        self = null;
    };
};

MapChanges.prototype.removeMapChangeListener = function (listener, token, beforeChange) {
    var descriptor = this.getMapChangeDescriptor(token);

    var listeners;
    if (beforeChange) {
        listeners = descriptor.willChangeListeners;
    } else {
        listeners = descriptor.changeListeners;
    }

    var node = listeners.findLast(listener);
    if (!node) {
        throw new Error("Can't remove map change listener: does not exist: token " + JSON.stringify(token));
    }
    node["delete"]();
};

MapChanges.prototype.dispatchMapChange = function (key, value, beforeChange) {
    var descriptors = this.getAllMapChangeDescriptors();
    var changeName = "Map" + (beforeChange ? "WillChange" : "Change");
    descriptors.forEach(function (descriptor, token) {

        if (descriptor.isActive) {
            return;
        } else {
            descriptor.isActive = true;
        }

        var listeners;
        if (beforeChange) {
            listeners = descriptor.willChangeListeners;
        } else {
            listeners = descriptor.changeListeners;
        }

        var tokenName = "handle" + (
            token.slice(0, 1).toUpperCase() +
            token.slice(1)
        ) + changeName;

        try {
            // dispatch to each listener
            listeners.forEach(function (listener) {
                if (listener[tokenName]) {
                    listener[tokenName](value, key, this);
                } else if (listener.call) {
                    listener.call(listener, value, key, this);
                } else {
                    throw new Error("Handler " + listener + " has no method " + tokenName + " and is not callable");
                }
            }, this);
        } finally {
            descriptor.isActive = false;
        }

    }, this);
};

MapChanges.prototype.hiveAddBeforeMapChangeListener = function (listener, token) {
    return this.hiveAddMapChangeListener(listener, token, true);
};

MapChanges.prototype.removeBeforeMapChangeListener = function (listener, token) {
    return this.removeMapChangeListener(listener, token, true);
};

MapChanges.prototype.dispatchBeforeMapChange = function (key, value) {
    return this.dispatchMapChange(key, value, true);
};



/***/ }),

/***/ "../../../node_modules/@hivestreaming/collections/listen/property-changes.js":
/*!****************************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/node_modules/@hivestreaming/collections/listen/property-changes.js ***!
  \****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*
    Based in part on observable arrays from Motorola Mobilitys Montage
    Copyright (c) 2012, Motorola Mobility LLC. All Rights Reserved.
    3-Clause BSD License
    https://github.com/motorola-mobility/montage/blob/master/LICENSE.md
*/

/*
    This module is responsible for observing changes to owned properties of
    objects and changes to the content of arrays caused by method calls.
    The interface for observing array content changes establishes the methods
    necessary for any collection with observable content.
*/

__webpack_require__(/*! ../shim */ "../../../node_modules/@hivestreaming/collections/shim.js");

// objectHasOwnProperty.call(myObject, key) will be used instead of
// myObject.hasOwnProperty(key) to allow myObject have defined
// a own property called "hasOwnProperty".

var objectHasOwnProperty = Object.prototype.hasOwnProperty;

// Object property descriptors carry information necessary for hiveAdding,
// removing, dispatching, and shorting events to listeners for property changes
// for a particular key on a particular object.  These descriptors are used
// here for shallow property changes.  The current listeners are the ones
// modified by hiveAdd and remove own property change listener methods.  During
// property change dispatch, we capture a snapshot of the current listeners in
// the active change listeners array.  The descriptor also keeps a memo of the
// corresponding handler method names.
//
// {
//     willChangeListeners:{current, active:Array<Function>, ...method names}
//     changeListeners:{current, active:Array<Function>, ...method names}
// }

// Maybe remove entries from this table if the corresponding object no longer
// has any property change listeners for any key.  However, the cost of
// book-keeping is probably not warranted since it would be rare for an
// observed object to no longer be observed unless it was about to be disposed
// of or reused as an observable.  The only benefit would be in avoiding bulk
// calls to dispatchOwnPropertyChange events on objects that have no listeners.

//  To observe shallow property changes for a particular key of a particular
//  object, we install a property descriptor on the object that overrides the previous
//  descriptor.  The overridden descriptors are stored in this weak map.  The
//  weak map associates an object with another object that maps property names
//  to property descriptors.
//
//  object.__overriddenPropertyDescriptors__[key]
//
//  We retain the old descriptor for various purposes.  For one, if the property
//  is no longer being observed by anyone, we revert the property descriptor to
//  the original.  For "value" descriptors, we store the actual value of the
//  descriptor on the overridden descriptor, so when the property is reverted, it
//  retains the most recently set value.  For "get" and "set" descriptors,
//  we observe then forward "get" and "set" operations to the original descriptor.

module.exports = PropertyChanges;

function PropertyChanges() {
    throw new Error("This is an abstract interface. Mix it. Don't construct it");
}

PropertyChanges.debug = true;

PropertyChanges.prototype.getOwnPropertyChangeDescriptor = function (key) {
    if (!this.__propertyChangeListeners__) {
        Object.defineProperty(this, "__propertyChangeListeners__", {
            value: {},
            enumerable: false,
            configurable: true,
            writable: true
        });
    }
    var objectPropertyChangeDescriptors = this.__propertyChangeListeners__;
    if (!objectHasOwnProperty.call(objectPropertyChangeDescriptors, key)) {
        var propertyName = String(key);

        propertyName = propertyName && propertyName[0].toUpperCase() + propertyName.slice(1);
        objectPropertyChangeDescriptors[key] = {
            willChangeListeners: {
                current: [],
                active: [],
                specificHandlerMethodName: "handle" + propertyName + "WillChange",
                genericHandlerMethodName: "handlePropertyWillChange"
            },
            changeListeners: {
                current: [],
                active: [],
                specificHandlerMethodName: "handle" + propertyName + "Change",
                genericHandlerMethodName: "handlePropertyChange"
            }
        };
    }
    return objectPropertyChangeDescriptors[key];
};

PropertyChanges.prototype.hasOwnPropertyChangeDescriptor = function (key) {
    if (!this.__propertyChangeListeners__) {
        return false;
    }
    if (!key) {
        return true;
    }
    var objectPropertyChangeDescriptors = this.__propertyChangeListeners__;
    if (!objectHasOwnProperty.call(objectPropertyChangeDescriptors, key)) {
        return false;
    }
    return true;
};

PropertyChanges.prototype.hiveAddOwnPropertyChangeListener = function (key, listener, beforeChange) {
    if (this.makeObservable && !this.isObservable) {
        this.makeObservable(); // particularly for observable arrays, for
        // their length property
    }
    var descriptor = PropertyChanges.getOwnPropertyChangeDescriptor(this, key);
    var listeners;
    if (beforeChange) {
        listeners = descriptor.willChangeListeners;
    } else {
        listeners = descriptor.changeListeners;
    }
    PropertyChanges.makePropertyObservable(this, key);
    listeners.current.push(listener);

    var self = this;
    return function cancelOwnPropertyChangeListener() {
        PropertyChanges.removeOwnPropertyChangeListener(self, key, listener, beforeChange);
        self = null;
    };
};

PropertyChanges.prototype.hiveAddBeforeOwnPropertyChangeListener = function (key, listener) {
    return PropertyChanges.hiveAddOwnPropertyChangeListener(this, key, listener, true);
};

PropertyChanges.prototype.removeOwnPropertyChangeListener = function (key, listener, beforeChange) {
    var descriptor = PropertyChanges.getOwnPropertyChangeDescriptor(this, key);

    var listeners;
    if (beforeChange) {
        listeners = descriptor.willChangeListeners;
    } else {
        listeners = descriptor.changeListeners;
    }

    var index = listeners.current.lastIndexOf(listener);
    if (index === -1) {
        throw new Error("Can't remove property change listener: does not exist: property name" + JSON.stringify(key));
    }
    listeners.current.splice(index, 1);
};

PropertyChanges.prototype.removeBeforeOwnPropertyChangeListener = function (key, listener) {
    return PropertyChanges.removeOwnPropertyChangeListener(this, key, listener, true);
};

PropertyChanges.prototype.dispatchOwnPropertyChange = function (key, value, beforeChange) {
    var descriptor = PropertyChanges.getOwnPropertyChangeDescriptor(this, key),
        listeners;

    if (!descriptor.isActive) {
        descriptor.isActive = true;
        if (beforeChange) {
            listeners = descriptor.willChangeListeners;
        } else {
            listeners = descriptor.changeListeners;
        }
        try {
            dispatchEach(listeners, key, value, this);
        } finally {
            descriptor.isActive = false;
        }
    }
};

function dispatchEach(listeners, key, value, object) {
    // copy snapshot of current listeners to active listeners
    var active = listeners.active;
    var current = listeners.current;
    var index = current.length;
    var listener, length = index, i, thisp;

    if (active.length > index) {
        active.length = index;
    }
    while (index--) {
        active[index] = current[index];
    }
    for (i = 0; i < length; i++) {
        thisp = active[i];
        //This is fixing the issue causing a regression in Montage's repetition
        if (!i || current.indexOf(thisp) >= 0) {
            listener = (
                thisp[listeners.specificHandlerMethodName] ||
                thisp[listeners.genericHandlerMethodName] ||
                thisp
            );
            if (!listener.call) {
                throw new Error("No event listener for " + listeners.specificHandlerName + " or " + listeners.genericHandlerName + " or call on " + listener);
            }
            listener.call(thisp, value, key, object);
        }

    }
}

PropertyChanges.prototype.dispatchBeforeOwnPropertyChange = function (key, listener) {
    return PropertyChanges.dispatchOwnPropertyChange(this, key, listener, true);
};

PropertyChanges.prototype.makePropertyObservable = function (key) {
    // arrays are special.  we do not support direct setting of properties
    // on an array.  instead, call .set(index, value).  this is observable.
    // 'length' property is observable for all mutating methods because
    // our overrides explicitly dispatch that change.


    var overriddenPropertyDescriptors = this.__overriddenPropertyDescriptors__;

    // memoize overridden property descriptor table
    if (!overriddenPropertyDescriptors) {
        if (Array.isArray(this)) {
            return;
        }
        if (!Object.isExtensible(this)) {
            throw new Error("Can't make property " + JSON.stringify(key) + " observable on " + this + " because object is not extensible");
        }
        overriddenPropertyDescriptors = {};
        Object.defineProperty(this, "__overriddenPropertyDescriptors__", {
            value: overriddenPropertyDescriptors,
            enumerable: false,
            writable: true,
            configurable: true
        });
    } else {
        if (objectHasOwnProperty.call(overriddenPropertyDescriptors, key)) {
            // if we have already recorded an overridden property descriptor,
            // we have already installed the observer, so short-here
            return;
        }
    }

    var state;
    if (typeof this.__state__ === "object") {
        state = this.__state__;
    } else {
        state = {};
        Object.defineProperty(this, "__state__", {
            value: state,
            writable: true,
            enumerable: false
        });
    }
    state[key] = this[key];



    // walk up the prototype chain to find a property descriptor for
    // the property name
    var overriddenDescriptor;
    var attached = this;
    do {
        overriddenDescriptor = Object.getOwnPropertyDescriptor(attached, key);
        if (overriddenDescriptor) {
            break;
        }
        attached = Object.getPrototypeOf(attached);
    } while (attached);
    // or default to an undefined value
    if (!overriddenDescriptor) {
        overriddenDescriptor = {
            value: undefined,
            enumerable: true,
            writable: true,
            configurable: true
        };
    } else {
        if (!overriddenDescriptor.configurable) {
            return;
        }
        if (!overriddenDescriptor.writable && !overriddenDescriptor.set) {
            return;
        }
    }

    // memoize the descriptor so we know not to install another layer,
    // and so we can reuse the overridden descriptor when uninstalling
    overriddenPropertyDescriptors[key] = overriddenDescriptor;


    // TODO reflect current value on a displayed property

    var propertyListener;
    // in both of these new descriptor variants, we reuse the overridden
    // descriptor to either store the current value or apply getters
    // and setters.  this is handy since we can reuse the overridden
    // descriptor if we uninstall the observer.  We even preserve the
    // assignment semantics, where we get the value from up the
    // prototype chain, and set as an owned property.
    if ('value' in overriddenDescriptor) {
        propertyListener = {
            get: function () {
                return overriddenDescriptor.value;
            },
            set: function (value) {
                var descriptor,
                    isActive;

                if (value !== overriddenDescriptor.value) {
                    descriptor = this.__propertyChangeListeners__[key];
                    isActive = descriptor.isActive;
                    if (!isActive) {
                        descriptor.isActive = true;
                        try {
                            dispatchEach(descriptor.willChangeListeners, key, overriddenDescriptor.value, this);
                        } finally {}
                    }
                    overriddenDescriptor.value = value;
                    state[key] = value;
                    if (!isActive) {
                        try {
                            dispatchEach(descriptor.changeListeners, key, value, this);
                        } finally {
                            descriptor.isActive = false;
                        }
                    }
                }
            },
            enumerable: overriddenDescriptor.enumerable,
            configurable: true
        };
    } else { // 'get' or 'set', but not necessarily both
        propertyListener = {
            get: overriddenDescriptor.get,
            set: function (value) {
                var formerValue = this[key],
                    descriptor,
                    isActive;

                overriddenDescriptor.set.call(this, value);
                value = this[key];
                if (value !== formerValue) {
                    descriptor = this.__propertyChangeListeners__[key];
                    isActive = descriptor.isActive;
                    if (!isActive) {
                        descriptor.isActive = true;
                        try {
                            dispatchEach(descriptor.willChangeListeners, key, formerValue, this);
                        } finally {}
                    }
                    state[key] = value;
                    if (!isActive) {
                        try {
                            dispatchEach(descriptor.changeListeners, key, value, this);
                        } finally {
                            descriptor.isActive = false;
                        }
                    }
                }
            },
            enumerable: overriddenDescriptor.enumerable,
            configurable: true
        };
    }

    Object.defineProperty(this, key, propertyListener);
};

// constructor functions

PropertyChanges.getOwnPropertyChangeDescriptor = function (object, key) {
    if (object.getOwnPropertyChangeDescriptor) {
        return object.getOwnPropertyChangeDescriptor(key);
    } else {
        return PropertyChanges.prototype.getOwnPropertyChangeDescriptor.call(object, key);
    }
};

PropertyChanges.hasOwnPropertyChangeDescriptor = function (object, key) {
    if (object.hasOwnPropertyChangeDescriptor) {
        return object.hasOwnPropertyChangeDescriptor(key);
    } else {
        return PropertyChanges.prototype.hasOwnPropertyChangeDescriptor.call(object, key);
    }
};

PropertyChanges.hiveAddOwnPropertyChangeListener = function (object, key, listener, beforeChange) {
    if (!Object.isObject(object)) {
    } else if (object.hiveAddOwnPropertyChangeListener) {
        return object.hiveAddOwnPropertyChangeListener(key, listener, beforeChange);
    } else {
        return PropertyChanges.prototype.hiveAddOwnPropertyChangeListener.call(object, key, listener, beforeChange);
    }
};

PropertyChanges.removeOwnPropertyChangeListener = function (object, key, listener, beforeChange) {
    if (!Object.isObject(object)) {
    } else if (object.removeOwnPropertyChangeListener) {
        return object.removeOwnPropertyChangeListener(key, listener, beforeChange);
    } else {
        return PropertyChanges.prototype.removeOwnPropertyChangeListener.call(object, key, listener, beforeChange);
    }
};

PropertyChanges.dispatchOwnPropertyChange = function (object, key, value, beforeChange) {
    if (!Object.isObject(object)) {
    } else if (object.dispatchOwnPropertyChange) {
        return object.dispatchOwnPropertyChange(key, value, beforeChange);
    } else {
        return PropertyChanges.prototype.dispatchOwnPropertyChange.call(object, key, value, beforeChange);
    }
};

PropertyChanges.hiveAddBeforeOwnPropertyChangeListener = function (object, key, listener) {
    return PropertyChanges.hiveAddOwnPropertyChangeListener(object, key, listener, true);
};

PropertyChanges.removeBeforeOwnPropertyChangeListener = function (object, key, listener) {
    return PropertyChanges.removeOwnPropertyChangeListener(object, key, listener, true);
};

PropertyChanges.dispatchBeforeOwnPropertyChange = function (object, key, value) {
    return PropertyChanges.dispatchOwnPropertyChange(object, key, value, true);
};

PropertyChanges.makePropertyObservable = function (object, key) {
    if (object.makePropertyObservable) {
        return object.makePropertyObservable(key);
    } else {
        return PropertyChanges.prototype.makePropertyObservable.call(object, key);
    }
};


/***/ }),

/***/ "../../../node_modules/@hivestreaming/collections/listen/range-changes.js":
/*!*************************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/node_modules/@hivestreaming/collections/listen/range-changes.js ***!
  \*************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var WeakMap = __webpack_require__(/*! weak-map */ "../../../node_modules/weak-map/weak-map.js");
var Dict = __webpack_require__(/*! ../dict */ "../../../node_modules/@hivestreaming/collections/dict.js");

var rangeChangeDescriptors = new WeakMap(); // {isActive, willChangeListeners, changeListeners}

module.exports = RangeChanges;
function RangeChanges() {
    throw new Error("Can't construct. RangeChanges is a mixin.");
}

RangeChanges.prototype.getAllRangeChangeDescriptors = function () {
    if (!rangeChangeDescriptors.has(this)) {
        rangeChangeDescriptors.set(this, Dict());
    }
    return rangeChangeDescriptors.get(this);
};

RangeChanges.prototype.getRangeChangeDescriptor = function (token) {
    var tokenChangeDescriptors = this.getAllRangeChangeDescriptors();
    token = token || "";
    if (!tokenChangeDescriptors.has(token)) {
        tokenChangeDescriptors.set(token, {
            isActive: false,
            changeListeners: [],
            willChangeListeners: []
        });
    }
    return tokenChangeDescriptors.get(token);
};

RangeChanges.prototype.hiveAddRangeChangeListener = function (listener, token, beforeChange) {
    // a concession for objects like Array that are not inherently observable
    if (!this.isObservable && this.makeObservable) {
        this.makeObservable();
    }

    var descriptor = this.getRangeChangeDescriptor(token);

    var listeners;
    if (beforeChange) {
        listeners = descriptor.willChangeListeners;
    } else {
        listeners = descriptor.changeListeners;
    }

    // even if already registered
    listeners.push(listener);
    Object.defineProperty(this, "dispatchesRangeChanges", {
        value: true,
        writable: true,
        configurable: true,
        enumerable: false
    });

    var self = this;
    return function cancelRangeChangeListener() {
        if (!self) {
            // TODO throw new Error("Range change listener " + JSON.stringify(token) + " has already been canceled");
            return;
        }
        self.removeRangeChangeListener(listener, token, beforeChange);
        self = null;
    };
};

RangeChanges.prototype.removeRangeChangeListener = function (listener, token, beforeChange) {
    var descriptor = this.getRangeChangeDescriptor(token);

    var listeners;
    if (beforeChange) {
        listeners = descriptor.willChangeListeners;
    } else {
        listeners = descriptor.changeListeners;
    }

    var index = listeners.lastIndexOf(listener);
    if (index === -1) {
        throw new Error("Can't remove range change listener: does not exist: token " + JSON.stringify(token));
    }
    listeners.splice(index, 1);
};

RangeChanges.prototype.dispatchRangeChange = function (plus, minus, index, beforeChange) {
    var descriptors = this.getAllRangeChangeDescriptors();
    var changeName = "Range" + (beforeChange ? "WillChange" : "Change");
    descriptors.forEach(function (descriptor, token) {

        if (descriptor.isActive) {
            return;
        } else {
            descriptor.isActive = true;
        }

        // before or after
        var listeners;
        if (beforeChange) {
            listeners = descriptor.willChangeListeners;
        } else {
            listeners = descriptor.changeListeners;
        }

        var tokenName = "handle" + (
            token.slice(0, 1).toUpperCase() +
            token.slice(1)
        ) + changeName;
        // notably, defaults to "handleRangeChange" or "handleRangeWillChange"
        // if token is "" (the default)

        // dispatch each listener
        try {
            listeners.slice().forEach(function (listener) {
                if (listeners.indexOf(listener) < 0) {
                    return;
                }
                if (listener[tokenName]) {
                    listener[tokenName](plus, minus, index, this, beforeChange);
                } else if (listener.call) {
                    listener.call(this, plus, minus, index, this, beforeChange);
                } else {
                    throw new Error("Handler " + listener + " has no method " + tokenName + " and is not callable");
                }
            }, this);
        } finally {
            descriptor.isActive = false;
        }
    }, this);
};

RangeChanges.prototype.hiveAddBeforeRangeChangeListener = function (listener, token) {
    return this.hiveAddRangeChangeListener(listener, token, true);
};

RangeChanges.prototype.removeBeforeRangeChangeListener = function (listener, token) {
    return this.removeRangeChangeListener(listener, token, true);
};

RangeChanges.prototype.dispatchBeforeRangeChange = function (plus, minus, index) {
    return this.dispatchRangeChange(plus, minus, index, true);
};



/***/ }),

/***/ "../../../node_modules/@hivestreaming/collections/map.js":
/*!********************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/node_modules/@hivestreaming/collections/map.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Shim = __webpack_require__(/*! ./shim */ "../../../node_modules/@hivestreaming/collections/shim.js");
var Set = __webpack_require__(/*! ./set */ "../../../node_modules/@hivestreaming/collections/set.js");
var GenericCollection = __webpack_require__(/*! ./generic-collection */ "../../../node_modules/@hivestreaming/collections/generic-collection.js");
var GenericMap = __webpack_require__(/*! ./generic-map */ "../../../node_modules/@hivestreaming/collections/generic-map.js");
var PropertyChanges = __webpack_require__(/*! ./listen/property-changes */ "../../../node_modules/@hivestreaming/collections/listen/property-changes.js");

module.exports = Map;

function Map(values, equals, hash, getDefault) {
    if (!(this instanceof Map)) {
        return new Map(values, equals, hash, getDefault);
    }
    equals = equals || Object.equals;
    hash = hash || Object.hash;
    getDefault = getDefault || Function.noop;
    this.contentEquals = equals;
    this.contentHash = hash;
    this.getDefault = getDefault;
    this.store = new Set(
        undefined,
        function keysEqual(a, b) {
            return equals(a.key, b.key);
        },
        function keyHash(item) {
            return hash(item.key);
        }
    );
    this.length = 0;
    this.hiveAddEach(values);
}

Map.Map = Map; // hack so require("map").Map will work in MontageJS

Object.hiveAddEach(Map.prototype, GenericCollection.prototype);
Object.hiveAddEach(Map.prototype, GenericMap.prototype); // overrides GenericCollection
Object.hiveAddEach(Map.prototype, PropertyChanges.prototype);
Object.defineProperty(Map.prototype,"size",GenericCollection._sizePropertyDescriptor);

Map.prototype.constructClone = function (values) {
    return new this.constructor(
        values,
        this.contentEquals,
        this.contentHash,
        this.getDefault
    );
};

Map.prototype.log = function (charmap, logNode, callback, thisp) {
    logNode = logNode || this.logNode;
    this.store.log(charmap, function (node, log, logBefore) {
        logNode(node.value.value, log, logBefore);
    }, callback, thisp);
};

Map.prototype.logNode = function (node, log) {
    log(' key: ' + node.key);
    log(' value: ' + node.value);
};


/***/ }),

/***/ "../../../node_modules/@hivestreaming/collections/set.js":
/*!********************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/node_modules/@hivestreaming/collections/set.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Shim = __webpack_require__(/*! ./shim */ "../../../node_modules/@hivestreaming/collections/shim.js");
var List = __webpack_require__(/*! ./list */ "../../../node_modules/@hivestreaming/collections/list.js");
var FastSet = __webpack_require__(/*! ./fast-set */ "../../../node_modules/@hivestreaming/collections/fast-set.js");
var GenericCollection = __webpack_require__(/*! ./generic-collection */ "../../../node_modules/@hivestreaming/collections/generic-collection.js");
var GenericSet = __webpack_require__(/*! ./generic-set */ "../../../node_modules/@hivestreaming/collections/generic-set.js");
var PropertyChanges = __webpack_require__(/*! ./listen/property-changes */ "../../../node_modules/@hivestreaming/collections/listen/property-changes.js");
var RangeChanges = __webpack_require__(/*! ./listen/range-changes */ "../../../node_modules/@hivestreaming/collections/listen/range-changes.js");
var Iterator = __webpack_require__(/*! ./iterator */ "../../../node_modules/@hivestreaming/collections/iterator.js");

module.exports = Set;

function Set(values, equals, hash, getDefault) {
    if (!(this instanceof Set)) {
        return new Set(values, equals, hash, getDefault);
    }
    equals = equals || Object.equals;
    hash = hash || Object.hash;
    getDefault = getDefault || Function.noop;
    this.contentEquals = equals;
    this.contentHash = hash;
    this.getDefault = getDefault;
    // a list of values in insertion order, used for all operations that depend
    // on iterating in insertion order
    this.order = new this.Order(undefined, equals);
    // a set of nodes from the order list, indexed by the corresponding value,
    // used for all operations that need to quickly seek  value in the list
    this.store = new this.Store(
        undefined,
        function (a, b) {
            return equals(a.value, b.value);
        },
        function (node) {
            return hash(node.value);
        }
    );
    this.length = 0;
    this.hiveAddEach(values);
}

Set.Set = Set; // hack so require("set").Set will work in MontageJS

Object.hiveAddEach(Set.prototype, GenericCollection.prototype);
Object.hiveAddEach(Set.prototype, GenericSet.prototype);
Object.hiveAddEach(Set.prototype, PropertyChanges.prototype);
Object.hiveAddEach(Set.prototype, RangeChanges.prototype);

Object.defineProperty(Set.prototype,"size",GenericCollection._sizePropertyDescriptor);

Set.prototype.Order = List;
Set.prototype.Store = FastSet;

Set.prototype.constructClone = function (values) {
    return new this.constructor(values, this.contentEquals, this.contentHash, this.getDefault);
};

Set.prototype.has = function (value) {
    var node = new this.order.Node(value);
    return this.store.has(node);
};

Set.prototype.get = function (value, equals) {
    if (equals) {
        throw new Error("Set#get does not support second argument: equals");
    }
    var node = new this.order.Node(value);
    node = this.store.get(node);
    if (node) {
        return node.value;
    } else {
        return this.getDefault(value);
    }
};

Set.prototype.hiveAdd = function (value) {
    var node = new this.order.Node(value);
    if (!this.store.has(node)) {
        var index = this.length;
        if (this.dispatchesRangeChanges) {
            this.dispatchBeforeRangeChange([value], [], index);
        }
        this.order.hiveAdd(value);
        node = this.order.head.prev;
        this.store.hiveAdd(node);
        this.length++;
        if (this.dispatchesRangeChanges) {
            this.dispatchRangeChange([value], [], index);
        }
        return true;
    }
    return false;
};

Set.prototype["delete"] = function (value, equals) {
    if (equals) {
        throw new Error("Set#delete does not support second argument: equals");
    }
    var node = new this.order.Node(value);
    if (this.store.has(node)) {
        node = this.store.get(node);
        if (this.dispatchesRangeChanges) {
            this.dispatchBeforeRangeChange([], [value], node.index);
        }
        this.store["delete"](node); // removes from the set
        this.order.splice(node, 1); // removes the node from the list
        this.length--;
        if (this.dispatchesRangeChanges) {
            this.dispatchRangeChange([], [value], node.index);
        }
        return true;
    }
    return false;
};

Set.prototype.pop = function () {
    if (this.length) {
        var result = this.order.head.prev.value;
        this["delete"](result);
        return result;
    }
};

Set.prototype.shift = function () {
    if (this.length) {
        var result = this.order.head.next.value;
        this["delete"](result);
        return result;
    }
};

Set.prototype.one = function () {
    if (this.length > 0) {
        return this.store.one().value;
    }
};

Set.prototype.clear = function () {
    var clearing;
    if (this.dispatchesRangeChanges) {
        clearing = this.toArray();
        this.dispatchBeforeRangeChange([], clearing, 0);
    }
    this.store.clear();
    this.order.clear();
    this.length = 0;
    if (this.dispatchesRangeChanges) {
        this.dispatchRangeChange([], clearing, 0);
    }
};

Set.prototype.reduce = function (callback, basis /*, thisp*/) {
    var thisp = arguments[2];
    var list = this.order;
    var index = 0;
    return list.reduce(function (basis, value) {
        return callback.call(thisp, basis, value, index++, this);
    }, basis, this);
};

Set.prototype.reduceRight = function (callback, basis /*, thisp*/) {
    var thisp = arguments[2];
    var list = this.order;
    var index = this.length - 1;
    return list.reduceRight(function (basis, value) {
        return callback.call(thisp, basis, value, index--, this);
    }, basis, this);
};

Set.prototype.iterate = function () {
    return this.order.iterate();
};

Set.prototype.values = function () {
    return new Iterator(this);
};

Set.prototype.log = function () {
    var set = this.store;
    return set.log.apply(set, arguments);
};

Set.prototype.makeObservable = function () {
    this.order.makeObservable();
};


/***/ }),

/***/ "../../../node_modules/@hivestreaming/collections/shim-array.js":
/*!***************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/node_modules/@hivestreaming/collections/shim-array.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*
    Based in part on extras from Motorola Mobilitys Montage
    Copyright (c) 2012, Motorola Mobility LLC. All Rights Reserved.
    3-Clause BSD License
    https://github.com/motorola-mobility/montage/blob/master/LICENSE.md
*/

var Function = __webpack_require__(/*! ./shim-function */ "../../../node_modules/@hivestreaming/collections/shim-function.js");
var GenericCollection = __webpack_require__(/*! ./generic-collection */ "../../../node_modules/@hivestreaming/collections/generic-collection.js");
var GenericOrder = __webpack_require__(/*! ./generic-order */ "../../../node_modules/@hivestreaming/collections/generic-order.js");
var WeakMap = __webpack_require__(/*! weak-map */ "../../../node_modules/weak-map/weak-map.js");

module.exports = Array;

var array_splice = Array.prototype.splice;
var array_slice = Array.prototype.slice;

Array.empty = [];

if (Object.freeze) {
    Object.freeze(Array.empty);
}

Array.from = Array.from || function (values) {
    var array = [];
    array.hiveAddEach(values);
    return array;
};

Array.unzip = function (table) {
    var transpose = [];
    var length = Infinity;
    // compute shortest row
    for (var i = 0; i < table.length; i++) {
        var row = table[i];
        table[i] = row.toArray();
        if (row.length < length) {
            length = row.length;
        }
    }
    for (var i = 0; i < table.length; i++) {
        var row = table[i];
        for (var j = 0; j < row.length; j++) {
            if (j < length && j in row) {
                transpose[j] = transpose[j] || [];
                transpose[j][i] = row[j];
            }
        }
    }
    return transpose;
};

function define(key, value) {
    if(!Array.prototype[key])
        Object.defineProperty(Array.prototype, key, {
            value: value,
            writable: true,
            configurable: true,
            enumerable: false
        });
}

define("hiveAddEach", GenericCollection.prototype.hiveAddEach);
define("deleteEach", GenericCollection.prototype.deleteEach);
define("toArray", GenericCollection.prototype.toArray);
define("toObject", GenericCollection.prototype.toObject);
define("all", GenericCollection.prototype.all);
define("any", GenericCollection.prototype.any);
define("min", GenericCollection.prototype.min);
define("max", GenericCollection.prototype.max);
define("sum", GenericCollection.prototype.sum);
define("average", GenericCollection.prototype.average);
define("only", GenericCollection.prototype.only);
define("flatten", GenericCollection.prototype.flatten);
define("zip", GenericCollection.prototype.zip);
define("enumerate", GenericCollection.prototype.enumerate);
define("group", GenericCollection.prototype.group);
define("sorted", GenericCollection.prototype.sorted);
define("reversed", GenericCollection.prototype.reversed);

define("constructClone", function (values) {
    var clone = new this.constructor();
    clone.hiveAddEach(values);
    return clone;
});

define("has", function (value, equals) {
    return this.find(value, equals) !== -1;
});

define("set", function (index, value) {
    this[index] = value;
    return true;
});

define("hiveAdd", function (value) {
    this.push(value);
    return true;
});

define("delete", function (value, equals) {
    var index = this.find(value, equals);
    if (index !== -1) {
        this.splice(index, 1);
        return true;
    }
    return false;
});

define("deleteAll", function (value, equals) {
    equals = equals || this.contentEquals || Object.equals;
    var count = 0;
    for (var index = 0; index < this.length;) {
        if (equals(value, this[index])) {
            this.swap(index, 1);
            count++;
        } else {
            index++;
        }
    }
    return count;
});

define("find", function (value, equals) {
    equals = equals || this.contentEquals || Object.equals;
    for (var index = 0; index < this.length; index++) {
        if (index in this && equals(value, this[index])) {
            return index;
        }
    }
    return -1;
});

define("findLast", function (value, equals) {
    equals = equals || this.contentEquals || Object.equals;
    var index = this.length;
    do {
        index--;
        if (index in this && equals(this[index], value)) {
            return index;
        }
    } while (index > 0);
    return -1;
});

define("swap", function (start, length, plus) {
    var args, plusLength, i, j, returnValue;
    if (start > this.length) {
        this.length = start;
    }
    if (typeof plus !== "undefined") {
        args = [start, length];
        if (!Array.isArray(plus)) {
            plus = array_slice.call(plus);
        }
        i = 0;
        plusLength = plus.length;
        // 1000 is a magic number, presumed to be smaller than the remaining
        // stack length. For swaps this small, we take the fast path and just
        // use the underlying Array splice. We could measure the exact size of
        // the remaining stack using a try/catch around an unbounded recursive
        // function, but this would defeat the purpose of short-circuiting in
        // the common case.
        if (plusLength < 1000) {
            for (i; i < plusLength; i++) {
                args[i+2] = plus[i];
            }
            return array_splice.apply(this, args);
        } else {
            // Avoid maximum call stack error.
            // First delete the desired entries.
            returnValue = array_splice.apply(this, args);
            // Second batch in 1000s.
            for (i; i < plusLength;) {
                args = [start+i, 0];
                for (j = 2; j < 1002 && i < plusLength; j++, i++) {
                    args[j] = plus[i];
                }
                array_splice.apply(this, args);
            }
            return returnValue;
        }
    // using call rather than apply to cut down on transient objects
    } else if (typeof length !== "undefined") {
        return array_splice.call(this, start, length);
    }  else if (typeof start !== "undefined") {
        return array_splice.call(this, start);
    } else {
        return [];
    }
});

define("peek", function () {
    return this[0];
});

define("poke", function (value) {
    if (this.length > 0) {
        this[0] = value;
    }
});

define("peekBack", function () {
    if (this.length > 0) {
        return this[this.length - 1];
    }
});

define("pokeBack", function (value) {
    if (this.length > 0) {
        this[this.length - 1] = value;
    }
});

define("one", function () {
    for (var i in this) {
        if (Object.owns(this, i)) {
            return this[i];
        }
    }
});

if (!Array.prototype.clear) {
    define("clear", function () {
        this.length = 0;
        return this;
    });
}

define("compare", function (that, compare) {
    compare = compare || Object.compare;
    var i;
    var length;
    var lhs;
    var rhs;
    var relative;

    if (this === that) {
        return 0;
    }

    if (!that || !Array.isArray(that)) {
        return GenericOrder.prototype.compare.call(this, that, compare);
    }

    length = Math.min(this.length, that.length);

    for (i = 0; i < length; i++) {
        if (i in this) {
            if (!(i in that)) {
                return -1;
            } else {
                lhs = this[i];
                rhs = that[i];
                relative = compare(lhs, rhs);
                if (relative) {
                    return relative;
                }
            }
        } else if (i in that) {
            return 1;
        }
    }

    return this.length - that.length;
});

define("equals", function (that, equals) {
    equals = equals || Object.equals;
    var i = 0;
    var length = this.length;
    var left;
    var right;

    if (this === that) {
        return true;
    }
    if (!that || !Array.isArray(that)) {
        return GenericOrder.prototype.equals.call(this, that);
    }

    if (length !== that.length) {
        return false;
    } else {
        for (; i < length; ++i) {
            if (i in this) {
                if (!(i in that)) {
                    return false;
                }
                left = this[i];
                right = that[i];
                if (!equals(left, right)) {
                    return false;
                }
            } else {
                if (i in that) {
                    return false;
                }
            }
        }
    }
    return true;
});

define("clone", function (depth, memo) {
    if (depth == null) {
        depth = Infinity;
    } else if (depth === 0) {
        return this;
    }
    memo = memo || new WeakMap();
    if (memo.has(this)) {
        return memo.get(this);
    }
    var clone = new Array(this.length);
    memo.set(this, clone);
    for (var i in this) {
        clone[i] = Object.clone(this[i], depth - 1, memo);
    };
    return clone;
});

define("iterate", function (start, end) {
    return new ArrayIterator(this, start, end);
});

define("Iterator", ArrayIterator);

function ArrayIterator(array, start, end) {
    this.array = array;
    this.start = start == null ? 0 : start;
    this.end = end;
};
ArrayIterator.prototype.__iterationObject = null;
Object.defineProperty(ArrayIterator.prototype,"_iterationObject", {
    get: function() {
        return this.__iterationObject || (this.__iterationObject = { done: false, value:null});
    }
});

ArrayIterator.prototype.next = function () {
    if (this.start === (this.end == null ? this.array.length : this.end)) {
        this._iterationObject.done = true;
        this._iterationObject.value = void 0;
    } else {
        this._iterationObject.value = this.array[this.start++];
    }
    return this._iterationObject;
};


/***/ }),

/***/ "../../../node_modules/@hivestreaming/collections/shim-function.js":
/*!******************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/node_modules/@hivestreaming/collections/shim-function.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {


module.exports = Function;

/**
    A utility to reduce unnecessary allocations of <code>function () {}</code>
    in its many colorful variations.  It does nothing and returns
    <code>undefined</code> thus makes a suitable default in some circumstances.

    @function external:Function.noop
*/
Function.noop = function () {
};

/**
    A utility to reduce unnecessary allocations of <code>function (x) {return
    x}</code> in its many colorful but ultimately wasteful parameter name
    variations.

    @function external:Function.identity
    @param {Any} any value
    @returns {Any} that value
*/
Function.identity = function (value) {
    return value;
};

/**
    A utility for creating a comparator function for a particular aspect of a
    figurative class of objects.

    @function external:Function.by
    @param {Function} relation A function that accepts a value and returns a
    corresponding value to use as a representative when sorting that object.
    @param {Function} compare an alternate comparator for comparing the
    represented values.  The default is <code>Object.compare</code>, which
    does a deep, type-sensitive, polymorphic comparison.
    @returns {Function} a comparator that has been annotated with
    <code>by</code> and <code>compare</code> properties so
    <code>sorted</code> can perform a transform that reduces the need to call
    <code>by</code> on each sorted object to just once.
 */
Function.by = function (by , compare) {
    compare = compare || Object.compare;
    by = by || Function.identity;
    var compareBy = function (a, b) {
        return compare(by(a), by(b));
    };
    compareBy.compare = compare;
    compareBy.by = by;
    return compareBy;
};

// TODO document
Function.get = function (key) {
    return function (object) {
        return Object.get(object, key);
    };
};



/***/ }),

/***/ "../../../node_modules/@hivestreaming/collections/shim-object.js":
/*!****************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/node_modules/@hivestreaming/collections/shim-object.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var WeakMap = __webpack_require__(/*! weak-map */ "../../../node_modules/weak-map/weak-map.js");

module.exports = Object;

/*
    Based in part on extras from Motorola Mobilitys Montage
    Copyright (c) 2012, Motorola Mobility LLC. All Rights Reserved.
    3-Clause BSD License
    https://github.com/motorola-mobility/montage/blob/master/LICENSE.md
*/

/**
    Defines extensions to intrinsic <code>Object</code>.
    @see [Object class]{@link external:Object}
*/

/**
    A utility object to avoid unnecessary allocations of an empty object
    <code>{}</code>.  This object is frozen so it is safe to share.

    @object external:Object.empty
*/
Object.empty = Object.freeze(Object.create(null));

/**
    Returns whether the given value is an object, as opposed to a value.
    Unboxed numbers, strings, true, false, undefined, and null are not
    objects.  Arrays are objects.

    @function external:Object.isObject
    @param {Any} value
    @returns {Boolean} whether the given value is an object
*/
Object.isObject = function (object) {
    return Object(object) === object;
};

/**
    Returns the value of an any value, particularly objects that
    implement <code>valueOf</code>.

    <p>Note that, unlike the precedent of methods like
    <code>Object.equals</code> and <code>Object.compare</code> would suggest,
    this method is named <code>Object.getValueOf</code> instead of
    <code>valueOf</code>.  This is a delicate issue, but the basis of this
    decision is that the JavaScript runtime would be far more likely to
    accidentally call this method with no arguments, assuming that it would
    return the value of <code>Object</code> itself in various situations,
    whereas <code>Object.equals(Object, null)</code> protects against this case
    by noting that <code>Object</code> owns the <code>equals</code> property
    and therefore does not delegate to it.

    @function external:Object.getValueOf
    @param {Any} value a value or object wrapping a value
    @returns {Any} the primitive value of that object, if one exists, or passes
    the value through
*/
Object.getValueOf = function (value) {
    if (value && typeof value.valueOf === "function") {
        value = value.valueOf();
    }
    return value;
};

var hashMap = new WeakMap();
Object.hash = function (object) {
    if (object && typeof object.hash === "function") {
        return "" + object.hash();
    } else if (Object(object) === object) {
        if (!hashMap.has(object)) {
            hashMap.set(object, Math.random().toString(36).slice(2));
        }
        return hashMap.get(object);
    } else {
        return "" + object;
    }
};

/**
    A shorthand for <code>Object.prototype.hasOwnProperty.call(object,
    key)</code>.  Returns whether the object owns a property for the given key.
    It does not consult the prototype chain and works for any string (including
    "hasOwnProperty") except "__proto__".

    @function external:Object.owns
    @param {Object} object
    @param {String} key
    @returns {Boolean} whether the object owns a property wfor the given key.
*/
var owns = Object.prototype.hasOwnProperty;
Object.owns = function (object, key) {
    return owns.call(object, key);
};

/**
    A utility that is like Object.owns but is also useful for finding
    properties on the prototype chain, provided that they do not refer to
    methods on the Object prototype.  Works for all strings except "__proto__".

    <p>Alternately, you could use the "in" operator as long as the object
    descends from "null" instead of the Object.prototype, as with
    <code>Object.create(null)</code>.  However,
    <code>Object.create(null)</code> only works in fully compliant EcmaScript 5
    JavaScript engines and cannot be faithfully shimmed.

    <p>If the given object is an instance of a type that implements a method
    named "has", this function defers to the collection, so this method can be
    used to generically handle objects, arrays, or other collections.  In that
    case, the domain of the key depends on the instance.

    @param {Object} object
    @param {String} key
    @returns {Boolean} whether the object, or any of its prototypes except
    <code>Object.prototype</code>
    @function external:Object.has
*/
Object.has = function (object, key) {
    if (typeof object !== "object") {
        throw new Error("Object.has can't accept non-object: " + typeof object);
    }
    // forward to mapped collections that implement "has"
    if (object && typeof object.has === "function") {
        return object.has(key);
    // otherwise report whether the key is on the prototype chain,
    // as long as it is not one of the methods on object.prototype
    } else if (typeof key === "string") {
        return key in object && object[key] !== Object.prototype[key];
    } else {
        throw new Error("Key must be a string for Object.has on plain objects");
    }
};

/**
    Gets the value for a corresponding key from an object.

    <p>Uses Object.has to determine whether there is a corresponding value for
    the given key.  As such, <code>Object.get</code> is capable of retriving
    values from the prototype chain as long as they are not from the
    <code>Object.prototype</code>.

    <p>If there is no corresponding value, returns the given default, which may
    be <code>undefined</code>.

    <p>If the given object is an instance of a type that implements a method
    named "get", this function defers to the collection, so this method can be
    used to generically handle objects, arrays, or other collections.  In that
    case, the domain of the key depends on the implementation.  For a `Map`,
    for example, the key might be any object.

    @param {Object} object
    @param {String} key
    @param {Any} value a default to return, <code>undefined</code> if omitted
    @returns {Any} value for key, or default value
    @function external:Object.get
*/
Object.get = function (object, key, value) {
    if (typeof object !== "object") {
        throw new Error("Object.get can't accept non-object: " + typeof object);
    }
    // forward to mapped collections that implement "get"
    if (object && typeof object.get === "function") {
        return object.get(key, value);
    } else if (Object.has(object, key)) {
        return object[key];
    } else {
        return value;
    }
};

/**
    Sets the value for a given key on an object.

    <p>If the given object is an instance of a type that implements a method
    named "set", this function defers to the collection, so this method can be
    used to generically handle objects, arrays, or other collections.  As such,
    the key domain varies by the object type.

    @param {Object} object
    @param {String} key
    @param {Any} value
    @returns <code>undefined</code>
    @function external:Object.set
*/
Object.set = function (object, key, value) {
    if (object && typeof object.set === "function") {
        object.set(key, value);
    } else {
        object[key] = value;
    }
};

Object.hiveAddEach = function (target, source) {
    if (!source) {
    } else if (typeof source.forEach === "function" && !source.hasOwnProperty("forEach")) {
        // copy map-alikes
        if (source.isMap === true) {
            source.forEach(function (value, key) {
                target[key] = value;
            });
        // iterate key value pairs of other iterables
        } else {
            source.forEach(function (pair) {
                target[pair[0]] = pair[1];
            });
        }
    } else if (typeof source.length === "number") {
        // arguments, strings
        for (var index = 0; index < source.length; index++) {
            target[index] = source[index];
        }
    } else {
        // copy other objects as map-alikes
        Object.keys(source).forEach(function (key) {
            target[key] = source[key];
        });
    }
    return target;
};

/**
    Iterates over the owned properties of an object.

    @function external:Object.forEach
    @param {Object} object an object to iterate.
    @param {Function} callback a function to call for every key and value
    pair in the object.  Receives <code>value</code>, <code>key</code>,
    and <code>object</code> as arguments.
    @param {Object} thisp the <code>this</code> to pass through to the
    callback
*/
Object.forEach = function (object, callback, thisp) {

    var keys = Object.keys(object), i = 0, iKey;
    for(;(iKey = keys[i]);i++) {
        callback.call(thisp, object[iKey], iKey, object);
    }

};

/**
    Iterates over the owned properties of a map, constructing a new array of
    mapped values.

    @function external:Object.map
    @param {Object} object an object to iterate.
    @param {Function} callback a function to call for every key and value
    pair in the object.  Receives <code>value</code>, <code>key</code>,
    and <code>object</code> as arguments.
    @param {Object} thisp the <code>this</code> to pass through to the
    callback
    @returns {Array} the respective values returned by the callback for each
    item in the object.
*/
Object.map = function (object, callback, thisp) {
    var keys = Object.keys(object), i = 0, result = [], iKey;
    for(;(iKey = keys[i]);i++) {
        result.push(callback.call(thisp, object[iKey], iKey, object));
    }
    return result;
};

/**
    Returns the values for owned properties of an object.

    @function external:Object.map
    @param {Object} object
    @returns {Array} the respective value for each owned property of the
    object.
*/
Object.values = function (object) {
    return Object.map(object, Function.identity);
};

// TODO inline document concat
Object.concat = function () {
    var object = {};
    for (var i = 0; i < arguments.length; i++) {
        Object.hiveAddEach(object, arguments[i]);
    }
    return object;
};

Object.from = Object.concat;

/**
    Returns whether two values are identical.  Any value is identical to itself
    and only itself.  This is much more restictive than equivalence and subtly
    different than strict equality, <code>===</code> because of edge cases
    including negative zero and <code>NaN</code>.  Identity is useful for
    resolving collisions among keys in a mapping where the domain is any value.
    This method does not delgate to any method on an object and cannot be
    overridden.
    @see http://wiki.ecmascript.org/doku.php?id=harmony:egal
    @param {Any} this
    @param {Any} that
    @returns {Boolean} whether this and that are identical
    @function external:Object.is
*/
Object.is = function (x, y) {
    if (x === y) {
        // 0 === -0, but they are not identical
        return x !== 0 || 1 / x === 1 / y;
    }
    // NaN !== NaN, but they are identical.
    // NaNs are the only non-reflexive value, i.e., if x !== x,
    // then x is a NaN.
    // isNaN is broken: it converts its argument to number, so
    // isNaN("foo") => true
    return x !== x && y !== y;
};

/**
    Performs a polymorphic, type-sensitive deep equivalence comparison of any
    two values.

    <p>As a basic principle, any value is equivalent to itself (as in
    identity), any boxed version of itself (as a <code>new Number(10)</code> is
    to 10), and any deep clone of itself.

    <p>Equivalence has the following properties:

    <ul>
        <li><strong>polymorphic:</strong>
            If the given object is an instance of a type that implements a
            methods named "equals", this function defers to the method.  So,
            this function can safely compare any values regardless of type,
            including undefined, null, numbers, strings, any pair of objects
            where either implements "equals", or object literals that may even
            contain an "equals" key.
        <li><strong>type-sensitive:</strong>
            Incomparable types are not equal.  No object is equivalent to any
            array.  No string is equal to any other number.
        <li><strong>deep:</strong>
            Collections with equivalent content are equivalent, recursively.
        <li><strong>equivalence:</strong>
            Identical values and objects are equivalent, but so are collections
            that contain equivalent content.  Whether order is important varies
            by type.  For Arrays and lists, order is important.  For Objects,
            maps, and sets, order is not important.  Boxed objects are mutally
            equivalent with their unboxed values, by virtue of the standard
            <code>valueOf</code> method.
    </ul>
    @param this
    @param that
    @returns {Boolean} whether the values are deeply equivalent
    @function external:Object.equals
*/
Object.equals = function (a, b, equals, memo) {
    equals = equals || Object.equals;
    // unbox objects, but do not confuse object literals
    a = Object.getValueOf(a);
    b = Object.getValueOf(b);
    if (a === b)
        return true;
    if (Object.isObject(a)) {
        memo = memo || new WeakMap();
        if (memo.has(a)) {
            return true;
        }
        memo.set(a, true);
    }
    if (Object.isObject(a) && typeof a.equals === "function") {
        return a.equals(b, equals, memo);
    }
    // commutative
    if (Object.isObject(b) && typeof b.equals === "function") {
        return b.equals(a, equals, memo);
    }
    if (Object.isObject(a) && Object.isObject(b)) {
        if (Object.getPrototypeOf(a) === Object.prototype && Object.getPrototypeOf(b) === Object.prototype) {
            for (var name in a) {
                if (!equals(a[name], b[name], equals, memo)) {
                    return false;
                }
            }
            for (var name in b) {
                if (!(name in a) || !equals(b[name], a[name], equals, memo)) {
                    return false;
                }
            }
            return true;
        }
    }
    // NaN !== NaN, but they are equal.
    // NaNs are the only non-reflexive value, i.e., if x !== x,
    // then x is a NaN.
    // isNaN is broken: it converts its argument to number, so
    // isNaN("foo") => true
    // We have established that a !== b, but if a !== a && b !== b, they are
    // both NaN.
    if (a !== a && b !== b)
        return true;
    if (!a || !b)
        return a === b;
    return false;
};

// Because a return value of 0 from a `compare` function  may mean either
// "equals" or "is incomparable", `equals` cannot be defined in terms of
// `compare`.  However, `compare` *can* be defined in terms of `equals` and
// `lessThan`.  Again however, more often it would be desirable to implement
// all of the comparison functions in terms of compare rather than the other
// way around.

/**
    Determines the order in which any two objects should be sorted by returning
    a number that has an analogous relationship to zero as the left value to
    the right.  That is, if the left is "less than" the right, the returned
    value will be "less than" zero, where "less than" may be any other
    transitive relationship.

    <p>Arrays are compared by the first diverging values, or by length.

    <p>Any two values that are incomparable return zero.  As such,
    <code>equals</code> should not be implemented with <code>compare</code>
    since incomparability is indistinguishable from equality.

    <p>Sorts strings lexicographically.  This is not suitable for any
    particular international setting.  Different locales sort their phone books
    in very different ways, particularly regarding diacritics and ligatures.

    <p>If the given object is an instance of a type that implements a method
    named "compare", this function defers to the instance.  The method does not
    need to be an owned property to distinguish it from an object literal since
    object literals are incomparable.  Unlike <code>Object</code> however,
    <code>Array</code> implements <code>compare</code>.

    @param {Any} left
    @param {Any} right
    @returns {Number} a value having the same transitive relationship to zero
    as the left and right values.
    @function external:Object.compare
*/
Object.compare = function (a, b) {
    // unbox objects, but do not confuse object literals
    // mercifully handles the Date case
    a = Object.getValueOf(a);
    b = Object.getValueOf(b);
    if (a === b)
        return 0;
    var aType = typeof a;
    var bType = typeof b;
    if (aType === "number" && bType === "number")
        return a - b;
    if (aType === "string" && bType === "string")
        return a < b ? -Infinity : Infinity;
        // the possibility of equality elimiated above
    if (a && typeof a.compare === "function")
        return a.compare(b);
    // not commutative, the relationship is reversed
    if (b && typeof b.compare === "function")
        return -b.compare(a);
    return 0;
};

/**
    Creates a deep copy of any value.  Values, being immutable, are
    returned without alternation.  Forwards to <code>clone</code> on
    objects and arrays.

    @function external:Object.clone
    @param {Any} value a value to clone
    @param {Number} depth an optional traversal depth, defaults to infinity.
    A value of <code>0</code> means to make no clone and return the value
    directly.
    @param {Map} memo an optional memo of already visited objects to preserve
    reference cycles.  The cloned object will have the exact same shape as the
    original, but no identical objects.  Te map may be later used to associate
    all objects in the original object graph with their corresponding member of
    the cloned graph.
    @returns a copy of the value
*/
Object.clone = function (value, depth, memo) {
    value = Object.getValueOf(value);
    memo = memo || new WeakMap();
    if (depth === undefined) {
        depth = Infinity;
    } else if (depth === 0) {
        return value;
    }
    if (Object.isObject(value)) {
        if (!memo.has(value)) {
            if (value && typeof value.clone === "function") {
                memo.set(value, value.clone(depth, memo));
            } else {
                var prototype = Object.getPrototypeOf(value);
                if (prototype === null || prototype === Object.prototype) {
                    var clone = Object.create(prototype);
                    memo.set(value, clone);
                    for (var key in value) {
                        clone[key] = Object.clone(value[key], depth - 1, memo);
                    }
                } else {
                    throw new Error("Can't clone " + value);
                }
            }
        }
        return memo.get(value);
    }
    return value;
};

/**
    Removes all properties owned by this object making the object suitable for
    reuse.

    @function external:Object.clear
    @returns this
*/
Object.clear = function (object) {
    if (object && typeof object.clear === "function") {
        object.clear();
    } else {
        var keys = Object.keys(object),
            i = keys.length;
        while (i) {
            i--;
            delete object[keys[i]];
        }
    }
    return object;
};


/***/ }),

/***/ "../../../node_modules/@hivestreaming/collections/shim-regexp.js":
/*!****************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/node_modules/@hivestreaming/collections/shim-regexp.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {


/**
    accepts a string; returns the string with regex metacharacters escaped.
    the returned string can safely be used within a regex to match a literal
    string. escaped characters are [, ], {, }, (, ), -, *, +, ?, ., \, ^, $,
    |, #, [comma], and whitespace.
*/
if (!RegExp.escape) {
    var special = /[-[\]{}()*+?.\\^$|,#\s]/g;
    RegExp.escape = function (string) {
        return string.replace(special, "\\$&");
    };
}



/***/ }),

/***/ "../../../node_modules/@hivestreaming/collections/shim.js":
/*!*********************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/node_modules/@hivestreaming/collections/shim.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


var Array = __webpack_require__(/*! ./shim-array */ "../../../node_modules/@hivestreaming/collections/shim-array.js");
var Object = __webpack_require__(/*! ./shim-object */ "../../../node_modules/@hivestreaming/collections/shim-object.js");
var Function = __webpack_require__(/*! ./shim-function */ "../../../node_modules/@hivestreaming/collections/shim-function.js");
var RegExp = __webpack_require__(/*! ./shim-regexp */ "../../../node_modules/@hivestreaming/collections/shim-regexp.js");



/***/ }),

/***/ "../../../node_modules/@hivestreaming/collections/sorted-array-set.js":
/*!*********************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/node_modules/@hivestreaming/collections/sorted-array-set.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = SortedArraySet;

var Shim = __webpack_require__(/*! ./shim */ "../../../node_modules/@hivestreaming/collections/shim.js");
var SortedArray = __webpack_require__(/*! ./sorted-array */ "../../../node_modules/@hivestreaming/collections/sorted-array.js");
var GenericSet = __webpack_require__(/*! ./generic-set */ "../../../node_modules/@hivestreaming/collections/generic-set.js");
var PropertyChanges = __webpack_require__(/*! ./listen/property-changes */ "../../../node_modules/@hivestreaming/collections/listen/property-changes.js");

function SortedArraySet(values, equals, compare, getDefault) {
    if (!(this instanceof SortedArraySet)) {
        return new SortedArraySet(values, equals, compare, getDefault);
    }
    SortedArray.call(this, values, equals, compare, getDefault);
}

// hack so require("sorted-array-set".SortedArraySet works in MontageJS
SortedArraySet.SortedArraySet = SortedArraySet;

SortedArraySet.prototype = Object.create(SortedArray.prototype);

SortedArraySet.prototype.constructor = SortedArraySet;

Object.hiveAddEach(SortedArraySet.prototype, GenericSet.prototype);
Object.hiveAddEach(SortedArraySet.prototype, PropertyChanges.prototype);

SortedArraySet.prototype.isSorted = true;

SortedArraySet.prototype.hiveAdd = function (value) {
    if (!this.has(value)) {
        SortedArray.prototype.hiveAdd.call(this, value);
        return true;
    } else {
        return false;
    }
};

SortedArraySet.prototype.reduce = function (callback, basis /*, thisp*/) {
    var self = this;
    var thisp = arguments[2];
    return this.array.reduce(function (basis, value, index) {
        return callback.call(thisp, basis, value, index, self);
    }, basis);
};

SortedArraySet.prototype.reduceRight = function (callback, basis /*, thisp*/) {
    var self = this;
    var thisp = arguments[2];
    return this.array.reduceRight(function (basis, value, index) {
        return callback.call(thisp, basis, value, index, self);
    }, basis);
};



/***/ }),

/***/ "../../../node_modules/@hivestreaming/collections/sorted-array.js":
/*!*****************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/node_modules/@hivestreaming/collections/sorted-array.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = SortedArray;

var Shim = __webpack_require__(/*! ./shim */ "../../../node_modules/@hivestreaming/collections/shim.js");
var GenericCollection = __webpack_require__(/*! ./generic-collection */ "../../../node_modules/@hivestreaming/collections/generic-collection.js");
var PropertyChanges = __webpack_require__(/*! ./listen/property-changes */ "../../../node_modules/@hivestreaming/collections/listen/property-changes.js");
var RangeChanges = __webpack_require__(/*! ./listen/range-changes */ "../../../node_modules/@hivestreaming/collections/listen/range-changes.js");

function SortedArray(values, equals, compare, getDefault) {
    if (!(this instanceof SortedArray)) {
        return new SortedArray(values, equals, compare, getDefault);
    }
    if (Array.isArray(values)) {
        this.array = values;
        values = values.splice(0, values.length);
    } else {
        this.array = [];
    }
    this.contentEquals = equals || Object.equals;
    this.contentCompare = compare || Object.compare;
    this.getDefault = getDefault || Function.noop;

    this.length = 0;
    this.hiveAddEach(values);
}

// hack so require("sorted-array").SortedArray will work in MontageJS
SortedArray.SortedArray = SortedArray;

Object.hiveAddEach(SortedArray.prototype, GenericCollection.prototype);
Object.hiveAddEach(SortedArray.prototype, PropertyChanges.prototype);
Object.hiveAddEach(SortedArray.prototype, RangeChanges.prototype);

SortedArray.prototype.isSorted = true;

function search(array, value, compare) {
    var first = 0;
    var last = array.length - 1;
    while (first <= last) {
        var middle = (first + last) >> 1; // Math.floor( / 2)
        var comparison = compare(value, array[middle]);
        if (comparison > 0) {
            first = middle + 1;
        } else if (comparison < 0) {
            last = middle - 1;
        } else {
            return middle;
        }
    }
    return -(first + 1);
}

function searchFirst(array, value, compare, equals) {
    var index = search(array, value, compare);
    if (index < 0) {
        return -1;
    } else {
        while (index > 0 && equals(value, array[index - 1])) {
            index--;
        }
        if (!equals(value, array[index])) {
            return -1;
        } else {
            return index;
        }
    }
}

function searchLast(array, value, compare, equals) {
    var index = search(array, value, compare);
    if (index < 0) {
        return -1;
    } else {
        while (index < array.length - 1 && equals(value, array[index + 1])) {
            index++;
        }
        if (!equals(value, array[index])) {
            return -1;
        } else {
            return index;
        }
    }
}

function searchForInsertionIndex(array, value, compare) {
    var index = search(array, value, compare);
    if (index < 0) {
        return -index - 1;
    } else {
        var last = array.length - 1;
        while (index < last && compare(value, array[index + 1]) === 0) {
            index++;
        }
        return index;
    }
}

SortedArray.prototype.constructClone = function (values) {
    return new this.constructor(
        values,
        this.contentEquals,
        this.contentCompare,
        this.getDefault
    );
};

SortedArray.prototype.has = function (value, equals) {
    if (equals) {
        throw new Error("SortedSet#has does not support second argument: equals");
    }
    var index = search(this.array, value, this.contentCompare);
    return index >= 0 && this.contentEquals(this.array[index], value);
};

SortedArray.prototype.get = function (value, equals) {
    if (equals) {
        throw new Error("SortedArray#get does not support second argument: equals");
    }
    var index = searchFirst(this.array, value, this.contentCompare, this.contentEquals);
    if (index !== -1) {
        return this.array[index];
    } else {
        return this.getDefault(value);
    }
};

SortedArray.prototype.hiveAdd = function (value) {
    var index = searchForInsertionIndex(this.array, value, this.contentCompare);
    if (this.dispatchesRangeChanges) {
        this.dispatchBeforeRangeChange([value], [], index);
    }
    this.array.splice(index, 0, value);
    this.length++;
    if (this.dispatchesRangeChanges) {
        this.dispatchRangeChange([value], [], index);
    }
    return true;
};

SortedArray.prototype["delete"] = function (value, equals) {
    if (equals) {
        throw new Error("SortedArray#delete does not support second argument: equals");
    }
    var index = searchFirst(this.array, value, this.contentCompare, this.contentEquals);
    if (index !== -1) {
        if (this.dispatchesRangeChanges) {
            this.dispatchBeforeRangeChange([], [value], index);
        }
        this.array.splice(index, 1);
        this.length--;
        if (this.dispatchesRangeChanges) {
            this.dispatchRangeChange([], [value], index);
        }
        return true;
    } else {
        return false;
    }
};

SortedArray.prototype.deleteAll = function (value, equals) {
    if (equals) {
        var count = this.array.deleteAll(value, equals);
        this.length -= count;
        return count;
    } else {
        var start = searchFirst(this.array, value, this.contentCompare, this.contentEquals);
        if (start !== -1) {
            var end = start;
            while (this.contentEquals(value, this.array[end])) {
                end++;
            }
            var minus = this.slice(start, end);
            if (this.dispatchesRangeChanges) {
                this.dispatchBeforeRangeChange([], minus, start);
            }
            this.array.splice(start, minus.length);
            this.length -= minus.length;
            if (this.dispatchesRangeChanges) {
                this.dispatchRangeChange([], minus, start);
            }
            return minus.length;
        } else {
            return 0;
        }
    }
};

SortedArray.prototype.indexOf = function (value) {
    // TODO throw error if provided a start index
    return searchFirst(this.array, value, this.contentCompare, this.contentEquals);
};

SortedArray.prototype.lastIndexOf = function (value) {
    // TODO throw error if provided a start index
    return searchLast(this.array, value, this.contentCompare, this.contentEquals);
};

SortedArray.prototype.find = function (value, equals, index) {
    // TODO throw error if provided a start index
    if (equals) {
        throw new Error("SortedArray#find does not support second argument: equals");
    }
    if (index) {
        throw new Error("SortedArray#find does not support third argument: index");
    }
    // TODO support initial partition index
    return searchFirst(this.array, value, this.contentCompare, this.contentEquals);
};

SortedArray.prototype.findLast = function (value, equals, index) {
    if (equals) {
        throw new Error("SortedArray#findLast does not support second argument: equals");
    }
    if (index) {
        throw new Error("SortedArray#findLast does not support third argument: index");
    }
    // TODO support initial partition index
    return searchLast(this.array, value, this.contentCompare, this.contentEquals);
};

SortedArray.prototype.push = function () {
    this.hiveAddEach(arguments);
};

SortedArray.prototype.unshift = function () {
    this.hiveAddEach(arguments);
};

SortedArray.prototype.pop = function () {
    var val = this.array.pop();
    this.length = this.array.length;
    return val;
};

SortedArray.prototype.shift = function () {
    var val = this.array.shift();
    this.length = this.array.length;
    return val;
};

SortedArray.prototype.slice = function () {
    return this.array.slice.apply(this.array, arguments);
};

SortedArray.prototype.splice = function (index, length /*...plus*/) {
    return this.swap(index, length, Array.prototype.slice.call(arguments, 2));
};

SortedArray.prototype.swap = function (index, length, plus) {
    if (index === undefined && length === undefined) {
        return [];
    }
    index = index || 0;
    if (index < 0) {
        index += this.length;
    }
    if (length === undefined) {
        length = Infinity;
    }
    var minus = this.slice(index, index + length);
    if (this.dispatchesRangeChanges) {
        this.dispatchBeforeRangeChange(plus, minus, index);
    }
    this.array.splice(index, length);
    this.length -= minus.length;
    if (this.dispatchesRangeChanges) {
        this.dispatchRangeChange([], minus, index);
    }
    this.hiveAddEach(plus);
    return minus;
};

SortedArray.prototype.reduce = function (callback, basis /*, thisp*/) {
    var thisp = arguments[2];
    return this.array.reduce(function (basis, value, key) {
        return callback.call(thisp, basis, value, key, this);
    }, basis, this);
};

SortedArray.prototype.reduceRight = function () {
    var thisp = arguments[2];
    return this.array.reduceRight(function (basis, value, key) {
        return callback.call(thisp, basis, value, key, this);
    }, basis, this);
};

SortedArray.prototype.min = function () {
    if (this.length) {
        return this.array[0];
    }
};

SortedArray.prototype.max = function () {
    if (this.length) {
        return this.array[this.length - 1];
    }
};

SortedArray.prototype.one = function () {
    return this.array.one();
};

SortedArray.prototype.clear = function () {
    var minus;
    if (this.dispatchesRangeChanges) {
        minus = this.array.slice();
        this.dispatchBeforeRangeChange([], minus, 0);
    }
    this.length = 0;
    this.array.clear();
    if (this.dispatchesRangeChanges) {
        this.dispatchRangeChange([], minus, 0);
    }
};

SortedArray.prototype.equals = function (that, equals) {
    return this.array.equals(that, equals);
};

SortedArray.prototype.compare = function (that, compare) {
    return this.array.compare(that, compare);
};

SortedArray.prototype.iterate = function (start, end) {
    return new this.Iterator(this.array, start, end);
};

SortedArray.prototype.toJSON = function () {
    return this.toArray();
};

SortedArray.prototype.Iterator = Array.prototype.Iterator;


/***/ }),

/***/ "../../../node_modules/@hivestreaming/collections/sorted-map.js":
/*!***************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/node_modules/@hivestreaming/collections/sorted-map.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Shim = __webpack_require__(/*! ./shim */ "../../../node_modules/@hivestreaming/collections/shim.js");
var SortedSet = __webpack_require__(/*! ./sorted-set */ "../../../node_modules/@hivestreaming/collections/sorted-set.js");
var GenericCollection = __webpack_require__(/*! ./generic-collection */ "../../../node_modules/@hivestreaming/collections/generic-collection.js");
var GenericMap = __webpack_require__(/*! ./generic-map */ "../../../node_modules/@hivestreaming/collections/generic-map.js");
var PropertyChanges = __webpack_require__(/*! ./listen/property-changes */ "../../../node_modules/@hivestreaming/collections/listen/property-changes.js");

module.exports = SortedMap;

function SortedMap(values, equals, compare, getDefault) {
    if (!(this instanceof SortedMap)) {
        return new SortedMap(values, equals, compare, getDefault);
    }
    equals = equals || Object.equals;
    compare = compare || Object.compare;
    getDefault = getDefault || Function.noop;
    this.contentEquals = equals;
    this.contentCompare = compare;
    this.getDefault = getDefault;
    this.store = new SortedSet(
        null,
        function keysEqual(a, b) {
            return equals(a.key, b.key);
        },
        function compareKeys(a, b) {
            return compare(a.key, b.key);
        }
    );
    this.length = 0;
    this.hiveAddEach(values);
}

// hack so require("sorted-map").SortedMap will work in MontageJS
SortedMap.SortedMap = SortedMap;

Object.hiveAddEach(SortedMap.prototype, GenericCollection.prototype);
Object.hiveAddEach(SortedMap.prototype, GenericMap.prototype);
Object.hiveAddEach(SortedMap.prototype, PropertyChanges.prototype);

SortedMap.prototype.constructClone = function (values) {
    return new this.constructor(
        values,
        this.contentEquals,
        this.contentCompare,
        this.getDefault
    );
};

SortedMap.prototype.log = function (charmap, logNode, callback, thisp) {
    logNode = logNode || this.logNode
    this.store.log(charmap, function (node, log, logBefore) {
        logNode(node.value, log, logBefore);
    }, callback, thisp);
};

SortedMap.prototype.logNode = function (node, log) {
    log(" key: " + node.key);
    log(" value: " + node.value);
};



/***/ }),

/***/ "../../../node_modules/@hivestreaming/collections/sorted-set.js":
/*!***************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/node_modules/@hivestreaming/collections/sorted-set.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = SortedSet;

var Shim = __webpack_require__(/*! ./shim */ "../../../node_modules/@hivestreaming/collections/shim.js");
var GenericCollection = __webpack_require__(/*! ./generic-collection */ "../../../node_modules/@hivestreaming/collections/generic-collection.js");
var GenericSet = __webpack_require__(/*! ./generic-set */ "../../../node_modules/@hivestreaming/collections/generic-set.js");
var PropertyChanges = __webpack_require__(/*! ./listen/property-changes */ "../../../node_modules/@hivestreaming/collections/listen/property-changes.js");
var RangeChanges = __webpack_require__(/*! ./listen/range-changes */ "../../../node_modules/@hivestreaming/collections/listen/range-changes.js");
var TreeLog = __webpack_require__(/*! ./tree-log */ "../../../node_modules/@hivestreaming/collections/tree-log.js");

function SortedSet(values, equals, compare, getDefault) {
    if (!(this instanceof SortedSet)) {
        return new SortedSet(values, equals, compare, getDefault);
    }
    this.contentEquals = equals || Object.equals;
    this.contentCompare = compare || Object.compare;
    this.getDefault = getDefault || Function.noop;
    this.root = null;
    this.length = 0;
    this.hiveAddEach(values);
}

// hack so require("sorted-set").SortedSet will work in MontageJS
SortedSet.SortedSet = SortedSet;

Object.hiveAddEach(SortedSet.prototype, GenericCollection.prototype);
Object.hiveAddEach(SortedSet.prototype, GenericSet.prototype);
Object.hiveAddEach(SortedSet.prototype, PropertyChanges.prototype);
Object.hiveAddEach(SortedSet.prototype, RangeChanges.prototype);

SortedSet.prototype.isSorted = true;

SortedSet.prototype.constructClone = function (values) {
    return new this.constructor(
        values,
        this.contentEquals,
        this.contentCompare,
        this.getDefault
    );
};

SortedSet.prototype.has = function (value, equals) {
    if (equals) {
        throw new Error("SortedSet#has does not support second argument: equals");
    }
    if (this.root) {
        this.splay(value);
        return this.contentEquals(value, this.root.value);
    } else {
        return false;
    }
};

SortedSet.prototype.get = function (value, equals) {
    if (equals) {
        throw new Error("SortedSet#get does not support second argument: equals");
    }
    if (this.root) {
        this.splay(value);
        if (this.contentEquals(value, this.root.value)) {
            return this.root.value;
        }
    }
    return this.getDefault(value);
};

SortedSet.prototype.hiveAdd = function (value) {
    var node = new this.Node(value);
    if (this.root) {
        this.splay(value);
        if (!this.contentEquals(value, this.root.value)) {
            var comparison = this.contentCompare(value, this.root.value);
            if (comparison === 0) {
                throw new Error("SortedSet cannot contain incomparable but inequal values: " + value + " and " + this.root.value);
            }
            if (this.dispatchesRangeChanges) {
                this.dispatchBeforeRangeChange([value], [], this.root.index);
            }
            if (comparison < 0) {
                // rotate right
                //   R        N
                //  / \  ->  / \
                // l   r    l   R
                // :   :    :    \
                //                r
                //                :
                node.right = this.root;
                node.left = this.root.left;
                this.root.left = null;
                this.root.touch();
            } else {
                // rotate left
                //   R        N
                //  / \  ->  / \
                // l   r    R   r
                // :   :   /    :
                //        l
                //        :
                node.left = this.root;
                node.right = this.root.right;
                this.root.right = null;
                this.root.touch();
            }
            node.touch();
            this.root = node;
            this.length++;
            if (this.dispatchesRangeChanges) {
                this.dispatchRangeChange([value], [], this.root.index);
            }
            return true;
        }
    } else {
        if (this.dispatchesRangeChanges) {
            this.dispatchBeforeRangeChange([value], [], 0);
        }
        this.root = node;
        this.length++;
        if (this.dispatchesRangeChanges) {
            this.dispatchRangeChange([value], [], 0);
        }
        return true;
    }
    return false;
};

SortedSet.prototype['delete'] = function (value, equals) {
    if (equals) {
        throw new Error("SortedSet#delete does not support second argument: equals");
    }
    if (this.root) {
        this.splay(value);
        if (this.contentEquals(value, this.root.value)) {
            var index = this.root.index;
            if (this.dispatchesRangeChanges) {
                this.dispatchBeforeRangeChange([], [value], index);
            }
            if (!this.root.left) {
                this.root = this.root.right;
            } else {
                // remove the right side of the tree,
                var right = this.root.right;
                this.root = this.root.left;
                // the tree now only contains the left side of the tree, so all
                // values are less than the value deleted.
                // splay so that the root has an empty right child
                this.splay(value);
                // put the right side of the tree back
                this.root.right = right;
            }
            this.length--;
            if (this.root) {
                this.root.touch();
            }
            if (this.dispatchesRangeChanges) {
                this.dispatchRangeChange([], [value], index);
            }
            return true;
        }
    }
    return false;
};

SortedSet.prototype.indexOf = function (value, index) {
    if (index) {
        throw new Error("SortedSet#indexOf does not support second argument: startIndex");
    }
    if (this.root) {
        this.splay(value);
        if (this.contentEquals(value, this.root.value)) {
            return this.root.index;
        }
    }
    return -1;
};

SortedSet.prototype.find = function (value, equals, index) {
    if (equals) {
        throw new Error("SortedSet#find does not support second argument: equals");
    }
    if (index) {
        // TODO contemplate using splayIndex to isolate a subtree in
        // which to search.
        throw new Error("SortedSet#find does not support third argument: index");
    }
    if (this.root) {
        this.splay(value);
        if (this.contentEquals(value, this.root.value)) {
            return this.root;
        }
    }
};

SortedSet.prototype.findGreatest = function (at) {
    if (this.root) {
        at = at || this.root;
        while (at.right) {
            at = at.right;
        }
        return at;
    }
};

SortedSet.prototype.findLeast = function (at) {
    if (this.root) {
        at = at || this.root;
        while (at.left) {
            at = at.left;
        }
        return at;
    }
};

SortedSet.prototype.findGreatestLessThanOrEqual = function (value) {
    if (this.root) {
        this.splay(value);
        if (this.contentCompare(this.root.value, value) > 0) {
            return this.root.getPrevious();
        } else {
            return this.root;
        }
    }
};

SortedSet.prototype.findGreatestLessThan = function (value) {
    if (this.root) {
        this.splay(value);
        if (this.contentCompare(this.root.value, value) >= 0) {
            return this.root.getPrevious();
        } else {
            return this.root;
        }
    }
};

SortedSet.prototype.findLeastGreaterThanOrEqual = function (value) {
    if (this.root) {
        this.splay(value);
        if (this.contentCompare(this.root.value, value) >= 0) {
            return this.root;
        } else {
            return this.root.getNext();
        }
    }
};

SortedSet.prototype.findLeastGreaterThan = function (value) {
    if (this.root) {
        this.splay(value);
        if (this.contentCompare(this.root.value, value) <= 0) {
            return this.root.getNext();
        } else {
            return this.root;
        }
    }
};

SortedSet.prototype.pop = function () {
    if (this.root) {
        var found = this.findGreatest();
        this["delete"](found.value);
        return found.value;
    }
};

SortedSet.prototype.shift = function () {
    if (this.root) {
        var found = this.findLeast();
        this["delete"](found.value);
        return found.value;
    }
};

SortedSet.prototype.push = function () {
    this.hiveAddEach(arguments);
};

SortedSet.prototype.unshift = function () {
    this.hiveAddEach(arguments);
};

SortedSet.prototype.slice = function (start, end) {
    var temp;
    start = start || 0;
    end = end || this.length;
    if (start < 0) {
        start += this.length;
    }
    if (end < 0) {
        end += this.length;
    }
    var sliced = [];
    if (this.root) {
        this.splayIndex(start);
        while (this.root.index < end) {
            sliced.push(this.root.value);
            if (!this.root.right) {
                break;
            }
            this.splay(this.root.getNext().value);
        }
    }
    return sliced;
};

SortedSet.prototype.splice = function (at, length /*...plus*/) {
    return this.swap(at, length, Array.prototype.slice.call(arguments, 2));
};

SortedSet.prototype.swap = function (start, length, plus) {
    if (start === undefined && length === undefined) {
        return [];
    }
    start = start || 0;
    if (start < 0) {
        start += this.length;
    }
    if (length === undefined) {
        length = Infinity;
    }
    var swapped = [];

    if (this.root) {

        // start
        this.splayIndex(start);

        // minus length
        for (var i = 0; i < length; i++) {
            swapped.push(this.root.value);
            var next = this.root.getNext();
            this["delete"](this.root.value);
            if (!next) {
                break;
            }
            this.splay(next.value);
        }
    }

    // plus
    this.hiveAddEach(plus);

    return swapped;
};

// This is the simplified top-down splaying algorithm from: "Self-adjusting
// Binary Search Trees" by Sleator and Tarjan. Guarantees that root.value
// equals value if value exists. If value does not exist, then root will be
// the node whose value either immediately preceeds or immediately follows value.
// - as described in https://github.com/hij1nx/forest
SortedSet.prototype.splay = function (value) {
    var stub, left, right, temp, root, history;

    if (!this.root) {
        return;
    }

    // Create a stub node.  The use of the stub node is a bit
    // counter-intuitive: The right child of the stub node will hold the L tree
    // of the algorithm.  The left child of the stub node will hold the R tree
    // of the algorithm.  Using a stub node, left and right will always be
    // nodes and we avoid special cases.
    // - http://code.google.com/p/v8/source/browse/branches/bleeding_edge/src/splay-tree-inl.h
    stub = left = right = new this.Node();
    // The history is an upside down tree used to propagate new tree sizes back
    // up the left and right arms of a traversal.  The right children of the
    // transitive left side of the tree will be former roots while linking
    // left.  The left children of the transitive walk to the right side of the
    // history tree will all be previous roots from linking right.  The last
    // node of the left and right traversal will each become a child of the new
    // root.
    history = new this.Node();
    root = this.root;

    while (true) {
        var comparison = this.contentCompare(value, root.value);
        if (comparison < 0) {
            if (root.left) {
                if (this.contentCompare(value, root.left.value) < 0) {
                    // rotate right
                    //        Root         L(temp)
                    //      /     \       / \
                    //     L(temp) R    LL    Root
                    //    / \                /    \
                    //  LL   LR            LR      R
                    temp = root.left;
                    root.left = temp.right;
                    root.touch();
                    temp.right = root;
                    temp.touch();
                    root = temp;
                    if (!root.left) {
                        break;
                    }
                }
                // remember former root for repropagating length
                temp = new Node();
                temp.right = root;
                temp.left = history.left;
                history.left = temp;
                // link left
                right.left = root;
                right.touch();
                right = root;
                root = root.left;
            } else {
                break;
            }
        } else if (comparison > 0) {
            if (root.right) {
                if (this.contentCompare(value, root.right.value) > 0) {
                    // rotate left
                    //        Root         L(temp)
                    //      /     \       / \
                    //     L(temp) R    LL    Root
                    //    / \                /    \
                    //  LL   LR            LR      R
                    temp = root.right;
                    root.right = temp.left;
                    root.touch();
                    temp.left = root;
                    temp.touch();
                    root = temp;
                    if (!root.right) {
                        break;
                    }
                }
                // remember former root for repropagating length
                temp = new Node();
                temp.left = root;
                temp.right = history.right;
                history.right = temp;
                // link right
                left.right = root;
                left.touch();
                left = root;
                root = root.right;
            } else {
                break;
            }
        } else { // equal or incomparable
            break;
        }
    }

    // reassemble
    left.right = root.left;
    left.touch();
    right.left = root.right;
    right.touch();
    root.left = stub.right;
    root.right = stub.left;

    // propagate new lengths
    while (history.left) {
        history.left.right.touch();
        history.left = history.left.left;
    }
    while (history.right) {
        history.right.left.touch();
        history.right = history.right.right;
    }
    root.touch();

    this.root = root;
};

// an internal utility for splaying a node based on its index
SortedSet.prototype.splayIndex = function (index) {
    if (this.root) {
        var at = this.root;
        var atIndex = this.root.index;

        while (atIndex !== index) {
            if (atIndex > index && at.left) {
                at = at.left;
                atIndex -= 1 + (at.right ? at.right.length : 0);
            } else if (atIndex < index && at.right) {
                at = at.right;
                atIndex += 1 + (at.left ? at.left.length : 0);
            } else {
                break;
            }
        }

        this.splay(at.value);

        return this.root.index === index;
    }
    return false;
};

SortedSet.prototype.reduce = function (callback, basis, thisp) {
    if (this.root) {
        basis = this.root.reduce(callback, basis, 0, thisp, this);
    }
    return basis;
};

SortedSet.prototype.reduceRight = function (callback, basis, thisp) {
    if (this.root) {
        basis = this.root.reduceRight(callback, basis, this.length - 1, thisp, this);
    }
    return basis;
};

SortedSet.prototype.min = function (at) {
    var least = this.findLeast(at);
    if (least) {
        return least.value;
    }
};

SortedSet.prototype.max = function (at) {
    var greatest = this.findGreatest(at);
    if (greatest) {
        return greatest.value;
    }
};

SortedSet.prototype.one = function () {
    return this.min();
};

SortedSet.prototype.clear = function () {
    var minus;
    if (this.dispatchesRangeChanges) {
        minus = this.toArray();
        this.dispatchBeforeRangeChange([], minus, 0);
    }
    this.root = null;
    this.length = 0;
    if (this.dispatchesRangeChanges) {
        this.dispatchRangeChange([], minus, 0);
    }
};

SortedSet.prototype.iterate = function (start, end) {
    return new this.Iterator(this, start, end);
};

SortedSet.prototype.Iterator = Iterator;

SortedSet.prototype.summary = function () {
    if (this.root) {
        return this.root.summary();
    } else {
        return "()";
    }
};

SortedSet.prototype.log = function (charmap, logNode, callback, thisp) {
    charmap = charmap || TreeLog.unicodeRound;
    logNode = logNode || this.logNode;
    if (!callback) {
        callback = console.log;
        thisp = console;
    }
    callback = callback.bind(thisp);
    if (this.root) {
        this.root.log(charmap, logNode, callback, callback);
    }
};

SortedSet.prototype.logNode = function (node, log, logBefore) {
    log(" " + node.value);
};

SortedSet.logCharsets = TreeLog;

SortedSet.prototype.Node = Node;

function Node(value) {
    this.value = value;
    this.left = null;
    this.right = null;
    this.length = 1;
}

// TODO case where no basis is provided for reduction

Node.prototype.reduce = function (callback, basis, index, thisp, tree, depth) {
    depth = depth || 0;
    if (this.left) {
        // prerecord length to be resistant to mutation
        var length = this.left.length;
        basis = this.left.reduce(callback, basis, index, thisp, tree, depth + 1);
        index += length;
    }
    basis = callback.call(thisp, basis, this.value, index, tree, this, depth);
    index += 1;
    if (this.right) {
        basis = this.right.reduce(callback, basis, index, thisp, tree, depth + 1);
    }
    return basis;
};

Node.prototype.reduceRight = function (callback, basis, index, thisp, tree, depth) {
    depth = depth || 0;
    if (this.right) {
        basis = this.right.reduce(callback, basis, index, thisp, tree, depth + 1);
        index -= this.right.length;
    }
    basis = callback.call(thisp, basis, this.value, this.value, tree, this, depth);
    index -= 1;
    if (this.left) {
        basis = this.left.reduce(callback, basis, index, thisp, tree, depth + 1);
    }
    return basis;
};

Node.prototype.touch = function () {
    this.length = 1 +
        (this.left ? this.left.length : 0) +
        (this.right ? this.right.length : 0);
    this.index = this.left ? this.left.length : 0;
};

Node.prototype.checkIntegrity = function () {
    var length = 1;
    length += this.left ? this.left.checkIntegrity() : 0;
    length += this.right ? this.right.checkIntegrity() : 0;
    if (this.length !== length)
        throw new Error("Integrity check failed: " + this.summary());
    return length;
}

// get the next node in this subtree
Node.prototype.getNext = function () {
    var node = this;
    if (node.right) {
        node = node.right;
        while (node.left) {
            node = node.left;
        }
        return node;
    }
};

// get the previous node in this subtree
Node.prototype.getPrevious = function () {
    var node = this;
    if (node.left) {
        node = node.left;
        while (node.right) {
            node = node.right;
        }
        return node;
    }
};

Node.prototype.summary = function () {
    var value = this.value || "-";
    value += " <" + this.length;
    if (!this.left && !this.right) {
        return "(" + value + ")";
    }
    return "(" + value + " " + (
        this.left ? this.left.summary() : "()"
    ) + ", " + (
        this.right ? this.right.summary() : "()"
    ) + ")";
};

Node.prototype.log = function (charmap, logNode, log, logAbove) {
    var self = this;

    var branch;
    if (this.left && this.right) {
        branch = charmap.intersection;
    } else if (this.left) {
        branch = charmap.branchUp;
    } else if (this.right) {
        branch = charmap.branchDown;
    } else {
        branch = charmap.through;
    }

    var loggedAbove;
    this.left && this.left.log(
        charmap,
        logNode,
        function innerWrite(line) {
            if (!loggedAbove) {
                loggedAbove = true;
                // leader
                logAbove(charmap.fromBelow + charmap.through + line);
            } else {
                // below
                logAbove(charmap.strafe + " " + line);
            }
        },
        function innerWriteAbove(line) {
            // above
            logAbove("  " + line);
        }
    );

    var loggedOn;
    logNode(
        this,
        function innerWrite(line) {
            if (!loggedOn) {
                loggedOn = true;
                log(branch + line);
            } else {
                log((self.right ? charmap.strafe : " ") + line);
            }
        },
        function innerWriteAbove(line) {
            logAbove((self.left ? charmap.strafe : " ") + line);
        }
    );

    var loggedBelow;
    this.right && this.right.log(
        charmap,
        logNode,
        function innerWrite(line) {
            if (!loggedBelow) {
                loggedBelow = true;
                log(charmap.fromAbove + charmap.through + line);
            } else {
                log("  " + line);
            }
        },
        function innerWriteAbove(line) {
            log(charmap.strafe + " " + line);
        }
    );
};

function Iterator(set, start, end) {
    this.set = set;
    this.prev = null;
    this.end = end;
    if (start) {
        var next = this.set.findLeastGreaterThanOrEqual(start);
        if (next) {
            this.set.splay(next.value);
            this.prev = next.getPrevious();
        }
    }
}
Iterator.prototype.__iterationObject = null;
Object.defineProperty(Iterator.prototype,"_iterationObject", {
    get: function() {
        return this.__iterationObject || (this.__iterationObject = { done: false, value:null});
    }
});

Iterator.prototype.next = function () {
    var next;
    if (this.prev) {
        next = this.set.findLeastGreaterThan(this.prev.value);
    } else {
        next = this.set.findLeast();
    }
    if (!next) {
        this._iterationObject.done = true;
        this._iterationObject.value = void 0;
    }
    else {
        if (
            this.end !== undefined &&
            this.set.contentCompare(next.value, this.end) >= 0
        ) {
            this._iterationObject.done = true;
            this._iterationObject.value = void 0;
        }
        else {
            this.prev = next;
            this._iterationObject.value =  next.value;
        }

    }
    return this._iterationObject;
};


/***/ }),

/***/ "../../../node_modules/@hivestreaming/collections/tree-log.js":
/*!*************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/node_modules/@hivestreaming/collections/tree-log.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = TreeLog;

function TreeLog() {
}

TreeLog.ascii = {
    intersection: "+",
    through: "-",
    branchUp: "+",
    branchDown: "+",
    fromBelow: ".",
    fromAbove: "'",
    fromBoth: "+",
    strafe: "|"
};

TreeLog.unicodeRound = {
    intersection: "\u254b",
    through: "\u2501",
    branchUp: "\u253b",
    branchDown: "\u2533",
    fromBelow: "\u256d", // round corner
    fromAbove: "\u2570", // round corner
    fromBoth: "\u2523",
    strafe: "\u2503"
};

TreeLog.unicodeSharp = {
    intersection: "\u254b",
    through: "\u2501",
    branchUp: "\u253b",
    branchDown: "\u2533",
    fromBelow: "\u250f", // sharp corner
    fromAbove: "\u2517", // sharp corner
    fromBoth: "\u2523",
    strafe: "\u2503"
};



/***/ }),

/***/ "../../../node_modules/@hivestreaming/dashjs/build/es5/externals/xml2json.js":
/*!****************************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/node_modules/@hivestreaming/dashjs/build/es5/externals/xml2json.js ***!
  \****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
Object.defineProperty(exports,"__esModule",{value:true});/*
 Copyright 2011-2013 Abdulla Abdurakhmanov
 Original sources are available at https://code.google.com/p/x2js/

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
 *//*
  Further modified for dashjs to:
  - keep track of children nodes in order in attribute __children.
  - add type conversion matchers
  - re-add ignoreRoot
  - allow zero-length attributePrefix
  - don't add white-space text nodes
  - remove explicit RequireJS support
*/function X2JS(config){'use strict';var VERSION="1.2.0";config=config||{};initConfigDefaults();initRequiredPolyfills();function initConfigDefaults(){if(config.escapeMode===undefined){config.escapeMode=true;}if(config.attributePrefix===undefined){config.attributePrefix="_";}config.arrayAccessForm=config.arrayAccessForm||"none";config.emptyNodeForm=config.emptyNodeForm||"text";if(config.enableToStringFunc===undefined){config.enableToStringFunc=true;}config.arrayAccessFormPaths=config.arrayAccessFormPaths||[];if(config.skipEmptyTextNodesForObj===undefined){config.skipEmptyTextNodesForObj=true;}if(config.stripWhitespaces===undefined){config.stripWhitespaces=true;}config.datetimeAccessFormPaths=config.datetimeAccessFormPaths||[];if(config.useDoubleQuotes===undefined){config.useDoubleQuotes=false;}config.xmlElementsFilter=config.xmlElementsFilter||[];config.jsonPropertiesFilter=config.jsonPropertiesFilter||[];if(config.keepCData===undefined){config.keepCData=false;}if(config.ignoreRoot===undefined){config.ignoreRoot=false;}}var DOMNodeTypes={ELEMENT_NODE:1,TEXT_NODE:3,CDATA_SECTION_NODE:4,COMMENT_NODE:8,DOCUMENT_NODE:9};function initRequiredPolyfills(){}function getNodeLocalName(node){var nodeLocalName=node.localName;if(nodeLocalName==null)// Yeah, this is IE!!
nodeLocalName=node.baseName;if(nodeLocalName==null||nodeLocalName=="")// =="" is IE too
nodeLocalName=node.nodeName;return nodeLocalName;}function getNodePrefix(node){return node.prefix;}function escapeXmlChars(str){if(typeof str=="string")return str.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;').replace(/'/g,'&apos;');else return str;}function unescapeXmlChars(str){return str.replace(/&lt;/g,'<').replace(/&gt;/g,'>').replace(/&quot;/g,'"').replace(/&apos;/g,"'").replace(/&amp;/g,'&');}function checkInStdFiltersArrayForm(stdFiltersArrayForm,obj,name,path){var idx=0;for(;idx<stdFiltersArrayForm.length;idx++){var filterPath=stdFiltersArrayForm[idx];if(typeof filterPath==="string"){if(filterPath==path)break;}else if(filterPath instanceof RegExp){if(filterPath.test(path))break;}else if(typeof filterPath==="function"){if(filterPath(obj,name,path))break;}}return idx!=stdFiltersArrayForm.length;}function toArrayAccessForm(obj,childName,path){switch(config.arrayAccessForm){case"property":if(!(obj[childName]instanceof Array))obj[childName+"_asArray"]=[obj[childName]];else obj[childName+"_asArray"]=obj[childName];break;/*case "none":
                break;*/}if(!(obj[childName]instanceof Array)&&config.arrayAccessFormPaths.length>0){if(checkInStdFiltersArrayForm(config.arrayAccessFormPaths,obj,childName,path)){obj[childName]=[obj[childName]];}}}function fromXmlDateTime(prop){// Implementation based up on http://stackoverflow.com/questions/8178598/xml-datetime-to-javascript-date-object
// Improved to support full spec and optional parts
var bits=prop.split(/[-T:+Z]/g);var d=new Date(bits[0],bits[1]-1,bits[2]);var secondBits=bits[5].split("\.");d.setHours(bits[3],bits[4],secondBits[0]);if(secondBits.length>1)d.setMilliseconds(secondBits[1]);// Get supplied time zone offset in minutes
if(bits[6]&&bits[7]){var offsetMinutes=bits[6]*60+Number(bits[7]);var sign=/\d\d-\d\d:\d\d$/.test(prop)?'-':'+';// Apply the sign
offsetMinutes=0+(sign=='-'?-1*offsetMinutes:offsetMinutes);// Apply offset and local timezone
d.setMinutes(d.getMinutes()-offsetMinutes-d.getTimezoneOffset());}else if(prop.indexOf("Z",prop.length-1)!==-1){d=new Date(Date.UTC(d.getFullYear(),d.getMonth(),d.getDate(),d.getHours(),d.getMinutes(),d.getSeconds(),d.getMilliseconds()));}// d is now a local time equivalent to the supplied time
return d;}function checkFromXmlDateTimePaths(value,childName,fullPath){if(config.datetimeAccessFormPaths.length>0){var path=fullPath.split("\.#")[0];if(checkInStdFiltersArrayForm(config.datetimeAccessFormPaths,value,childName,path)){return fromXmlDateTime(value);}else return value;}else return value;}function checkXmlElementsFilter(obj,childType,childName,childPath){if(childType==DOMNodeTypes.ELEMENT_NODE&&config.xmlElementsFilter.length>0){return checkInStdFiltersArrayForm(config.xmlElementsFilter,obj,childName,childPath);}else return true;}function parseDOMChildren(node,path){if(node.nodeType==DOMNodeTypes.DOCUMENT_NODE){var result=new Object();var nodeChildren=node.childNodes;// Alternative for firstElementChild which is not supported in some environments
for(var cidx=0;cidx<nodeChildren.length;cidx++){var child=nodeChildren[cidx];if(child.nodeType==DOMNodeTypes.ELEMENT_NODE){if(config.ignoreRoot){result=parseDOMChildren(child);}else{result={};var childName=getNodeLocalName(child);result[childName]=parseDOMChildren(child);}}}return result;}else if(node.nodeType==DOMNodeTypes.ELEMENT_NODE){var result=new Object();result.__cnt=0;var children=[];var nodeChildren=node.childNodes;// Children nodes
for(var cidx=0;cidx<nodeChildren.length;cidx++){var child=nodeChildren[cidx];var childName=getNodeLocalName(child);if(child.nodeType!=DOMNodeTypes.COMMENT_NODE){var childPath=path+"."+childName;if(checkXmlElementsFilter(result,child.nodeType,childName,childPath)){result.__cnt++;if(result[childName]==null){var c=parseDOMChildren(child,childPath);if(childName!="#text"||/[^\s]/.test(c)){var o={};o[childName]=c;children.push(o);}result[childName]=c;toArrayAccessForm(result,childName,childPath);}else{if(result[childName]!=null){if(!(result[childName]instanceof Array)){result[childName]=[result[childName]];toArrayAccessForm(result,childName,childPath);}}var c=parseDOMChildren(child,childPath);if(childName!="#text"||/[^\s]/.test(c)){// Don't add white-space text nodes
var o={};o[childName]=c;children.push(o);}result[childName][result[childName].length]=c;}}}}result.__children=children;// Attributes
var nodeLocalName=getNodeLocalName(node);for(var aidx=0;aidx<node.attributes.length;aidx++){var attr=node.attributes[aidx];result.__cnt++;var value2=attr.value;if(Array.isArray(config.matchers)){for(var m=0,ml=config.matchers.length;m<ml;m++){var matchobj=config.matchers[m];if(matchobj.test(attr,nodeLocalName))value2=matchobj.converter(attr.value);}}result[config.attributePrefix+attr.name]=value2;}// Node namespace prefix
var nodePrefix=getNodePrefix(node);if(nodePrefix!=null&&nodePrefix!=""){result.__cnt++;result.__prefix=nodePrefix;}if(result["#text"]!=null){result.__text=result["#text"];if(result.__text instanceof Array){result.__text=result.__text.join("\n");}//if(config.escapeMode)
//	result.__text = unescapeXmlChars(result.__text);
if(config.stripWhitespaces)result.__text=result.__text.trim();delete result["#text"];if(config.arrayAccessForm=="property")delete result["#text_asArray"];result.__text=checkFromXmlDateTimePaths(result.__text,childName,path+"."+childName);}if(result["#cdata-section"]!=null){result.__cdata=result["#cdata-section"];delete result["#cdata-section"];if(config.arrayAccessForm=="property")delete result["#cdata-section_asArray"];}if(result.__cnt==0&&config.emptyNodeForm=="text"){result='';}else if(result.__cnt==1&&result.__text!=null){result=result.__text;}else if(result.__cnt==1&&result.__cdata!=null&&!config.keepCData){result=result.__cdata;}else if(result.__cnt>1&&result.__text!=null&&config.skipEmptyTextNodesForObj){if(config.stripWhitespaces&&result.__text==""||result.__text.trim()==""){delete result.__text;}}delete result.__cnt;if(config.enableToStringFunc&&(result.__text!=null||result.__cdata!=null)){result.toString=function(){return(this.__text!=null?this.__text:'')+(this.__cdata!=null?this.__cdata:'');};}return result;}else if(node.nodeType==DOMNodeTypes.TEXT_NODE||node.nodeType==DOMNodeTypes.CDATA_SECTION_NODE){return node.nodeValue;}}function startTag(jsonObj,element,attrList,closed){var resultStr="<"+(jsonObj!=null&&jsonObj.__prefix!=null?jsonObj.__prefix+":":"")+element;if(attrList!=null){for(var aidx=0;aidx<attrList.length;aidx++){var attrName=attrList[aidx];var attrVal=jsonObj[attrName];if(config.escapeMode)attrVal=escapeXmlChars(attrVal);resultStr+=" "+attrName.substr(config.attributePrefix.length)+"=";if(config.useDoubleQuotes)resultStr+='"'+attrVal+'"';else resultStr+="'"+attrVal+"'";}}if(!closed)resultStr+=">";else resultStr+="/>";return resultStr;}function endTag(jsonObj,elementName){return"</"+(jsonObj.__prefix!=null?jsonObj.__prefix+":":"")+elementName+">";}function endsWith(str,suffix){return str.indexOf(suffix,str.length-suffix.length)!==-1;}function jsonXmlSpecialElem(jsonObj,jsonObjField){if(config.arrayAccessForm=="property"&&endsWith(jsonObjField.toString(),"_asArray")||jsonObjField.toString().indexOf(config.attributePrefix)==0||jsonObjField.toString().indexOf("__")==0||jsonObj[jsonObjField]instanceof Function)return true;else return false;}function jsonXmlElemCount(jsonObj){var elementsCnt=0;if(jsonObj instanceof Object){for(var it in jsonObj){if(jsonXmlSpecialElem(jsonObj,it))continue;elementsCnt++;}}return elementsCnt;}function checkJsonObjPropertiesFilter(jsonObj,propertyName,jsonObjPath){return config.jsonPropertiesFilter.length==0||jsonObjPath==""||checkInStdFiltersArrayForm(config.jsonPropertiesFilter,jsonObj,propertyName,jsonObjPath);}function parseJSONAttributes(jsonObj){var attrList=[];if(jsonObj instanceof Object){for(var ait in jsonObj){if(ait.toString().indexOf("__")==-1&&ait.toString().indexOf(config.attributePrefix)==0){attrList.push(ait);}}}return attrList;}function parseJSONTextAttrs(jsonTxtObj){var result="";if(jsonTxtObj.__cdata!=null){result+="<![CDATA["+jsonTxtObj.__cdata+"]]>";}if(jsonTxtObj.__text!=null){if(config.escapeMode)result+=escapeXmlChars(jsonTxtObj.__text);else result+=jsonTxtObj.__text;}return result;}function parseJSONTextObject(jsonTxtObj){var result="";if(jsonTxtObj instanceof Object){result+=parseJSONTextAttrs(jsonTxtObj);}else if(jsonTxtObj!=null){if(config.escapeMode)result+=escapeXmlChars(jsonTxtObj);else result+=jsonTxtObj;}return result;}function getJsonPropertyPath(jsonObjPath,jsonPropName){if(jsonObjPath===""){return jsonPropName;}else return jsonObjPath+"."+jsonPropName;}function parseJSONArray(jsonArrRoot,jsonArrObj,attrList,jsonObjPath){var result="";if(jsonArrRoot.length==0){result+=startTag(jsonArrRoot,jsonArrObj,attrList,true);}else{for(var arIdx=0;arIdx<jsonArrRoot.length;arIdx++){result+=startTag(jsonArrRoot[arIdx],jsonArrObj,parseJSONAttributes(jsonArrRoot[arIdx]),false);result+=parseJSONObject(jsonArrRoot[arIdx],getJsonPropertyPath(jsonObjPath,jsonArrObj));result+=endTag(jsonArrRoot[arIdx],jsonArrObj);}}return result;}function parseJSONObject(jsonObj,jsonObjPath){var result="";var elementsCnt=jsonXmlElemCount(jsonObj);if(elementsCnt>0){for(var it in jsonObj){if(jsonXmlSpecialElem(jsonObj,it)||jsonObjPath!=""&&!checkJsonObjPropertiesFilter(jsonObj,it,getJsonPropertyPath(jsonObjPath,it)))continue;var subObj=jsonObj[it];var attrList=parseJSONAttributes(subObj);if(subObj==null||subObj==undefined){result+=startTag(subObj,it,attrList,true);}else if(subObj instanceof Object){if(subObj instanceof Array){result+=parseJSONArray(subObj,it,attrList,jsonObjPath);}else if(subObj instanceof Date){result+=startTag(subObj,it,attrList,false);result+=subObj.toISOString();result+=endTag(subObj,it);}else{var subObjElementsCnt=jsonXmlElemCount(subObj);if(subObjElementsCnt>0||subObj.__text!=null||subObj.__cdata!=null){result+=startTag(subObj,it,attrList,false);result+=parseJSONObject(subObj,getJsonPropertyPath(jsonObjPath,it));result+=endTag(subObj,it);}else{result+=startTag(subObj,it,attrList,true);}}}else{result+=startTag(subObj,it,attrList,false);result+=parseJSONTextObject(subObj);result+=endTag(subObj,it);}}}result+=parseJSONTextObject(jsonObj);return result;}this.parseXmlString=function(xmlDocStr){var isIEParser=window.ActiveXObject||"ActiveXObject"in window;if(xmlDocStr===undefined){return null;}var xmlDoc;if(window.DOMParser){var parser=new window.DOMParser();var parsererrorNS=null;try{xmlDoc=parser.parseFromString(xmlDocStr,"text/xml");if(xmlDoc.getElementsByTagNameNS("*","parsererror").length>0){xmlDoc=null;}}catch(err){xmlDoc=null;}}else{// IE :(
if(xmlDocStr.indexOf("<?")==0){xmlDocStr=xmlDocStr.substr(xmlDocStr.indexOf("?>")+2);}xmlDoc=new ActiveXObject("Microsoft.XMLDOM");xmlDoc.async="false";xmlDoc.loadXML(xmlDocStr);}return xmlDoc;};this.asArray=function(prop){if(prop===undefined||prop==null)return[];else if(prop instanceof Array)return prop;else return[prop];};this.toXmlDateTime=function(dt){if(dt instanceof Date)return dt.toISOString();else if(typeof dt==='number')return new Date(dt).toISOString();else return null;};this.asDateTime=function(prop){if(typeof prop=="string"){return fromXmlDateTime(prop);}else return prop;};this.xml2json=function(xmlDoc){return parseDOMChildren(xmlDoc);};this.xml_str2json=function(xmlDocStr){var xmlDoc=this.parseXmlString(xmlDocStr);if(xmlDoc!=null)return this.xml2json(xmlDoc);else return null;};this.json2xml_str=function(jsonObj){return parseJSONObject(jsonObj,"");};this.json2xml=function(jsonObj){var xmlDocStr=this.json2xml_str(jsonObj);return this.parseXmlString(xmlDocStr);};this.getVersion=function(){return VERSION;};}exports.default=X2JS;
//# sourceMappingURL=xml2json.js.map


/***/ }),

/***/ "../../../node_modules/@hivestreaming/dashjs/build/es5/src/core/FactoryMaker.js":
/*!*******************************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/node_modules/@hivestreaming/dashjs/build/es5/src/core/FactoryMaker.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
Object.defineProperty(exports,"__esModule",{value:true});/**
 * The copyright in this software is being made available under the BSD License,
 * included below. This software may be subject to other third party and contributor
 * rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2013, Dash Industry Forum.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *  * Redistributions of source code must retain the above copyright notice, this
 *  list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *  this list of conditions and the following disclaimer in the documentation and/or
 *  other materials provided with the distribution.
 *  * Neither the name of Dash Industry Forum nor the names of its
 *  contributors may be used to endorse or promote products derived from this software
 *  without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY
 *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 *  POSSIBILITY OF SUCH DAMAGE.
 *//**
 * @module FactoryMaker
 * @ignore
 */var FactoryMaker=function(){var instance=void 0;var singletonContexts=[];var singletonFactories={};var classFactories={};function extend(name,childInstance,override,context){if(!context[name]&&childInstance){context[name]={instance:childInstance,override:override};}}/**
     * Use this method from your extended object.  this.factory is injected into your object.
     * this.factory.getSingletonInstance(this.context, 'VideoModel')
     * will return the video model for use in the extended object.
     *
     * @param {Object} context - injected into extended object as this.context
     * @param {string} className - string name found in all dash.js objects
     * with name __dashjs_factory_name Will be at the bottom. Will be the same as the object's name.
     * @returns {*} Context aware instance of specified singleton name.
     * @memberof module:FactoryMaker
     * @instance
     */function getSingletonInstance(context,className){for(var i in singletonContexts){var obj=singletonContexts[i];if(obj.context===context&&obj.name===className){return obj.instance;}}return null;}/**
     * Use this method to add an singleton instance to the system.  Useful for unit testing to mock objects etc.
     *
     * @param {Object} context
     * @param {string} className
     * @param {Object} instance
     * @memberof module:FactoryMaker
     * @instance
     */function setSingletonInstance(context,className,instance){for(var i in singletonContexts){var obj=singletonContexts[i];if(obj.context===context&&obj.name===className){singletonContexts[i].instance=instance;return;}}singletonContexts.push({name:className,context:context,instance:instance});}/*------------------------------------------------------------------------------------------*/// Factories storage Management
/*------------------------------------------------------------------------------------------*/function getFactoryByName(name,factoriesArray){return factoriesArray[name];}function updateFactory(name,factory,factoriesArray){if(name in factoriesArray){factoriesArray[name]=factory;}}/*------------------------------------------------------------------------------------------*/// Class Factories Management
/*------------------------------------------------------------------------------------------*/function updateClassFactory(name,factory){updateFactory(name,factory,classFactories);}function getClassFactoryByName(name){return getFactoryByName(name,classFactories);}function getClassFactory(classConstructor){var factory=getFactoryByName(classConstructor.__dashjs_factory_name,classFactories);if(!factory){factory=function factory(context){if(context===undefined){context={};}return{create:function create(){return merge(classConstructor,context,arguments);}};};classFactories[classConstructor.__dashjs_factory_name]=factory;// store factory
}return factory;}/*------------------------------------------------------------------------------------------*/// Singleton Factory MAangement
/*------------------------------------------------------------------------------------------*/function updateSingletonFactory(name,factory){updateFactory(name,factory,singletonFactories);}function getSingletonFactoryByName(name){return getFactoryByName(name,singletonFactories);}function getSingletonFactory(classConstructor){var factory=getFactoryByName(classConstructor.__dashjs_factory_name,singletonFactories);if(!factory){factory=function factory(context){var instance=void 0;if(context===undefined){context={};}return{getInstance:function getInstance(){// If we don't have an instance yet check for one on the context
if(!instance){instance=getSingletonInstance(context,classConstructor.__dashjs_factory_name);}// If there's no instance on the context then create one
if(!instance){instance=merge(classConstructor,context,arguments);singletonContexts.push({name:classConstructor.__dashjs_factory_name,context:context,instance:instance});}return instance;}};};singletonFactories[classConstructor.__dashjs_factory_name]=factory;// store factory
}return factory;}function merge(classConstructor,context,args){var classInstance=void 0;var className=classConstructor.__dashjs_factory_name;var extensionObject=context[className];if(extensionObject){var extension=extensionObject.instance;if(extensionObject.override){//Override public methods in parent but keep parent.
classInstance=classConstructor.apply({context:context},args);extension=extension.apply({context:context,factory:instance,parent:classInstance},args);for(var prop in extension){if(classInstance.hasOwnProperty(prop)){classInstance[prop]=extension[prop];}}}else{//replace parent object completely with new object. Same as dijon.
return extension.apply({context:context,factory:instance},args);}}else{// Create new instance of the class
classInstance=classConstructor.apply({context:context},args);}// Add getClassName function to class instance prototype (used by Debug)
classInstance.getClassName=function(){return className;};return classInstance;}instance={extend:extend,getSingletonInstance:getSingletonInstance,setSingletonInstance:setSingletonInstance,getSingletonFactory:getSingletonFactory,getSingletonFactoryByName:getSingletonFactoryByName,updateSingletonFactory:updateSingletonFactory,getClassFactory:getClassFactory,getClassFactoryByName:getClassFactoryByName,updateClassFactory:updateClassFactory};return instance;}();exports.default=FactoryMaker;
//# sourceMappingURL=FactoryMaker.js.map


/***/ }),

/***/ "../../../node_modules/@hivestreaming/dashjs/build/es5/src/dash/constants/DashConstants.js":
/*!******************************************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/node_modules/@hivestreaming/dashjs/build/es5/src/dash/constants/DashConstants.js ***!
  \******************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
Object.defineProperty(exports,"__esModule",{value:true});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}/**
 * The copyright in this software is being made available under the BSD License,
 * included below. This software may be subject to other third party and contributor
 * rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2013, Dash Industry Forum.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *  * Redistributions of source code must retain the above copyright notice, this
 *  list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *  this list of conditions and the following disclaimer in the documentation and/or
 *  other materials provided with the distribution.
 *  * Neither the name of Dash Industry Forum nor the names of its
 *  contributors may be used to endorse or promote products derived from this software
 *  without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY
 *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 *  POSSIBILITY OF SUCH DAMAGE.
 *//**
 * Dash constants declaration
 * @class
 * @ignore
 */var DashConstants=function(){_createClass(DashConstants,[{key:'init',value:function init(){this.BASE_URL='BaseURL';this.SEGMENT_BASE='SegmentBase';this.SEGMENT_TEMPLATE='SegmentTemplate';this.SEGMENT_LIST='SegmentList';this.SEGMENT_URL='SegmentURL';this.SEGMENT_TIMELINE='SegmentTimeline';this.SEGMENT_PROFILES='segmentProfiles';this.ADAPTATION_SET='AdaptationSet';this.REPRESENTATION='Representation';this.REPRESENTATION_INDEX='RepresentationIndex';this.SUB_REPRESENTATION='SubRepresentation';this.INITIALIZATION='Initialization';this.INITIALIZATION_MINUS='initialization';this.MPD='MPD';this.PERIOD='Period';this.ASSET_IDENTIFIER='AssetIdentifier';this.EVENT_STREAM='EventStream';this.ID='id';this.PROFILES='profiles';this.SERVICE_LOCATION='serviceLocation';this.RANGE='range';this.INDEX='index';this.MEDIA='media';this.BYTE_RANGE='byteRange';this.INDEX_RANGE='indexRange';this.MEDIA_RANGE='mediaRange';this.VALUE='value';this.CONTENT_TYPE='contentType';this.MIME_TYPE='mimeType';this.BITSTREAM_SWITCHING='BitstreamSwitching';this.BITSTREAM_SWITCHING_MINUS='bitstreamSwitching';this.CODECS='codecs';this.DEPENDENCY_ID='dependencyId';this.MEDIA_STREAM_STRUCTURE_ID='mediaStreamStructureId';this.METRICS='Metrics';this.METRICS_MINUS='metrics';this.REPORTING='Reporting';this.WIDTH='width';this.HEIGHT='height';this.SAR='sar';this.FRAMERATE='frameRate';this.AUDIO_SAMPLING_RATE='audioSamplingRate';this.MAXIMUM_SAP_PERIOD='maximumSAPPeriod';this.START_WITH_SAP='startWithSAP';this.MAX_PLAYOUT_RATE='maxPlayoutRate';this.CODING_DEPENDENCY='codingDependency';this.SCAN_TYPE='scanType';this.FRAME_PACKING='FramePacking';this.AUDIO_CHANNEL_CONFIGURATION='AudioChannelConfiguration';this.CONTENT_PROTECTION='ContentProtection';this.ESSENTIAL_PROPERTY='EssentialProperty';this.SUPPLEMENTAL_PROPERTY='SupplementalProperty';this.INBAND_EVENT_STREAM='InbandEventStream';this.ACCESSIBILITY='Accessibility';this.ROLE='Role';this.RATING='Rating';this.CONTENT_COMPONENT='ContentComponent';this.SUBSET='Subset';this.LANG='lang';this.VIEWPOINT='Viewpoint';this.ROLE_ASARRAY='Role_asArray';this.ACCESSIBILITY_ASARRAY='Accessibility_asArray';this.AUDIOCHANNELCONFIGURATION_ASARRAY='AudioChannelConfiguration_asArray';this.CONTENTPROTECTION_ASARRAY='ContentProtection_asArray';this.MAIN='main';this.DYNAMIC='dynamic';this.STATIC='static';this.MEDIA_PRESENTATION_DURATION='mediaPresentationDuration';this.MINIMUM_UPDATE_PERIOD='minimumUpdatePeriod';this.CODEC_PRIVATE_DATA='codecPrivateData';this.BANDWITH='bandwidth';this.SOURCE_URL='sourceURL';this.TIMESCALE='timescale';this.DURATION='duration';this.START_NUMBER='startNumber';this.PRESENTATION_TIME_OFFSET='presentationTimeOffset';this.AVAILABILITY_START_TIME='availabilityStartTime';this.AVAILABILITY_END_TIME='availabilityEndTime';this.TIMESHIFT_BUFFER_DEPTH='timeShiftBufferDepth';this.MAX_SEGMENT_DURATION='maxSegmentDuration';this.PRESENTATION_TIME='presentationTime';this.MIN_BUFFER_TIME='minBufferTime';this.MAX_SUBSEGMENT_DURATION='maxSubsegmentDuration';this.START='start';this.AVAILABILITY_TIME_OFFSET='availabilityTimeOffset';this.AVAILABILITY_TIME_COMPLETE='availabilityTimeComplete';this.CENC_DEFAULT_KID='cenc:default_KID';this.DVB_PRIORITY='dvb:priority';this.DVB_WEIGHT='dvb:weight';this.SUGGESTED_PRESENTATION_DELAY='suggestedPresentationDelay';this.SERVICE_DESCRIPTION='ServiceDescription';this.SERVICE_DESCRIPTION_SCOPE='Scope';this.SERVICE_DESCRIPTION_LATENCY='Latency';this.SERVICE_DESCRIPTION_PLAYBACK_RATE='PlaybackRate';}}]);function DashConstants(){_classCallCheck(this,DashConstants);this.init();}return DashConstants;}();var constants=new DashConstants();exports.default=constants;
//# sourceMappingURL=DashConstants.js.map


/***/ }),

/***/ "../../../node_modules/@hivestreaming/dashjs/build/es5/src/dash/parser/DashParser.js":
/*!************************************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/node_modules/@hivestreaming/dashjs/build/es5/src/dash/parser/DashParser.js ***!
  \************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
Object.defineProperty(exports,"__esModule",{value:true});var _FactoryMaker=__webpack_require__(/*! ../../core/FactoryMaker */ "../../../node_modules/@hivestreaming/dashjs/build/es5/src/core/FactoryMaker.js");var _FactoryMaker2=_interopRequireDefault(_FactoryMaker);var _objectiron=__webpack_require__(/*! ./objectiron */ "../../../node_modules/@hivestreaming/dashjs/build/es5/src/dash/parser/objectiron.js");var _objectiron2=_interopRequireDefault(_objectiron);var _xml2json=__webpack_require__(/*! ../../../externals/xml2json */ "../../../node_modules/@hivestreaming/dashjs/build/es5/externals/xml2json.js");var _xml2json2=_interopRequireDefault(_xml2json);var _StringMatcher=__webpack_require__(/*! ./matchers/StringMatcher */ "../../../node_modules/@hivestreaming/dashjs/build/es5/src/dash/parser/matchers/StringMatcher.js");var _StringMatcher2=_interopRequireDefault(_StringMatcher);var _DurationMatcher=__webpack_require__(/*! ./matchers/DurationMatcher */ "../../../node_modules/@hivestreaming/dashjs/build/es5/src/dash/parser/matchers/DurationMatcher.js");var _DurationMatcher2=_interopRequireDefault(_DurationMatcher);var _DateTimeMatcher=__webpack_require__(/*! ./matchers/DateTimeMatcher */ "../../../node_modules/@hivestreaming/dashjs/build/es5/src/dash/parser/matchers/DateTimeMatcher.js");var _DateTimeMatcher2=_interopRequireDefault(_DateTimeMatcher);var _NumericMatcher=__webpack_require__(/*! ./matchers/NumericMatcher */ "../../../node_modules/@hivestreaming/dashjs/build/es5/src/dash/parser/matchers/NumericMatcher.js");var _NumericMatcher2=_interopRequireDefault(_NumericMatcher);var _RepresentationBaseValuesMap=__webpack_require__(/*! ./maps/RepresentationBaseValuesMap */ "../../../node_modules/@hivestreaming/dashjs/build/es5/src/dash/parser/maps/RepresentationBaseValuesMap.js");var _RepresentationBaseValuesMap2=_interopRequireDefault(_RepresentationBaseValuesMap);var _SegmentValuesMap=__webpack_require__(/*! ./maps/SegmentValuesMap */ "../../../node_modules/@hivestreaming/dashjs/build/es5/src/dash/parser/maps/SegmentValuesMap.js");var _SegmentValuesMap2=_interopRequireDefault(_SegmentValuesMap);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function DashParser(config){config=config||{};var context=this.context;var debug=config.debug;var instance=void 0,logger=void 0,matchers=void 0,converter=void 0,objectIron=void 0;function setup(){logger=debug&&debug.getLogger(instance);matchers=[new _DurationMatcher2.default(),new _DateTimeMatcher2.default(),new _NumericMatcher2.default(),new _StringMatcher2.default()// last in list to take precedence over NumericMatcher
];converter=new _xml2json2.default({escapeMode:false,attributePrefix:'',arrayAccessForm:'property',emptyNodeForm:'object',stripWhitespaces:false,enableToStringFunc:true,ignoreRoot:true,matchers:matchers});objectIron=(0,_objectiron2.default)(context).create({adaptationset:new _RepresentationBaseValuesMap2.default(),period:new _SegmentValuesMap2.default()});}function getMatchers(){return matchers;}function getIron(){return objectIron;}function parse(data){var manifest=void 0;var startTime=window.performance.now();manifest=converter.xml_str2json(data);if(!manifest){throw new Error('parsing the manifest failed');}var jsonTime=window.performance.now();objectIron.run(manifest);var ironedTime=window.performance.now();if(logger&&typeof logger.info==='function'){logger.info('Parsing complete: ( xml2json: '+(jsonTime-startTime).toPrecision(3)+'ms, objectiron: '+(ironedTime-jsonTime).toPrecision(3)+'ms, total: '+((ironedTime-startTime)/1000).toPrecision(3)+'s)');}manifest.protocol='DASH';return manifest;}instance={parse:parse,getMatchers:getMatchers,getIron:getIron};setup();return instance;}/**
 * The copyright in this software is being made available under the BSD License,
 * included below. This software may be subject to other third party and contributor
 * rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2013, Dash Industry Forum.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *  * Redistributions of source code must retain the above copyright notice, this
 *  list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *  this list of conditions and the following disclaimer in the documentation and/or
 *  other materials provided with the distribution.
 *  * Neither the name of Dash Industry Forum nor the names of its
 *  contributors may be used to endorse or promote products derived from this software
 *  without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY
 *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 *  POSSIBILITY OF SUCH DAMAGE.
 */DashParser.__dashjs_factory_name='DashParser';exports.default=_FactoryMaker2.default.getClassFactory(DashParser);
//# sourceMappingURL=DashParser.js.map


/***/ }),

/***/ "../../../node_modules/@hivestreaming/dashjs/build/es5/src/dash/parser/maps/CommonProperty.js":
/*!*********************************************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/node_modules/@hivestreaming/dashjs/build/es5/src/dash/parser/maps/CommonProperty.js ***!
  \*********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
Object.defineProperty(exports,"__esModule",{value:true});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}/**
 * The copyright in this software is being made available under the BSD License,
 * included below. This software may be subject to other third party and contributor
 * rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2013, Dash Industry Forum.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *  * Redistributions of source code must retain the above copyright notice, this
 *  list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *  this list of conditions and the following disclaimer in the documentation and/or
 *  other materials provided with the distribution.
 *  * Neither the name of Dash Industry Forum nor the names of its
 *  contributors may be used to endorse or promote products derived from this software
 *  without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY
 *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 *  POSSIBILITY OF SUCH DAMAGE.
 *//**
 * @classdesc a property belonging to a MapNode
 * @ignore
 */var CommonProperty=function(){function CommonProperty(name){_classCallCheck(this,CommonProperty);var getDefaultMergeForName=function getDefaultMergeForName(n){return n&&n.length&&n.charAt(0)===n.charAt(0).toUpperCase();};this._name=name;this._merge=getDefaultMergeForName(name);}_createClass(CommonProperty,[{key:"name",get:function get(){return this._name;}},{key:"merge",get:function get(){return this._merge;}}]);return CommonProperty;}();exports.default=CommonProperty;
//# sourceMappingURL=CommonProperty.js.map


/***/ }),

/***/ "../../../node_modules/@hivestreaming/dashjs/build/es5/src/dash/parser/maps/MapNode.js":
/*!**************************************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/node_modules/@hivestreaming/dashjs/build/es5/src/dash/parser/maps/MapNode.js ***!
  \**************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
Object.defineProperty(exports,"__esModule",{value:true});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();/**
 * The copyright in this software is being made available under the BSD License,
 * included below. This software may be subject to other third party and contributor
 * rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2013, Dash Industry Forum.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *  * Redistributions of source code must retain the above copyright notice, this
 *  list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *  this list of conditions and the following disclaimer in the documentation and/or
 *  other materials provided with the distribution.
 *  * Neither the name of Dash Industry Forum nor the names of its
 *  contributors may be used to endorse or promote products derived from this software
 *  without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY
 *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 *  POSSIBILITY OF SUCH DAMAGE.
 *//**
 * @classdesc a node at some level in a ValueMap
 */var _CommonProperty=__webpack_require__(/*! ./CommonProperty */ "../../../node_modules/@hivestreaming/dashjs/build/es5/src/dash/parser/maps/CommonProperty.js");var _CommonProperty2=_interopRequireDefault(_CommonProperty);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}var MapNode=function(){function MapNode(name,properties,children){var _this=this;_classCallCheck(this,MapNode);this._name=name||'';this._properties=[];this._children=children||[];if(Array.isArray(properties)){properties.forEach(function(p){_this._properties.push(new _CommonProperty2.default(p));});}}_createClass(MapNode,[{key:'name',get:function get(){return this._name;}},{key:'children',get:function get(){return this._children;}},{key:'properties',get:function get(){return this._properties;}}]);return MapNode;}();exports.default=MapNode;
//# sourceMappingURL=MapNode.js.map


/***/ }),

/***/ "../../../node_modules/@hivestreaming/dashjs/build/es5/src/dash/parser/maps/RepresentationBaseValuesMap.js":
/*!**********************************************************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/node_modules/@hivestreaming/dashjs/build/es5/src/dash/parser/maps/RepresentationBaseValuesMap.js ***!
  \**********************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
Object.defineProperty(exports,"__esModule",{value:true});var _MapNode2=__webpack_require__(/*! ./MapNode */ "../../../node_modules/@hivestreaming/dashjs/build/es5/src/dash/parser/maps/MapNode.js");var _MapNode3=_interopRequireDefault(_MapNode2);var _DashConstants=__webpack_require__(/*! ../../constants/DashConstants */ "../../../node_modules/@hivestreaming/dashjs/build/es5/src/dash/constants/DashConstants.js");var _DashConstants2=_interopRequireDefault(_DashConstants);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}/**
 * The copyright in this software is being made available under the BSD License,
 * included below. This software may be subject to other third party and contributor
 * rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2013, Dash Industry Forum.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *  * Redistributions of source code must retain the above copyright notice, this
 *  list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *  this list of conditions and the following disclaimer in the documentation and/or
 *  other materials provided with the distribution.
 *  * Neither the name of Dash Industry Forum nor the names of its
 *  contributors may be used to endorse or promote products derived from this software
 *  without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY
 *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 *  POSSIBILITY OF SUCH DAMAGE.
 *//**
 * @classdesc a RepresentationBaseValuesMap type for input to objectiron
 */var RepresentationBaseValuesMap=function(_MapNode){_inherits(RepresentationBaseValuesMap,_MapNode);function RepresentationBaseValuesMap(){_classCallCheck(this,RepresentationBaseValuesMap);var commonProperties=[_DashConstants2.default.PROFILES,_DashConstants2.default.WIDTH,_DashConstants2.default.HEIGHT,_DashConstants2.default.SAR,_DashConstants2.default.FRAMERATE,_DashConstants2.default.AUDIO_SAMPLING_RATE,_DashConstants2.default.MIME_TYPE,_DashConstants2.default.SEGMENT_PROFILES,_DashConstants2.default.CODECS,_DashConstants2.default.MAXIMUM_SAP_PERIOD,_DashConstants2.default.START_WITH_SAP,_DashConstants2.default.MAX_PLAYOUT_RATE,_DashConstants2.default.CODING_DEPENDENCY,_DashConstants2.default.SCAN_TYPE,_DashConstants2.default.FRAME_PACKING,_DashConstants2.default.AUDIO_CHANNEL_CONFIGURATION,_DashConstants2.default.CONTENT_PROTECTION,_DashConstants2.default.ESSENTIAL_PROPERTY,_DashConstants2.default.SUPPLEMENTAL_PROPERTY,_DashConstants2.default.INBAND_EVENT_STREAM];return _possibleConstructorReturn(this,(RepresentationBaseValuesMap.__proto__||Object.getPrototypeOf(RepresentationBaseValuesMap)).call(this,_DashConstants2.default.ADAPTATION_SET,commonProperties,[new _MapNode3.default(_DashConstants2.default.REPRESENTATION,commonProperties,[new _MapNode3.default(_DashConstants2.default.SUB_REPRESENTATION,commonProperties)])]));}return RepresentationBaseValuesMap;}(_MapNode3.default);exports.default=RepresentationBaseValuesMap;
//# sourceMappingURL=RepresentationBaseValuesMap.js.map


/***/ }),

/***/ "../../../node_modules/@hivestreaming/dashjs/build/es5/src/dash/parser/maps/SegmentValuesMap.js":
/*!***********************************************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/node_modules/@hivestreaming/dashjs/build/es5/src/dash/parser/maps/SegmentValuesMap.js ***!
  \***********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
Object.defineProperty(exports,"__esModule",{value:true});var _MapNode2=__webpack_require__(/*! ./MapNode */ "../../../node_modules/@hivestreaming/dashjs/build/es5/src/dash/parser/maps/MapNode.js");var _MapNode3=_interopRequireDefault(_MapNode2);var _DashConstants=__webpack_require__(/*! ../../constants/DashConstants */ "../../../node_modules/@hivestreaming/dashjs/build/es5/src/dash/constants/DashConstants.js");var _DashConstants2=_interopRequireDefault(_DashConstants);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}/**
 * The copyright in this software is being made available under the BSD License,
 * included below. This software may be subject to other third party and contributor
 * rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2013, Dash Industry Forum.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *  * Redistributions of source code must retain the above copyright notice, this
 *  list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *  this list of conditions and the following disclaimer in the documentation and/or
 *  other materials provided with the distribution.
 *  * Neither the name of Dash Industry Forum nor the names of its
 *  contributors may be used to endorse or promote products derived from this software
 *  without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY
 *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 *  POSSIBILITY OF SUCH DAMAGE.
 *//**
 * @classdesc a SegmentValuesMap type for input to objectiron
 */var SegmentValuesMap=function(_MapNode){_inherits(SegmentValuesMap,_MapNode);function SegmentValuesMap(){_classCallCheck(this,SegmentValuesMap);var commonProperties=[_DashConstants2.default.SEGMENT_BASE,_DashConstants2.default.SEGMENT_TEMPLATE,_DashConstants2.default.SEGMENT_LIST];return _possibleConstructorReturn(this,(SegmentValuesMap.__proto__||Object.getPrototypeOf(SegmentValuesMap)).call(this,_DashConstants2.default.PERIOD,commonProperties,[new _MapNode3.default(_DashConstants2.default.ADAPTATION_SET,commonProperties,[new _MapNode3.default(_DashConstants2.default.REPRESENTATION,commonProperties)])]));}return SegmentValuesMap;}(_MapNode3.default);exports.default=SegmentValuesMap;
//# sourceMappingURL=SegmentValuesMap.js.map


/***/ }),

/***/ "../../../node_modules/@hivestreaming/dashjs/build/es5/src/dash/parser/matchers/BaseMatcher.js":
/*!**********************************************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/node_modules/@hivestreaming/dashjs/build/es5/src/dash/parser/matchers/BaseMatcher.js ***!
  \**********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
Object.defineProperty(exports,"__esModule",{value:true});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}/**
 * The copyright in this software is being made available under the BSD License,
 * included below. This software may be subject to other third party and contributor
 * rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2013, Dash Industry Forum.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *  * Redistributions of source code must retain the above copyright notice, this
 *  list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *  this list of conditions and the following disclaimer in the documentation and/or
 *  other materials provided with the distribution.
 *  * Neither the name of Dash Industry Forum nor the names of its
 *  contributors may be used to endorse or promote products derived from this software
 *  without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY
 *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 *  POSSIBILITY OF SUCH DAMAGE.
 *//**
 * @classdesc a base type for matching and converting types in manifest to
 * something more useful
 * @ignore
 */var BaseMatcher=function(){function BaseMatcher(test,converter){_classCallCheck(this,BaseMatcher);this._test=test;this._converter=converter;}_createClass(BaseMatcher,[{key:"test",get:function get(){return this._test;}},{key:"converter",get:function get(){return this._converter;}}]);return BaseMatcher;}();exports.default=BaseMatcher;
//# sourceMappingURL=BaseMatcher.js.map


/***/ }),

/***/ "../../../node_modules/@hivestreaming/dashjs/build/es5/src/dash/parser/matchers/DateTimeMatcher.js":
/*!**************************************************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/node_modules/@hivestreaming/dashjs/build/es5/src/dash/parser/matchers/DateTimeMatcher.js ***!
  \**************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
Object.defineProperty(exports,"__esModule",{value:true});var _BaseMatcher2=__webpack_require__(/*! ./BaseMatcher */ "../../../node_modules/@hivestreaming/dashjs/build/es5/src/dash/parser/matchers/BaseMatcher.js");var _BaseMatcher3=_interopRequireDefault(_BaseMatcher2);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}/**
 * The copyright in this software is being made available under the BSD License,
 * included below. This software may be subject to other third party and contributor
 * rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2013, Dash Industry Forum.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *  * Redistributions of source code must retain the above copyright notice, this
 *  list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *  this list of conditions and the following disclaimer in the documentation and/or
 *  other materials provided with the distribution.
 *  * Neither the name of Dash Industry Forum nor the names of its
 *  contributors may be used to endorse or promote products derived from this software
 *  without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY
 *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 *  POSSIBILITY OF SUCH DAMAGE.
 *//**
 * @classdesc matches and converts xs:datetime to Date
 */var SECONDS_IN_MIN=60;var MINUTES_IN_HOUR=60;var MILLISECONDS_IN_SECONDS=1000;var datetimeRegex=/^([0-9]{4})-([0-9]{2})-([0-9]{2})T([0-9]{2}):([0-9]{2})(?::([0-9]*)(\.[0-9]*)?)?(?:([+-])([0-9]{2})(?::?)([0-9]{2}))?/;var DateTimeMatcher=function(_BaseMatcher){_inherits(DateTimeMatcher,_BaseMatcher);function DateTimeMatcher(){_classCallCheck(this,DateTimeMatcher);return _possibleConstructorReturn(this,(DateTimeMatcher.__proto__||Object.getPrototypeOf(DateTimeMatcher)).call(this,function(attr){return datetimeRegex.test(attr.value);},function(str){var match=datetimeRegex.exec(str);var utcDate=void 0;// If the string does not contain a timezone offset different browsers can interpret it either
// as UTC or as a local time so we have to parse the string manually to normalize the given date value for
// all browsers
utcDate=Date.UTC(parseInt(match[1],10),parseInt(match[2],10)-1,// months start from zero
parseInt(match[3],10),parseInt(match[4],10),parseInt(match[5],10),match[6]&&parseInt(match[6],10)||0,match[7]&&parseFloat(match[7])*MILLISECONDS_IN_SECONDS||0);// If the date has timezone offset take it into account as well
if(match[9]&&match[10]){var timezoneOffset=parseInt(match[9],10)*MINUTES_IN_HOUR+parseInt(match[10],10);utcDate+=(match[8]==='+'?-1:+1)*timezoneOffset*SECONDS_IN_MIN*MILLISECONDS_IN_SECONDS;}return new Date(utcDate);}));}return DateTimeMatcher;}(_BaseMatcher3.default);exports.default=DateTimeMatcher;
//# sourceMappingURL=DateTimeMatcher.js.map


/***/ }),

/***/ "../../../node_modules/@hivestreaming/dashjs/build/es5/src/dash/parser/matchers/DurationMatcher.js":
/*!**************************************************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/node_modules/@hivestreaming/dashjs/build/es5/src/dash/parser/matchers/DurationMatcher.js ***!
  \**************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
Object.defineProperty(exports,"__esModule",{value:true});var _BaseMatcher2=__webpack_require__(/*! ./BaseMatcher */ "../../../node_modules/@hivestreaming/dashjs/build/es5/src/dash/parser/matchers/BaseMatcher.js");var _BaseMatcher3=_interopRequireDefault(_BaseMatcher2);var _Constants=__webpack_require__(/*! ../../../streaming/constants/Constants */ "../../../node_modules/@hivestreaming/dashjs/build/es5/src/streaming/constants/Constants.js");var _Constants2=_interopRequireDefault(_Constants);var _DashConstants=__webpack_require__(/*! ../../constants/DashConstants */ "../../../node_modules/@hivestreaming/dashjs/build/es5/src/dash/constants/DashConstants.js");var _DashConstants2=_interopRequireDefault(_DashConstants);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}/**
 * The copyright in this software is being made available under the BSD License,
 * included below. This software may be subject to other third party and contributor
 * rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2013, Dash Industry Forum.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *  * Redistributions of source code must retain the above copyright notice, this
 *  list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *  this list of conditions and the following disclaimer in the documentation and/or
 *  other materials provided with the distribution.
 *  * Neither the name of Dash Industry Forum nor the names of its
 *  contributors may be used to endorse or promote products derived from this software
 *  without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY
 *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 *  POSSIBILITY OF SUCH DAMAGE.
 *//**
 * @classdesc matches and converts xs:duration to seconds
 */var durationRegex=/^([-])?P(([\d.]*)Y)?(([\d.]*)M)?(([\d.]*)D)?T?(([\d.]*)H)?(([\d.]*)M)?(([\d.]*)S)?/;var SECONDS_IN_YEAR=365*24*60*60;var SECONDS_IN_MONTH=30*24*60*60;var SECONDS_IN_DAY=24*60*60;var SECONDS_IN_HOUR=60*60;var SECONDS_IN_MIN=60;var DurationMatcher=function(_BaseMatcher){_inherits(DurationMatcher,_BaseMatcher);function DurationMatcher(){_classCallCheck(this,DurationMatcher);return _possibleConstructorReturn(this,(DurationMatcher.__proto__||Object.getPrototypeOf(DurationMatcher)).call(this,function(attr){var attributeList=[_DashConstants2.default.MIN_BUFFER_TIME,_DashConstants2.default.MEDIA_PRESENTATION_DURATION,_DashConstants2.default.MINIMUM_UPDATE_PERIOD,_DashConstants2.default.TIMESHIFT_BUFFER_DEPTH,_DashConstants2.default.MAX_SEGMENT_DURATION,_DashConstants2.default.MAX_SUBSEGMENT_DURATION,_DashConstants2.default.SUGGESTED_PRESENTATION_DELAY,_DashConstants2.default.START,_Constants2.default.START_TIME,_DashConstants2.default.DURATION];var len=attributeList.length;for(var i=0;i<len;i++){if(attr.nodeName===attributeList[i]){return durationRegex.test(attr.value);}}return false;},function(str){//str = "P10Y10M10DT10H10M10.1S";
var match=durationRegex.exec(str);var result=parseFloat(match[3]||0)*SECONDS_IN_YEAR+parseFloat(match[5]||0)*SECONDS_IN_MONTH+parseFloat(match[7]||0)*SECONDS_IN_DAY+parseFloat(match[9]||0)*SECONDS_IN_HOUR+parseFloat(match[11]||0)*SECONDS_IN_MIN+parseFloat(match[13]||0);if(match[1]!==undefined){result=-result;}return result;}));}return DurationMatcher;}(_BaseMatcher3.default);exports.default=DurationMatcher;
//# sourceMappingURL=DurationMatcher.js.map


/***/ }),

/***/ "../../../node_modules/@hivestreaming/dashjs/build/es5/src/dash/parser/matchers/NumericMatcher.js":
/*!*************************************************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/node_modules/@hivestreaming/dashjs/build/es5/src/dash/parser/matchers/NumericMatcher.js ***!
  \*************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
Object.defineProperty(exports,"__esModule",{value:true});var _BaseMatcher2=__webpack_require__(/*! ./BaseMatcher */ "../../../node_modules/@hivestreaming/dashjs/build/es5/src/dash/parser/matchers/BaseMatcher.js");var _BaseMatcher3=_interopRequireDefault(_BaseMatcher2);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}/**
 * The copyright in this software is being made available under the BSD License,
 * included below. This software may be subject to other third party and contributor
 * rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2013, Dash Industry Forum.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *  * Redistributions of source code must retain the above copyright notice, this
 *  list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *  this list of conditions and the following disclaimer in the documentation and/or
 *  other materials provided with the distribution.
 *  * Neither the name of Dash Industry Forum nor the names of its
 *  contributors may be used to endorse or promote products derived from this software
 *  without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY
 *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 *  POSSIBILITY OF SUCH DAMAGE.
 *//**
 * @classdesc Matches and converts xs:numeric to float
 */var numericRegex=/^[-+]?[0-9]+[.]?[0-9]*([eE][-+]?[0-9]+)?$/;var NumericMatcher=function(_BaseMatcher){_inherits(NumericMatcher,_BaseMatcher);function NumericMatcher(){_classCallCheck(this,NumericMatcher);return _possibleConstructorReturn(this,(NumericMatcher.__proto__||Object.getPrototypeOf(NumericMatcher)).call(this,function(attr){return numericRegex.test(attr.value);},function(str){return parseFloat(str);}));}return NumericMatcher;}(_BaseMatcher3.default);exports.default=NumericMatcher;
//# sourceMappingURL=NumericMatcher.js.map


/***/ }),

/***/ "../../../node_modules/@hivestreaming/dashjs/build/es5/src/dash/parser/matchers/StringMatcher.js":
/*!************************************************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/node_modules/@hivestreaming/dashjs/build/es5/src/dash/parser/matchers/StringMatcher.js ***!
  \************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
Object.defineProperty(exports,"__esModule",{value:true});var _BaseMatcher2=__webpack_require__(/*! ./BaseMatcher */ "../../../node_modules/@hivestreaming/dashjs/build/es5/src/dash/parser/matchers/BaseMatcher.js");var _BaseMatcher3=_interopRequireDefault(_BaseMatcher2);var _DashConstants=__webpack_require__(/*! ../../constants/DashConstants */ "../../../node_modules/@hivestreaming/dashjs/build/es5/src/dash/constants/DashConstants.js");var _DashConstants2=_interopRequireDefault(_DashConstants);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else{obj[key]=value;}return obj;}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}/**
 * The copyright in this software is being made available under the BSD License,
 * included below. This software may be subject to other third party and contributor
 * rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2013, Dash Industry Forum.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *  * Redistributions of source code must retain the above copyright notice, this
 *  list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *  this list of conditions and the following disclaimer in the documentation and/or
 *  other materials provided with the distribution.
 *  * Neither the name of Dash Industry Forum nor the names of its
 *  contributors may be used to endorse or promote products derived from this software
 *  without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY
 *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 *  POSSIBILITY OF SUCH DAMAGE.
 *//**
 * @classdesc Matches and converts xs:string to string, but only for specific attributes on specific nodes
 */var StringMatcher=function(_BaseMatcher){_inherits(StringMatcher,_BaseMatcher);function StringMatcher(){_classCallCheck(this,StringMatcher);return _possibleConstructorReturn(this,(StringMatcher.__proto__||Object.getPrototypeOf(StringMatcher)).call(this,function(attr,nodeName){var _stringAttrsInElement;var stringAttrsInElements=(_stringAttrsInElement={},_defineProperty(_stringAttrsInElement,_DashConstants2.default.MPD,[_DashConstants2.default.ID,_DashConstants2.default.PROFILES]),_defineProperty(_stringAttrsInElement,_DashConstants2.default.PERIOD,[_DashConstants2.default.ID]),_defineProperty(_stringAttrsInElement,_DashConstants2.default.BASE_URL,[_DashConstants2.default.SERVICE_LOCATION,_DashConstants2.default.BYTE_RANGE]),_defineProperty(_stringAttrsInElement,_DashConstants2.default.SEGMENT_BASE,[_DashConstants2.default.INDEX_RANGE]),_defineProperty(_stringAttrsInElement,_DashConstants2.default.INITIALIZATION,[_DashConstants2.default.RANGE]),_defineProperty(_stringAttrsInElement,_DashConstants2.default.REPRESENTATION_INDEX,[_DashConstants2.default.RANGE]),_defineProperty(_stringAttrsInElement,_DashConstants2.default.SEGMENT_LIST,[_DashConstants2.default.INDEX_RANGE]),_defineProperty(_stringAttrsInElement,_DashConstants2.default.BITSTREAM_SWITCHING,[_DashConstants2.default.RANGE]),_defineProperty(_stringAttrsInElement,_DashConstants2.default.SEGMENT_URL,[_DashConstants2.default.MEDIA_RANGE,_DashConstants2.default.INDEX_RANGE]),_defineProperty(_stringAttrsInElement,_DashConstants2.default.SEGMENT_TEMPLATE,[_DashConstants2.default.INDEX_RANGE,_DashConstants2.default.MEDIA,_DashConstants2.default.INDEX,_DashConstants2.default.INITIALIZATION_MINUS,_DashConstants2.default.BITSTREAM_SWITCHING_MINUS]),_defineProperty(_stringAttrsInElement,_DashConstants2.default.ASSET_IDENTIFIER,[_DashConstants2.default.VALUE,_DashConstants2.default.ID]),_defineProperty(_stringAttrsInElement,_DashConstants2.default.EVENT_STREAM,[_DashConstants2.default.VALUE]),_defineProperty(_stringAttrsInElement,_DashConstants2.default.ADAPTATION_SET,[_DashConstants2.default.PROFILES,_DashConstants2.default.MIME_TYPE,_DashConstants2.default.SEGMENT_PROFILES,_DashConstants2.default.CODECS,_DashConstants2.default.CONTENT_TYPE]),_defineProperty(_stringAttrsInElement,_DashConstants2.default.FRAME_PACKING,[_DashConstants2.default.VALUE,_DashConstants2.default.ID]),_defineProperty(_stringAttrsInElement,_DashConstants2.default.AUDIO_CHANNEL_CONFIGURATION,[_DashConstants2.default.VALUE,_DashConstants2.default.ID]),_defineProperty(_stringAttrsInElement,_DashConstants2.default.CONTENT_PROTECTION,[_DashConstants2.default.VALUE,_DashConstants2.default.ID]),_defineProperty(_stringAttrsInElement,_DashConstants2.default.ESSENTIAL_PROPERTY,[_DashConstants2.default.VALUE,_DashConstants2.default.ID]),_defineProperty(_stringAttrsInElement,_DashConstants2.default.SUPPLEMENTAL_PROPERTY,[_DashConstants2.default.VALUE,_DashConstants2.default.ID]),_defineProperty(_stringAttrsInElement,_DashConstants2.default.INBAND_EVENT_STREAM,[_DashConstants2.default.VALUE,_DashConstants2.default.ID]),_defineProperty(_stringAttrsInElement,_DashConstants2.default.ACCESSIBILITY,[_DashConstants2.default.VALUE,_DashConstants2.default.ID]),_defineProperty(_stringAttrsInElement,_DashConstants2.default.ROLE,[_DashConstants2.default.VALUE,_DashConstants2.default.ID]),_defineProperty(_stringAttrsInElement,_DashConstants2.default.RATING,[_DashConstants2.default.VALUE,_DashConstants2.default.ID]),_defineProperty(_stringAttrsInElement,_DashConstants2.default.VIEWPOINT,[_DashConstants2.default.VALUE,_DashConstants2.default.ID]),_defineProperty(_stringAttrsInElement,_DashConstants2.default.CONTENT_COMPONENT,[_DashConstants2.default.CONTENT_TYPE]),_defineProperty(_stringAttrsInElement,_DashConstants2.default.REPRESENTATION,[_DashConstants2.default.ID,_DashConstants2.default.DEPENDENCY_ID,_DashConstants2.default.MEDIA_STREAM_STRUCTURE_ID]),_defineProperty(_stringAttrsInElement,_DashConstants2.default.SUBSET,[_DashConstants2.default.ID]),_defineProperty(_stringAttrsInElement,_DashConstants2.default.METRICS,[_DashConstants2.default.METRICS_MINUS]),_defineProperty(_stringAttrsInElement,_DashConstants2.default.REPORTING,[_DashConstants2.default.VALUE,_DashConstants2.default.ID]),_stringAttrsInElement);if(stringAttrsInElements.hasOwnProperty(nodeName)){var attrNames=stringAttrsInElements[nodeName];if(attrNames!==undefined){return attrNames.indexOf(attr.name)>=0;}else{return false;}}return false;},function(str){return String(str);}));}return StringMatcher;}(_BaseMatcher3.default);exports.default=StringMatcher;
//# sourceMappingURL=StringMatcher.js.map


/***/ }),

/***/ "../../../node_modules/@hivestreaming/dashjs/build/es5/src/dash/parser/objectiron.js":
/*!************************************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/node_modules/@hivestreaming/dashjs/build/es5/src/dash/parser/objectiron.js ***!
  \************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
Object.defineProperty(exports,"__esModule",{value:true});var _typeof=typeof Symbol==="function"&&typeof Symbol.iterator==="symbol"?function(obj){return typeof obj;}:function(obj){return obj&&typeof Symbol==="function"&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj;};/**
 * The copyright in this software is being made available under the BSD License,
 * included below. This software may be subject to other third party and contributor
 * rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2013, Dash Industry Forum.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *  * Redistributions of source code must retain the above copyright notice, this
 *  list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *  this list of conditions and the following disclaimer in the documentation and/or
 *  other materials provided with the distribution.
 *  * Neither the name of Dash Industry Forum nor the names of its
 *  contributors may be used to endorse or promote products derived from this software
 *  without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY
 *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 *  POSSIBILITY OF SUCH DAMAGE.
 */var _FactoryMaker=__webpack_require__(/*! ../../core/FactoryMaker */ "../../../node_modules/@hivestreaming/dashjs/build/es5/src/core/FactoryMaker.js");var _FactoryMaker2=_interopRequireDefault(_FactoryMaker);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function ObjectIron(mappers){function mergeValues(parentItem,childItem){for(var name in parentItem){if(!childItem.hasOwnProperty(name)){childItem[name]=parentItem[name];}}}function mapProperties(properties,parent,child){for(var i=0,len=properties.length;i<len;++i){var property=properties[i];if(parent[property.name]){if(child[property.name]){// check to see if we should merge
if(property.merge){var parentValue=parent[property.name];var childValue=child[property.name];// complex objects; merge properties
if((typeof parentValue==='undefined'?'undefined':_typeof(parentValue))==='object'&&(typeof childValue==='undefined'?'undefined':_typeof(childValue))==='object'){mergeValues(parentValue,childValue);}// simple objects; merge them together
else{child[property.name]=parentValue+childValue;}}}else{// just add the property
child[property.name]=parent[property.name];}}}}function mapItem(item,node){for(var i=0,len=item.children.length;i<len;++i){var childItem=item.children[i];var array=node[childItem.name+'_asArray'];if(array){for(var v=0,len2=array.length;v<len2;++v){var childNode=array[v];mapProperties(item.properties,node,childNode);mapItem(childItem,childNode);}}}}function run(source){if(source===null||(typeof source==='undefined'?'undefined':_typeof(source))!=='object'){return source;}if('period'in mappers){var periodMapper=mappers.period;var periods=source.Period_asArray;for(var i=0,len=periods.length;i<len;++i){var period=periods[i];mapItem(periodMapper,period);if('adaptationset'in mappers){var adaptationSets=period.AdaptationSet_asArray;if(adaptationSets){var adaptationSetMapper=mappers.adaptationset;for(var _i=0,_len=adaptationSets.length;_i<_len;++_i){mapItem(adaptationSetMapper,adaptationSets[_i]);}}}}}return source;}return{run:run};}ObjectIron.__dashjs_factory_name='ObjectIron';var factory=_FactoryMaker2.default.getClassFactory(ObjectIron);exports.default=factory;
//# sourceMappingURL=objectiron.js.map


/***/ }),

/***/ "../../../node_modules/@hivestreaming/dashjs/build/es5/src/streaming/constants/Constants.js":
/*!*******************************************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/node_modules/@hivestreaming/dashjs/build/es5/src/streaming/constants/Constants.js ***!
  \*******************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
Object.defineProperty(exports,"__esModule",{value:true});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}/**
 * The copyright in this software is being made available under the BSD License,
 * included below. This software may be subject to other third party and contributor
 * rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2013, Dash Industry Forum.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *  * Redistributions of source code must retain the above copyright notice, this
 *  list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *  this list of conditions and the following disclaimer in the documentation and/or
 *  other materials provided with the distribution.
 *  * Neither the name of Dash Industry Forum nor the names of its
 *  contributors may be used to endorse or promote products derived from this software
 *  without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY
 *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 *  POSSIBILITY OF SUCH DAMAGE.
 *//**
 * Constants declaration
 * @class
 * @ignore
 * @hideconstructor
 */var Constants=function(){_createClass(Constants,[{key:'init',value:function init(){/**
         *  @constant {string} STREAM Stream media type. Mainly used to report metrics relative to the full stream
         *  @memberof Constants#
         *  @static
         */this.STREAM='stream';/**
         *  @constant {string} VIDEO Video media type
         *  @memberof Constants#
         *  @static
         */this.VIDEO='video';/**
         *  @constant {string} AUDIO Audio media type
         *  @memberof Constants#
         *  @static
         */this.AUDIO='audio';/**
         *  @constant {string} TEXT Text media type
         *  @memberof Constants#
         *  @static
         */this.TEXT='text';/**
         *  @constant {string} FRAGMENTED_TEXT Fragmented text media type
         *  @memberof Constants#
         *  @static
         */this.FRAGMENTED_TEXT='fragmentedText';/**
         *  @constant {string} EMBEDDED_TEXT Embedded text media type
         *  @memberof Constants#
         *  @static
         */this.EMBEDDED_TEXT='embeddedText';/**
         *  @constant {string} MUXED Muxed (video/audio in the same chunk) media type
         *  @memberof Constants#
         *  @static
         */this.MUXED='muxed';/**
         *  @constant {string} IMAGE Image media type
         *  @memberof Constants#
         *  @static
         */this.IMAGE='image';/**
         *  @constant {string} STPP STTP Subtitles format
         *  @memberof Constants#
         *  @static
         */this.STPP='stpp';/**
         *  @constant {string} TTML STTP Subtitles format
         *  @memberof Constants#
         *  @static
         */this.TTML='ttml';/**
         *  @constant {string} VTT STTP Subtitles format
         *  @memberof Constants#
         *  @static
         */this.VTT='vtt';/**
         *  @constant {string} WVTT STTP Subtitles format
         *  @memberof Constants#
         *  @static
         */this.WVTT='wvtt';/**
         *  @constant {string} ABR_STRATEGY_DYNAMIC Dynamic Adaptive bitrate algorithm
         *  @memberof Constants#
         *  @static
         */this.ABR_STRATEGY_DYNAMIC='abrDynamic';/**
         *  @constant {string} ABR_STRATEGY_BOLA Adaptive bitrate algorithm based on Bola (buffer level)
         *  @memberof Constants#
         *  @static
         */this.ABR_STRATEGY_BOLA='abrBola';/**
         *  @constant {string} ABR_STRATEGY_THROUGHPUT Adaptive bitrate algorithm based on throughput
         *  @memberof Constants#
         *  @static
         */this.ABR_STRATEGY_THROUGHPUT='abrThroughput';/**
         *  @constant {string} MOVING_AVERAGE_SLIDING_WINDOW Moving average sliding window
         *  @memberof Constants#
         *  @static
         */this.MOVING_AVERAGE_SLIDING_WINDOW='slidingWindow';/**
         *  @constant {string} EWMA Exponential moving average
         *  @memberof Constants#
         *  @static
         */this.MOVING_AVERAGE_EWMA='ewma';/**
         *  @constant {string} BAD_ARGUMENT_ERROR Invalid Arguments type of error
         *  @memberof Constants#
         *  @static
         */this.BAD_ARGUMENT_ERROR='Invalid Arguments';/**
         *  @constant {string} MISSING_CONFIG_ERROR Missing ocnfiguration parameters type of error
         *  @memberof Constants#
         *  @static
         */this.MISSING_CONFIG_ERROR='Missing config parameter(s)';this.LOCATION='Location';this.INITIALIZE='initialize';this.TEXT_SHOWING='showing';this.TEXT_HIDDEN='hidden';this.CC1='CC1';this.CC3='CC3';this.UTF8='utf-8';this.SCHEME_ID_URI='schemeIdUri';this.START_TIME='starttime';this.SERVICE_DESCRIPTION_LL_SCHEME='urn:dvb:dash:lowlatency:scope:2019';this.SUPPLEMENTAL_PROPERTY_LL_SCHEME='urn:dvb:dash:lowlatency:critical:2019';this.XML='XML';this.ARRAY_BUFFER='ArrayBuffer';}}]);function Constants(){_classCallCheck(this,Constants);this.init();}return Constants;}();var constants=new Constants();exports.default=constants;
//# sourceMappingURL=Constants.js.map


/***/ }),

/***/ "../../../node_modules/@hivestreaming/jsrsasign/lib/jsrsasign.js":
/*!****************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/node_modules/@hivestreaming/jsrsasign/lib/jsrsasign.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {


var navigator = {};
navigator.userAgent = false;

var window = {};
var KJUR;
/*
 * jsrsasign 5.0.12 (c) 2010-2016 Kenji Urushima | kjur.github.com/jsrsasign/license
 */

/*
 yahoo-min.js
 Copyright (c) 2011, Yahoo! Inc. All rights reserved.
 Code licensed under the BSD License:
 http://developer.yahoo.com/yui/license.html
 version: 2.9.0
 */
if(typeof YAHOO=="undefined"||!YAHOO){var YAHOO={};}YAHOO.namespace=function(){var b=arguments,g=null,e,c,f;for(e=0;e<b.length;e=e+1){f=(""+b[e]).split(".");g=YAHOO;for(c=(f[0]=="YAHOO")?1:0;c<f.length;c=c+1){g[f[c]]=g[f[c]]||{};g=g[f[c]];}}return g;};YAHOO.log=function(d,a,c){var b=YAHOO.widget.Logger;if(b&&b.log){return b.log(d,a,c);}else{return false;}};YAHOO.register=function(a,f,e){var k=YAHOO.env.modules,c,j,h,g,d;if(!k[a]){k[a]={versions:[],builds:[]};}c=k[a];j=e.version;h=e.build;g=YAHOO.env.listeners;c.name=a;c.version=j;c.build=h;c.versions.push(j);c.builds.push(h);c.mainClass=f;for(d=0;d<g.length;d=d+1){g[d](c);}if(f){f.VERSION=j;f.BUILD=h;}else{YAHOO.log("mainClass is undefined for module "+a,"warn");}};YAHOO.env=YAHOO.env||{modules:[],listeners:[]};YAHOO.env.getVersion=function(a){return YAHOO.env.modules[a]||null;};YAHOO.env.parseUA=function(d){var e=function(i){var j=0;return parseFloat(i.replace(/\./g,function(){return(j++==1)?"":".";}));},h=navigator,g={ie:0,opera:0,gecko:0,webkit:0,chrome:0,mobile:null,air:0,ipad:0,iphone:0,ipod:0,ios:null,android:0,webos:0,caja:h&&h.cajaVersion,secure:false,os:null},c=d||(navigator&&navigator.userAgent),f=window&&window.location,b=f&&f.href,a;g.secure=b&&(b.toLowerCase().indexOf("https")===0);if(c){if((/windows|win32/i).test(c)){g.os="windows";}else{if((/macintosh/i).test(c)){g.os="macintosh";}else{if((/rhino/i).test(c)){g.os="rhino";}}}if((/KHTML/).test(c)){g.webkit=1;}a=c.match(/AppleWebKit\/([^\s]*)/);if(a&&a[1]){g.webkit=e(a[1]);if(/ Mobile\//.test(c)){g.mobile="Apple";a=c.match(/OS ([^\s]*)/);if(a&&a[1]){a=e(a[1].replace("_","."));}g.ios=a;g.ipad=g.ipod=g.iphone=0;a=c.match(/iPad|iPod|iPhone/);if(a&&a[0]){g[a[0].toLowerCase()]=g.ios;}}else{a=c.match(/NokiaN[^\/]*|Android \d\.\d|webOS\/\d\.\d/);if(a){g.mobile=a[0];}if(/webOS/.test(c)){g.mobile="WebOS";a=c.match(/webOS\/([^\s]*);/);if(a&&a[1]){g.webos=e(a[1]);}}if(/ Android/.test(c)){g.mobile="Android";a=c.match(/Android ([^\s]*);/);if(a&&a[1]){g.android=e(a[1]);}}}a=c.match(/Chrome\/([^\s]*)/);if(a&&a[1]){g.chrome=e(a[1]);}else{a=c.match(/AdobeAIR\/([^\s]*)/);if(a){g.air=a[0];}}}if(!g.webkit){a=c.match(/Opera[\s\/]([^\s]*)/);if(a&&a[1]){g.opera=e(a[1]);a=c.match(/Version\/([^\s]*)/);if(a&&a[1]){g.opera=e(a[1]);}a=c.match(/Opera Mini[^;]*/);if(a){g.mobile=a[0];}}else{a=c.match(/MSIE\s([^;]*)/);if(a&&a[1]){g.ie=e(a[1]);}else{a=c.match(/Gecko\/([^\s]*)/);if(a){g.gecko=1;a=c.match(/rv:([^\s\)]*)/);if(a&&a[1]){g.gecko=e(a[1]);}}}}}}return g;};YAHOO.env.ua=YAHOO.env.parseUA();(function(){YAHOO.namespace("util","widget","example");if("undefined"!==typeof YAHOO_config){var b=YAHOO_config.listener,a=YAHOO.env.listeners,d=true,c;if(b){for(c=0;c<a.length;c++){if(a[c]==b){d=false;break;}}if(d){a.push(b);}}}})();YAHOO.lang=YAHOO.lang||{};(function(){var f=YAHOO.lang,a=Object.prototype,c="[object Array]",h="[object Function]",i="[object Object]",b=[],g={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#x27;","/":"&#x2F;","`":"&#x60;"},d=["toString","valueOf"],e={isArray:function(j){return a.toString.apply(j)===c;},isBoolean:function(j){return typeof j==="boolean";},isFunction:function(j){return(typeof j==="function")||a.toString.apply(j)===h;},isNull:function(j){return j===null;},isNumber:function(j){return typeof j==="number"&&isFinite(j);},isObject:function(j){return(j&&(typeof j==="object"||f.isFunction(j)))||false;},isString:function(j){return typeof j==="string";},isUndefined:function(j){return typeof j==="undefined";},_IEEnumFix:(YAHOO.env.ua.ie)?function(l,k){var j,n,m;for(j=0;j<d.length;j=j+1){n=d[j];m=k[n];if(f.isFunction(m)&&m!=a[n]){l[n]=m;}}}:function(){},escapeHTML:function(j){return j.replace(/[&<>"'\/`]/g,function(k){return g[k];});},extend:function(m,n,l){if(!n||!m){throw new Error("extend failed, please check that "+"all dependencies are included.");}var k=function(){},j;k.prototype=n.prototype;m.prototype=new k();m.prototype.constructor=m;m.superclass=n.prototype;if(n.prototype.constructor==a.constructor){n.prototype.constructor=n;}if(l){for(j in l){if(f.hasOwnProperty(l,j)){m.prototype[j]=l[j];}}f._IEEnumFix(m.prototype,l);}},augmentObject:function(n,m){if(!m||!n){throw new Error("Absorb failed, verify dependencies.");}var j=arguments,l,o,k=j[2];if(k&&k!==true){for(l=2;l<j.length;l=l+1){n[j[l]]=m[j[l]];}}else{for(o in m){if(k||!(o in n)){n[o]=m[o];}}f._IEEnumFix(n,m);}return n;},augmentProto:function(m,l){if(!l||!m){throw new Error("Augment failed, verify dependencies.");}var j=[m.prototype,l.prototype],k;for(k=2;k<arguments.length;k=k+1){j.push(arguments[k]);}f.augmentObject.apply(this,j);return m;},dump:function(j,p){var l,n,r=[],t="{...}",k="f(){...}",q=", ",m=" => ";if(!f.isObject(j)){return j+"";}else{if(j instanceof Date||("nodeType" in j&&"tagName" in j)){return j;}else{if(f.isFunction(j)){return k;}}}p=(f.isNumber(p))?p:3;if(f.isArray(j)){r.push("[");for(l=0,n=j.length;l<n;l=l+1){if(f.isObject(j[l])){r.push((p>0)?f.dump(j[l],p-1):t);}else{r.push(j[l]);}r.push(q);}if(r.length>1){r.pop();}r.push("]");}else{r.push("{");for(l in j){if(f.hasOwnProperty(j,l)){r.push(l+m);if(f.isObject(j[l])){r.push((p>0)?f.dump(j[l],p-1):t);}else{r.push(j[l]);}r.push(q);}}if(r.length>1){r.pop();}r.push("}");}return r.join("");},substitute:function(x,y,E,l){var D,C,B,G,t,u,F=[],p,z=x.length,A="dump",r=" ",q="{",m="}",n,w;for(;;){D=x.lastIndexOf(q,z);if(D<0){break;}C=x.indexOf(m,D);if(D+1>C){break;}p=x.substring(D+1,C);G=p;u=null;B=G.indexOf(r);if(B>-1){u=G.substring(B+1);G=G.substring(0,B);}t=y[G];if(E){t=E(G,t,u);}if(f.isObject(t)){if(f.isArray(t)){t=f.dump(t,parseInt(u,10));}else{u=u||"";n=u.indexOf(A);if(n>-1){u=u.substring(4);}w=t.toString();if(w===i||n>-1){t=f.dump(t,parseInt(u,10));}else{t=w;}}}else{if(!f.isString(t)&&!f.isNumber(t)){t="~-"+F.length+"-~";F[F.length]=p;}}x=x.substring(0,D)+t+x.substring(C+1);if(l===false){z=D-1;}}for(D=F.length-1;D>=0;D=D-1){x=x.replace(new RegExp("~-"+D+"-~"),"{"+F[D]+"}","g");}return x;},trim:function(j){try{return j.replace(/^\s+|\s+$/g,"");}catch(k){return j;
}},merge:function(){var n={},k=arguments,j=k.length,m;for(m=0;m<j;m=m+1){f.augmentObject(n,k[m],true);}return n;},later:function(t,k,u,n,p){t=t||0;k=k||{};var l=u,s=n,q,j;if(f.isString(u)){l=k[u];}if(!l){throw new TypeError("method undefined");}if(!f.isUndefined(n)&&!f.isArray(s)){s=[n];}q=function(){l.apply(k,s||b);};j=(p)?setInterval(q,t):setTimeout(q,t);return{interval:p,cancel:function(){if(this.interval){clearInterval(j);}else{clearTimeout(j);}}};},isValue:function(j){return(f.isObject(j)||f.isString(j)||f.isNumber(j)||f.isBoolean(j));}};f.hasOwnProperty=(a.hasOwnProperty)?function(j,k){return j&&j.hasOwnProperty&&j.hasOwnProperty(k);}:function(j,k){return !f.isUndefined(j[k])&&j.constructor.prototype[k]!==j[k];};e.augmentObject(f,e,true);YAHOO.util.Lang=f;f.augment=f.augmentProto;YAHOO.augment=f.augmentProto;YAHOO.extend=f.extend;})();YAHOO.register("yahoo",YAHOO,{version:"2.9.0",build:"2800"});

/*! CryptoJS v3.1.2 core-fix.js
 * code.google.com/p/crypto-js
 * (c) 2009-2013 by Jeff Mott. All rights reserved.
 * code.google.com/p/crypto-js/wiki/License
 * THIS IS FIX of 'core.js' to fix Hmac issue.
 * https://code.google.com/p/crypto-js/issues/detail?id=84
 * https://crypto-js.googlecode.com/svn-history/r667/branches/3.x/src/core.js
 */
var CryptoJS=CryptoJS||(function(e,g){var a={};var b=a.lib={};var j=b.Base=(function(){function n(){}return{extend:function(p){n.prototype=this;var o=new n();if(p){o.mixIn(p)}if(!o.hasOwnProperty("init")){o.init=function(){o.$super.init.apply(this,arguments)}}o.init.prototype=o;o.$super=this;return o},create:function(){var o=this.extend();o.init.apply(o,arguments);return o},init:function(){},mixIn:function(p){for(var o in p){if(p.hasOwnProperty(o)){this[o]=p[o]}}if(p.hasOwnProperty("toString")){this.toString=p.toString}},clone:function(){return this.init.prototype.extend(this)}}}());var l=b.WordArray=j.extend({init:function(o,n){o=this.words=o||[];if(n!=g){this.sigBytes=n}else{this.sigBytes=o.length*4}},toString:function(n){return(n||h).stringify(this)},concat:function(t){var q=this.words;var p=t.words;var n=this.sigBytes;var s=t.sigBytes;this.clamp();if(n%4){for(var r=0;r<s;r++){var o=(p[r>>>2]>>>(24-(r%4)*8))&255;q[(n+r)>>>2]|=o<<(24-((n+r)%4)*8)}}else{for(var r=0;r<s;r+=4){q[(n+r)>>>2]=p[r>>>2]}}this.sigBytes+=s;return this},clamp:function(){var o=this.words;var n=this.sigBytes;o[n>>>2]&=4294967295<<(32-(n%4)*8);o.length=e.ceil(n/4)},clone:function(){var n=j.clone.call(this);n.words=this.words.slice(0);return n},random:function(p){var o=[];for(var n=0;n<p;n+=4){o.push((e.random()*4294967296)|0)}return new l.init(o,p)}});var m=a.enc={};var h=m.Hex={stringify:function(p){var r=p.words;var o=p.sigBytes;var q=[];for(var n=0;n<o;n++){var s=(r[n>>>2]>>>(24-(n%4)*8))&255;q.push((s>>>4).toString(16));q.push((s&15).toString(16))}return q.join("")},parse:function(p){var n=p.length;var q=[];for(var o=0;o<n;o+=2){q[o>>>3]|=parseInt(p.substr(o,2),16)<<(24-(o%8)*4)}return new l.init(q,n/2)}};var d=m.Latin1={stringify:function(q){var r=q.words;var p=q.sigBytes;var n=[];for(var o=0;o<p;o++){var s=(r[o>>>2]>>>(24-(o%4)*8))&255;n.push(String.fromCharCode(s))}return n.join("")},parse:function(p){var n=p.length;var q=[];for(var o=0;o<n;o++){q[o>>>2]|=(p.charCodeAt(o)&255)<<(24-(o%4)*8)}return new l.init(q,n)}};var c=m.Utf8={stringify:function(n){try{return decodeURIComponent(escape(d.stringify(n)))}catch(o){throw new Error("Malformed UTF-8 data")}},parse:function(n){return d.parse(unescape(encodeURIComponent(n)))}};var i=b.BufferedBlockAlgorithm=j.extend({reset:function(){this._data=new l.init();this._nDataBytes=0},_append:function(n){if(typeof n=="string"){n=c.parse(n)}this._data.concat(n);this._nDataBytes+=n.sigBytes},_process:function(w){var q=this._data;var x=q.words;var n=q.sigBytes;var t=this.blockSize;var v=t*4;var u=n/v;if(w){u=e.ceil(u)}else{u=e.max((u|0)-this._minBufferSize,0)}var s=u*t;var r=e.min(s*4,n);if(s){for(var p=0;p<s;p+=t){this._doProcessBlock(x,p)}var o=x.splice(0,s);q.sigBytes-=r}return new l.init(o,r)},clone:function(){var n=j.clone.call(this);n._data=this._data.clone();return n},_minBufferSize:0});var f=b.Hasher=i.extend({cfg:j.extend(),init:function(n){this.cfg=this.cfg.extend(n);this.reset()},reset:function(){i.reset.call(this);this._doReset()},update:function(n){this._append(n);this._process();return this},finalize:function(n){if(n){this._append(n)}var o=this._doFinalize();return o},blockSize:512/32,_createHelper:function(n){return function(p,o){return new n.init(o).finalize(p)}},_createHmacHelper:function(n){return function(p,o){return new k.HMAC.init(n,o).finalize(p)}}});var k=a.algo={};return a}(Math));
/*
 CryptoJS v3.1.2 md5-min.js
 code.google.com/p/crypto-js
 (c) 2009-2013 by Jeff Mott. All rights reserved.
 code.google.com/p/crypto-js/wiki/License
 */
(function(E){function h(a,f,g,j,p,h,k){a=a+(f&g|~f&j)+p+k;return(a<<h|a>>>32-h)+f}function k(a,f,g,j,p,h,k){a=a+(f&j|g&~j)+p+k;return(a<<h|a>>>32-h)+f}function l(a,f,g,j,h,k,l){a=a+(f^g^j)+h+l;return(a<<k|a>>>32-k)+f}function n(a,f,g,j,h,k,l){a=a+(g^(f|~j))+h+l;return(a<<k|a>>>32-k)+f}for(var r=CryptoJS,q=r.lib,F=q.WordArray,s=q.Hasher,q=r.algo,a=[],t=0;64>t;t++)a[t]=4294967296*E.abs(E.sin(t+1))|0;q=q.MD5=s.extend({_doReset:function(){this._hash=new F.init([1732584193,4023233417,2562383102,271733878])},
_doProcessBlock:function(m,f){for(var g=0;16>g;g++){var j=f+g,p=m[j];m[j]=(p<<8|p>>>24)&16711935|(p<<24|p>>>8)&4278255360}var g=this._hash.words,j=m[f+0],p=m[f+1],q=m[f+2],r=m[f+3],s=m[f+4],t=m[f+5],u=m[f+6],v=m[f+7],w=m[f+8],x=m[f+9],y=m[f+10],z=m[f+11],A=m[f+12],B=m[f+13],C=m[f+14],D=m[f+15],b=g[0],c=g[1],d=g[2],e=g[3],b=h(b,c,d,e,j,7,a[0]),e=h(e,b,c,d,p,12,a[1]),d=h(d,e,b,c,q,17,a[2]),c=h(c,d,e,b,r,22,a[3]),b=h(b,c,d,e,s,7,a[4]),e=h(e,b,c,d,t,12,a[5]),d=h(d,e,b,c,u,17,a[6]),c=h(c,d,e,b,v,22,a[7]),
b=h(b,c,d,e,w,7,a[8]),e=h(e,b,c,d,x,12,a[9]),d=h(d,e,b,c,y,17,a[10]),c=h(c,d,e,b,z,22,a[11]),b=h(b,c,d,e,A,7,a[12]),e=h(e,b,c,d,B,12,a[13]),d=h(d,e,b,c,C,17,a[14]),c=h(c,d,e,b,D,22,a[15]),b=k(b,c,d,e,p,5,a[16]),e=k(e,b,c,d,u,9,a[17]),d=k(d,e,b,c,z,14,a[18]),c=k(c,d,e,b,j,20,a[19]),b=k(b,c,d,e,t,5,a[20]),e=k(e,b,c,d,y,9,a[21]),d=k(d,e,b,c,D,14,a[22]),c=k(c,d,e,b,s,20,a[23]),b=k(b,c,d,e,x,5,a[24]),e=k(e,b,c,d,C,9,a[25]),d=k(d,e,b,c,r,14,a[26]),c=k(c,d,e,b,w,20,a[27]),b=k(b,c,d,e,B,5,a[28]),e=k(e,b,
c,d,q,9,a[29]),d=k(d,e,b,c,v,14,a[30]),c=k(c,d,e,b,A,20,a[31]),b=l(b,c,d,e,t,4,a[32]),e=l(e,b,c,d,w,11,a[33]),d=l(d,e,b,c,z,16,a[34]),c=l(c,d,e,b,C,23,a[35]),b=l(b,c,d,e,p,4,a[36]),e=l(e,b,c,d,s,11,a[37]),d=l(d,e,b,c,v,16,a[38]),c=l(c,d,e,b,y,23,a[39]),b=l(b,c,d,e,B,4,a[40]),e=l(e,b,c,d,j,11,a[41]),d=l(d,e,b,c,r,16,a[42]),c=l(c,d,e,b,u,23,a[43]),b=l(b,c,d,e,x,4,a[44]),e=l(e,b,c,d,A,11,a[45]),d=l(d,e,b,c,D,16,a[46]),c=l(c,d,e,b,q,23,a[47]),b=n(b,c,d,e,j,6,a[48]),e=n(e,b,c,d,v,10,a[49]),d=n(d,e,b,c,
C,15,a[50]),c=n(c,d,e,b,t,21,a[51]),b=n(b,c,d,e,A,6,a[52]),e=n(e,b,c,d,r,10,a[53]),d=n(d,e,b,c,y,15,a[54]),c=n(c,d,e,b,p,21,a[55]),b=n(b,c,d,e,w,6,a[56]),e=n(e,b,c,d,D,10,a[57]),d=n(d,e,b,c,u,15,a[58]),c=n(c,d,e,b,B,21,a[59]),b=n(b,c,d,e,s,6,a[60]),e=n(e,b,c,d,z,10,a[61]),d=n(d,e,b,c,q,15,a[62]),c=n(c,d,e,b,x,21,a[63]);g[0]=g[0]+b|0;g[1]=g[1]+c|0;g[2]=g[2]+d|0;g[3]=g[3]+e|0},_doFinalize:function(){var a=this._data,f=a.words,g=8*this._nDataBytes,j=8*a.sigBytes;f[j>>>5]|=128<<24-j%32;var h=E.floor(g/
4294967296);f[(j+64>>>9<<4)+15]=(h<<8|h>>>24)&16711935|(h<<24|h>>>8)&4278255360;f[(j+64>>>9<<4)+14]=(g<<8|g>>>24)&16711935|(g<<24|g>>>8)&4278255360;a.sigBytes=4*(f.length+1);this._process();a=this._hash;f=a.words;for(g=0;4>g;g++)j=f[g],f[g]=(j<<8|j>>>24)&16711935|(j<<24|j>>>8)&4278255360;return a},clone:function(){var a=s.clone.call(this);a._hash=this._hash.clone();return a}});r.MD5=s._createHelper(q);r.HmacMD5=s._createHmacHelper(q)})(Math);

/*
 CryptoJS v3.1.2 sha1-min.js
 code.google.com/p/crypto-js
 (c) 2009-2013 by Jeff Mott. All rights reserved.
 code.google.com/p/crypto-js/wiki/License
 */
(function(){var k=CryptoJS,b=k.lib,m=b.WordArray,l=b.Hasher,d=[],b=k.algo.SHA1=l.extend({_doReset:function(){this._hash=new m.init([1732584193,4023233417,2562383102,271733878,3285377520])},_doProcessBlock:function(n,p){for(var a=this._hash.words,e=a[0],f=a[1],h=a[2],j=a[3],b=a[4],c=0;80>c;c++){if(16>c)d[c]=n[p+c]|0;else{var g=d[c-3]^d[c-8]^d[c-14]^d[c-16];d[c]=g<<1|g>>>31}g=(e<<5|e>>>27)+b+d[c];g=20>c?g+((f&h|~f&j)+1518500249):40>c?g+((f^h^j)+1859775393):60>c?g+((f&h|f&j|h&j)-1894007588):g+((f^h^
j)-899497514);b=j;j=h;h=f<<30|f>>>2;f=e;e=g}a[0]=a[0]+e|0;a[1]=a[1]+f|0;a[2]=a[2]+h|0;a[3]=a[3]+j|0;a[4]=a[4]+b|0},_doFinalize:function(){var b=this._data,d=b.words,a=8*this._nDataBytes,e=8*b.sigBytes;d[e>>>5]|=128<<24-e%32;d[(e+64>>>9<<4)+14]=Math.floor(a/4294967296);d[(e+64>>>9<<4)+15]=a;b.sigBytes=4*d.length;this._process();return this._hash},clone:function(){var b=l.clone.call(this);b._hash=this._hash.clone();return b}});k.SHA1=l._createHelper(b);k.HmacSHA1=l._createHmacHelper(b)})();

/*! (c) Tom Wu | http://www-cs-students.stanford.edu/~tjw/jsbn/
*/
var b64map="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";var b64pad="=";function hex2b64(d){var b;var e;var a="";for(b=0;b+3<=d.length;b+=3){e=parseInt(d.substring(b,b+3),16);a+=b64map.charAt(e>>6)+b64map.charAt(e&63)}if(b+1==d.length){e=parseInt(d.substring(b,b+1),16);a+=b64map.charAt(e<<2)}else{if(b+2==d.length){e=parseInt(d.substring(b,b+2),16);a+=b64map.charAt(e>>2)+b64map.charAt((e&3)<<4)}}if(b64pad){while((a.length&3)>0){a+=b64pad}}return a}function b64tohex(f){var d="";var e;var b=0;var c;var a;for(e=0;e<f.length;++e){if(f.charAt(e)==b64pad){break}a=b64map.indexOf(f.charAt(e));if(a<0){continue}if(b==0){d+=int2char(a>>2);c=a&3;b=1}else{if(b==1){d+=int2char((c<<2)|(a>>4));c=a&15;b=2}else{if(b==2){d+=int2char(c);d+=int2char(a>>2);c=a&3;b=3}else{d+=int2char((c<<2)|(a>>4));d+=int2char(a&15);b=0}}}}if(b==1){d+=int2char(c<<2)}return d}function b64toBA(e){var d=b64tohex(e);var c;var b=new Array();for(c=0;2*c<d.length;++c){b[c]=parseInt(d.substring(2*c,2*c+2),16)}return b};
/*! (c) Tom Wu | http://www-cs-students.stanford.edu/~tjw/jsbn/
 */
var dbits;var canary=244837814094590;var j_lm=((canary&16777215)==15715070);function BigInteger(e,d,f){if(e!=null){if("number"==typeof e){this.fromNumber(e,d,f)}else{if(d==null&&"string"!=typeof e){this.fromString(e,256)}else{this.fromString(e,d)}}}}function nbi(){return new BigInteger(null)}function am1(f,a,b,e,h,g){while(--g>=0){var d=a*this[f++]+b[e]+h;h=Math.floor(d/67108864);b[e++]=d&67108863}return h}function am2(f,q,r,e,o,a){var k=q&32767,p=q>>15;while(--a>=0){var d=this[f]&32767;var g=this[f++]>>15;var b=p*d+g*k;d=k*d+((b&32767)<<15)+r[e]+(o&1073741823);o=(d>>>30)+(b>>>15)+p*g+(o>>>30);r[e++]=d&1073741823}return o}function am3(f,q,r,e,o,a){var k=q&16383,p=q>>14;while(--a>=0){var d=this[f]&16383;var g=this[f++]>>14;var b=p*d+g*k;d=k*d+((b&16383)<<14)+r[e]+o;o=(d>>28)+(b>>14)+p*g;r[e++]=d&268435455}return o}if(j_lm&&(navigator.appName=="Microsoft Internet Explorer")){BigInteger.prototype.am=am2;dbits=30}else{if(j_lm&&(navigator.appName!="Netscape")){BigInteger.prototype.am=am1;dbits=26}else{BigInteger.prototype.am=am3;dbits=28}}BigInteger.prototype.DB=dbits;BigInteger.prototype.DM=((1<<dbits)-1);BigInteger.prototype.DV=(1<<dbits);var BI_FP=52;BigInteger.prototype.FV=Math.pow(2,BI_FP);BigInteger.prototype.F1=BI_FP-dbits;BigInteger.prototype.F2=2*dbits-BI_FP;var BI_RM="0123456789abcdefghijklmnopqrstuvwxyz";var BI_RC=new Array();var rr,vv;rr="0".charCodeAt(0);for(vv=0;vv<=9;++vv){BI_RC[rr++]=vv}rr="a".charCodeAt(0);for(vv=10;vv<36;++vv){BI_RC[rr++]=vv}rr="A".charCodeAt(0);for(vv=10;vv<36;++vv){BI_RC[rr++]=vv}function int2char(a){return BI_RM.charAt(a)}function intAt(b,a){var d=BI_RC[b.charCodeAt(a)];return(d==null)?-1:d}function bnpCopyTo(b){for(var a=this.t-1;a>=0;--a){b[a]=this[a]}b.t=this.t;b.s=this.s}function bnpFromInt(a){this.t=1;this.s=(a<0)?-1:0;if(a>0){this[0]=a}else{if(a<-1){this[0]=a+this.DV}else{this.t=0}}}function nbv(a){var b=nbi();b.fromInt(a);return b}function bnpFromString(h,c){var e;if(c==16){e=4}else{if(c==8){e=3}else{if(c==256){e=8}else{if(c==2){e=1}else{if(c==32){e=5}else{if(c==4){e=2}else{this.fromRadix(h,c);return}}}}}}this.t=0;this.s=0;var g=h.length,d=false,f=0;while(--g>=0){var a=(e==8)?h[g]&255:intAt(h,g);if(a<0){if(h.charAt(g)=="-"){d=true}continue}d=false;if(f==0){this[this.t++]=a}else{if(f+e>this.DB){this[this.t-1]|=(a&((1<<(this.DB-f))-1))<<f;this[this.t++]=(a>>(this.DB-f))}else{this[this.t-1]|=a<<f}}f+=e;if(f>=this.DB){f-=this.DB}}if(e==8&&(h[0]&128)!=0){this.s=-1;if(f>0){this[this.t-1]|=((1<<(this.DB-f))-1)<<f}}this.clamp();if(d){BigInteger.ZERO.subTo(this,this)}}function bnpClamp(){var a=this.s&this.DM;while(this.t>0&&this[this.t-1]==a){--this.t}}function bnToString(c){if(this.s<0){return"-"+this.negate().toString(c)}var e;if(c==16){e=4}else{if(c==8){e=3}else{if(c==2){e=1}else{if(c==32){e=5}else{if(c==4){e=2}else{return this.toRadix(c)}}}}}var g=(1<<e)-1,l,a=false,h="",f=this.t;var j=this.DB-(f*this.DB)%e;if(f-->0){if(j<this.DB&&(l=this[f]>>j)>0){a=true;h=int2char(l)}while(f>=0){if(j<e){l=(this[f]&((1<<j)-1))<<(e-j);l|=this[--f]>>(j+=this.DB-e)}else{l=(this[f]>>(j-=e))&g;if(j<=0){j+=this.DB;--f}}if(l>0){a=true}if(a){h+=int2char(l)}}}return a?h:"0"}function bnNegate(){var a=nbi();BigInteger.ZERO.subTo(this,a);return a}function bnAbs(){return(this.s<0)?this.negate():this}function bnCompareTo(b){var d=this.s-b.s;if(d!=0){return d}var c=this.t;d=c-b.t;if(d!=0){return(this.s<0)?-d:d}while(--c>=0){if((d=this[c]-b[c])!=0){return d}}return 0}function nbits(a){var c=1,b;if((b=a>>>16)!=0){a=b;c+=16}if((b=a>>8)!=0){a=b;c+=8}if((b=a>>4)!=0){a=b;c+=4}if((b=a>>2)!=0){a=b;c+=2}if((b=a>>1)!=0){a=b;c+=1}return c}function bnBitLength(){if(this.t<=0){return 0}return this.DB*(this.t-1)+nbits(this[this.t-1]^(this.s&this.DM))}function bnpDLShiftTo(c,b){var a;for(a=this.t-1;a>=0;--a){b[a+c]=this[a]}for(a=c-1;a>=0;--a){b[a]=0}b.t=this.t+c;b.s=this.s}function bnpDRShiftTo(c,b){for(var a=c;a<this.t;++a){b[a-c]=this[a]}b.t=Math.max(this.t-c,0);b.s=this.s}function bnpLShiftTo(j,e){var b=j%this.DB;var a=this.DB-b;var g=(1<<a)-1;var f=Math.floor(j/this.DB),h=(this.s<<b)&this.DM,d;for(d=this.t-1;d>=0;--d){e[d+f+1]=(this[d]>>a)|h;h=(this[d]&g)<<b}for(d=f-1;d>=0;--d){e[d]=0}e[f]=h;e.t=this.t+f+1;e.s=this.s;e.clamp()}function bnpRShiftTo(g,d){d.s=this.s;var e=Math.floor(g/this.DB);if(e>=this.t){d.t=0;return}var b=g%this.DB;var a=this.DB-b;var f=(1<<b)-1;d[0]=this[e]>>b;for(var c=e+1;c<this.t;++c){d[c-e-1]|=(this[c]&f)<<a;d[c-e]=this[c]>>b}if(b>0){d[this.t-e-1]|=(this.s&f)<<a}d.t=this.t-e;d.clamp()}function bnpSubTo(d,f){var e=0,g=0,b=Math.min(d.t,this.t);while(e<b){g+=this[e]-d[e];f[e++]=g&this.DM;g>>=this.DB}if(d.t<this.t){g-=d.s;while(e<this.t){g+=this[e];f[e++]=g&this.DM;g>>=this.DB}g+=this.s}else{g+=this.s;while(e<d.t){g-=d[e];f[e++]=g&this.DM;g>>=this.DB}g-=d.s}f.s=(g<0)?-1:0;if(g<-1){f[e++]=this.DV+g}else{if(g>0){f[e++]=g}}f.t=e;f.clamp()}function bnpMultiplyTo(c,e){var b=this.abs(),f=c.abs();var d=b.t;e.t=d+f.t;while(--d>=0){e[d]=0}for(d=0;d<f.t;++d){e[d+b.t]=b.am(0,f[d],e,d,0,b.t)}e.s=0;e.clamp();if(this.s!=c.s){BigInteger.ZERO.subTo(e,e)}}function bnpSquareTo(d){var a=this.abs();var b=d.t=2*a.t;while(--b>=0){d[b]=0}for(b=0;b<a.t-1;++b){var e=a.am(b,a[b],d,2*b,0,1);if((d[b+a.t]+=a.am(b+1,2*a[b],d,2*b+1,e,a.t-b-1))>=a.DV){d[b+a.t]-=a.DV;d[b+a.t+1]=1}}if(d.t>0){d[d.t-1]+=a.am(b,a[b],d,2*b,0,1)}d.s=0;d.clamp()}function bnpDivRemTo(n,h,g){var w=n.abs();if(w.t<=0){return}var k=this.abs();if(k.t<w.t){if(h!=null){h.fromInt(0)}if(g!=null){this.copyTo(g)}return}if(g==null){g=nbi()}var d=nbi(),a=this.s,l=n.s;var v=this.DB-nbits(w[w.t-1]);if(v>0){w.lShiftTo(v,d);k.lShiftTo(v,g)}else{w.copyTo(d);k.copyTo(g)}var p=d.t;var b=d[p-1];if(b==0){return}var o=b*(1<<this.F1)+((p>1)?d[p-2]>>this.F2:0);var A=this.FV/o,z=(1<<this.F1)/o,x=1<<this.F2;var u=g.t,s=u-p,f=(h==null)?nbi():h;d.dlShiftTo(s,f);if(g.compareTo(f)>=0){g[g.t++]=1;g.subTo(f,g)}BigInteger.ONE.dlShiftTo(p,f);f.subTo(d,d);while(d.t<p){d[d.t++]=0}while(--s>=0){var c=(g[--u]==b)?this.DM:Math.floor(g[u]*A+(g[u-1]+x)*z);if((g[u]+=d.am(0,c,g,s,0,p))<c){d.dlShiftTo(s,f);g.subTo(f,g);while(g[u]<--c){g.subTo(f,g)}}}if(h!=null){g.drShiftTo(p,h);if(a!=l){BigInteger.ZERO.subTo(h,h)}}g.t=p;g.clamp();if(v>0){g.rShiftTo(v,g)}if(a<0){BigInteger.ZERO.subTo(g,g)}}function bnMod(b){var c=nbi();this.abs().divRemTo(b,null,c);if(this.s<0&&c.compareTo(BigInteger.ZERO)>0){b.subTo(c,c)}return c}function Classic(a){this.m=a}function cConvert(a){if(a.s<0||a.compareTo(this.m)>=0){return a.mod(this.m)}else{return a}}function cRevert(a){return a}function cReduce(a){a.divRemTo(this.m,null,a)}function cMulTo(a,c,b){a.multiplyTo(c,b);this.reduce(b)}function cSqrTo(a,b){a.squareTo(b);this.reduce(b)}Classic.prototype.convert=cConvert;Classic.prototype.revert=cRevert;Classic.prototype.reduce=cReduce;Classic.prototype.mulTo=cMulTo;Classic.prototype.sqrTo=cSqrTo;function bnpInvDigit(){if(this.t<1){return 0}var a=this[0];if((a&1)==0){return 0}var b=a&3;b=(b*(2-(a&15)*b))&15;b=(b*(2-(a&255)*b))&255;b=(b*(2-(((a&65535)*b)&65535)))&65535;b=(b*(2-a*b%this.DV))%this.DV;return(b>0)?this.DV-b:-b}function Montgomery(a){this.m=a;this.mp=a.invDigit();this.mpl=this.mp&32767;this.mph=this.mp>>15;this.um=(1<<(a.DB-15))-1;this.mt2=2*a.t}function montConvert(a){var b=nbi();a.abs().dlShiftTo(this.m.t,b);b.divRemTo(this.m,null,b);if(a.s<0&&b.compareTo(BigInteger.ZERO)>0){this.m.subTo(b,b)}return b}function montRevert(a){var b=nbi();a.copyTo(b);this.reduce(b);return b}function montReduce(a){while(a.t<=this.mt2){a[a.t++]=0}for(var c=0;c<this.m.t;++c){var b=a[c]&32767;var d=(b*this.mpl+(((b*this.mph+(a[c]>>15)*this.mpl)&this.um)<<15))&a.DM;b=c+this.m.t;a[b]+=this.m.am(0,d,a,c,0,this.m.t);while(a[b]>=a.DV){a[b]-=a.DV;a[++b]++}}a.clamp();a.drShiftTo(this.m.t,a);if(a.compareTo(this.m)>=0){a.subTo(this.m,a)}}function montSqrTo(a,b){a.squareTo(b);this.reduce(b)}function montMulTo(a,c,b){a.multiplyTo(c,b);this.reduce(b)}Montgomery.prototype.convert=montConvert;Montgomery.prototype.revert=montRevert;Montgomery.prototype.reduce=montReduce;Montgomery.prototype.mulTo=montMulTo;Montgomery.prototype.sqrTo=montSqrTo;function bnpIsEven(){return((this.t>0)?(this[0]&1):this.s)==0}function bnpExp(h,j){if(h>4294967295||h<1){return BigInteger.ONE}var f=nbi(),a=nbi(),d=j.convert(this),c=nbits(h)-1;d.copyTo(f);while(--c>=0){j.sqrTo(f,a);if((h&(1<<c))>0){j.mulTo(a,d,f)}else{var b=f;f=a;a=b}}return j.revert(f)}function bnModPowInt(b,a){var c;if(b<256||a.isEven()){c=new Classic(a)}else{c=new Montgomery(a)}return this.exp(b,c)}BigInteger.prototype.copyTo=bnpCopyTo;BigInteger.prototype.fromInt=bnpFromInt;BigInteger.prototype.fromString=bnpFromString;BigInteger.prototype.clamp=bnpClamp;BigInteger.prototype.dlShiftTo=bnpDLShiftTo;BigInteger.prototype.drShiftTo=bnpDRShiftTo;BigInteger.prototype.lShiftTo=bnpLShiftTo;BigInteger.prototype.rShiftTo=bnpRShiftTo;BigInteger.prototype.subTo=bnpSubTo;BigInteger.prototype.multiplyTo=bnpMultiplyTo;BigInteger.prototype.squareTo=bnpSquareTo;BigInteger.prototype.divRemTo=bnpDivRemTo;BigInteger.prototype.invDigit=bnpInvDigit;BigInteger.prototype.isEven=bnpIsEven;BigInteger.prototype.exp=bnpExp;BigInteger.prototype.toString=bnToString;BigInteger.prototype.negate=bnNegate;BigInteger.prototype.abs=bnAbs;BigInteger.prototype.compareTo=bnCompareTo;BigInteger.prototype.bitLength=bnBitLength;BigInteger.prototype.mod=bnMod;BigInteger.prototype.modPowInt=bnModPowInt;BigInteger.ZERO=nbv(0);BigInteger.ONE=nbv(1);
/*! (c) Tom Wu | http://www-cs-students.stanford.edu/~tjw/jsbn/
*/
function parseBigInt(b,a){return new BigInteger(b,a)}function linebrk(c,d){var a="";var b=0;while(b+d<c.length){a+=c.substring(b,b+d)+"\n";b+=d}return a+c.substring(b,c.length)}function byte2Hex(a){if(a<16){return"0"+a.toString(16)}else{return a.toString(16)}}function pkcs1pad2(e,h){if(h<e.length+11){alert("Message too long for RSA");return null}var g=new Array();var d=e.length-1;while(d>=0&&h>0){var f=e.charCodeAt(d--);if(f<128){g[--h]=f}else{if((f>127)&&(f<2048)){g[--h]=(f&63)|128;g[--h]=(f>>6)|192}else{g[--h]=(f&63)|128;g[--h]=((f>>6)&63)|128;g[--h]=(f>>12)|224}}}g[--h]=0;var b=new SecureRandom();var a=new Array();while(h>2){a[0]=0;while(a[0]==0){b.nextBytes(a)}g[--h]=a[0]}g[--h]=2;g[--h]=0;return new BigInteger(g)}function oaep_mgf1_arr(c,a,e){var b="",d=0;while(b.length<a){b+=e(String.fromCharCode.apply(String,c.concat([(d&4278190080)>>24,(d&16711680)>>16,(d&65280)>>8,d&255])));d+=1}return b}var SHA1_SIZE=20;function oaep_pad(l,a,c){if(l.length+2*SHA1_SIZE+2>a){throw"Message too long for RSA"}var h="",d;for(d=0;d<a-l.length-2*SHA1_SIZE-2;d+=1){h+="\x00"}var e=rstr_sha1("")+h+"\x01"+l;var f=new Array(SHA1_SIZE);new SecureRandom().nextBytes(f);var g=oaep_mgf1_arr(f,e.length,c||rstr_sha1);var k=[];for(d=0;d<e.length;d+=1){k[d]=e.charCodeAt(d)^g.charCodeAt(d)}var j=oaep_mgf1_arr(k,f.length,rstr_sha1);var b=[0];for(d=0;d<f.length;d+=1){b[d+1]=f[d]^j.charCodeAt(d)}return new BigInteger(b.concat(k))}function RSAKey(){this.n=null;this.e=0;this.d=null;this.p=null;this.q=null;this.dmp1=null;this.dmq1=null;this.coeff=null}function RSASetPublic(b,a){this.isPublic=true;if(typeof b!=="string"){this.n=b;this.e=a}else{if(b!=null&&a!=null&&b.length>0&&a.length>0){this.n=parseBigInt(b,16);this.e=parseInt(a,16)}else{alert("Invalid RSA public key")}}}function RSADoPublic(a){return a.modPowInt(this.e,this.n)}function RSAEncrypt(d){var a=pkcs1pad2(d,(this.n.bitLength()+7)>>3);if(a==null){return null}var e=this.doPublic(a);if(e==null){return null}var b=e.toString(16);if((b.length&1)==0){return b}else{return"0"+b}}function RSAEncryptOAEP(e,d){var a=oaep_pad(e,(this.n.bitLength()+7)>>3,d);if(a==null){return null}var f=this.doPublic(a);if(f==null){return null}var b=f.toString(16);if((b.length&1)==0){return b}else{return"0"+b}}RSAKey.prototype.doPublic=RSADoPublic;RSAKey.prototype.setPublic=RSASetPublic;RSAKey.prototype.encrypt=RSAEncrypt;RSAKey.prototype.encryptOAEP=RSAEncryptOAEP;RSAKey.prototype.type="RSA";
/*! asn1-1.0.9.js (c) 2013-2015 Kenji Urushima | kjur.github.com/jsrsasign/license
 */
if(typeof KJUR=="undefined"||!KJUR){KJUR={}}if(typeof KJUR.asn1=="undefined"||!KJUR.asn1){KJUR.asn1={}}KJUR.asn1.ASN1Util=new function(){this.integerToByteHex=function(a){var b=a.toString(16);if((b.length%2)==1){b="0"+b}return b};this.bigIntToMinTwosComplementsHex=function(j){var f=j.toString(16);if(f.substr(0,1)!="-"){if(f.length%2==1){f="0"+f}else{if(!f.match(/^[0-7]/)){f="00"+f}}}else{var a=f.substr(1);var e=a.length;if(e%2==1){e+=1}else{if(!f.match(/^[0-7]/)){e+=2}}var g="";for(var d=0;d<e;d++){g+="f"}var c=new BigInteger(g,16);var b=c.xor(j).add(BigInteger.ONE);f=b.toString(16).replace(/^-/,"")}return f};this.getPEMStringFromHex=function(a,b){var c=KJUR.asn1;var f=CryptoJS.enc.Hex.parse(a);var d=CryptoJS.enc.Base64.stringify(f);var e=d.replace(/(.{64})/g,"$1\r\n");e=e.replace(/\r\n$/,"");return"-----BEGIN "+b+"-----\r\n"+e+"\r\n-----END "+b+"-----\r\n"};this.newObject=function(b){var g=KJUR.asn1;var k=Object.keys(b);if(k.length!=1){throw"key of param shall be only one."}var j=k[0];if(":bool:int:bitstr:octstr:null:oid:enum:utf8str:numstr:prnstr:telstr:ia5str:utctime:gentime:seq:set:tag:".indexOf(":"+j+":")==-1){throw"undefined key: "+j}if(j=="bool"){return new g.DERBoolean(b[j])}if(j=="int"){return new g.DERInteger(b[j])}if(j=="bitstr"){return new g.DERBitString(b[j])}if(j=="octstr"){return new g.DEROctetString(b[j])}if(j=="null"){return new g.DERNull(b[j])}if(j=="oid"){return new g.DERObjectIdentifier(b[j])}if(j=="enum"){return new g.DEREnumerated(b[j])}if(j=="utf8str"){return new g.DERUTF8String(b[j])}if(j=="numstr"){return new g.DERNumericString(b[j])}if(j=="prnstr"){return new g.DERPrintableString(b[j])}if(j=="telstr"){return new g.DERTeletexString(b[j])}if(j=="ia5str"){return new g.DERIA5String(b[j])}if(j=="utctime"){return new g.DERUTCTime(b[j])}if(j=="gentime"){return new g.DERGeneralizedTime(b[j])}if(j=="seq"){var m=b[j];var h=[];for(var e=0;e<m.length;e++){var l=g.ASN1Util.newObject(m[e]);h.push(l)}return new g.DERSequence({array:h})}if(j=="set"){var m=b[j];var h=[];for(var e=0;e<m.length;e++){var l=g.ASN1Util.newObject(m[e]);h.push(l)}return new g.DERSet({array:h})}if(j=="tag"){var c=b[j];if(Object.prototype.toString.call(c)==="[object Array]"&&c.length==3){var d=g.ASN1Util.newObject(c[2]);return new g.DERTaggedObject({tag:c[0],explicit:c[1],obj:d})}else{var f={};if(c.explicit!==undefined){f.explicit=c.explicit}if(c.tag!==undefined){f.tag=c.tag}if(c.obj===undefined){throw"obj shall be specified for 'tag'."}f.obj=g.ASN1Util.newObject(c.obj);return new g.DERTaggedObject(f)}}};this.jsonToASN1HEX=function(b){var a=this.newObject(b);return a.getEncodedHex()}};KJUR.asn1.ASN1Util.oidHexToInt=function(a){var j="";var k=parseInt(a.substr(0,2),16);var d=Math.floor(k/40);var c=k%40;var j=d+"."+c;var e="";for(var f=2;f<a.length;f+=2){var g=parseInt(a.substr(f,2),16);var h=("00000000"+g.toString(2)).slice(-8);e=e+h.substr(1,7);if(h.substr(0,1)=="0"){var b=new BigInteger(e,2);j=j+"."+b.toString(10);e=""}}return j};KJUR.asn1.ASN1Util.oidIntToHex=function(f){var e=function(a){var k=a.toString(16);if(k.length==1){k="0"+k}return k};var d=function(o){var n="";var k=new BigInteger(o,10);var a=k.toString(2);var l=7-a.length%7;if(l==7){l=0}var q="";for(var m=0;m<l;m++){q+="0"}a=q+a;for(var m=0;m<a.length-1;m+=7){var p=a.substr(m,7);if(m!=a.length-7){p="1"+p}n+=e(parseInt(p,2))}return n};if(!f.match(/^[0-9.]+$/)){throw"malformed oid string: "+f}var g="";var b=f.split(".");var j=parseInt(b[0])*40+parseInt(b[1]);g+=e(j);b.splice(0,2);for(var c=0;c<b.length;c++){g+=d(b[c])}return g};KJUR.asn1.ASN1Object=function(){var c=true;var b=null;var d="00";var e="00";var a="";this.getLengthHexFromValue=function(){if(typeof this.hV=="undefined"||this.hV==null){throw"this.hV is null or undefined."}if(this.hV.length%2==1){throw"value hex must be even length: n="+a.length+",v="+this.hV}var i=this.hV.length/2;var h=i.toString(16);if(h.length%2==1){h="0"+h}if(i<128){return h}else{var g=h.length/2;if(g>15){throw"ASN.1 length too long to represent by 8x: n = "+i.toString(16)}var f=128+g;return f.toString(16)+h}};this.getEncodedHex=function(){if(this.hTLV==null||this.isModified){this.hV=this.getFreshValueHex();this.hL=this.getLengthHexFromValue();this.hTLV=this.hT+this.hL+this.hV;this.isModified=false}return this.hTLV};this.getValueHex=function(){this.getEncodedHex();return this.hV};this.getFreshValueHex=function(){return""}};KJUR.asn1.DERAbstractString=function(c){KJUR.asn1.DERAbstractString.superclass.constructor.call(this);var b=null;var a=null;this.getString=function(){return this.s};this.setString=function(d){this.hTLV=null;this.isModified=true;this.s=d;this.hV=stohex(this.s)};this.setStringHex=function(d){this.hTLV=null;this.isModified=true;this.s=null;this.hV=d};this.getFreshValueHex=function(){return this.hV};if(typeof c!="undefined"){if(typeof c=="string"){this.setString(c)}else{if(typeof c.str!="undefined"){this.setString(c.str)}else{if(typeof c.hex!="undefined"){this.setStringHex(c.hex)}}}}};YAHOO.lang.extend(KJUR.asn1.DERAbstractString,KJUR.asn1.ASN1Object);KJUR.asn1.DERAbstractTime=function(c){KJUR.asn1.DERAbstractTime.superclass.constructor.call(this);var b=null;var a=null;this.localDateToUTC=function(f){utc=f.getTime()+(f.getTimezoneOffset()*60000);var e=new Date(utc);return e};this.formatDate=function(m,o,e){var g=this.zeroPadding;var n=this.localDateToUTC(m);var p=String(n.getFullYear());if(o=="utc"){p=p.substr(2,2)}var l=g(String(n.getMonth()+1),2);var q=g(String(n.getDate()),2);var h=g(String(n.getHours()),2);var i=g(String(n.getMinutes()),2);var j=g(String(n.getSeconds()),2);var r=p+l+q+h+i+j;if(e===true){var f=n.getMilliseconds();if(f!=0){var k=g(String(f),3);k=k.replace(/[0]+$/,"");r=r+"."+k}}return r+"Z"};this.zeroPadding=function(e,d){if(e.length>=d){return e}return new Array(d-e.length+1).join("0")+e};this.getString=function(){return this.s};this.setString=function(d){this.hTLV=null;this.isModified=true;this.s=d;this.hV=stohex(d)};this.setByDateValue=function(h,j,e,d,f,g){var i=new Date(Date.UTC(h,j-1,e,d,f,g,0));this.setByDate(i)};this.getFreshValueHex=function(){return this.hV}};YAHOO.lang.extend(KJUR.asn1.DERAbstractTime,KJUR.asn1.ASN1Object);KJUR.asn1.DERAbstractStructured=function(b){KJUR.asn1.DERAbstractString.superclass.constructor.call(this);var a=null;this.setByASN1ObjectArray=function(c){this.hTLV=null;this.isModified=true;this.asn1Array=c};this.appendASN1Object=function(c){this.hTLV=null;this.isModified=true;this.asn1Array.push(c)};this.asn1Array=new Array();if(typeof b!="undefined"){if(typeof b.array!="undefined"){this.asn1Array=b.array}}};YAHOO.lang.extend(KJUR.asn1.DERAbstractStructured,KJUR.asn1.ASN1Object);KJUR.asn1.DERBoolean=function(){KJUR.asn1.DERBoolean.superclass.constructor.call(this);this.hT="01";this.hTLV="0101ff"};YAHOO.lang.extend(KJUR.asn1.DERBoolean,KJUR.asn1.ASN1Object);KJUR.asn1.DERInteger=function(a){KJUR.asn1.DERInteger.superclass.constructor.call(this);this.hT="02";this.setByBigInteger=function(b){this.hTLV=null;this.isModified=true;this.hV=KJUR.asn1.ASN1Util.bigIntToMinTwosComplementsHex(b)};this.setByInteger=function(c){var b=new BigInteger(String(c),10);this.setByBigInteger(b)};this.setValueHex=function(b){this.hV=b};this.getFreshValueHex=function(){return this.hV};if(typeof a!="undefined"){if(typeof a.bigint!="undefined"){this.setByBigInteger(a.bigint)}else{if(typeof a["int"]!="undefined"){this.setByInteger(a["int"])}else{if(typeof a=="number"){this.setByInteger(a)}else{if(typeof a.hex!="undefined"){this.setValueHex(a.hex)}}}}}};YAHOO.lang.extend(KJUR.asn1.DERInteger,KJUR.asn1.ASN1Object);KJUR.asn1.DERBitString=function(a){KJUR.asn1.DERBitString.superclass.constructor.call(this);this.hT="03";this.setHexValueIncludingUnusedBits=function(b){this.hTLV=null;this.isModified=true;this.hV=b};this.setUnusedBitsAndHexValue=function(b,d){if(b<0||7<b){throw"unused bits shall be from 0 to 7: u = "+b}var c="0"+b;this.hTLV=null;this.isModified=true;this.hV=c+d};this.setByBinaryString=function(e){e=e.replace(/0+$/,"");var f=8-e.length%8;if(f==8){f=0}for(var g=0;g<=f;g++){e+="0"}var j="";for(var g=0;g<e.length-1;g+=8){var d=e.substr(g,8);var c=parseInt(d,2).toString(16);if(c.length==1){c="0"+c}j+=c}this.hTLV=null;this.isModified=true;this.hV="0"+f+j};this.setByBooleanArray=function(d){var c="";for(var b=0;b<d.length;b++){if(d[b]==true){c+="1"}else{c+="0"}}this.setByBinaryString(c)};this.newFalseArray=function(d){var b=new Array(d);for(var c=0;c<d;c++){b[c]=false}return b};this.getFreshValueHex=function(){return this.hV};if(typeof a!="undefined"){if(typeof a=="string"&&a.toLowerCase().match(/^[0-9a-f]+$/)){this.setHexValueIncludingUnusedBits(a)}else{if(typeof a.hex!="undefined"){this.setHexValueIncludingUnusedBits(a.hex)}else{if(typeof a.bin!="undefined"){this.setByBinaryString(a.bin)}else{if(typeof a.array!="undefined"){this.setByBooleanArray(a.array)}}}}}};YAHOO.lang.extend(KJUR.asn1.DERBitString,KJUR.asn1.ASN1Object);KJUR.asn1.DEROctetString=function(a){KJUR.asn1.DEROctetString.superclass.constructor.call(this,a);this.hT="04"};YAHOO.lang.extend(KJUR.asn1.DEROctetString,KJUR.asn1.DERAbstractString);KJUR.asn1.DERNull=function(){KJUR.asn1.DERNull.superclass.constructor.call(this);this.hT="05";this.hTLV="0500"};YAHOO.lang.extend(KJUR.asn1.DERNull,KJUR.asn1.ASN1Object);KJUR.asn1.DERObjectIdentifier=function(c){var b=function(d){var e=d.toString(16);if(e.length==1){e="0"+e}return e};var a=function(k){var j="";var e=new BigInteger(k,10);var d=e.toString(2);var f=7-d.length%7;if(f==7){f=0}var m="";for(var g=0;g<f;g++){m+="0"}d=m+d;for(var g=0;g<d.length-1;g+=7){var l=d.substr(g,7);if(g!=d.length-7){l="1"+l}j+=b(parseInt(l,2))}return j};KJUR.asn1.DERObjectIdentifier.superclass.constructor.call(this);this.hT="06";this.setValueHex=function(d){this.hTLV=null;this.isModified=true;this.s=null;this.hV=d};this.setValueOidString=function(f){if(!f.match(/^[0-9.]+$/)){throw"malformed oid string: "+f}var g="";var d=f.split(".");var j=parseInt(d[0])*40+parseInt(d[1]);g+=b(j);d.splice(0,2);for(var e=0;e<d.length;e++){g+=a(d[e])}this.hTLV=null;this.isModified=true;this.s=null;this.hV=g};this.setValueName=function(e){if(typeof KJUR.asn1.x509.OID.name2oidList[e]!="undefined"){var d=KJUR.asn1.x509.OID.name2oidList[e];this.setValueOidString(d)}else{throw"DERObjectIdentifier oidName undefined: "+e}};this.getFreshValueHex=function(){return this.hV};if(typeof c!="undefined"){if(typeof c=="string"&&c.match(/^[0-2].[0-9.]+$/)){this.setValueOidString(c)}else{if(KJUR.asn1.x509.OID.name2oidList[c]!==undefined){this.setValueOidString(KJUR.asn1.x509.OID.name2oidList[c])}else{if(typeof c.oid!="undefined"){this.setValueOidString(c.oid)}else{if(typeof c.hex!="undefined"){this.setValueHex(c.hex)}else{if(typeof c.name!="undefined"){this.setValueName(c.name)}}}}}}};YAHOO.lang.extend(KJUR.asn1.DERObjectIdentifier,KJUR.asn1.ASN1Object);KJUR.asn1.DEREnumerated=function(a){KJUR.asn1.DEREnumerated.superclass.constructor.call(this);this.hT="0a";this.setByBigInteger=function(b){this.hTLV=null;this.isModified=true;this.hV=KJUR.asn1.ASN1Util.bigIntToMinTwosComplementsHex(b)};this.setByInteger=function(c){var b=new BigInteger(String(c),10);this.setByBigInteger(b)};this.setValueHex=function(b){this.hV=b};this.getFreshValueHex=function(){return this.hV};if(typeof a!="undefined"){if(typeof a["int"]!="undefined"){this.setByInteger(a["int"])}else{if(typeof a=="number"){this.setByInteger(a)}else{if(typeof a.hex!="undefined"){this.setValueHex(a.hex)}}}}};YAHOO.lang.extend(KJUR.asn1.DEREnumerated,KJUR.asn1.ASN1Object);KJUR.asn1.DERUTF8String=function(a){KJUR.asn1.DERUTF8String.superclass.constructor.call(this,a);this.hT="0c"};YAHOO.lang.extend(KJUR.asn1.DERUTF8String,KJUR.asn1.DERAbstractString);KJUR.asn1.DERNumericString=function(a){KJUR.asn1.DERNumericString.superclass.constructor.call(this,a);this.hT="12"};YAHOO.lang.extend(KJUR.asn1.DERNumericString,KJUR.asn1.DERAbstractString);KJUR.asn1.DERPrintableString=function(a){KJUR.asn1.DERPrintableString.superclass.constructor.call(this,a);this.hT="13"};YAHOO.lang.extend(KJUR.asn1.DERPrintableString,KJUR.asn1.DERAbstractString);KJUR.asn1.DERTeletexString=function(a){KJUR.asn1.DERTeletexString.superclass.constructor.call(this,a);this.hT="14"};YAHOO.lang.extend(KJUR.asn1.DERTeletexString,KJUR.asn1.DERAbstractString);KJUR.asn1.DERIA5String=function(a){KJUR.asn1.DERIA5String.superclass.constructor.call(this,a);this.hT="16"};YAHOO.lang.extend(KJUR.asn1.DERIA5String,KJUR.asn1.DERAbstractString);KJUR.asn1.DERUTCTime=function(a){KJUR.asn1.DERUTCTime.superclass.constructor.call(this,a);this.hT="17";this.setByDate=function(b){this.hTLV=null;this.isModified=true;this.date=b;this.s=this.formatDate(this.date,"utc");this.hV=stohex(this.s)};this.getFreshValueHex=function(){if(typeof this.date=="undefined"&&typeof this.s=="undefined"){this.date=new Date();this.s=this.formatDate(this.date,"utc");this.hV=stohex(this.s)}return this.hV};if(a!==undefined){if(a.str!==undefined){this.setString(a.str)}else{if(typeof a=="string"&&a.match(/^[0-9]{12}Z$/)){this.setString(a)}else{if(a.hex!==undefined){this.setStringHex(a.hex)}else{if(a.date!==undefined){this.setByDate(a.date)}}}}}};YAHOO.lang.extend(KJUR.asn1.DERUTCTime,KJUR.asn1.DERAbstractTime);KJUR.asn1.DERGeneralizedTime=function(a){KJUR.asn1.DERGeneralizedTime.superclass.constructor.call(this,a);this.hT="18";this.withMillis=false;this.setByDate=function(b){this.hTLV=null;this.isModified=true;this.date=b;this.s=this.formatDate(this.date,"gen",this.withMillis);this.hV=stohex(this.s)};this.getFreshValueHex=function(){if(this.date===undefined&&this.s===undefined){this.date=new Date();this.s=this.formatDate(this.date,"gen",this.withMillis);this.hV=stohex(this.s)}return this.hV};if(a!==undefined){if(a.str!==undefined){this.setString(a.str)}else{if(typeof a=="string"&&a.match(/^[0-9]{14}Z$/)){this.setString(a)}else{if(a.hex!==undefined){this.setStringHex(a.hex)}else{if(a.date!==undefined){this.setByDate(a.date)}}}}if(a.millis===true){this.withMillis=true}}};YAHOO.lang.extend(KJUR.asn1.DERGeneralizedTime,KJUR.asn1.DERAbstractTime);KJUR.asn1.DERSequence=function(a){KJUR.asn1.DERSequence.superclass.constructor.call(this,a);this.hT="30";this.getFreshValueHex=function(){var c="";for(var b=0;b<this.asn1Array.length;b++){var d=this.asn1Array[b];c+=d.getEncodedHex()}this.hV=c;return this.hV}};YAHOO.lang.extend(KJUR.asn1.DERSequence,KJUR.asn1.DERAbstractStructured);KJUR.asn1.DERSet=function(a){KJUR.asn1.DERSet.superclass.constructor.call(this,a);this.hT="31";this.sortFlag=true;this.getFreshValueHex=function(){var b=new Array();for(var c=0;c<this.asn1Array.length;c++){var d=this.asn1Array[c];b.push(d.getEncodedHex())}if(this.sortFlag==true){b.sort()}this.hV=b.join("");return this.hV};if(typeof a!="undefined"){if(typeof a.sortflag!="undefined"&&a.sortflag==false){this.sortFlag=false}}};YAHOO.lang.extend(KJUR.asn1.DERSet,KJUR.asn1.DERAbstractStructured);KJUR.asn1.DERTaggedObject=function(a){KJUR.asn1.DERTaggedObject.superclass.constructor.call(this);this.hT="a0";this.hV="";this.isExplicit=true;this.asn1Object=null;this.setASN1Object=function(b,c,d){this.hT=c;this.isExplicit=b;this.asn1Object=d;if(this.isExplicit){this.hV=this.asn1Object.getEncodedHex();this.hTLV=null;this.isModified=true}else{this.hV=null;this.hTLV=d.getEncodedHex();this.hTLV=this.hTLV.replace(/^../,c);this.isModified=false}};this.getFreshValueHex=function(){return this.hV};if(typeof a!="undefined"){if(typeof a.tag!="undefined"){this.hT=a.tag}if(typeof a.explicit!="undefined"){this.isExplicit=a.explicit}if(typeof a.obj!="undefined"){this.asn1Object=a.obj;this.setASN1Object(this.isExplicit,this.hT,this.asn1Object)}}};YAHOO.lang.extend(KJUR.asn1.DERTaggedObject,KJUR.asn1.ASN1Object);
/*! crypto-1.1.8.js (c) 2013-2016 Kenji Urushima | kjur.github.com/jsrsasign/license
 */
if(typeof KJUR=="undefined"||!KJUR){KJUR={}}if(typeof KJUR.crypto=="undefined"||!KJUR.crypto){KJUR.crypto={}}KJUR.crypto.Util=new function(){this.DIGESTINFOHEAD={sha1:"3021300906052b0e03021a05000414",sha224:"302d300d06096086480165030402040500041c",sha256:"3031300d060960864801650304020105000420",sha384:"3041300d060960864801650304020205000430",sha512:"3051300d060960864801650304020305000440",md2:"3020300c06082a864886f70d020205000410",md5:"3020300c06082a864886f70d020505000410",ripemd160:"3021300906052b2403020105000414",};this.DEFAULTPROVIDER={md5:"cryptojs",sha1:"cryptojs",sha224:"cryptojs",sha256:"cryptojs",sha384:"cryptojs",sha512:"cryptojs",ripemd160:"cryptojs",hmacmd5:"cryptojs",hmacsha1:"cryptojs",hmacsha224:"cryptojs",hmacsha256:"cryptojs",hmacsha384:"cryptojs",hmacsha512:"cryptojs",hmacripemd160:"cryptojs",MD5withRSA:"cryptojs/jsrsa",SHA1withRSA:"cryptojs/jsrsa",SHA224withRSA:"cryptojs/jsrsa",SHA256withRSA:"cryptojs/jsrsa",SHA384withRSA:"cryptojs/jsrsa",SHA512withRSA:"cryptojs/jsrsa",RIPEMD160withRSA:"cryptojs/jsrsa",MD5withECDSA:"cryptojs/jsrsa",SHA1withECDSA:"cryptojs/jsrsa",SHA224withECDSA:"cryptojs/jsrsa",SHA256withECDSA:"cryptojs/jsrsa",SHA384withECDSA:"cryptojs/jsrsa",SHA512withECDSA:"cryptojs/jsrsa",RIPEMD160withECDSA:"cryptojs/jsrsa",SHA1withDSA:"cryptojs/jsrsa",SHA224withDSA:"cryptojs/jsrsa",SHA256withDSA:"cryptojs/jsrsa",MD5withRSAandMGF1:"cryptojs/jsrsa",SHA1withRSAandMGF1:"cryptojs/jsrsa",SHA224withRSAandMGF1:"cryptojs/jsrsa",SHA256withRSAandMGF1:"cryptojs/jsrsa",SHA384withRSAandMGF1:"cryptojs/jsrsa",SHA512withRSAandMGF1:"cryptojs/jsrsa",RIPEMD160withRSAandMGF1:"cryptojs/jsrsa",};this.CRYPTOJSMESSAGEDIGESTNAME={md5:CryptoJS.algo.MD5,sha1:CryptoJS.algo.SHA1,sha224:CryptoJS.algo.SHA224,sha256:CryptoJS.algo.SHA256,sha384:CryptoJS.algo.SHA384,sha512:CryptoJS.algo.SHA512,ripemd160:CryptoJS.algo.RIPEMD160};this.getDigestInfoHex=function(a,b){if(typeof this.DIGESTINFOHEAD[b]=="undefined"){throw"alg not supported in Util.DIGESTINFOHEAD: "+b}return this.DIGESTINFOHEAD[b]+a};this.getPaddedDigestInfoHex=function(h,a,j){var c=this.getDigestInfoHex(h,a);var d=j/4;if(c.length+22>d){throw"key is too short for SigAlg: keylen="+j+","+a}var b="0001";var k="00"+c;var g="";var l=d-b.length-k.length;for(var f=0;f<l;f+=2){g+="ff"}var e=b+g+k;return e};this.hashString=function(a,c){var b=new KJUR.crypto.MessageDigest({alg:c});return b.digestString(a)};this.hashHex=function(b,c){var a=new KJUR.crypto.MessageDigest({alg:c});return a.digestHex(b)};this.sha1=function(a){var b=new KJUR.crypto.MessageDigest({alg:"sha1",prov:"cryptojs"});return b.digestString(a)};this.sha256=function(a){var b=new KJUR.crypto.MessageDigest({alg:"sha256",prov:"cryptojs"});return b.digestString(a)};this.sha256Hex=function(a){var b=new KJUR.crypto.MessageDigest({alg:"sha256",prov:"cryptojs"});return b.digestHex(a)};this.sha512=function(a){var b=new KJUR.crypto.MessageDigest({alg:"sha512",prov:"cryptojs"});return b.digestString(a)};this.sha512Hex=function(a){var b=new KJUR.crypto.MessageDigest({alg:"sha512",prov:"cryptojs"});return b.digestHex(a)};this.md5=function(a){var b=new KJUR.crypto.MessageDigest({alg:"md5",prov:"cryptojs"});return b.digestString(a)};this.ripemd160=function(a){var b=new KJUR.crypto.MessageDigest({alg:"ripemd160",prov:"cryptojs"});return b.digestString(a)};this.getCryptoJSMDByName=function(a){}};KJUR.crypto.MessageDigest=function(c){var b=null;var a=null;var d=null;this.setAlgAndProvider=function(g,f){if(g!=null&&f===undefined){f=KJUR.crypto.Util.DEFAULTPROVIDER[g]}if(":md5:sha1:sha224:sha256:sha384:sha512:ripemd160:".indexOf(g)!=-1&&f=="cryptojs"){try{this.md=KJUR.crypto.Util.CRYPTOJSMESSAGEDIGESTNAME[g].create()}catch(e){throw"setAlgAndProvider hash alg set fail alg="+g+"/"+e}this.updateString=function(h){this.md.update(h)};this.updateHex=function(h){var i=CryptoJS.enc.Hex.parse(h);this.md.update(i)};this.digest=function(){var h=this.md.finalize();return h.toString(CryptoJS.enc.Hex)};this.digestString=function(h){this.updateString(h);return this.digest()};this.digestHex=function(h){this.updateHex(h);return this.digest()}}if(":sha256:".indexOf(g)!=-1&&f=="sjcl"){try{this.md=new sjcl.hash.sha256()}catch(e){throw"setAlgAndProvider hash alg set fail alg="+g+"/"+e}this.updateString=function(h){this.md.update(h)};this.updateHex=function(i){var h=sjcl.codec.hex.toBits(i);this.md.update(h)};this.digest=function(){var h=this.md.finalize();return sjcl.codec.hex.fromBits(h)};this.digestString=function(h){this.updateString(h);return this.digest()};this.digestHex=function(h){this.updateHex(h);return this.digest()}}};this.updateString=function(e){throw"updateString(str) not supported for this alg/prov: "+this.algName+"/"+this.provName};this.updateHex=function(e){throw"updateHex(hex) not supported for this alg/prov: "+this.algName+"/"+this.provName};this.digest=function(){throw"digest() not supported for this alg/prov: "+this.algName+"/"+this.provName};this.digestString=function(e){throw"digestString(str) not supported for this alg/prov: "+this.algName+"/"+this.provName};this.digestHex=function(e){throw"digestHex(hex) not supported for this alg/prov: "+this.algName+"/"+this.provName};if(c!==undefined){if(c.alg!==undefined){this.algName=c.alg;if(c.prov===undefined){this.provName=KJUR.crypto.Util.DEFAULTPROVIDER[this.algName]}this.setAlgAndProvider(this.algName,this.provName)}}};KJUR.crypto.Mac=function(d){var f=null;var c=null;var a=null;var e=null;var b=null;this.setAlgAndProvider=function(k,i){k=k.toLowerCase();if(k==null){k="hmacsha1"}k=k.toLowerCase();if(k.substr(0,4)!="hmac"){throw"setAlgAndProvider unsupported HMAC alg: "+k}if(i===undefined){i=KJUR.crypto.Util.DEFAULTPROVIDER[k]}this.algProv=k+"/"+i;var g=k.substr(4);if(":md5:sha1:sha224:sha256:sha384:sha512:ripemd160:".indexOf(g)!=-1&&i=="cryptojs"){try{var j=KJUR.crypto.Util.CRYPTOJSMESSAGEDIGESTNAME[g];this.mac=CryptoJS.algo.HMAC.create(j,this.pass)}catch(h){throw"setAlgAndProvider hash alg set fail hashAlg="+g+"/"+h}this.updateString=function(l){this.mac.update(l)};this.updateHex=function(l){var m=CryptoJS.enc.Hex.parse(l);this.mac.update(m)};this.doFinal=function(){var l=this.mac.finalize();return l.toString(CryptoJS.enc.Hex)};this.doFinalString=function(l){this.updateString(l);return this.doFinal()};this.doFinalHex=function(l){this.updateHex(l);return this.doFinal()}}};this.updateString=function(g){throw"updateString(str) not supported for this alg/prov: "+this.algProv};this.updateHex=function(g){throw"updateHex(hex) not supported for this alg/prov: "+this.algProv};this.doFinal=function(){throw"digest() not supported for this alg/prov: "+this.algProv};this.doFinalString=function(g){throw"digestString(str) not supported for this alg/prov: "+this.algProv};this.doFinalHex=function(g){throw"digestHex(hex) not supported for this alg/prov: "+this.algProv};this.setPassword=function(h){if(typeof h=="string"){var g=h;if(h.length%2==1||!h.match(/^[0-9A-Fa-f]+$/)){g=rstrtohex(h)}this.pass=CryptoJS.enc.Hex.parse(g);return}if(typeof h!="object"){throw"KJUR.crypto.Mac unsupported password type: "+h}var g=null;if(h.hex!==undefined){if(h.hex.length%2!=0||!h.hex.match(/^[0-9A-Fa-f]+$/)){throw"Mac: wrong hex password: "+h.hex}g=h.hex}if(h.utf8!==undefined){g=utf8tohex(h.utf8)}if(h.rstr!==undefined){g=rstrtohex(h.rstr)}if(h.b64!==undefined){g=b64tohex(h.b64)}if(h.b64u!==undefined){g=b64utohex(h.b64u)}if(g==null){throw"KJUR.crypto.Mac unsupported password type: "+h}this.pass=CryptoJS.enc.Hex.parse(g)};if(d!==undefined){if(d.pass!==undefined){this.setPassword(d.pass)}if(d.alg!==undefined){this.algName=d.alg;if(d.prov===undefined){this.provName=KJUR.crypto.Util.DEFAULTPROVIDER[this.algName]}this.setAlgAndProvider(this.algName,this.provName)}}};KJUR.crypto.Signature=function(o){var q=null;var n=null;var r=null;var c=null;var l=null;var d=null;var k=null;var h=null;var p=null;var e=null;var b=-1;var g=null;var j=null;var a=null;var i=null;var f=null;this._setAlgNames=function(){if(this.algName.match(/^(.+)with(.+)$/)){this.mdAlgName=RegExp.$1.toLowerCase();this.pubkeyAlgName=RegExp.$2.toLowerCase()}};this._zeroPaddingOfSignature=function(x,w){var v="";var t=w/4-x.length;for(var u=0;u<t;u++){v=v+"0"}return v+x};this.setAlgAndProvider=function(u,t){this._setAlgNames();if(t!="cryptojs/jsrsa"){throw"provider not supported: "+t}if(":md5:sha1:sha224:sha256:sha384:sha512:ripemd160:".indexOf(this.mdAlgName)!=-1){try{this.md=new KJUR.crypto.MessageDigest({alg:this.mdAlgName})}catch(s){throw"setAlgAndProvider hash alg set fail alg="+this.mdAlgName+"/"+s}this.init=function(w,x){var y=null;try{if(x===undefined){y=KEYUTIL.getKey(w)}else{y=KEYUTIL.getKey(w,x)}}catch(v){throw"init failed:"+v}if(y.isPrivate===true){this.prvKey=y;this.state="SIGN"}else{if(y.isPublic===true){this.pubKey=y;this.state="VERIFY"}else{throw"init failed.:"+y}}};this.initSign=function(v){if(typeof v.ecprvhex=="string"&&typeof v.eccurvename=="string"){this.ecprvhex=v.ecprvhex;this.eccurvename=v.eccurvename}else{this.prvKey=v}this.state="SIGN"};this.initVerifyByPublicKey=function(v){if(typeof v.ecpubhex=="string"&&typeof v.eccurvename=="string"){this.ecpubhex=v.ecpubhex;this.eccurvename=v.eccurvename}else{if(v instanceof KJUR.crypto.ECDSA){this.pubKey=v}else{if(v instanceof RSAKey){this.pubKey=v}}}this.state="VERIFY"};this.initVerifyByCertificatePEM=function(v){var w=new X509();w.readCertPEM(v);this.pubKey=w.subjectPublicKeyRSA;this.state="VERIFY"};this.updateString=function(v){this.md.updateString(v)};this.updateHex=function(v){this.md.updateHex(v)};this.sign=function(){this.sHashHex=this.md.digest();if(typeof this.ecprvhex!="undefined"&&typeof this.eccurvename!="undefined"){var v=new KJUR.crypto.ECDSA({curve:this.eccurvename});this.hSign=v.signHex(this.sHashHex,this.ecprvhex)}else{if(this.prvKey instanceof RSAKey&&this.pubkeyAlgName=="rsaandmgf1"){this.hSign=this.prvKey.signWithMessageHashPSS(this.sHashHex,this.mdAlgName,this.pssSaltLen)}else{if(this.prvKey instanceof RSAKey&&this.pubkeyAlgName=="rsa"){this.hSign=this.prvKey.signWithMessageHash(this.sHashHex,this.mdAlgName)}else{if(this.prvKey instanceof KJUR.crypto.ECDSA){this.hSign=this.prvKey.signWithMessageHash(this.sHashHex)}else{if(this.prvKey instanceof KJUR.crypto.DSA){this.hSign=this.prvKey.signWithMessageHash(this.sHashHex)}else{throw"Signature: unsupported public key alg: "+this.pubkeyAlgName}}}}}return this.hSign};this.signString=function(v){this.updateString(v);return this.sign()};this.signHex=function(v){this.updateHex(v);return this.sign()};this.verify=function(v){this.sHashHex=this.md.digest();if(typeof this.ecpubhex!="undefined"&&typeof this.eccurvename!="undefined"){var w=new KJUR.crypto.ECDSA({curve:this.eccurvename});return w.verifyHex(this.sHashHex,v,this.ecpubhex)}else{if(this.pubKey instanceof RSAKey&&this.pubkeyAlgName=="rsaandmgf1"){return this.pubKey.verifyWithMessageHashPSS(this.sHashHex,v,this.mdAlgName,this.pssSaltLen)}else{if(this.pubKey instanceof RSAKey&&this.pubkeyAlgName=="rsa"){return this.pubKey.verifyWithMessageHash(this.sHashHex,v)}else{if(this.pubKey instanceof KJUR.crypto.ECDSA){return this.pubKey.verifyWithMessageHash(this.sHashHex,v)}else{if(this.pubKey instanceof KJUR.crypto.DSA){return this.pubKey.verifyWithMessageHash(this.sHashHex,v)}else{throw"Signature: unsupported public key alg: "+this.pubkeyAlgName}}}}}}}};this.init=function(s,t){throw"init(key, pass) not supported for this alg:prov="+this.algProvName};this.initVerifyByPublicKey=function(s){throw"initVerifyByPublicKey(rsaPubKeyy) not supported for this alg:prov="+this.algProvName};this.initVerifyByCertificatePEM=function(s){throw"initVerifyByCertificatePEM(certPEM) not supported for this alg:prov="+this.algProvName};this.initSign=function(s){throw"initSign(prvKey) not supported for this alg:prov="+this.algProvName};this.updateString=function(s){throw"updateString(str) not supported for this alg:prov="+this.algProvName};this.updateHex=function(s){throw"updateHex(hex) not supported for this alg:prov="+this.algProvName};this.sign=function(){throw"sign() not supported for this alg:prov="+this.algProvName};this.signString=function(s){throw"digestString(str) not supported for this alg:prov="+this.algProvName};this.signHex=function(s){throw"digestHex(hex) not supported for this alg:prov="+this.algProvName};this.verify=function(s){throw"verify(hSigVal) not supported for this alg:prov="+this.algProvName};this.initParams=o;if(o!==undefined){if(o.alg!==undefined){this.algName=o.alg;if(o.prov===undefined){this.provName=KJUR.crypto.Util.DEFAULTPROVIDER[this.algName]}else{this.provName=o.prov}this.algProvName=this.algName+":"+this.provName;this.setAlgAndProvider(this.algName,this.provName);this._setAlgNames()}if(o.psssaltlen!==undefined){this.pssSaltLen=o.psssaltlen}if(o.prvkeypem!==undefined){if(o.prvkeypas!==undefined){throw"both prvkeypem and prvkeypas parameters not supported"}else{try{var q=new RSAKey();q.readPrivateKeyFromPEMString(o.prvkeypem);this.initSign(q)}catch(m){throw"fatal error to load pem private key: "+m}}}}};KJUR.crypto.OID=new function(){this.oidhex2name={"2a864886f70d010101":"rsaEncryption","2a8648ce3d0201":"ecPublicKey","2a8648ce380401":"dsa","2a8648ce3d030107":"secp256r1","2b8104001f":"secp192k1","2b81040021":"secp224r1","2b8104000a":"secp256k1","2b81040023":"secp521r1","2b81040022":"secp384r1","2a8648ce380403":"SHA1withDSA","608648016503040301":"SHA224withDSA","608648016503040302":"SHA256withDSA",}};
/*! rsasign-1.2.7.js (c) 2012 Kenji Urushima | kjur.github.com/jsrsasign/license
 */
var _RE_HEXDECONLY=new RegExp("");_RE_HEXDECONLY.compile("[^0-9a-f]","gi");function _rsasign_getHexPaddedDigestInfoForString(d,e,a){var b=function(f){return KJUR.crypto.Util.hashString(f,a)};var c=b(d);return KJUR.crypto.Util.getPaddedDigestInfoHex(c,a,e)}function _zeroPaddingOfSignature(e,d){var c="";var a=d/4-e.length;for(var b=0;b<a;b++){c=c+"0"}return c+e}function _rsasign_signString(d,a){var b=function(e){return KJUR.crypto.Util.hashString(e,a)};var c=b(d);return this.signWithMessageHash(c,a)}function _rsasign_signWithMessageHash(e,c){var f=KJUR.crypto.Util.getPaddedDigestInfoHex(e,c,this.n.bitLength());var b=parseBigInt(f,16);var d=this.doPrivate(b);var a=d.toString(16);return _zeroPaddingOfSignature(a,this.n.bitLength())}function _rsasign_signStringWithSHA1(a){return _rsasign_signString.call(this,a,"sha1")}function _rsasign_signStringWithSHA256(a){return _rsasign_signString.call(this,a,"sha256")}function pss_mgf1_str(c,a,e){var b="",d=0;while(b.length<a){b+=hextorstr(e(rstrtohex(c+String.fromCharCode.apply(String,[(d&4278190080)>>24,(d&16711680)>>16,(d&65280)>>8,d&255]))));d+=1}return b}function _rsasign_signStringPSS(e,a,d){var c=function(f){return KJUR.crypto.Util.hashHex(f,a)};var b=c(rstrtohex(e));if(d===undefined){d=-1}return this.signWithMessageHashPSS(b,a,d)}function _rsasign_signWithMessageHashPSS(l,a,k){var b=hextorstr(l);var g=b.length;var m=this.n.bitLength()-1;var c=Math.ceil(m/8);var d;var o=function(i){return KJUR.crypto.Util.hashHex(i,a)};if(k===-1||k===undefined){k=g}else{if(k===-2){k=c-g-2}else{if(k<-2){throw"invalid salt length"}}}if(c<(g+k+2)){throw"data too long"}var f="";if(k>0){f=new Array(k);new SecureRandom().nextBytes(f);f=String.fromCharCode.apply(String,f)}var n=hextorstr(o(rstrtohex("\x00\x00\x00\x00\x00\x00\x00\x00"+b+f)));var j=[];for(d=0;d<c-k-g-2;d+=1){j[d]=0}var e=String.fromCharCode.apply(String,j)+"\x01"+f;var h=pss_mgf1_str(n,e.length,o);var q=[];for(d=0;d<e.length;d+=1){q[d]=e.charCodeAt(d)^h.charCodeAt(d)}var p=(65280>>(8*c-m))&255;q[0]&=~p;for(d=0;d<g;d++){q.push(n.charCodeAt(d))}q.push(188);return _zeroPaddingOfSignature(this.doPrivate(new BigInteger(q)).toString(16),this.n.bitLength())}function _rsasign_getDecryptSignatureBI(a,d,c){var b=new RSAKey();b.setPublic(d,c);var e=b.doPublic(a);return e}function _rsasign_getHexDigestInfoFromSig(a,c,b){var e=_rsasign_getDecryptSignatureBI(a,c,b);var d=e.toString(16).replace(/^1f+00/,"");return d}function _rsasign_getAlgNameAndHashFromHexDisgestInfo(f){for(var e in KJUR.crypto.Util.DIGESTINFOHEAD){var d=KJUR.crypto.Util.DIGESTINFOHEAD[e];var b=d.length;if(f.substring(0,b)==d){var c=[e,f.substring(b)];return c}}return[]}function _rsasign_verifySignatureWithArgs(f,b,g,j){var e=_rsasign_getHexDigestInfoFromSig(b,g,j);var h=_rsasign_getAlgNameAndHashFromHexDisgestInfo(e);if(h.length==0){return false}var d=h[0];var i=h[1];var a=function(k){return KJUR.crypto.Util.hashString(k,d)};var c=a(f);return(i==c)}function _rsasign_verifyHexSignatureForMessage(c,b){var d=parseBigInt(c,16);var a=_rsasign_verifySignatureWithArgs(b,d,this.n.toString(16),this.e.toString(16));return a}function _rsasign_verifyString(f,j){j=j.replace(_RE_HEXDECONLY,"");j=j.replace(/[ \n]+/g,"");var b=parseBigInt(j,16);if(b.bitLength()>this.n.bitLength()){return 0}var i=this.doPublic(b);var e=i.toString(16).replace(/^1f+00/,"");var g=_rsasign_getAlgNameAndHashFromHexDisgestInfo(e);if(g.length==0){return false}var d=g[0];var h=g[1];var a=function(k){return KJUR.crypto.Util.hashString(k,d)};var c=a(f);return(h==c)}function _rsasign_verifyWithMessageHash(e,a){a=a.replace(_RE_HEXDECONLY,"");a=a.replace(/[ \n]+/g,"");var b=parseBigInt(a,16);if(b.bitLength()>this.n.bitLength()){return 0}var h=this.doPublic(b);var g=h.toString(16).replace(/^1f+00/,"");var c=_rsasign_getAlgNameAndHashFromHexDisgestInfo(g);if(c.length==0){return false}var d=c[0];var f=c[1];return(f==e)}function _rsasign_verifyStringPSS(c,b,a,f){var e=function(g){return KJUR.crypto.Util.hashHex(g,a)};var d=e(rstrtohex(c));if(f===undefined){f=-1}return this.verifyWithMessageHashPSS(d,b,a,f)}function _rsasign_verifyWithMessageHashPSS(f,s,l,c){var k=new BigInteger(s,16);if(k.bitLength()>this.n.bitLength()){return false}var r=function(i){return KJUR.crypto.Util.hashHex(i,l)};var j=hextorstr(f);var h=j.length;var g=this.n.bitLength()-1;var m=Math.ceil(g/8);var q;if(c===-1||c===undefined){c=h}else{if(c===-2){c=m-h-2}else{if(c<-2){throw"invalid salt length"}}}if(m<(h+c+2)){throw"data too long"}var a=this.doPublic(k).toByteArray();for(q=0;q<a.length;q+=1){a[q]&=255}while(a.length<m){a.unshift(0)}if(a[m-1]!==188){throw"encoded message does not end in 0xbc"}a=String.fromCharCode.apply(String,a);var d=a.substr(0,m-h-1);var e=a.substr(d.length,h);var p=(65280>>(8*m-g))&255;if((d.charCodeAt(0)&p)!==0){throw"bits beyond keysize not zero"}var n=pss_mgf1_str(e,d.length,r);var o=[];for(q=0;q<d.length;q+=1){o[q]=d.charCodeAt(q)^n.charCodeAt(q)}o[0]&=~p;var b=m-h-c-2;for(q=0;q<b;q+=1){if(o[q]!==0){throw"leftmost octets not zero"}}if(o[b]!==1){throw"0x01 marker not found"}return e===hextorstr(r(rstrtohex("\x00\x00\x00\x00\x00\x00\x00\x00"+j+String.fromCharCode.apply(String,o.slice(-c)))))}RSAKey.prototype.signWithMessageHash=_rsasign_signWithMessageHash;RSAKey.prototype.signString=_rsasign_signString;RSAKey.prototype.signStringWithSHA1=_rsasign_signStringWithSHA1;RSAKey.prototype.signStringWithSHA256=_rsasign_signStringWithSHA256;RSAKey.prototype.sign=_rsasign_signString;RSAKey.prototype.signWithSHA1=_rsasign_signStringWithSHA1;RSAKey.prototype.signWithSHA256=_rsasign_signStringWithSHA256;RSAKey.prototype.signWithMessageHashPSS=_rsasign_signWithMessageHashPSS;RSAKey.prototype.signStringPSS=_rsasign_signStringPSS;RSAKey.prototype.signPSS=_rsasign_signStringPSS;RSAKey.SALT_LEN_HLEN=-1;RSAKey.SALT_LEN_MAX=-2;RSAKey.prototype.verifyWithMessageHash=_rsasign_verifyWithMessageHash;RSAKey.prototype.verifyString=_rsasign_verifyString;RSAKey.prototype.verifyHexSignatureForMessage=_rsasign_verifyHexSignatureForMessage;RSAKey.prototype.verify=_rsasign_verifyString;RSAKey.prototype.verifyHexSignatureForByteArrayMessage=_rsasign_verifyHexSignatureForMessage;RSAKey.prototype.verifyWithMessageHashPSS=_rsasign_verifyWithMessageHashPSS;RSAKey.prototype.verifyStringPSS=_rsasign_verifyStringPSS;RSAKey.prototype.verifyPSS=_rsasign_verifyStringPSS;RSAKey.SALT_LEN_RECOVER=-2;
// exports.SecureRandom = SecureRandom;
// exports.rng_seed_time = rng_seed_time;

exports.BigInteger = BigInteger;
exports.RSAKey = RSAKey;
// exports.ECDSA = KJUR.crypto.ECDSA;
// exports.DSA = KJUR.crypto.DSA;
exports.Signature = KJUR.crypto.Signature;
exports.MessageDigest = KJUR.crypto.MessageDigest;
// exports.Mac = KJUR.crypto.Mac;
// exports.KEYUTIL = KEYUTIL;
// exports.ASN1HEX = ASN1HEX;
// exports.X509 = X509;
exports.CryptoJS = CryptoJS;

// ext/base64.js
exports.b64tohex = b64tohex;
exports.b64toBA = b64toBA;

// base64x.js
// exports.stoBA = stoBA;
// exports.BAtos = BAtos;
// exports.BAtohex = BAtohex;
// exports.stohex = stohex;
// exports.stob64 = stob64;
// exports.stob64u = stob64u;
// exports.b64utos = b64utos;
// exports.b64tob64u = b64tob64u;
// exports.b64utob64 = b64utob64;
// exports.hex2b64 = hex2b64;
// exports.hextob64u = hextob64u;
// exports.b64utohex = b64utohex;
// exports.b64tohex = b64tohex;
// exports.utf8tob64u = utf8tob64u;
// exports.b64utoutf8 = b64utoutf8;
// exports.utf8tob64 = utf8tob64;
// exports.b64toutf8 = b64toutf8;
// exports.utf8tohex = utf8tohex;
// exports.hextoutf8 = hextoutf8;
// exports.hextorstr = hextorstr;
// exports.rstrtohex = rstrtohex;
// exports.newline_toUnix = newline_toUnix;
// exports.newline_toDos = newline_toDos;
// exports.intarystrtohex = intarystrtohex;
// exports.strdiffidx = strdiffidx;
//
// exports.crypto = KJUR.crypto;
// exports.asn1 = KJUR.asn1;
// exports.jws = KJUR.jws;
//
// exports.readFileUTF8 = readFileUTF8;
// exports.readFileHexByBin = readFileHexByBin;
// exports.readFile = readFile;
// exports.saveFile = saveFile;
// exports.saveFileBinByHex = saveFileBinByHex;


/***/ }),

/***/ "../../../node_modules/@hivestreaming/m3u8/index.js":
/*!***************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/node_modules/@hivestreaming/m3u8/index.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {



var m3u8 = (function () {
    var m3u8 = {};
    /**
     * Object functions container
     * @type {Object}
     * @private
     */
    m3u8.obj = {};

    /**
     * Object.create shim for prototypal inheritance
     *
     * https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/create
     *
     * @function
     * @param  {Object}   obj Object to use as prototype
     * @private
     */
    m3u8.obj.create = Object.create || function (obj) {
            //Create a new function called 'F' which is just an empty object.
            function F() {
            }

            //the prototype of the 'F' function should point to the
            //parameter of the anonymous function.
            F.prototype = obj;

            //create a new constructor function based off of the 'F' function.
            return new F();
        };

    /**
     * Loop through each property in an object and call a function
     * whose arguments are (key,value)
     * @param  {Object}   obj Object of properties
     * @param  {Function} fn  Function to be called on each property.
     * @this {*}
     * @private
     */
    m3u8.obj.each = function (obj, fn, context) {
        for (var key in obj) {
            if (hasOwnProp.call(obj, key)) {
                fn.call(context || this, key, obj[key]);
            }
        }
    };

    /**
     * Merge two objects together and return the original.
     * @param  {Object} obj1
     * @param  {Object} obj2
     * @return {Object}
     * @private
     */
    m3u8.obj.merge = function (obj1, obj2) {
        if (!obj2) {
            return obj1;
        }
        for (var key in obj2) {
            if (hasOwnProp.call(obj2, key)) {
                obj1[key] = obj2[key];
            }
        }
        return obj1;
    };

    /**
     * Merge two objects, and merge any properties that are objects
     * instead of just overwriting one. Uses to merge options hashes
     * where deeper default settings are important.
     * @param  {Object} obj1 Object to override
     * @param  {Object} obj2 Overriding object
     * @return {Object}      New object. Obj1 and Obj2 will be untouched.
     * @private
     */
    m3u8.obj.deepMerge = function (obj1, obj2) {
        var key, val1, val2;

        // make a copy of obj1 so we're not overwriting original values.
        // like prototype.options_ and all sub options objects
        obj1 = m3u8.obj.copy(obj1);

        for (key in obj2) {
            if (hasOwnProp.call(obj2, key)) {
                val1 = obj1[key];
                val2 = obj2[key];

                // Check if both properties are pure objects and do a deep merge if so
                if (m3u8.obj.isPlain(val1) && m3u8.obj.isPlain(val2)) {
                    obj1[key] = m3u8.obj.deepMerge(val1, val2);
                } else {
                    obj1[key] = obj2[key];
                }
            }
        }
        return obj1;
    };

    /**
     * Make a copy of the supplied object
     * @param  {Object} obj Object to copy
     * @return {Object}     Copy of object
     * @private
     */
    m3u8.obj.copy = function (obj) {
        return m3u8.obj.merge({}, obj);
    };

    /**
     * Check if an object is plain, and not a dom node or any object sub-instance
     * @param  {Object} obj Object to check
     * @return {Boolean}     True if plain, false otherwise
     * @private
     */
    m3u8.obj.isPlain = function (obj) {
        return !!obj
            && typeof obj === 'object'
            && obj.toString() === '[object Object]'
            && obj.constructor === Object;
    };

    /**
     * Check if an object is Array
     *  Since instanceof Array will not work on arrays created in another frame we need to use Array.isArray, but since IE8 does not support Array.isArray we need this shim
     * @param  {Object} obj Object to check
     * @return {Boolean}     True if plain, false otherwise
     * @private
     */
    m3u8.obj.isArray = Array.isArray || function (arr) {
            return Object.prototype.toString.call(arr) === '[object Array]';
        };

    var mergeOptions = function (obj1, obj2) {
        var key, val1, val2;

        // make a copy of obj1 so we're not overwriting original values.
        // like prototype.options_ and all sub options objects
        obj1 = m3u8.obj.copy(obj1);

        for (key in obj2) {
            if (obj2.hasOwnProperty(key)) {
                val1 = obj1[key];
                val2 = obj2[key];

                // Check if both properties are pure objects and do a deep merge if so
                if (m3u8.obj.isPlain(val1) && m3u8.obj.isPlain(val2)) {
                    obj1[key] = m3u8.util.mergeOptions(val1, val2);
                } else {
                    obj1[key] = obj2[key];
                }
            }
        }
        return obj1;
    };

    m3u8.mergeOptions = mergeOptions;


    /**
     * A lightweight readable stream implemention that handles event dispatching.
     * Objects that inherit from streams should call init in their constructors.
     */

    var Stream = function () {
        this.init = function () {
            var listeners = {};
            /**
             * Add a listener for a specified event type.
             * @param type {string} the event name
             * @param listener {function} the callback to be invoked when an event of
             * the specified type occurs
             */
            this.on = function (type, listener) {
                if (!listeners[type]) {
                    listeners[type] = [];
                }
                listeners[type].push(listener);
            };
            /**
             * Remove a listener for a specified event type.
             * @param type {string} the event name
             * @param listener {function} a function previously registered for this
             * type of event through `on`
             */
            this.off = function (type, listener) {
                var index;
                if (!listeners[type]) {
                    return false;
                }
                index = listeners[type].indexOf(listener);
                listeners[type].splice(index, 1);
                return index > -1;
            };
            /**
             * Trigger an event of the specified type on this stream. Any additional
             * arguments to this function are passed as parameters to event listeners.
             * @param type {string} the event name
             */
            this.trigger = function (type) {
                var callbacks, i, length, args;
                callbacks = listeners[type];
                if (!callbacks) {
                    return;
                }
                args = Array.prototype.slice.call(arguments, 1);
                length = callbacks.length;
                for (i = 0; i < length; ++i) {
                    callbacks[i].apply(this, args);
                }
            };
            /**
             * Destroys the stream and cleans up.
             */
            this.dispose = function () {
                listeners = {};
            };
        };
    };
    /**
     * Forwards all `data` events on this stream to the destination stream. The
     * destination stream should provide a method `push` to receive the data
     * events as they arrive.
     * @param destination {stream} the stream that will receive all `data` events
     * @see http://nodejs.org/api/stream.html#stream_readable_pipe_destination_options
     */
    Stream.prototype.pipe = function (destination) {
        this.on('data', function (data) {
            destination.push(data);
        });
    };

    m3u8.Stream = Stream


    /**
     * Utilities for parsing M3U8 files. If the entire manifest is available,
     * `Parser` will create an object representation with enough detail for managing
     * playback. `ParseStream` and `LineStream` are lower-level parsing primitives
     * that do not assume the entirety of the manifest is ready and expose a
     * ReadableStream-like interface.
     */
    var
        noop = function () {
        },

    // "forgiving" attribute list psuedo-grammar:
    // attributes -> keyvalue (',' keyvalue)*
    // keyvalue   -> key '=' value
    // key        -> [^=]*
    // value      -> '"' [^"]* '"' | [^,]*
        attributeSeparator = (function () {
            var
                key = '[^=]*',
                value = '"[^"]*"|[^,]*',
                keyvalue = '(?:' + key + ')=(?:' + value + ')';

            return new RegExp('(?:^|,)(' + keyvalue + ')');
        })(),
        parseAttributes = function (attributes) {
            var
            // split the string using attributes as the separator
                attrs = attributes.split(attributeSeparator),
                i = attrs.length,
                result = {},
                attr;

            while (i--) {
                // filter out unmatched portions of the string
                if (attrs[i] === '') {
                    continue;
                }

                // split the key and value
                attr = /([^=]*)=(.*)/.exec(attrs[i]).slice(1);
                // trim whitespace and remove optional quotes around the value
                attr[0] = attr[0].replace(/^\s+|\s+$/g, '');
                attr[1] = attr[1].replace(/^\s+|\s+$/g, '');
                attr[1] = attr[1].replace(/^['"](.*)['"]$/g, '$1');
                result[attr[0]] = attr[1];
            }
            return result;
        },
        Stream = m3u8.Stream,
        LineStream,
        ParseStream,
        Parser;

    /**
     * A stream that buffers string input and generates a `data` event for each
     * line.
     */
    LineStream = function () {
        var buffer = '';
        LineStream.prototype.init.call(this);

        /**
         * Add new data to be parsed.
         * @param data {string} the text to process
         */
        this.push = function (data) {
            var nextNewline;

            buffer += data;
            nextNewline = buffer.indexOf('\n');

            for (; nextNewline > -1; nextNewline = buffer.indexOf('\n')) {
                this.trigger('data', buffer.substring(0, nextNewline));
                buffer = buffer.substring(nextNewline + 1);
            }
        };
    };
    LineStream.prototype = new Stream();

    /**
     * A line-level M3U8 parser event stream. It expects to receive input one
     * line at a time and performs a context-free parse of its contents. A stream
     * interpretation of a manifest can be useful if the manifest is expected to
     * be too large to fit comfortably into memory or the entirety of the input
     * is not immediately available. Otherwise, it's probably much easier to work
     * with a regular `Parser` object.
     *
     * Produces `data` events with an object that captures the parser's
     * interpretation of the input. That object has a property `tag` that is one
     * of `uri`, `comment`, or `tag`. URIs only have a single additional
     * property, `line`, which captures the entirety of the input without
     * interpretation. Comments similarly have a single additional property
     * `text` which is the input without the leading `#`.
     *
     * Tags always have a property `tagType` which is the lower-cased version of
     * the M3U8 directive without the `#EXT` or `#EXT-X-` prefix. For instance,
     * `#EXT-X-MEDIA-SEQUENCE` becomes `media-sequence` when parsed. Unrecognized
     * tags are given the tag type `unknown` and a single additional property
     * `data` with the remainder of the input.
     */
    ParseStream = function () {
        ParseStream.prototype.init.call(this);
    };
    ParseStream.prototype = new Stream();
    /**
     * Parses an additional line of input.
     * @param line {string} a single line of an M3U8 file to parse
     */
    ParseStream.prototype.push = function (line) {
        var match, event;

        //strip whitespace
        line = line.replace(/^\s+|\s+$/g, '');
        if (line.length === 0) {
            // ignore empty lines
            return;
        }

        // URIs
        if (line[0] !== '#') {
            this.trigger('data', {
                type: 'uri',
                uri: line
            });
            return;
        }

        // Comments
        if (line.indexOf('#EXT') !== 0) {
            this.trigger('data', {
                type: 'comment',
                text: line.slice(1)
            });
            return;
        }

        //strip off any carriage returns here so the regex matching
        //doesn't have to account for them.
        line = line.replace('\r', '');

        // Tags
        match = /^#EXTM3U/.exec(line);
        if (match) {
            this.trigger('data', {
                type: 'tag',
                tagType: 'm3u'
            });
            return;
        }
        match = (/^#EXTINF:?([0-9\.]*)?,?(.*)?$/).exec(line);
        if (match) {
            event = {
                type: 'tag',
                tagType: 'inf'
            };
            if (match[1]) {
                event.duration = parseFloat(match[1]);
            }
            if (match[2]) {
                event.title = match[2];
            }
            this.trigger('data', event);
            return;
        }
        match = (/^#EXT-X-MAP:?(.*)$/).exec(line);
        if (match) {
            event = {
                type: 'tag',
                tagType: 'x-map'
            };
            if (match[1]) {
                event.attributes = parseAttributes(match[1]);
                if (event.attributes.URI) {
                    this.trigger('data', event);
                    this.trigger('data', {
                        type: 'uri',
                        uri: event.attributes.URI
                    });
                }
            }
            return;
        }
        match = (/^#EXT-X-TARGETDURATION:?([0-9.]*)?/).exec(line);
        if (match) {
            event = {
                type: 'tag',
                tagType: 'targetduration'
            };
            if (match[1]) {
                event.duration = parseInt(match[1], 10);
            }
            this.trigger('data', event);
            return;
        }
        match = (/^#ZEN-TOTAL-DURATION:?([0-9.]*)?/).exec(line);
        if (match) {
            event = {
                type: 'tag',
                tagType: 'totalduration'
            };
            if (match[1]) {
                event.duration = parseInt(match[1], 10);
            }
            this.trigger('data', event);
            return;
        }
        match = (/^#EXT-X-VERSION:?([0-9.]*)?/).exec(line);
        if (match) {
            event = {
                type: 'tag',
                tagType: 'version'
            };
            if (match[1]) {
                event.version = parseInt(match[1], 10);
            }
            this.trigger('data', event);
            return;
        }
        match = (/^#EXT-X-MEDIA-SEQUENCE:?(\-?[0-9.]*)?/).exec(line);
        if (match) {
            event = {
                type: 'tag',
                tagType: 'media-sequence'
            };
            if (match[1]) {
                event.number = parseInt(match[1], 10);
            }
            this.trigger('data', event);
            return;
        }
        match = (/^#EXT-X-DISCONTINUITY-SEQUENCE:?(\-?[0-9.]*)?/).exec(line);
        if (match) {
            event = {
                type: 'tag',
                tagType: 'discontinuity-sequence'
            };
            if (match[1]) {
                event.number = parseInt(match[1], 10);
            }
            this.trigger('data', event);
            return;
        }
        match = (/^#EXT-X-PLAYLIST-TYPE:?(.*)?$/).exec(line);
        if (match) {
            event = {
                type: 'tag',
                tagType: 'playlist-type'
            };
            if (match[1]) {
                event.playlistType = match[1];
            }
            this.trigger('data', event);
            return;
        }
        match = (/^#EXT-X-BYTERANGE:?([0-9.]*)?@?([0-9.]*)?/).exec(line);
        if (match) {
            event = {
                type: 'tag',
                tagType: 'byterange'
            };
            if (match[1]) {
                event.length = parseInt(match[1], 10);
            }
            if (match[2]) {
                event.offset = parseInt(match[2], 10);
            }
            this.trigger('data', event);
            return;
        }
        match = (/^#EXT-X-ALLOW-CACHE:?(YES|NO)?/).exec(line);
        if (match) {
            event = {
                type: 'tag',
                tagType: 'allow-cache'
            };
            if (match[1]) {
                event.allowed = !(/NO/).test(match[1]);
            }
            this.trigger('data', event);
            return;
        }
        match = (/^#EXT-X-STREAM-INF:?(.*)$/).exec(line);
        if (match) {
            event = {
                type: 'tag',
                tagType: 'stream-inf'
            };
            if (match[1]) {
                event.attributes = parseAttributes(match[1]);
                event.attributes.type = 'VIDEO';
                if (event.attributes.RESOLUTION) {
                    (function () {
                        var
                            split = event.attributes.RESOLUTION.split('x'),
                            resolution = {};
                        if (split[0]) {
                            resolution.width = parseInt(split[0], 10);
                        }
                        if (split[1]) {
                            resolution.height = parseInt(split[1], 10);
                        }
                        event.attributes.RESOLUTION = resolution;
                    })();
                }
                if (event.attributes.BANDWIDTH) {
                    event.attributes.BANDWIDTH = parseInt(event.attributes.BANDWIDTH, 10);
                }
                if (event.attributes['PROGRAM-ID']) {
                    event.attributes['PROGRAM-ID'] = parseInt(event.attributes['PROGRAM-ID'], 10);
                }
            }
            this.trigger('data', event);
            return;
        }
        match = (/^#EXT-X-MEDIA:?(.*)$/).exec(line);
        if (match) {
            event = {
                type: 'tag',
                tagType: 'x-media'
            };
            if (match[1]) {
                event.attributes = parseAttributes(match[1]);
                if (event.attributes.URI) {
                    this.trigger('data', event);
                    this.trigger('data', {
                        type: 'uri',
                        uri: event.attributes.URI
                    });
                }
            }
            return;
        }
        match = (/^#EXT-X-ENDLIST/).exec(line);
        if (match) {
            this.trigger('data', {
                type: 'tag',
                tagType: 'endlist'
            });
            return;
        }
        match = (/^#EXT-X-DISCONTINUITY/).exec(line);
        if (match) {
            this.trigger('data', {
                type: 'tag',
                tagType: 'discontinuity'
            });
            return;
        }
        match = (/^#EXT-X-KEY:?(.*)$/).exec(line);
        if (match) {
            event = {
                type: 'tag',
                tagType: 'key'
            };
            if (match[1]) {
                event.attributes = parseAttributes(match[1]);
                // parse the IV string into a Uint32Array
                if (event.attributes.IV) {
                    if (event.attributes.IV.substring(0, 2) === '0x') {
                        event.attributes.IV = event.attributes.IV.substring(2);
                    }

                    event.attributes.IV = event.attributes.IV.match(/.{8}/g);
                    event.attributes.IV[0] = parseInt(event.attributes.IV[0], 16);
                    event.attributes.IV[1] = parseInt(event.attributes.IV[1], 16);
                    event.attributes.IV[2] = parseInt(event.attributes.IV[2], 16);
                    event.attributes.IV[3] = parseInt(event.attributes.IV[3], 16);
                    event.attributes.IV = new Uint32Array(event.attributes.IV);
                }
            }
            this.trigger('data', event);
            return;
        }

        // unknown tag type
        this.trigger('data', {
            type: 'tag',
            data: line.slice(4, line.length)
        });
    };

    /**
     * A parser for M3U8 files. The current interpretation of the input is
     * exposed as a property `manifest` on parser objects. It's just two lines to
     * create and parse a manifest once you have the contents available as a string:
     *
     * ```js
     * var parser = new videojs.m3u8.Parser();
     * parser.push(xhr.responseText);
     * ```
     *
     * New input can later be applied to update the manifest object by calling
     * `push` again.
     *
     * The parser attempts to create a usable manifest object even if the
     * underlying input is somewhat nonsensical. It emits `info` and `warning`
     * events during the parse if it encounters input that seems invalid or
     * requires some property of the manifest object to be defaulted.
     */
    Parser = function () {
        var
            self = this,
            uris = [],
            currentUri = {},
            key;
        Parser.prototype.init.call(this);

        this.lineStream = new LineStream();
        this.parseStream = new ParseStream();
        this.lineStream.pipe(this.parseStream);

        // the manifest is empty until the parse stream begins delivering data
        this.manifest = {
            allowCache: true
        };

        // update the manifest with the m3u8 entry from the parse stream
        this.parseStream.on('data', function (entry) {
            ({
                tag: function () {
                    // switch based on the tag type
                    (({
                        'allow-cache': function () {
                            this.manifest.allowCache = entry.allowed;
                            if (!('allowed' in entry)) {
                                this.trigger('info', {
                                    message: 'defaulting allowCache to YES'
                                });
                                this.manifest.allowCache = true;
                            }
                        },
                        'byterange': function () {
                            var byterange = {};
                            if ('length' in entry) {
                                currentUri.byterange = byterange;
                                byterange.length = entry.length;

                                if (!('offset' in entry)) {
                                    this.trigger('info', {
                                        message: 'defaulting offset to zero'
                                    });
                                    entry.offset = 0;
                                }
                            }
                            if ('offset' in entry) {
                                currentUri.byterange = byterange;
                                byterange.offset = entry.offset;
                            }
                        },
                        'endlist': function () {
                            this.manifest.endList = true;
                        },
                        'inf': function () {
                            if (!('mediaSequence' in this.manifest)) {
                                this.manifest.mediaSequence = 0;
                                this.trigger('info', {
                                    message: 'defaulting media sequence to zero'
                                });
                            }
                            if (!('discontinuitySequence' in this.manifest)) {
                                this.manifest.discontinuitySequence = 0;
                                this.trigger('info', {
                                    message: 'defaulting discontinuity sequence to zero'
                                });
                            }
                            if (entry.duration >= 0) {
                                currentUri.duration = entry.duration;
                            }

                            this.manifest.segments = uris;

                        },
                        'x-map': function () {
                            if (!entry.attributes) {
                                this.trigger('warn', {
                                    message: 'ignoring x-map declaration without attribute list'
                                });
                                return;
                            }
                            if (!entry.attributes.URI) {
                                this.trigger('warn', {
                                    message: 'ignoring x-map declaration without URI'
                                });
                                return;
                            }
                            this.manifest.segments = uris;
                        },
                        'key': function () {
                            if (!entry.attributes) {
                                this.trigger('warn', {
                                    message: 'ignoring key declaration without attribute list'
                                });
                                return;
                            }
                            // clear the active encryption key
                            if (entry.attributes.METHOD === 'NONE') {
                                key = null;
                                return;
                            }
                            if (!entry.attributes.URI) {
                                this.trigger('warn', {
                                    message: 'ignoring key declaration without URI'
                                });
                                return;
                            }
                            if (!entry.attributes.METHOD) {
                                this.trigger('warn', {
                                    message: 'defaulting key method to AES-128'
                                });
                            }

                            // setup an encryption key for upcoming segments
                            key = {
                                method: entry.attributes.METHOD || 'AES-128',
                                uri: entry.attributes.URI
                            };

                            if (entry.attributes.IV !== undefined) {
                                key.iv = entry.attributes.IV;
                            }
                        },
                        'media-sequence': function () {
                            if (!isFinite(entry.number)) {
                                this.trigger('warn', {
                                    message: 'ignoring invalid media sequence: ' + entry.number
                                });
                                return;
                            }
                            this.manifest.mediaSequence = entry.number;
                        },
                        'discontinuity-sequence': function () {
                            if (!isFinite(entry.number)) {
                                this.trigger('warn', {
                                    message: 'ignoring invalid discontinuity sequence: ' + entry.number
                                });
                                return;
                            }
                            this.manifest.discontinuitySequence = entry.number;
                        },
                        'playlist-type': function () {
                            if (!(/VOD|EVENT/).test(entry.playlistType)) {
                                this.trigger('warn', {
                                    message: 'ignoring unknown playlist type: ' + entry.playlist
                                });
                                return;
                            }
                            this.manifest.playlistType = entry.playlistType;
                        },
                        'stream-inf': function () {
                            this.manifest.playlists = uris;

                            if (!entry.attributes) {
                                this.trigger('warn', {
                                    message: 'ignoring empty stream-inf attributes'
                                });
                                return;
                            }

                            if (!currentUri.attributes) {
                                currentUri.attributes = {};
                            }
                            currentUri.attributes = m3u8.mergeOptions(currentUri.attributes,
                                entry.attributes);
                        },
                        'x-media': function () { 
                            this.manifest.playlists = uris;

                            if (!entry.attributes) {
                                this.trigger('warn', {
                                    message: 'ignoring empty x-media attributes'
                                });
                                return;
                            }
                            if (!currentUri.attributes) {
                                currentUri.attributes = {};
                            }
                            currentUri.attributes = m3u8.mergeOptions(currentUri.attributes,
                                entry.attributes);
                        },
                        'discontinuity': function () {
                            currentUri.discontinuity = true;
                        },
                        'targetduration': function () {
                            if (!isFinite(entry.duration) || entry.duration < 0) {
                                this.trigger('warn', {
                                    message: 'ignoring invalid target duration: ' + entry.duration
                                });
                                return;
                            }
                            this.manifest.targetDuration = entry.duration;
                        },
                        'totalduration': function () {
                            if (!isFinite(entry.duration) || entry.duration < 0) {
                                this.trigger('warn', {
                                    message: 'ignoring invalid total duration: ' + entry.duration
                                });
                                return;
                            }
                            this.manifest.totalDuration = entry.duration;
                        }
                    })[entry.tagType] || noop).call(self);
                },
                uri: function () {
                    currentUri.uri = entry.uri;
                    uris.push(currentUri);

                    // if no explicit duration was declared, use the target duration
                    if (this.manifest.targetDuration && !('duration' in currentUri)) {
                        this.trigger('warn', {
                            message: 'defaulting segment duration to the target duration'
                        });
                        currentUri.duration = this.manifest.targetDuration;
                    }
                    // annotate with encryption information, if necessary
                    if (key) {
                        currentUri.key = key;
                    }

                    // prepare for the next URI
                    currentUri = {};
                },
                comment: function () {
                    // comments are not important for playback
                }
            })[entry.type].call(self);
        });
    };
    Parser.prototype = new Stream();
    /**
     * Parse the input string and update the manifest object.
     * @param chunk {string} a potentially incomplete portion of the manifest
     */
    Parser.prototype.push = function (chunk) {
        this.lineStream.push(chunk);
    };
    /**
     * Flush any totalFromP2P input. This can be handy if the last line of an M3U8
     * manifest did not contain a trailing newline but the file has been
     * completely received.
     */
    Parser.prototype.end = function () {
        // flush any buffered input
        this.lineStream.push('\n');
    };

    m3u8.LineStream = LineStream;
    m3u8.ParseStream = ParseStream;
    m3u8.Parser = Parser;

    return m3u8;

}());

if(true) {
    module.exports = m3u8;
}

/***/ }),

/***/ "../../../node_modules/@hivestreaming/q/q.js":
/*!********************************************************************!*\
  !*** /home/omar/Desktop/hivejs/node_modules/@hivestreaming/q/q.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process, setImmediate) {// vim:ts=4:sts=4:sw=4:
/*!
 *
 * Copyright 2009-2017 Kris Kowal under the terms of the MIT
 * license found at https://github.com/kriskowal/q/blob/v1/LICENSE
 *
 * With parts by Tyler Close
 * Copyright 2007-2009 Tyler Close under the terms of the MIT X license found
 * at http://www.opensource.org/licenses/mit-license.html
 * Forked at ref_send.js version: 2009-05-11
 *
 * With parts by Mark Miller
 * Copyright (C) 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

(function (definition) {
    "use strict";

    // This file will function properly as a <script> tag, or a module
    // using CommonJS and NodeJS or RequireJS module formats.  In
    // Common/Node/RequireJS, the module exports the Q API and when
    // executed as a simple <script>, it creates a Q global instead.

    // Montage Require
    if (typeof bootstrap === "function") {
        bootstrap("promise", definition);

    // CommonJS
    } else if (true) {
        module.exports = definition();

    // RequireJS
    } else { var previousQ, global; }

})(function () {
"use strict";

// utilities for timeouts working in HiveJS simulation
function internalSetTimeout(cb, ms) {
  if ((typeof Framework != "undefined") && Framework.isSimulated()) {
      return Framework.setTimeout(cb, ms);
  } else {
      return setTimeout(cb, ms);
  }
}

function internalClearTimeout(id) {
  if ((typeof Framework != "undefined") && Framework.isSimulated()) {
      return Framework.clearTimeout(id);
  } else {
      return clearTimeout(id);
  }
}

var hasStacks = false;
try {
    throw new Error();
} catch (e) {
    hasStacks = !!e.stack;
}

// All code after this point will be filtered from stack traces reported
// by Q.
var qStartingLine = captureLine();
var qFileName;

// shims

// used for fallback in "allResolved"
var noop = function () {};

// Use the fastest possible means to execute a task in a future turn
// of the event loop.
var nextTick =(function () {
    // linked list of tasks (single, with head node)
    var head = {task: void 0, next: null};
    var tail = head;
    var flushing = false;
    var requestTick = void 0;
    var isNodeJS = false;
    var isIe = false;
    try {
        isIe = navigator && (navigator.appName === 'Microsoft Internet Explorer' || navigator.appVersion.match(/(trident).+rv[:\s]([\w\.]+).+like\sgecko/i) != null);
    } catch (e) {
        // navigator was not found. this can happen in our integration tests or anyway whenever the
        // q library is used in a node app without browser or electron
    }
    // queue for late tasks, used by unhandled rejection tracking
    var laterQueue = [];

    function flush() {
        /* jshint loopfunc: true */
        var task, domain;

        while (head.next) {
            head = head.next;
            task = head.task;
            head.task = void 0;
            domain = head.domain;

            if (domain) {
                head.domain = void 0;
                domain.enter();
            }
            runSingle(task, domain);

        }
        while (laterQueue.length) {
            task = laterQueue.pop();
            runSingle(task);
        }
        flushing = false;
    }
    // runs a single function in the async queue
    function runSingle(task, domain) {
        try {
            task();

        } catch (e) {
            if (isNodeJS) {
                // In node, uncaught exceptions are considered fatal errors.
                // Re-throw them synchronously to interrupt flushing!

                // Ensure continuation if the uncaught exception is suppressed
                // listening "uncaughtException" events (as domains does).
                // Continue in next event to avoid tick recursion.
                if (domain) {
                    domain.exit();
                }
                internalSetTimeout(flush, 0);
                if (domain) {
                    domain.enter();
                }

                throw e;

            } else {
                // In browsers, uncaught exceptions are not fatal.
                // Re-throw them asynchronously to avoid slow-downs.
                internalSetTimeout(function () {
                    throw e;
                }, 0);
            }
        }

        if (domain) {
            domain.exit();
        }
    }

    nextTick = function (task) {
        tail = tail.next = {
            task: task,
            domain: isNodeJS && process.domain,
            next: null
        };

        if (!flushing) {
            flushing = true;
            requestTick();
        }
    
    };

    if (typeof process === "object" && process &&
        process.toString() === "[object process]" && process.nextTick) {
        // Ensure Q is in a real Node environment, with a `process.nextTick`.
        // To see through fake Node environments:
        // * Mocha test runner - exposes a `process` global without a `nextTick`
        // * Browserify - exposes a `process.nexTick` function that uses
        //   `setTimeout`. In this case `setImmediate` is preferred because
        //    it is faster. Browserify's `process.toString()` yields
        //   "[object Object]", while in a real Node environment
        //   `process.toString()` yields "[object process]".
        isNodeJS = true;

        requestTick = function () {
            process.nextTick(flush);
        };

    } else if (typeof setImmediate === "function" && !isIe) {
        // Node.js 0.9+, or https://github.com/NobleJS/setImmediate
        if (typeof window !== "undefined") {
            requestTick = setImmediate.bind(window, flush);
        } else {
            requestTick = function () {
                setImmediate(flush);
            };
        }

    } else if (typeof MessageChannel !== "undefined" && !isIe) {
        // modern browsers
        // http://www.nonblocking.io/2011/06/windownexttick.html
        var channel = new MessageChannel();
        // At least Safari Version 6.0.5 (8536.30.1) intermittently cannot create
        // working message ports the first time a page loads.
        channel.port1.onmessage = function () {
            requestTick = requestPortTick;
            channel.port1.onmessage = flush;
            flush();
        };
        var requestPortTick = function () {
            // Opera requires us to provide a message payload, regardless of
            // whether we use it.
            channel.port2.postMessage(0);
        };
        requestTick = function () {
            internalSetTimeout(flush, 0);
            requestPortTick();
        };

    } else {
        // old browsers
        requestTick = function () {
            internalSetTimeout(flush, 0);
        };
    }
    // runs a task after all other tasks have been run
    // this is useful for unhandled rejection tracking that needs to happen
    // after all `then`d tasks have been run.
    nextTick.runAfter = function (task) {
        laterQueue.push(task);
        if (!flushing) {
            flushing = true;
            requestTick();
        }
    };
    return nextTick;
})();

// Attempt to make generics safe in the face of downstream
// modifications.
// There is no situation where this is necessary.
// If you need a security guarantee, these primordials need to be
// deeply frozen anyway, and if you dont need a security guarantee,
// this is just plain paranoid.
// However, this **might** have the nice side-effect of reducing the size of
// the minified code by reducing x.call() to merely x()
// See Mark Millers explanation of what this does.
// http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming
var call = Function.call;
function uncurryThis(f) {
    return function () {
        return call.apply(f, arguments);
    };
}
// This is equivalent, but slower:
// uncurryThis = Function_bind.bind(Function_bind.call);
// http://jsperf.com/uncurrythis

var array_slice = uncurryThis(Array.prototype.slice);

var array_reduce = uncurryThis(
    Array.prototype.reduce || function (callback, basis) {
        var index = 0,
            length = this.length;
        // concerning the initial value, if one is not provided
        if (arguments.length === 1) {
            // seek to the first value in the array, accounting
            // for the possibility that is is a sparse array
            do {
                if (index in this) {
                    basis = this[index++];
                    break;
                }
                if (++index >= length) {
                    throw new TypeError();
                }
            } while (1);
        }
        // reduce
        for (; index < length; index++) {
            // account for the possibility that the array is sparse
            if (index in this) {
                basis = callback(basis, this[index], index);
            }
        }
        return basis;
    }
);

var array_indexOf = uncurryThis(
    Array.prototype.indexOf || function (value) {
        // not a very good shim, but good enough for our one use of it
        for (var i = 0; i < this.length; i++) {
            if (this[i] === value) {
                return i;
            }
        }
        return -1;
    }
);

var array_map = uncurryThis(
    Array.prototype.map || function (callback, thisp) {
        var self = this;
        var collect = [];
        array_reduce(self, function (undefined, value, index) {
            collect.push(callback.call(thisp, value, index, self));
        }, void 0);
        return collect;
    }
);

var object_create = Object.create || function (prototype) {
    function Type() { }
    Type.prototype = prototype;
    return new Type();
};

var object_defineProperty = Object.defineProperty || function (obj, prop, descriptor) {
    obj[prop] = descriptor.value;
    return obj;
};

var object_hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);

var object_keys = Object.keys || function (object) {
    var keys = [];
    for (var key in object) {
        if (object_hasOwnProperty(object, key)) {
            keys.push(key);
        }
    }
    return keys;
};

var object_toString = uncurryThis(Object.prototype.toString);

function isObject(value) {
    return value === Object(value);
}

// generator related shims

// FIXME: Remove this function once ES6 generators are in SpiderMonkey.
function isStopIteration(exception) {
    return (
        object_toString(exception) === "[object StopIteration]" ||
        exception instanceof QReturnValue
    );
}

// FIXME: Remove this helper and Q.return once ES6 generators are in
// SpiderMonkey.
var QReturnValue;
if (typeof ReturnValue !== "undefined") {
    QReturnValue = ReturnValue;
} else {
    QReturnValue = function (value) {
        this.value = value;
    };
}

// long stack traces

var STACK_JUMP_SEPARATOR = "From previous event:";

function makeStackTraceLong(error, promise) {
    // If possible, transform the error stack trace by removing Node and Q
    // cruft, then concatenating with the stack trace of `promise`. See #57.
    if (hasStacks &&
        promise.stack &&
        typeof error === "object" &&
        error !== null &&
        error.stack
    ) {
        var stacks = [];
        for (var p = promise; !!p; p = p.source) {
            if (p.stack && (!error.__minimumStackCounter__ || error.__minimumStackCounter__ > p.stackCounter)) {
                object_defineProperty(error, "__minimumStackCounter__", {value: p.stackCounter, configurable: true});
                stacks.unshift(p.stack);
            }
        }
        stacks.unshift(error.stack);

        var concatedStacks = stacks.join("\n" + STACK_JUMP_SEPARATOR + "\n");
        var stack = filterStackString(concatedStacks);
        object_defineProperty(error, "stack", {value: stack, configurable: true});
    }
}

function filterStackString(stackString) {
    var lines = stackString.split("\n");
    var desiredLines = [];
    for (var i = 0; i < lines.length; ++i) {
        var line = lines[i];

        if (!isInternalFrame(line) && !isNodeFrame(line) && line) {
            desiredLines.push(line);
        }
    }
    return desiredLines.join("\n");
}

function isNodeFrame(stackLine) {
    return stackLine.indexOf("(module.js:") !== -1 ||
           stackLine.indexOf("(node.js:") !== -1;
}

function getFileNameAndLineNumber(stackLine) {
    // Named functions: "at functionName (filename:lineNumber:columnNumber)"
    // In IE10 function name can have spaces ("Anonymous function") O_o
    var attempt1 = /at .+ \((.+):(\d+):(?:\d+)\)$/.exec(stackLine);
    if (attempt1) {
        return [attempt1[1], Number(attempt1[2])];
    }

    // Anonymous functions: "at filename:lineNumber:columnNumber"
    var attempt2 = /at ([^ ]+):(\d+):(?:\d+)$/.exec(stackLine);
    if (attempt2) {
        return [attempt2[1], Number(attempt2[2])];
    }

    // Firefox style: "function@filename:lineNumber or @filename:lineNumber"
    var attempt3 = /.*@(.+):(\d+)$/.exec(stackLine);
    if (attempt3) {
        return [attempt3[1], Number(attempt3[2])];
    }
}

function isInternalFrame(stackLine) {
    var fileNameAndLineNumber = getFileNameAndLineNumber(stackLine);

    if (!fileNameAndLineNumber) {
        return false;
    }

    var fileName = fileNameAndLineNumber[0];
    var lineNumber = fileNameAndLineNumber[1];

    return fileName === qFileName &&
        lineNumber >= qStartingLine &&
        lineNumber <= qEndingLine;
}

// discover own file name and line number range for filtering stack
// traces
function captureLine() {
    if (!hasStacks) {
        return;
    }

    try {
        throw new Error();
    } catch (e) {
        var lines = e.stack.split("\n");
        var firstLine = lines[0].indexOf("@") > 0 ? lines[1] : lines[2];
        var fileNameAndLineNumber = getFileNameAndLineNumber(firstLine);
        if (!fileNameAndLineNumber) {
            return;
        }

        qFileName = fileNameAndLineNumber[0];
        return fileNameAndLineNumber[1];
    }
}

function deprecate(callback, name, alternative) {
    return function () {
        if (typeof console !== "undefined" &&
            typeof console.warn === "function") {
            console.warn(name + " is deprecated, use " + alternative +
                         " instead.", new Error("").stack);
        }
        return callback.apply(callback, arguments);
    };
}

// end of shims
// beginning of real work

/**
 * Constructs a promise for an immediate reference, passes promises through, or
 * coerces promises from different systems.
 * @param value immediate reference or promise
 */
function Q(value) {
    // If the object is already a Promise, return it directly.  This enables
    // the resolve function to both be used to created references from objects,
    // but to tolerably coerce non-promises to promises.
    if (value instanceof Promise) {
        return value;
    }

    // assimilate thenables
    if (isPromiseAlike(value)) {
        return coerce(value);
    } else {
        return fulfill(value);
    }
}
Q.resolve = Q;

/**
 * Performs a task in a future turn of the event loop.
 * @param {Function} task
 */
Q.nextTick = nextTick;

/**
 * Controls whether or not long stack traces will be on
 */
Q.longStackSupport = false;

/**
 * The counter is used to determine the stopping point for building
 * long stack traces. In makeStackTraceLong we walk backwards through
 * the linked list of promises, only stacks which were created before
 * the rejection are concatenated.
 */
var longStackCounter = 1;

// enable long stacks if Q_DEBUG is set
if (typeof process === "object" && process && process.env && process.env.Q_DEBUG) {
    Q.longStackSupport = true;
}

/**
 * Constructs a {promise, resolve, reject} object.
 *
 * `resolve` is a callback to invoke with a more resolved value for the
 * promise. To fulfill the promise, invoke `resolve` with any value that is
 * not a thenable. To reject the promise, invoke `resolve` with a rejected
 * thenable, or invoke `reject` with the reason directly. To resolve the
 * promise to another thenable, thus putting it in the same state, invoke
 * `resolve` with that other thenable.
 */
Q.defer = defer;
function defer() {
    // if "messages" is an "Array", that indicates that the promise has not yet
    // been resolved.  If it is "undefined", it has been resolved.  Each
    // element of the messages array is itself an array of complete arguments to
    // forward to the resolved promise.  We coerce the resolution value to a
    // promise using the `resolve` function because it handles both fully
    // non-thenable values and other thenables gracefully.
    var messages = [], progressListeners = [], resolvedPromise;

    var deferred = object_create(defer.prototype);
    var promise = object_create(Promise.prototype);

    promise.promiseDispatch = function (resolve, op, operands) {
        var args = array_slice(arguments);
        if (messages) {
            messages.push(args);
            if (op === "when" && operands[1]) { // progress operand
                progressListeners.push(operands[1]);
            }
        } else {
            Q.nextTick(function () {
                resolvedPromise.promiseDispatch.apply(resolvedPromise, args);
            });
        }
    };

    // XXX deprecated
    promise.valueOf = function () {
        if (messages) {
            return promise;
        }
        var nearerValue = nearer(resolvedPromise);
        if (isPromise(nearerValue)) {
            resolvedPromise = nearerValue; // shorten chain
        }
        return nearerValue;
    };

    promise.inspect = function () {
        if (!resolvedPromise) {
            return { status: "pending" };
        }
        return resolvedPromise.inspect();
    };

    if (Q.longStackSupport && hasStacks) {
        try {
            throw new Error();
        } catch (e) {
            // NOTE: don't try to use `Error.captureStackTrace` or transfer the
            // accessor around; that causes memory leaks as per GH-111. Just
            // reify the stack trace as a string ASAP.
            //
            // At the same time, cut off the first line; it's always just
            // "[object Promise]\n", as per the `toString`.
            promise.stack = e.stack.substring(e.stack.indexOf("\n") + 1);
            promise.stackCounter = longStackCounter++;
        }
    }

    // NOTE: we do the checks for `resolvedPromise` in each method, instead of
    // consolidating them into `become`, since otherwise we'd create new
    // promises with the lines `become(whatever(value))`. See e.g. GH-252.

    function become(newPromise) {
        resolvedPromise = newPromise;

        if (Q.longStackSupport && hasStacks) {
            // Only hold a reference to the new promise if long stacks
            // are enabled to reduce memory usage
            promise.source = newPromise;
        }

        array_reduce(messages, function (undefined, message) {
            Q.nextTick(function () {
                newPromise.promiseDispatch.apply(newPromise, message);
            });
        }, void 0);

        messages = void 0;
        progressListeners = void 0;
    }

    deferred.promise = promise;
    deferred.resolve = function (value) {
        if (resolvedPromise) {
            return;
        }

        become(Q(value));
    };

    deferred.fulfill = function (value) {
        if (resolvedPromise) {
            return;
        }

        become(fulfill(value));
    };
    deferred.reject = function (reason) {
        if (resolvedPromise) {
            return;
        }

        become(reject(reason));
    };
    deferred.notify = function (progress) {
        if (resolvedPromise) {
            return;
        }

        array_reduce(progressListeners, function (undefined, progressListener) {
            Q.nextTick(function () {
                progressListener(progress);
            });
        }, void 0);
    };

    return deferred;
}

/**
 * Creates a Node-style callback that will resolve or reject the deferred
 * promise.
 * @returns a nodeback
 */
defer.prototype.makeNodeResolver = function () {
    var self = this;
    return function (error, value) {
        if (error) {
            self.reject(error);
        } else if (arguments.length > 2) {
            self.resolve(array_slice(arguments, 1));
        } else {
            self.resolve(value);
        }
    };
};

/**
 * @param resolver {Function} a function that returns nothing and accepts
 * the resolve, reject, and notify functions for a deferred.
 * @returns a promise that may be resolved with the given resolve and reject
 * functions, or rejected by a thrown exception in resolver
 */
Q.Promise = promise; // ES6
Q.promise = promise;
function promise(resolver) {
    if (typeof resolver !== "function") {
        throw new TypeError("resolver must be a function.");
    }
    var deferred = defer();
    try {
        resolver(deferred.resolve, deferred.reject, deferred.notify);
    } catch (reason) {
        deferred.reject(reason);
    }
    return deferred.promise;
}

promise.race = race; // ES6
promise.all = all; // ES6
promise.reject = reject; // ES6
promise.resolve = Q; // ES6

// XXX experimental.  This method is a way to denote that a local value is
// serializable and should be immediately dispatched to a remote upon request,
// instead of passing a reference.
Q.passByCopy = function (object) {
    //freeze(object);
    //passByCopies.set(object, true);
    return object;
};

Promise.prototype.passByCopy = function () {
    //freeze(object);
    //passByCopies.set(object, true);
    return this;
};

/**
 * If two promises eventually fulfill to the same value, promises that value,
 * but otherwise rejects.
 * @param x {Any*}
 * @param y {Any*}
 * @returns {Any*} a promise for x and y if they are the same, but a rejection
 * otherwise.
 *
 */
Q.join = function (x, y) {
    return Q(x).join(y);
};

Promise.prototype.join = function (that) {
    return Q([this, that]).spread(function (x, y) {
        if (x === y) {
            // TODO: "===" should be Object.is or equiv
            return x;
        } else {
            throw new Error("Q can't join: not the same: " + x + " " + y);
        }
    });
};

/**
 * Returns a promise for the first of an array of promises to become settled.
 * @param answers {Array[Any*]} promises to race
 * @returns {Any*} the first promise to be settled
 */
Q.race = race;
function race(answerPs) {
    return promise(function (resolve, reject) {
        // Switch to this once we can assume at least ES5
        // answerPs.forEach(function (answerP) {
        //     Q(answerP).then(resolve, reject);
        // });
        // Use this in the meantime
        for (var i = 0, len = answerPs.length; i < len; i++) {
            Q(answerPs[i]).then(resolve, reject);
        }
    });
}

Promise.prototype.race = function () {
    return this.then(Q.race);
};

/**
 * Constructs a Promise with a promise descriptor object and optional fallback
 * function.  The descriptor contains methods like when(rejected), get(name),
 * set(name, value), post(name, args), and delete(name), which all
 * return either a value, a promise for a value, or a rejection.  The fallback
 * accepts the operation name, a resolver, and any further arguments that would
 * have been forwarded to the appropriate method above had a method been
 * provided with the proper name.  The API makes no guarantees about the nature
 * of the returned object, apart from that it is usable whereever promises are
 * bought and sold.
 */
Q.makePromise = Promise;
function Promise(descriptor, fallback, inspect) {
    if (fallback === void 0) {
        fallback = function (op) {
            return reject(new Error(
                "Promise does not support operation: " + op
            ));
        };
    }
    if (inspect === void 0) {
        inspect = function () {
            return {status: "unknown"};
        };
    }

    var promise = object_create(Promise.prototype);

    promise.promiseDispatch = function (resolve, op, args) {
        var result;
        try {
            if (descriptor[op]) {
                result = descriptor[op].apply(promise, args);
            } else {
                result = fallback.call(promise, op, args);
            }
        } catch (exception) {
            result = reject(exception);
        }
        if (resolve) {
            resolve(result);
        }
    };

    promise.inspect = inspect;

    // XXX deprecated `valueOf` and `exception` support
    if (inspect) {
        var inspected = inspect();
        if (inspected.status === "rejected") {
            promise.exception = inspected.reason;
        }

        promise.valueOf = function () {
            var inspected = inspect();
            if (inspected.status === "pending" ||
                inspected.status === "rejected") {
                return promise;
            }
            return inspected.value;
        };
    }

    return promise;
}

Promise.prototype.toString = function () {
    return "[object Promise]";
};

Promise.prototype.then = function (fulfilled, rejected, progressed) {
    var self = this;
    var deferred = defer();
    var done = false;   // ensure the untrusted promise makes at most a
                        // single call to one of the callbacks

    function _fulfilled(value) {
        try {
            return typeof fulfilled === "function" ? fulfilled(value) : value;
        } catch (exception) {
            return reject(exception);
        }
    }

    function _rejected(exception) {
        if (typeof rejected === "function") {
            makeStackTraceLong(exception, self);
            try {
                return rejected(exception);
            } catch (newException) {
                return reject(newException);
            }
        }
        return reject(exception);
    }

    function _progressed(value) {
        return typeof progressed === "function" ? progressed(value) : value;
    }

    Q.nextTick(function () {
        self.promiseDispatch(function (value) {
            if (done) {
                return;
            }
            done = true;

            deferred.resolve(_fulfilled(value));
        }, "when", [function (exception) {
            if (done) {
                return;
            }
            done = true;

            deferred.resolve(_rejected(exception));
        }]);
    });

    // Progress propagator need to be attached in the current tick.
    self.promiseDispatch(void 0, "when", [void 0, function (value) {
        var newValue;
        var threw = false;
        try {
            newValue = _progressed(value);
        } catch (e) {
            threw = true;
            if (Q.onerror) {
                Q.onerror(e);
            } else {
                throw e;
            }
        }

        if (!threw) {
            deferred.notify(newValue);
        }
    }]);

    return deferred.promise;
};

Q.tap = function (promise, callback) {
    return Q(promise).tap(callback);
};

/**
 * Works almost like "finally", but not called for rejections.
 * Original resolution value is passed through callback unaffected.
 * Callback may return a promise that will be awaited for.
 * @param {Function} callback
 * @returns {Q.Promise}
 * @example
 * doSomething()
 *   .then(...)
 *   .tap(console.log)
 *   .then(...);
 */
Promise.prototype.tap = function (callback) {
    callback = Q(callback);

    return this.then(function (value) {
        return callback.fcall(value).thenResolve(value);
    });
};

/**
 * Registers an observer on a promise.
 *
 * Guarantees:
 *
 * 1. that fulfilled and rejected will be called only once.
 * 2. that either the fulfilled callback or the rejected callback will be
 *    called, but not both.
 * 3. that fulfilled and rejected will not be called in this turn.
 *
 * @param value      promise or immediate reference to observe
 * @param fulfilled  function to be called with the fulfilled value
 * @param rejected   function to be called with the rejection exception
 * @param progressed function to be called on any progress notifications
 * @return promise for the return value from the invoked callback
 */
Q.when = when;
function when(value, fulfilled, rejected, progressed) {
    return Q(value).then(fulfilled, rejected, progressed);
}

Promise.prototype.thenResolve = function (value) {
    return this.then(function () { return value; });
};

Q.thenResolve = function (promise, value) {
    return Q(promise).thenResolve(value);
};

Promise.prototype.thenReject = function (reason) {
    return this.then(function () { throw reason; });
};

Q.thenReject = function (promise, reason) {
    return Q(promise).thenReject(reason);
};

/**
 * If an object is not a promise, it is as "near" as possible.
 * If a promise is rejected, it is as "near" as possible too.
 * If its a fulfilled promise, the fulfillment value is nearer.
 * If its a deferred promise and the deferred has been resolved, the
 * resolution is "nearer".
 * @param object
 * @returns most resolved (nearest) form of the object
 */

// XXX should we re-do this?
Q.nearer = nearer;
function nearer(value) {
    if (isPromise(value)) {
        var inspected = value.inspect();
        if (inspected.status === "fulfilled") {
            return inspected.value;
        }
    }
    return value;
}

/**
 * @returns whether the given object is a promise.
 * Otherwise it is a fulfilled value.
 */
Q.isPromise = isPromise;
function isPromise(object) {
    return object instanceof Promise;
}

Q.isPromiseAlike = isPromiseAlike;
function isPromiseAlike(object) {
    return isObject(object) && typeof object.then === "function";
}

/**
 * @returns whether the given object is a pending promise, meaning not
 * fulfilled or rejected.
 */
Q.isPending = isPending;
function isPending(object) {
    return isPromise(object) && object.inspect().status === "pending";
}

Promise.prototype.isPending = function () {
    return this.inspect().status === "pending";
};

/**
 * @returns whether the given object is a value or fulfilled
 * promise.
 */
Q.isFulfilled = isFulfilled;
function isFulfilled(object) {
    return !isPromise(object) || object.inspect().status === "fulfilled";
}

Promise.prototype.isFulfilled = function () {
    return this.inspect().status === "fulfilled";
};

/**
 * @returns whether the given object is a rejected promise.
 */
Q.isRejected = isRejected;
function isRejected(object) {
    return isPromise(object) && object.inspect().status === "rejected";
}

Promise.prototype.isRejected = function () {
    return this.inspect().status === "rejected";
};

//// BEGIN UNHANDLED REJECTION TRACKING

// This promise library consumes exceptions thrown in handlers so they can be
// handled by a subsequent promise.  The exceptions get added to this array when
// they are created, and removed when they are handled.  Note that in ES6 or
// shimmed environments, this would naturally be a `Set`.
var unhandledReasons = [];
var unhandledRejections = [];
var reportedUnhandledRejections = [];
var trackUnhandledRejections = true;

function resetUnhandledRejections() {
    unhandledReasons.length = 0;
    unhandledRejections.length = 0;

    if (!trackUnhandledRejections) {
        trackUnhandledRejections = true;
    }
}

function trackRejection(promise, reason) {
    if (!trackUnhandledRejections) {
        return;
    }
    if (typeof process === "object" && process && typeof process.emit === "function") {
        Q.nextTick.runAfter(function () {
            if (array_indexOf(unhandledRejections, promise) !== -1) {
                process.emit("unhandledRejection", reason, promise);
                reportedUnhandledRejections.push(promise);
            }
        });
    }

    unhandledRejections.push(promise);
    if (reason && typeof reason.stack !== "undefined") {
        unhandledReasons.push(reason.stack);
    } else {
        unhandledReasons.push("(no stack) " + reason);
    }
}

function untrackRejection(promise) {
    if (!trackUnhandledRejections) {
        return;
    }

    var at = array_indexOf(unhandledRejections, promise);
    if (at !== -1) {
        if (typeof process === "object" && process && typeof process.emit === "function") {
            Q.nextTick.runAfter(function () {
                var atReport = array_indexOf(reportedUnhandledRejections, promise);
                if (atReport !== -1) {
                    process.emit("rejectionHandled", unhandledReasons[at], promise);
                    reportedUnhandledRejections.splice(atReport, 1);
                }
            });
        }
        unhandledRejections.splice(at, 1);
        unhandledReasons.splice(at, 1);
    }
}

Q.resetUnhandledRejections = resetUnhandledRejections;

Q.getUnhandledReasons = function () {
    // Make a copy so that consumers can't interfere with our internal state.
    return unhandledReasons.slice();
};

Q.stopUnhandledRejectionTracking = function () {
    resetUnhandledRejections();
    trackUnhandledRejections = false;
};

resetUnhandledRejections();

//// END UNHANDLED REJECTION TRACKING

/**
 * Constructs a rejected promise.
 * @param reason value describing the failure
 */
Q.reject = reject;
function reject(reason) {
    var rejection = Promise({
        "when": function (rejected) {
            // note that the error has been handled
            if (rejected) {
                untrackRejection(this);
            }
            return rejected ? rejected(reason) : this;
        }
    }, function fallback() {
        return this;
    }, function inspect() {
        return { status: "rejected", reason: reason };
    });

    // Note that the reason has not been handled.
    trackRejection(rejection, reason);

    return rejection;
}

/**
 * Constructs a fulfilled promise for an immediate reference.
 * @param value immediate reference
 */
Q.fulfill = fulfill;
function fulfill(value) {
    return Promise({
        "when": function () {
            return value;
        },
        "get": function (name) {
            return value[name];
        },
        "set": function (name, rhs) {
            value[name] = rhs;
        },
        "delete": function (name) {
            delete value[name];
        },
        "post": function (name, args) {
            // Mark Miller proposes that post with no name should apply a
            // promised function.
            if (name === null || name === void 0) {
                return value.apply(void 0, args);
            } else {
                return value[name].apply(value, args);
            }
        },
        "apply": function (thisp, args) {
            return value.apply(thisp, args);
        },
        "keys": function () {
            return object_keys(value);
        }
    }, void 0, function inspect() {
        return { status: "fulfilled", value: value };
    });
}

/**
 * Converts thenables to Q promises.
 * @param promise thenable promise
 * @returns a Q promise
 */
function coerce(promise) {
    var deferred = defer();
    Q.nextTick(function () {
        try {
            promise.then(deferred.resolve, deferred.reject, deferred.notify);
        } catch (exception) {
            deferred.reject(exception);
        }
    });
    return deferred.promise;
}

/**
 * Annotates an object such that it will never be
 * transferred away from this process over any promise
 * communication channel.
 * @param object
 * @returns promise a wrapping of that object that
 * additionally responds to the "isDef" message
 * without a rejection.
 */
Q.master = master;
function master(object) {
    return Promise({
        "isDef": function () {}
    }, function fallback(op, args) {
        return dispatch(object, op, args);
    }, function () {
        return Q(object).inspect();
    });
}

/**
 * Spreads the values of a promised array of arguments into the
 * fulfillment callback.
 * @param fulfilled callback that receives variadic arguments from the
 * promised array
 * @param rejected callback that receives the exception if the promise
 * is rejected.
 * @returns a promise for the return value or thrown exception of
 * either callback.
 */
Q.spread = spread;
function spread(value, fulfilled, rejected) {
    return Q(value).spread(fulfilled, rejected);
}

Promise.prototype.spread = function (fulfilled, rejected) {
    return this.all().then(function (array) {
        return fulfilled.apply(void 0, array);
    }, rejected);
};

/**
 * The async function is a decorator for generator functions, turning
 * them into asynchronous generators.  Although generators are only part
 * of the newest ECMAScript 6 drafts, this code does not cause syntax
 * errors in older engines.  This code should continue to work and will
 * in fact improve over time as the language improves.
 *
 * ES6 generators are currently part of V8 version 3.19 with the
 * --harmony-generators runtime flag enabled.  SpiderMonkey has had them
 * for longer, but under an older Python-inspired form.  This function
 * works on both kinds of generators.
 *
 * Decorates a generator function such that:
 *  - it may yield promises
 *  - execution will continue when that promise is fulfilled
 *  - the value of the yield expression will be the fulfilled value
 *  - it returns a promise for the return value (when the generator
 *    stops iterating)
 *  - the decorated function returns a promise for the return value
 *    of the generator or the first rejected promise among those
 *    yielded.
 *  - if an error is thrown in the generator, it propagates through
 *    every following yield until it is caught, or until it escapes
 *    the generator function altogether, and is translated into a
 *    rejection for the promise returned by the decorated generator.
 */
Q.async = async;
function async(makeGenerator) {
    return function () {
        // when verb is "send", arg is a value
        // when verb is "throw", arg is an exception
        function continuer(verb, arg) {
            var result;

            // Until V8 3.19 / Chromium 29 is released, SpiderMonkey is the only
            // engine that has a deployed base of browsers that support generators.
            // However, SM's generators use the Python-inspired semantics of
            // outdated ES6 drafts.  We would like to support ES6, but we'd also
            // like to make it possible to use generators in deployed browsers, so
            // we also support Python-style generators.  At some point we can remove
            // this block.

            if (typeof StopIteration === "undefined") {
                // ES6 Generators
                try {
                    result = generator[verb](arg);
                } catch (exception) {
                    return reject(exception);
                }
                if (result.done) {
                    return Q(result.value);
                } else {
                    return when(result.value, callback, errback);
                }
            } else {
                // SpiderMonkey Generators
                // FIXME: Remove this case when SM does ES6 generators.
                try {
                    result = generator[verb](arg);
                } catch (exception) {
                    if (isStopIteration(exception)) {
                        return Q(exception.value);
                    } else {
                        return reject(exception);
                    }
                }
                return when(result, callback, errback);
            }
        }
        var generator = makeGenerator.apply(this, arguments);
        var callback = continuer.bind(continuer, "next");
        var errback = continuer.bind(continuer, "throw");
        return callback();
    };
}

/**
 * The spawn function is a small wrapper around async that immediately
 * calls the generator and also ends the promise chain, so that any
 * unhandled errors are thrown instead of forwarded to the error
 * handler. This is useful because it's extremely common to run
 * generators at the top-level to work with libraries.
 */
Q.spawn = spawn;
function spawn(makeGenerator) {
    Q.done(Q.async(makeGenerator)());
}

// FIXME: Remove this interface once ES6 generators are in SpiderMonkey.
/**
 * Throws a ReturnValue exception to stop an asynchronous generator.
 *
 * This interface is a stop-gap measure to support generator return
 * values in older Firefox/SpiderMonkey.  In browsers that support ES6
 * generators like Chromium 29, just use "return" in your generator
 * functions.
 *
 * @param value the return value for the surrounding generator
 * @throws ReturnValue exception with the value.
 * @example
 * // ES6 style
 * Q.async(function* () {
 *      var foo = yield getFooPromise();
 *      var bar = yield getBarPromise();
 *      return foo + bar;
 * })
 * // Older SpiderMonkey style
 * Q.async(function () {
 *      var foo = yield getFooPromise();
 *      var bar = yield getBarPromise();
 *      Q.return(foo + bar);
 * })
 */
Q["return"] = _return;
function _return(value) {
    throw new QReturnValue(value);
}

/**
 * The promised function decorator ensures that any promise arguments
 * are settled and passed as values (`this` is also settled and passed
 * as a value).  It will also ensure that the result of a function is
 * always a promise.
 *
 * @example
 * var add = Q.promised(function (a, b) {
 *     return a + b;
 * });
 * add(Q(a), Q(B));
 *
 * @param {function} callback The function to decorate
 * @returns {function} a function that has been decorated.
 */
Q.promised = promised;
function promised(callback) {
    return function () {
        return spread([this, all(arguments)], function (self, args) {
            return callback.apply(self, args);
        });
    };
}

/**
 * sends a message to a value in a future turn
 * @param object* the recipient
 * @param op the name of the message operation, e.g., "when",
 * @param args further arguments to be forwarded to the operation
 * @returns result {Promise} a promise for the result of the operation
 */
Q.dispatch = dispatch;
function dispatch(object, op, args) {
    return Q(object).dispatch(op, args);
}

Promise.prototype.dispatch = function (op, args) {
    var self = this;
    var deferred = defer();
    Q.nextTick(function () {
        self.promiseDispatch(deferred.resolve, op, args);
    });
    return deferred.promise;
};

/**
 * Gets the value of a property in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of property to get
 * @return promise for the property value
 */
Q.get = function (object, key) {
    return Q(object).dispatch("get", [key]);
};

Promise.prototype.get = function (key) {
    return this.dispatch("get", [key]);
};

/**
 * Sets the value of a property in a future turn.
 * @param object    promise or immediate reference for object object
 * @param name      name of property to set
 * @param value     new value of property
 * @return promise for the return value
 */
Q.set = function (object, key, value) {
    return Q(object).dispatch("set", [key, value]);
};

Promise.prototype.set = function (key, value) {
    return this.dispatch("set", [key, value]);
};

/**
 * Deletes a property in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of property to delete
 * @return promise for the return value
 */
Q.del = // XXX legacy
Q["delete"] = function (object, key) {
    return Q(object).dispatch("delete", [key]);
};

Promise.prototype.del = // XXX legacy
Promise.prototype["delete"] = function (key) {
    return this.dispatch("delete", [key]);
};

/**
 * Invokes a method in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of method to invoke
 * @param value     a value to post, typically an array of
 *                  invocation arguments for promises that
 *                  are ultimately backed with `resolve` values,
 *                  as opposed to those backed with URLs
 *                  wherein the posted value can be any
 *                  JSON serializable object.
 * @return promise for the return value
 */
// bound locally because it is used by other methods
Q.mapply = // XXX As proposed by "Redsandro"
Q.post = function (object, name, args) {
    return Q(object).dispatch("post", [name, args]);
};

Promise.prototype.mapply = // XXX As proposed by "Redsandro"
Promise.prototype.post = function (name, args) {
    return this.dispatch("post", [name, args]);
};

/**
 * Invokes a method in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of method to invoke
 * @param ...args   array of invocation arguments
 * @return promise for the return value
 */
Q.send = // XXX Mark Miller's proposed parlance
Q.mcall = // XXX As proposed by "Redsandro"
Q.invoke = function (object, name /*...args*/) {
    return Q(object).dispatch("post", [name, array_slice(arguments, 2)]);
};

Promise.prototype.send = // XXX Mark Miller's proposed parlance
Promise.prototype.mcall = // XXX As proposed by "Redsandro"
Promise.prototype.invoke = function (name /*...args*/) {
    return this.dispatch("post", [name, array_slice(arguments, 1)]);
};

/**
 * Applies the promised function in a future turn.
 * @param object    promise or immediate reference for target function
 * @param args      array of application arguments
 */
Q.fapply = function (object, args) {
    return Q(object).dispatch("apply", [void 0, args]);
};

Promise.prototype.fapply = function (args) {
    return this.dispatch("apply", [void 0, args]);
};

/**
 * Calls the promised function in a future turn.
 * @param object    promise or immediate reference for target function
 * @param ...args   array of application arguments
 */
Q["try"] =
Q.fcall = function (object /* ...args*/) {
    return Q(object).dispatch("apply", [void 0, array_slice(arguments, 1)]);
};

Promise.prototype.fcall = function (/*...args*/) {
    return this.dispatch("apply", [void 0, array_slice(arguments)]);
};

/**
 * Binds the promised function, transforming return values into a fulfilled
 * promise and thrown errors into a rejected one.
 * @param object    promise or immediate reference for target function
 * @param ...args   array of application arguments
 */
Q.fbind = function (object /*...args*/) {
    var promise = Q(object);
    var args = array_slice(arguments, 1);
    return function fbound() {
        return promise.dispatch("apply", [
            this,
            args.concat(array_slice(arguments))
        ]);
    };
};
Promise.prototype.fbind = function (/*...args*/) {
    var promise = this;
    var args = array_slice(arguments);
    return function fbound() {
        return promise.dispatch("apply", [
            this,
            args.concat(array_slice(arguments))
        ]);
    };
};

/**
 * Requests the names of the owned properties of a promised
 * object in a future turn.
 * @param object    promise or immediate reference for target object
 * @return promise for the keys of the eventually settled object
 */
Q.keys = function (object) {
    return Q(object).dispatch("keys", []);
};

Promise.prototype.keys = function () {
    return this.dispatch("keys", []);
};

/**
 * Turns an array of promises into a promise for an array.  If any of
 * the promises gets rejected, the whole array is rejected immediately.
 * @param {Array*} an array (or promise for an array) of values (or
 * promises for values)
 * @returns a promise for an array of the corresponding values
 */
// By Mark Miller
// http://wiki.ecmascript.org/doku.php?id=strawman:concurrency&rev=1308776521#allfulfilled
Q.all = all;
function all(promises) {
    return when(promises, function (promises) {
        var pendingCount = 0;
        var deferred = defer();
        array_reduce(promises, function (undefined, promise, index) {
            var snapshot;
            if (
                isPromise(promise) &&
                (snapshot = promise.inspect()).status === "fulfilled"
            ) {
                promises[index] = snapshot.value;
            } else {
                ++pendingCount;
                when(
                    promise,
                    function (value) {
                        promises[index] = value;
                        if (--pendingCount === 0) {
                            deferred.resolve(promises);
                        }
                    },
                    deferred.reject,
                    function (progress) {
                        deferred.notify({ index: index, value: progress });
                    }
                );
            }
        }, void 0);
        if (pendingCount === 0) {
            deferred.resolve(promises);
        }
        return deferred.promise;
    });
}

Promise.prototype.all = function () {
    return all(this);
};

/**
 * Returns the first resolved promise of an array. Prior rejected promises are
 * ignored.  Rejects only if all promises are rejected.
 * @param {Array*} an array containing values or promises for values
 * @returns a promise fulfilled with the value of the first resolved promise,
 * or a rejected promise if all promises are rejected.
 */
Q.any = any;

function any(promises) {
    if (promises.length === 0) {
        return Q.resolve();
    }

    var deferred = Q.defer();
    var pendingCount = 0;
    array_reduce(promises, function (prev, current, index) {
        var promise = promises[index];

        pendingCount++;

        when(promise, onFulfilled, onRejected, onProgress);
        function onFulfilled(result) {
            deferred.resolve(result);
        }
        function onRejected(err) {
            pendingCount--;
            if (pendingCount === 0) {
                var rejection = err || new Error("" + err);

                rejection.message = ("Q can't get fulfillment value from any promise, all " +
                    "promises were rejected. Last error message: " + rejection.message);

                deferred.reject(rejection);
            }
        }
        function onProgress(progress) {
            deferred.notify({
                index: index,
                value: progress
            });
        }
    }, undefined);

    return deferred.promise;
}

Promise.prototype.any = function () {
    return any(this);
};

/**
 * Waits for all promises to be settled, either fulfilled or
 * rejected.  This is distinct from `all` since that would stop
 * waiting at the first rejection.  The promise returned by
 * `allResolved` will never be rejected.
 * @param promises a promise for an array (or an array) of promises
 * (or values)
 * @return a promise for an array of promises
 */
Q.allResolved = deprecate(allResolved, "allResolved", "allSettled");
function allResolved(promises) {
    return when(promises, function (promises) {
        promises = array_map(promises, Q);
        return when(all(array_map(promises, function (promise) {
            return when(promise, noop, noop);
        })), function () {
            return promises;
        });
    });
}

Promise.prototype.allResolved = function () {
    return allResolved(this);
};

/**
 * @see Promise#allSettled
 */
Q.allSettled = allSettled;
function allSettled(promises) {
    return Q(promises).allSettled();
}

/**
 * Turns an array of promises into a promise for an array of their states (as
 * returned by `inspect`) when they have all settled.
 * @param {Array[Any*]} values an array (or promise for an array) of values (or
 * promises for values)
 * @returns {Array[status]} an array of states for the respective values.
 */
Promise.prototype.allSettled = function () {
    return this.then(function (promises) {
        return all(array_map(promises, function (promise) {
            promise = Q(promise);
            function regardless() {
                return promise.inspect();
            }
            return promise.then(regardless, regardless);
        }));
    });
};

/**
 * Captures the failure of a promise, giving an oportunity to recover
 * with a callback.  If the given promise is fulfilled, the returned
 * promise is fulfilled.
 * @param {Any*} promise for something
 * @param {Function} callback to fulfill the returned promise if the
 * given promise is rejected
 * @returns a promise for the return value of the callback
 */
Q.fail = // XXX legacy
Q["catch"] = function (object, rejected) {
    return Q(object).then(void 0, rejected);
};

Promise.prototype.fail = // XXX legacy
Promise.prototype["catch"] = function (rejected) {
    return this.then(void 0, rejected);
};

/**
 * Attaches a listener that can respond to progress notifications from a
 * promise's originating deferred. This listener receives the exact arguments
 * passed to ``deferred.notify``.
 * @param {Any*} promise for something
 * @param {Function} callback to receive any progress notifications
 * @returns the given promise, unchanged
 */
Q.progress = progress;
function progress(object, progressed) {
    return Q(object).then(void 0, void 0, progressed);
}

Promise.prototype.progress = function (progressed) {
    return this.then(void 0, void 0, progressed);
};

/**
 * Provides an opportunity to observe the settling of a promise,
 * regardless of whether the promise is fulfilled or rejected.  Forwards
 * the resolution to the returned promise when the callback is done.
 * The callback can return a promise to defer completion.
 * @param {Any*} promise
 * @param {Function} callback to observe the resolution of the given
 * promise, takes no arguments.
 * @returns a promise for the resolution of the given promise when
 * ``fin`` is done.
 */
Q.fin = // XXX legacy
Q["finally"] = function (object, callback) {
    return Q(object)["finally"](callback);
};

Promise.prototype.fin = // XXX legacy
Promise.prototype["finally"] = function (callback) {
    if (!callback || typeof callback.apply !== "function") {
        throw new Error("Q can't apply finally callback");
    }
    callback = Q(callback);
    return this.then(function (value) {
        return callback.fcall().then(function () {
            return value;
        });
    }, function (reason) {
        // TODO attempt to recycle the rejection with "this".
        return callback.fcall().then(function () {
            throw reason;
        });
    });
};

/**
 * Terminates a chain of promises, forcing rejections to be
 * thrown as exceptions.
 * @param {Any*} promise at the end of a chain of promises
 * @returns nothing
 */
Q.done = function (object, fulfilled, rejected, progress) {
    return Q(object).done(fulfilled, rejected, progress);
};

Promise.prototype.done = function (fulfilled, rejected, progress) {
    var onUnhandledError = function (error) {
        // forward to a future turn so that ``when``
        // does not catch it and turn it into a rejection.
        Q.nextTick(function () {
            makeStackTraceLong(error, promise);
            if (Q.onerror) {
                Q.onerror(error);
            } else {
                throw error;
            }
        });
    };

    // Avoid unnecessary `nextTick`ing via an unnecessary `when`.
    var promise = fulfilled || rejected || progress ?
        this.then(fulfilled, rejected, progress) :
        this;

    if (typeof process === "object" && process && process.domain) {
        onUnhandledError = process.domain.bind(onUnhandledError);
    }

    promise.then(void 0, onUnhandledError);
};

/**
 * Causes a promise to be rejected if it does not get fulfilled before
 * some milliseconds time out.
 * @param {Any*} promise
 * @param {Number} milliseconds timeout
 * @param {Any*} custom error message or Error object (optional)
 * @returns a promise for the resolution of the given promise if it is
 * fulfilled before the timeout, otherwise rejected.
 */
Q.timeout = function (object, ms, error) {
    return Q(object).timeout(ms, error);
};

Promise.prototype.timeout = function (ms, error) {
    var deferred = defer();
    var timeoutId = internalSetTimeout(function () {
        if (!error || "string" === typeof error) {
            error = new Error(error || "Timed out after " + ms + " ms");
            error.code = "ETIMEDOUT";
        }
        deferred.reject(error);
    }, ms);

    this.then(function (value) {
        internalClearTimeout(timeoutId);
        deferred.resolve(value);
    }, function (exception) {
        internalClearTimeout(timeoutId);
        deferred.reject(exception);
    }, deferred.notify);

    return deferred.promise;
};

/**
 * Returns a promise for the given value (or promised value), some
 * milliseconds after it resolved. Passes rejections immediately.
 * @param {Any*} promise
 * @param {Number} milliseconds
 * @returns a promise for the resolution of the given promise after milliseconds
 * time has elapsed since the resolution of the given promise.
 * If the given promise rejects, that is passed immediately.
 */
Q.delay = function (object, timeout) {
    if (timeout === void 0) {
        timeout = object;
        object = void 0;
    }
    return Q(object).delay(timeout);
};

Promise.prototype.delay = function (timeout) {
    return this.then(function (value) {
        var deferred = defer();
        internalSetTimeout(function () {
            deferred.resolve(value);
        }, timeout);
        return deferred.promise;
    });
};

/**
 * Passes a continuation to a Node function, which is called with the given
 * arguments provided as an array, and returns a promise.
 *
 *      Q.nfapply(FS.readFile, [__filename])
 *      .then(function (content) {
 *      })
 *
 */
Q.nfapply = function (callback, args) {
    return Q(callback).nfapply(args);
};

Promise.prototype.nfapply = function (args) {
    var deferred = defer();
    var nodeArgs = array_slice(args);
    nodeArgs.push(deferred.makeNodeResolver());
    this.fapply(nodeArgs).fail(deferred.reject);
    return deferred.promise;
};

/**
 * Passes a continuation to a Node function, which is called with the given
 * arguments provided individually, and returns a promise.
 * @example
 * Q.nfcall(FS.readFile, __filename)
 * .then(function (content) {
 * })
 *
 */
Q.nfcall = function (callback /*...args*/) {
    var args = array_slice(arguments, 1);
    return Q(callback).nfapply(args);
};

Promise.prototype.nfcall = function (/*...args*/) {
    var nodeArgs = array_slice(arguments);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    this.fapply(nodeArgs).fail(deferred.reject);
    return deferred.promise;
};

/**
 * Wraps a NodeJS continuation passing function and returns an equivalent
 * version that returns a promise.
 * @example
 * Q.nfbind(FS.readFile, __filename)("utf-8")
 * .then(console.log)
 * .done()
 */
Q.nfbind =
Q.denodeify = function (callback /*...args*/) {
    if (callback === undefined) {
        throw new Error("Q can't wrap an undefined function");
    }
    var baseArgs = array_slice(arguments, 1);
    return function () {
        var nodeArgs = baseArgs.concat(array_slice(arguments));
        var deferred = defer();
        nodeArgs.push(deferred.makeNodeResolver());
        Q(callback).fapply(nodeArgs).fail(deferred.reject);
        return deferred.promise;
    };
};

Promise.prototype.nfbind =
Promise.prototype.denodeify = function (/*...args*/) {
    var args = array_slice(arguments);
    args.unshift(this);
    return Q.denodeify.apply(void 0, args);
};

Q.nbind = function (callback, thisp /*...args*/) {
    var baseArgs = array_slice(arguments, 2);
    return function () {
        var nodeArgs = baseArgs.concat(array_slice(arguments));
        var deferred = defer();
        nodeArgs.push(deferred.makeNodeResolver());
        function bound() {
            return callback.apply(thisp, arguments);
        }
        Q(bound).fapply(nodeArgs).fail(deferred.reject);
        return deferred.promise;
    };
};

Promise.prototype.nbind = function (/*thisp, ...args*/) {
    var args = array_slice(arguments, 0);
    args.unshift(this);
    return Q.nbind.apply(void 0, args);
};

/**
 * Calls a method of a Node-style object that accepts a Node-style
 * callback with a given array of arguments, plus a provided callback.
 * @param object an object that has the named method
 * @param {String} name name of the method of object
 * @param {Array} args arguments to pass to the method; the callback
 * will be provided by Q and appended to these arguments.
 * @returns a promise for the value or error
 */
Q.nmapply = // XXX As proposed by "Redsandro"
Q.npost = function (object, name, args) {
    return Q(object).npost(name, args);
};

Promise.prototype.nmapply = // XXX As proposed by "Redsandro"
Promise.prototype.npost = function (name, args) {
    var nodeArgs = array_slice(args || []);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
    return deferred.promise;
};

/**
 * Calls a method of a Node-style object that accepts a Node-style
 * callback, forwarding the given variadic arguments, plus a provided
 * callback argument.
 * @param object an object that has the named method
 * @param {String} name name of the method of object
 * @param ...args arguments to pass to the method; the callback will
 * be provided by Q and appended to these arguments.
 * @returns a promise for the value or error
 */
Q.nsend = // XXX Based on Mark Miller's proposed "send"
Q.nmcall = // XXX Based on "Redsandro's" proposal
Q.ninvoke = function (object, name /*...args*/) {
    var nodeArgs = array_slice(arguments, 2);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    Q(object).dispatch("post", [name, nodeArgs]).fail(deferred.reject);
    return deferred.promise;
};

Promise.prototype.nsend = // XXX Based on Mark Miller's proposed "send"
Promise.prototype.nmcall = // XXX Based on "Redsandro's" proposal
Promise.prototype.ninvoke = function (name /*...args*/) {
    var nodeArgs = array_slice(arguments, 1);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
    return deferred.promise;
};

/**
 * If a function would like to support both Node continuation-passing-style and
 * promise-returning-style, it can end its internal promise chain with
 * `nodeify(nodeback)`, forwarding the optional nodeback argument.  If the user
 * elects to use a nodeback, the result will be sent there.  If they do not
 * pass a nodeback, they will receive the result promise.
 * @param object a result (or a promise for a result)
 * @param {Function} nodeback a Node.js-style callback
 * @returns either the promise or nothing
 */
Q.nodeify = nodeify;
function nodeify(object, nodeback) {
    return Q(object).nodeify(nodeback);
}

Promise.prototype.nodeify = function (nodeback) {
    if (nodeback) {
        this.then(function (value) {
            Q.nextTick(function () {
                nodeback(null, value);
            });
        }, function (error) {
            Q.nextTick(function () {
                nodeback(error);
            });
        });
    } else {
        return this;
    }
};

Q.noConflict = function() {
    throw new Error("Q.noConflict only works when Q is used as a global");
};

// All code before this point will be filtered from stack traces.
var qEndingLine = captureLine();

return Q;

});
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../process/browser.js */ "../../../node_modules/process/browser.js"), __webpack_require__(/*! ./../../timers-browserify/main.js */ "../../../node_modules/timers-browserify/main.js").setImmediate))

/***/ }),

/***/ "../../../node_modules/@hivestreaming/remote-config-keys/dist/config-values.js":
/*!******************************************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/node_modules/@hivestreaming/remote-config-keys/dist/config-values.js ***!
  \******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * This file was automatically generated by the remote config key generator.
 * DO NOT MODIFY IT BY HAND. Instead, modify the key.ts source file.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConfigValues = void 0;
var ConfigValuesClass = /** @class */ (function () {
    function ConfigValuesClass() {
        // The policy defines how the peers are allowed to connect and exchange data between each other based on their site info.
        this['p2p.peeringPolicy'] = 'excludeVpnSites';
        // Used to change site to site peering behavior for sites listed on the site info table. If set to FALSE, all sites affected by this config will no longer peer with other sites listed on the provided site info table.
        this['p2p.siteToSiteEnabled'] = false;
        // Value set is the highest bitrate allowed on the manifest. All higher values (if any) will be trimmed away from the manifest. This configuration can be used for both HLS and DASH. As an example: If a player uses 4 bitrates at 90000 bps, 350000, 850000, 1700000 and the value was set at 1000000, then all bitrates under 1Mbps are kept. All above are removed.
        this['stream.maxBandwidth'] = 0;
        // Removes resolutions (width and height attributes) from the manifest. The resolution is used to decide which bitrate to fetch based on the player windows size. Removing the resolution makes it possible for the Silent Test Browser to go to the highest bitrate even when opening a 1x1 pixel window. This config is used in silent tests only.
        this['stream.removeResolution'] = false;
        // Used to obfuscate the private IP and host name in metric snapshots sent to our backend for storage. The private IP will still be used for peering purposes, but this use case will not store the private IP as it will not be sent in metric snapshots.
        this['pii.obfuscationEnabled'] = false;
        // If set to true, the plugin will authenticate each fragment received from peer to peer by comparing the last 32 bytes received from P2P with the last 32 bytes from the CDN. In case they are different, the fragment will be dropped, because it means the encryption was broken.
        this['security.fragmentAuthenticationEnabled'] = false;
        // If set to true, the plugin will use STUN to discover the public IP of the machine. If set to false, the plugin will not use STUN.
        this['webrtc.enableStun'] = true;
    }
    return ConfigValuesClass;
}());
exports.ConfigValues = new ConfigValuesClass();


/***/ }),

/***/ "../../../node_modules/@hivestreaming/thrift/src/thrift.js":
/*!**********************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/node_modules/@hivestreaming/thrift/src/thrift.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/*jshint evil:true*/

/**
 * The Thrift namespace houses the Apache Thrift JavaScript library 
 * elements providing JavaScript bindings for the Apache Thrift RPC 
 * system. End users will typically only directly make use of the 
 * Transport (TXHRTransport/TWebSocketTransport) and Protocol 
 * (TJSONPRotocol/TBinaryProtocol) constructors.
 * 
 * Object methods beginning with a __ (e.g. __onOpen()) are internal 
 * and should not be called outside of the object's own methods.
 * 
 * This library creates one global object: Thrift
 * Code in this library must never create additional global identifiers,
 * all features must be scoped within the Thrift namespace.
 * @namespace
 * @example
 *     var transport = new Thrift.Transport("http://localhost:8585");
 *     var protocol  = new Thrift.Protocol(transport);
 *     var client = new MyThriftSvcClient(protocol);
 *     var result = client.MyMethod();
 */
var Thrift = {
    /**
     * Thrift JavaScript library version.
     * @readonly
     * @const {string} Version
     * @memberof Thrift
     */
    Version: '0.9.3',

    /**
     * Thrift IDL type string to Id mapping.
     * @readonly
     * @property {number}  STOP   - End of a set of fields.
     * @property {number}  VOID   - No value (only legal for return types).
     * @property {number}  BOOL   - True/False integer.
     * @property {number}  BYTE   - Signed 8 bit integer.
     * @property {number}  I08    - Signed 8 bit integer.     
     * @property {number}  DOUBLE - 64 bit IEEE 854 floating point.
     * @property {number}  I16    - Signed 16 bit integer.
     * @property {number}  I32    - Signed 32 bit integer.
     * @property {number}  I64    - Signed 64 bit integer.
     * @property {number}  STRING - Array of bytes representing a string of characters.
     * @property {number}  UTF7   - Array of bytes representing a string of UTF7 encoded characters.
     * @property {number}  STRUCT - A multifield type.
     * @property {number}  MAP    - A collection type (map/associative-array/dictionary).
     * @property {number}  SET    - A collection type (unordered and without repeated values).
     * @property {number}  LIST   - A collection type (unordered).
     * @property {number}  UTF8   - Array of bytes representing a string of UTF8 encoded characters.
     * @property {number}  UTF16  - Array of bytes representing a string of UTF16 encoded characters.
     */
    Type: {
        'STOP' : 0,
        'VOID' : 1,
        'BOOL' : 2,
        'BYTE' : 3,
        'I08' : 3,
        'DOUBLE' : 4,
        'I16' : 6,
        'I32' : 8,
        'I64' : 10,
        'STRING' : 11,
        'UTF7' : 11,
        'STRUCT' : 12,
        'MAP' : 13,
        'SET' : 14,
        'LIST' : 15,
        'UTF8' : 16,
        'UTF16' : 17
    },

    /**
     * Thrift RPC message type string to Id mapping.
     * @readonly
     * @property {number}  CALL      - RPC call sent from client to server.
     * @property {number}  REPLY     - RPC call normal response from server to client.
     * @property {number}  EXCEPTION - RPC call exception response from server to client.
     * @property {number}  ONEWAY    - Oneway RPC call from client to server with no response.
     */
    MessageType: {
        'CALL' : 1,
        'REPLY' : 2,
        'EXCEPTION' : 3,
        'ONEWAY' : 4
    },

    /**
     * Utility function returning the count of an object's own properties.
     * @param {object} obj - Object to test.
     * @returns {number} number of object's own properties
     */
    objectLength: function(obj) {
        var length = 0;
        for (var k in obj) {
            if (obj.hasOwnProperty(k)) {
                length++;
            }
        }
        return length;
    },

    /**
     * Utility function to establish prototype inheritance.
     * @see {@link http://javascript.crockford.com/prototypal.html|Prototypal Inheritance}
     * @param {function} constructor - Contstructor function to set as derived.
     * @param {function} superConstructor - Contstructor function to set as base.
     * @param {string} [name] - Type name to set as name property in derived prototype.
     */
    inherits: function(constructor, superConstructor, name) {
      function F() {}
      F.prototype = superConstructor.prototype;
      constructor.prototype = new F();
      constructor.prototype.name = name || "";
    }
};

/**
 * Initializes a Thrift TException instance.
 * @constructor
 * @augments Error
 * @param {string} message - The TException message (distinct from the Error message).
 * @classdesc TException is the base class for all Thrift exceptions types.
 */
Thrift.TException = function(message) {
    this.message = message;
};
Thrift.inherits(Thrift.TException, Error, 'TException');

/**
 * Returns the message set on the exception.
 * @readonly
 * @returns {string} exception message
 */
Thrift.TException.prototype.getMessage = function() {
    return this.message;
};

/**
 * Thrift Application Exception type string to Id mapping.
 * @readonly
 * @property {number}  UNKNOWN                 - Unknown/undefined.
 * @property {number}  UNKNOWN_METHOD          - Client attempted to call a method unknown to the server.
 * @property {number}  INVALID_MESSAGE_TYPE    - Client passed an unknown/unsupported MessageType.
 * @property {number}  WRONG_METHOD_NAME       - Unused.
 * @property {number}  BAD_SEQUENCE_ID         - Unused in Thrift RPC, used to flag proprietary sequence number errors.
 * @property {number}  MISSING_RESULT          - Raised by a server processor if a handler fails to supply the required return result.
 * @property {number}  INTERNAL_ERROR          - Something bad happened.
 * @property {number}  PROTOCOL_ERROR          - The protocol layer failed to serialize or deserialize data.
 * @property {number}  INVALID_TRANSFORM       - Unused.
 * @property {number}  INVALID_PROTOCOL        - The protocol (or version) is not supported.
 * @property {number}  UNSUPPORTED_CLIENT_TYPE - Unused.
 */
Thrift.TApplicationExceptionType = {
    'UNKNOWN' : 0,
    'UNKNOWN_METHOD' : 1,
    'INVALID_MESSAGE_TYPE' : 2,
    'WRONG_METHOD_NAME' : 3,
    'BAD_SEQUENCE_ID' : 4,
    'MISSING_RESULT' : 5,
    'INTERNAL_ERROR' : 6,
    'PROTOCOL_ERROR' : 7,
    'INVALID_TRANSFORM' : 8,
    'INVALID_PROTOCOL' : 9,
    'UNSUPPORTED_CLIENT_TYPE' : 10
};

/**
 * Initializes a Thrift TApplicationException instance.
 * @constructor
 * @augments Thrift.TException
 * @param {string} message - The TApplicationException message (distinct from the Error message).
 * @param {Thrift.TApplicationExceptionType} [code] - The TApplicationExceptionType code.
 * @classdesc TApplicationException is the exception class used to propagate exceptions from an RPC server back to a calling client.
*/
Thrift.TApplicationException = function(message, code) {
    this.message = message;
    this.code = typeof code === "number" ? code : 0;
};
Thrift.inherits(Thrift.TApplicationException, Thrift.TException, 'TApplicationException');

/**
 * Read a TApplicationException from the supplied protocol.
 * @param {object} input - The input protocol to read from.
 */
Thrift.TApplicationException.prototype.read = function(input) {
    while (1) {
        var ret = input.readFieldBegin();

        if (ret.ftype == Thrift.Type.STOP) {
            break;
        }

        var fid = ret.fid;

        switch (fid) {
            case 1:
                if (ret.ftype == Thrift.Type.STRING) {
                    ret = input.readString();
                    this.message = ret.value;
                } else {
                    ret = input.skip(ret.ftype);
                }
                break;
            case 2:
                if (ret.ftype == Thrift.Type.I32) {
                    ret = input.readI32();
                    this.code = ret.value;
                } else {
                    ret = input.skip(ret.ftype);
                }
                break;
           default:
                ret = input.skip(ret.ftype);
                break;
        }

        input.readFieldEnd();
    }

    input.readStructEnd();
};

/**
 * Wite a TApplicationException to the supplied protocol.
 * @param {object} output - The output protocol to write to.
 */
Thrift.TApplicationException.prototype.write = function(output) {
    output.writeStructBegin('TApplicationException');

    if (this.message) {
        output.writeFieldBegin('message', Thrift.Type.STRING, 1);
        output.writeString(this.getMessage());
        output.writeFieldEnd();
    }

    if (this.code) {
        output.writeFieldBegin('type', Thrift.Type.I32, 2);
        output.writeI32(this.code);
        output.writeFieldEnd();
    }

    output.writeFieldStop();
    output.writeStructEnd();
};

/**
 * Returns the application exception code set on the exception.
 * @readonly
 * @returns {Thrift.TApplicationExceptionType} exception code
 */
Thrift.TApplicationException.prototype.getCode = function() {
    return this.code;
};

/**
 * Constructor Function for the XHR transport.
 * If you do not specify a url then you must handle XHR operations on
 * your own. This type can also be constructed using the Transport alias
 * for backward compatibility.
 * @constructor
 * @param {string} [url] - The URL to connect to.
 * @classdesc The Apache Thrift Transport layer performs byte level I/O 
 * between RPC clients and servers. The JavaScript TXHRTransport object 
 * uses Http[s]/XHR. Target servers must implement the http[s] transport
 * (see: node.js example server_http.js).
 * @example
 *     var transport = new Thrift.TXHRTransport("http://localhost:8585");
 */
Thrift.Transport = Thrift.TXHRTransport = function(url, options) {
    this.url = url;
    this.wpos = 0;
    this.rpos = 0;
    this.useCORS = (options && options.useCORS);
    this.send_buf = '';
    this.recv_buf = '';
};

Thrift.TXHRTransport.prototype = {
    /**
     * Gets the browser specific XmlHttpRequest Object.
     * @returns {object} the browser XHR interface object
     */
    getXmlHttpRequestObject: function() {
        try { return new XMLHttpRequest(); } catch (e1) { }
        try { return new ActiveXObject('Msxml2.XMLHTTP'); } catch (e2) { }
        try { return new ActiveXObject('Microsoft.XMLHTTP'); } catch (e3) { }

        throw "Your browser doesn't support XHR.";
    },

    /**
     * Sends the current XRH request if the transport was created with a URL 
     * and the async parameter is false. If the transport was not created with
     * a URL, or the async parameter is True and no callback is provided, or 
     * the URL is an empty string, the current send buffer is returned.
     * @param {object} async - If true the current send buffer is returned.
     * @param {object} callback - Optional async completion callback 
     * @returns {undefined|string} Nothing or the current send buffer.
     * @throws {string} If XHR fails.
     */
    flush: function(async, callback) {
        var self = this;
        if ((async && !callback) || this.url === undefined || this.url === '') {
            return this.send_buf;
        }

        var xreq = this.getXmlHttpRequestObject();

        if (xreq.overrideMimeType) {
            xreq.overrideMimeType('application/vnd.apache.thrift.json; charset=utf-8');
        }

        if (callback) {
            //Ignore XHR callbacks until the data arrives, then call the
            //  client's callback
            xreq.onreadystatechange = 
              (function() {
                var clientCallback = callback;    
                return function() {
                  if (this.readyState == 4 && this.status == 200) {
                    self.setRecvBuffer(this.responseText);
                    clientCallback();
                  }
                };
              }());
        }

        xreq.open('POST', this.url, !!async);

        if (xreq.setRequestHeader) {
            xreq.setRequestHeader('Accept', 'application/vnd.apache.thrift.json; charset=utf-8');
            xreq.setRequestHeader('Content-Type', 'application/vnd.apache.thrift.json; charset=utf-8');
        }

        xreq.send(this.send_buf);
        if (async && callback) {
            return;
        }

        if (xreq.readyState != 4) {
            throw 'encountered an unknown ajax ready state: ' + xreq.readyState;
        }

        if (xreq.status != 200) {
            throw 'encountered a unknown request status: ' + xreq.status;
        }

        this.recv_buf = xreq.responseText;
        this.recv_buf_sz = this.recv_buf.length;
        this.wpos = this.recv_buf.length;
        this.rpos = 0;
    },

    /**
     * Creates a jQuery XHR object to be used for a Thrift server call.
     * @param {object} client - The Thrift Service client object generated by the IDL compiler.
     * @param {object} postData - The message to send to the server.
     * @param {function} args - The original call arguments with the success call back at the end.
     * @param {function} recv_method - The Thrift Service Client receive method for the call.
     * @returns {object} A new jQuery XHR object.
     * @throws {string} If the jQuery version is prior to 1.5 or if jQuery is not found.
     */
    jqRequest: function(client, postData, args, recv_method) {
        if (typeof jQuery === 'undefined' ||
            typeof jQuery.Deferred === 'undefined') {
            throw 'Thrift.js requires jQuery 1.5+ to use asynchronous requests';
        }

        var thriftTransport = this;

        var jqXHR = jQuery.ajax({
            url: this.url,
            data: postData,
            type: 'POST',
            cache: false,
            contentType: 'application/vnd.apache.thrift.json; charset=utf-8',
            dataType: 'text thrift',
            converters: {
                'text thrift' : function(responseData) {
                    thriftTransport.setRecvBuffer(responseData);
                    var value = recv_method.call(client);
                    return value;
                }
            },
            context: client,
            success: jQuery.makeArray(args).pop()
        });

        return jqXHR;
    },

    /**
     * Sets the buffer to provide the protocol when deserializing.
     * @param {string} buf - The buffer to supply the protocol.
     */
    setRecvBuffer: function(buf) {
        this.recv_buf = buf;
        this.recv_buf_sz = this.recv_buf.length;
        this.wpos = this.recv_buf.length;
        this.rpos = 0;
    },

    /**
     * Returns true if the transport is open, XHR always returns true.
     * @readonly
     * @returns {boolean} Always True.
     */    
    isOpen: function() {
        return true;
    },

    /**
     * Opens the transport connection, with XHR this is a nop.
     */    
    open: function() {},

    /**
     * Closes the transport connection, with XHR this is a nop.
     */    
    close: function() {},

    /**
     * Returns the specified number of characters from the response
     * buffer.
     * @param {number} len - The number of characters to return.
     * @returns {string} Characters sent by the server.
     */
    read: function(len) {
        var avail = this.wpos - this.rpos;

        if (avail === 0) {
            return '';
        }

        var give = len;

        if (avail < len) {
            give = avail;
        }

        var ret = this.read_buf.substr(this.rpos, give);
        this.rpos += give;

        //clear buf when complete?
        return ret;
    },

    /**
     * Returns the entire response buffer.
     * @returns {string} Characters sent by the server.
     */
    readAll: function() {
        return this.recv_buf;
    },

    /**
     * Sets the send buffer to buf.
     * @param {string} buf - The buffer to send.
     */    
    write: function(buf) {
        this.send_buf = buf;
    },

    /**
     * Returns the send buffer.
     * @readonly
     * @returns {string} The send buffer.
     */ 
    getSendBuffer: function() {
        return this.send_buf;
    }

};


/**
 * Constructor Function for the WebSocket transport.
 * @constructor
 * @param {string} [url] - The URL to connect to.
 * @classdesc The Apache Thrift Transport layer performs byte level I/O 
 * between RPC clients and servers. The JavaScript TWebSocketTransport object 
 * uses the WebSocket protocol. Target servers must implement WebSocket.
 * (see: node.js example server_http.js).
 * @example
 *   var transport = new Thrift.TWebSocketTransport("http://localhost:8585");
 */
Thrift.TWebSocketTransport = function(url) {
    this.__reset(url);
};

Thrift.TWebSocketTransport.prototype = {
    __reset: function(url) {
      this.url = url;             //Where to connect
      this.socket = null;         //The web socket
      this.callbacks = [];        //Pending callbacks
      this.send_pending = [];     //Buffers/Callback pairs waiting to be sent
      this.send_buf = '';         //Outbound data, immutable until sent
      this.recv_buf = '';         //Inbound data
      this.rb_wpos = 0;           //Network write position in receive buffer
      this.rb_rpos = 0;           //Client read position in receive buffer
    },

    /**
     * Sends the current WS request and registers callback. The async 
     * parameter is ignored (WS flush is always async) and the callback 
     * function parameter is required.
     * @param {object} async - Ignored.
     * @param {object} callback - The client completion callback.
     * @returns {undefined|string} Nothing (undefined) 
     */
    flush: function(async, callback) {
      var self = this;
      if (this.isOpen()) {
        //Send data and register a callback to invoke the client callback
        this.socket.send(this.send_buf); 
        this.callbacks.push((function() {
          var clientCallback = callback;    
          return function(msg) {
            self.setRecvBuffer(msg);
            clientCallback();
          };
        }()));
      } else {
        //Queue the send to go out __onOpen
        this.send_pending.push({
          buf: this.send_buf,
          cb:  callback
        });
      }
    },

    __onOpen: function() { 
       var self = this;
       if (this.send_pending.length > 0) {
          //If the user made calls before the connection was fully 
          //open, send them now
          this.send_pending.forEach(function(elem) {
             this.socket.send(elem.buf);
             this.callbacks.push((function() {
               var clientCallback = elem.cb;    
               return function(msg) {
                  self.setRecvBuffer(msg);
                  clientCallback();
               };
             }()));
          });
          this.send_pending = [];
       }
    },
    
    __onClose: function(evt) { 
      this.__reset(this.url);
    },
     
    __onMessage: function(evt) {
      if (this.callbacks.length) {
        this.callbacks.shift()(evt.data);
      }
    },
     
    __onError: function(evt) { 
      console.log("Thrift WebSocket Error: " + evt.toString());
      this.socket.close();
    },

    /**
     * Sets the buffer to use when receiving server responses.
     * @param {string} buf - The buffer to receive server responses.
     */
    setRecvBuffer: function(buf) {
        this.recv_buf = buf;
        this.recv_buf_sz = this.recv_buf.length;
        this.wpos = this.recv_buf.length;
        this.rpos = 0;
    },

    /**
     * Returns true if the transport is open
     * @readonly
     * @returns {boolean} 
     */    
    isOpen: function() {
        return this.socket && this.socket.readyState == this.socket.OPEN;
    },

    /**
     * Opens the transport connection
     */    
    open: function() {
      //If OPEN/CONNECTING/CLOSING ignore additional opens
      if (this.socket && this.socket.readyState != this.socket.CLOSED) {
        return;
      }
      //If there is no socket or the socket is closed:
      this.socket = new WebSocket(this.url);
      this.socket.onopen = this.__onOpen.bind(this); 
      this.socket.onmessage = this.__onMessage.bind(this); 
      this.socket.onerror = this.__onError.bind(this); 
      this.socket.onclose = this.__onClose.bind(this); 
    },

    /**
     * Closes the transport connection
     */    
    close: function() {
      this.socket.close();
    },

    /**
     * Returns the specified number of characters from the response
     * buffer.
     * @param {number} len - The number of characters to return.
     * @returns {string} Characters sent by the server.
     */
    read: function(len) {
        var avail = this.wpos - this.rpos;

        if (avail === 0) {
            return '';
        }

        var give = len;

        if (avail < len) {
            give = avail;
        }

        var ret = this.read_buf.substr(this.rpos, give);
        this.rpos += give;

        //clear buf when complete?
        return ret;
    },

    /**
     * Returns the entire response buffer.
     * @returns {string} Characters sent by the server.
     */
    readAll: function() {
        return this.recv_buf;
    },

    /**
     * Sets the send buffer to buf.
     * @param {string} buf - The buffer to send.
     */    
    write: function(buf) {
        this.send_buf = buf;
    },

    /**
     * Returns the send buffer.
     * @readonly
     * @returns {string} The send buffer.
     */ 
    getSendBuffer: function() {
        return this.send_buf;
    }

};

/**
 * Initializes a Thrift JSON protocol instance.
 * @constructor
 * @param {Thrift.Transport} transport - The transport to serialize to/from.
 * @classdesc Apache Thrift Protocols perform serialization which enables cross 
 * language RPC. The Protocol type is the JavaScript browser implementation 
 * of the Apache Thrift TJSONProtocol.
 * @example
 *     var protocol  = new Thrift.Protocol(transport);
 */
Thrift.TJSONProtocol = Thrift.Protocol = function(transport) {
    this.tstack = [];
    this.tpos = [];
    this.transport = transport;
};

/**
 * Thrift IDL type Id to string mapping.
 * @readonly
 * @see {@link Thrift.Type}
 */
Thrift.Protocol.Type = {};
Thrift.Protocol.Type[Thrift.Type.BOOL] = '"tf"';
Thrift.Protocol.Type[Thrift.Type.BYTE] = '"i8"';
Thrift.Protocol.Type[Thrift.Type.I16] = '"i16"';
Thrift.Protocol.Type[Thrift.Type.I32] = '"i32"';
Thrift.Protocol.Type[Thrift.Type.I64] = '"i64"';
Thrift.Protocol.Type[Thrift.Type.DOUBLE] = '"dbl"';
Thrift.Protocol.Type[Thrift.Type.STRUCT] = '"rec"';
Thrift.Protocol.Type[Thrift.Type.STRING] = '"str"';
Thrift.Protocol.Type[Thrift.Type.MAP] = '"map"';
Thrift.Protocol.Type[Thrift.Type.LIST] = '"lst"';
Thrift.Protocol.Type[Thrift.Type.SET] = '"set"';

/**
 * Thrift IDL type string to Id mapping.
 * @readonly
 * @see {@link Thrift.Type}
 */
Thrift.Protocol.RType = {};
Thrift.Protocol.RType.tf = Thrift.Type.BOOL;
Thrift.Protocol.RType.i8 = Thrift.Type.BYTE;
Thrift.Protocol.RType.i16 = Thrift.Type.I16;
Thrift.Protocol.RType.i32 = Thrift.Type.I32;
Thrift.Protocol.RType.i64 = Thrift.Type.I64;
Thrift.Protocol.RType.dbl = Thrift.Type.DOUBLE;
Thrift.Protocol.RType.rec = Thrift.Type.STRUCT;
Thrift.Protocol.RType.str = Thrift.Type.STRING;
Thrift.Protocol.RType.map = Thrift.Type.MAP;
Thrift.Protocol.RType.lst = Thrift.Type.LIST;
Thrift.Protocol.RType.set = Thrift.Type.SET;

/**
 * The TJSONProtocol version number.
 * @readonly
 * @const {number} Version
 * @memberof Thrift.Protocol
 */
 Thrift.Protocol.Version = 1;

Thrift.Protocol.prototype = {
    /**
     * Returns the underlying transport.
     * @readonly
     * @returns {Thrift.Transport} The underlying transport.
     */ 
    getTransport: function() {
        return this.transport;
    },

    /**
     * Serializes the beginning of a Thrift RPC message.
     * @param {string} name - The service method to call.
     * @param {Thrift.MessageType} messageType - The type of method call.
     * @param {number} seqid - The sequence number of this call (always 0 in Apache Thrift).
     */
    writeMessageBegin: function(name, messageType, seqid) {
        this.tstack = [];
        this.tpos = [];

        this.tstack.push([Thrift.Protocol.Version, '"' +
            name + '"', messageType, seqid]);
    },

    /**
     * Serializes the end of a Thrift RPC message.
     */
    writeMessageEnd: function() {
        var obj = this.tstack.pop();

        this.wobj = this.tstack.pop();
        this.wobj.push(obj);

        this.wbuf = '[' + this.wobj.join(',') + ']';

        this.transport.write(this.wbuf);
     },


    /**
     * Serializes the beginning of a struct.
     * @param {string} name - The name of the struct.
     */
    writeStructBegin: function(name) {
        this.tpos.push(this.tstack.length);
        this.tstack.push({});
    },

    /**
     * Serializes the end of a struct.
     */
    writeStructEnd: function() {

        var p = this.tpos.pop();
        var struct = this.tstack[p];
        var str = '{';
        var first = true;
        for (var key in struct) {
            if (first) {
                first = false;
            } else {
                str += ',';
            }

            str += key + ':' + struct[key];
        }

        str += '}';
        this.tstack[p] = str;
    },

    /**
     * Serializes the beginning of a struct field.
     * @param {string} name - The name of the field.
     * @param {Thrift.Protocol.Type} fieldType - The data type of the field.
     * @param {number} fieldId - The field's unique identifier.
     */
    writeFieldBegin: function(name, fieldType, fieldId) {
        this.tpos.push(this.tstack.length);
        this.tstack.push({ 'fieldId': '"' +
            fieldId + '"', 'fieldType': Thrift.Protocol.Type[fieldType]
        });

    },

    /**
     * Serializes the end of a field.
     */
    writeFieldEnd: function() {
        var value = this.tstack.pop();
        var fieldInfo = this.tstack.pop();

        this.tstack[this.tstack.length - 1][fieldInfo.fieldId] = '{' +
            fieldInfo.fieldType + ':' + value + '}';
        this.tpos.pop();
    },

    /**
     * Serializes the end of the set of fields for a struct.
     */
    writeFieldStop: function() {
        //na
    },

    /**
     * Serializes the beginning of a map collection.
     * @param {Thrift.Type} keyType - The data type of the key.
     * @param {Thrift.Type} valType - The data type of the value.
     * @param {number} [size] - The number of elements in the map (ignored).
     */
    writeMapBegin: function(keyType, valType, size) {
        this.tpos.push(this.tstack.length);
        this.tstack.push([Thrift.Protocol.Type[keyType],
            Thrift.Protocol.Type[valType], 0]);
    },

    /**
     * Serializes the end of a map.
     */
    writeMapEnd: function() {
        var p = this.tpos.pop();

        if (p == this.tstack.length) {
            return;
        }

        if ((this.tstack.length - p - 1) % 2 !== 0) {
            this.tstack.push('');
        }

        var size = (this.tstack.length - p - 1) / 2;

        this.tstack[p][this.tstack[p].length - 1] = size;

        var map = '}';
        var first = true;
        while (this.tstack.length > p + 1) {
            var v = this.tstack.pop();
            var k = this.tstack.pop();
            if (first) {
                first = false;
            } else {
                map = ',' + map;
            }

            if (! isNaN(k)) { k = '"' + k + '"'; } //json "keys" need to be strings
            map = k + ':' + v + map;
        }
        map = '{' + map;

        this.tstack[p].push(map);
        this.tstack[p] = '[' + this.tstack[p].join(',') + ']';
    },

    /**
     * Serializes the beginning of a list collection.
     * @param {Thrift.Type} elemType - The data type of the elements.
     * @param {number} size - The number of elements in the list.
     */
    writeListBegin: function(elemType, size) {
        this.tpos.push(this.tstack.length);
        this.tstack.push([Thrift.Protocol.Type[elemType], size]);
    },

    /**
     * Serializes the end of a list.
     */
    writeListEnd: function() {
        var p = this.tpos.pop();

        while (this.tstack.length > p + 1) {
            var tmpVal = this.tstack[p + 1];
            this.tstack.splice(p + 1, 1);
            this.tstack[p].push(tmpVal);
        }

        this.tstack[p] = '[' + this.tstack[p].join(',') + ']';
    },

    /**
     * Serializes the beginning of a set collection.
     * @param {Thrift.Type} elemType - The data type of the elements.
     * @param {number} size - The number of elements in the list.
     */
    writeSetBegin: function(elemType, size) {
        this.tpos.push(this.tstack.length);
        this.tstack.push([Thrift.Protocol.Type[elemType], size]);
    },

    /**
     * Serializes the end of a set.
     */
    writeSetEnd: function() {
        var p = this.tpos.pop();

        while (this.tstack.length > p + 1) {
            var tmpVal = this.tstack[p + 1];
            this.tstack.splice(p + 1, 1);
            this.tstack[p].push(tmpVal);
        }

        this.tstack[p] = '[' + this.tstack[p].join(',') + ']';
    },

    /** Serializes a boolean */
    writeBool: function(value) {
        this.tstack.push(value ? 1 : 0);
    },

    /** Serializes a number */
    writeByte: function(i8) {
        this.tstack.push(i8);
    },

    /** Serializes a number */
    writeI16: function(i16) {
        this.tstack.push(i16);
    },

    /** Serializes a number */
    writeI32: function(i32) {
        this.tstack.push(i32);
    },

    /** Serializes a number */
    writeI64: function(i64) {
        this.tstack.push(i64);
    },

    /** Serializes a number */
    writeDouble: function(dbl) {
        this.tstack.push(dbl);
    },

    /** Serializes a string */
    writeString: function(str) {
        // We do not encode uri components for wire transfer:
        if (str === null) {
            this.tstack.push(null);
        } else {
            // concat may be slower than building a byte buffer
            var escapedString = '';
            for (var i = 0; i < str.length; i++) {
                var ch = str.charAt(i);      // a single double quote: "
                if (ch === '\"') {
                    escapedString += '\\\"'; // write out as: \"
                } else if (ch === '\\') {    // a single backslash
                    escapedString += '\\\\'; // write out as double backslash 
                } else if (ch === '\b') {    // a single backspace: invisible
                    escapedString += '\\b';  // write out as: \b"
                } else if (ch === '\f') {    // a single formfeed: invisible
                    escapedString += '\\f';  // write out as: \f"
                } else if (ch === '\n') {    // a single newline: invisible
                    escapedString += '\\n';  // write out as: \n"
                } else if (ch === '\r') {    // a single return: invisible
                    escapedString += '\\r';  // write out as: \r"
                } else if (ch === '\t') {    // a single tab: invisible
                    escapedString += '\\t';  // write out as: \t"
                } else {
                    escapedString += ch;     // Else it need not be escaped
                }
            }
            this.tstack.push('"' + escapedString + '"');
        }
    },

    /** Serializes a string */
    writeBinary: function(str) {
        this.writeString(str);
    },

    /**
       @class
       @name AnonReadMessageBeginReturn
       @property {string} fname - The name of the service method.
       @property {Thrift.MessageType} mtype - The type of message call.
       @property {number} rseqid - The sequence number of the message (0 in Thrift RPC).
     */
    /** 
     * Deserializes the beginning of a message. 
     * @returns {AnonReadMessageBeginReturn}
     */
    readMessageBegin: function() {
        this.rstack = [];
        this.rpos = [];

        if (typeof JSON !== 'undefined' && typeof JSON.parse === 'function') {
            this.robj = JSON.parse(this.transport.readAll());
        } else if (typeof jQuery !== 'undefined') {
            this.robj = jQuery.parseJSON(this.transport.readAll());
        } else {
            this.robj = eval(this.transport.readAll());
        }

        var r = {};
        var version = this.robj.shift();

        if (version != Thrift.Protocol.Version) {
            throw 'Wrong thrift protocol version: ' + version;
        }

        r.fname = this.robj.shift();
        r.mtype = this.robj.shift();
        r.rseqid = this.robj.shift();


        //get to the main obj
        this.rstack.push(this.robj.shift());

        return r;
    },

    /** Deserializes the end of a message. */
    readMessageEnd: function() {
    },

    /** 
     * Deserializes the beginning of a struct. 
     * @param {string} [name] - The name of the struct (ignored)
     * @returns {object} - An object with an empty string fname property
     */    
    readStructBegin: function(name) {
        var r = {};
        r.fname = '';

        //incase this is an array of structs
        if (this.rstack[this.rstack.length - 1] instanceof Array) {
            this.rstack.push(this.rstack[this.rstack.length - 1].shift());
        }

        return r;
    },

    /** Deserializes the end of a struct. */
    readStructEnd: function() {
        if (this.rstack[this.rstack.length - 2] instanceof Array) {
            this.rstack.pop();
        }
    },

    /**
       @class
       @name AnonReadFieldBeginReturn
       @property {string} fname - The name of the field (always '').
       @property {Thrift.Type} ftype - The data type of the field.
       @property {number} fid - The unique identifier of the field.
     */
    /** 
     * Deserializes the beginning of a field. 
     * @returns {AnonReadFieldBeginReturn}
     */
    readFieldBegin: function() {
        var r = {};

        var fid = -1;
        var ftype = Thrift.Type.STOP;

        //get a fieldId
        for (var f in (this.rstack[this.rstack.length - 1])) {
            if (f === null) {
              continue;
            }

            fid = parseInt(f, 10);
            this.rpos.push(this.rstack.length);

            var field = this.rstack[this.rstack.length - 1][fid];

            //remove so we don't see it again
            delete this.rstack[this.rstack.length - 1][fid];

            this.rstack.push(field);

            break;
        }

        if (fid != -1) {

            //should only be 1 of these but this is the only
            //way to match a key
            for (var i in (this.rstack[this.rstack.length - 1])) {
                if (Thrift.Protocol.RType[i] === null) {
                    continue;
                }

                ftype = Thrift.Protocol.RType[i];
                this.rstack[this.rstack.length - 1] =
                    this.rstack[this.rstack.length - 1][i];
            }
        }

        r.fname = '';
        r.ftype = ftype;
        r.fid = fid;

        return r;
    },

    /** Deserializes the end of a field. */
    readFieldEnd: function() {
        var pos = this.rpos.pop();

        //get back to the right place in the stack
        while (this.rstack.length > pos) {
            this.rstack.pop();
        }

    },

    /**
       @class
       @name AnonReadMapBeginReturn
       @property {Thrift.Type} ktype - The data type of the key.
       @property {Thrift.Type} vtype - The data type of the value.
       @property {number} size - The number of elements in the map.
     */
    /** 
     * Deserializes the beginning of a map. 
     * @returns {AnonReadMapBeginReturn}
     */
    readMapBegin: function() {
        var map = this.rstack.pop();
        var first = map.shift();
        if (first instanceof Array) {
          this.rstack.push(map);
          map = first;
          first = map.shift();
        }

        var r = {};
        r.ktype = Thrift.Protocol.RType[first];
        r.vtype = Thrift.Protocol.RType[map.shift()];
        r.size = map.shift();


        this.rpos.push(this.rstack.length);
        this.rstack.push(map.shift());

        return r;
    },

    /** Deserializes the end of a map. */
    readMapEnd: function() {
        this.readFieldEnd();
    },

    /**
       @class
       @name AnonReadColBeginReturn
       @property {Thrift.Type} etype - The data type of the element.
       @property {number} size - The number of elements in the collection.
     */
    /** 
     * Deserializes the beginning of a list. 
     * @returns {AnonReadColBeginReturn}
     */
    readListBegin: function() {
        var list = this.rstack[this.rstack.length - 1];

        var r = {};
        r.etype = Thrift.Protocol.RType[list.shift()];
        r.size = list.shift();

        this.rpos.push(this.rstack.length);
        this.rstack.push(list.shift());

        return r;
    },

    /** Deserializes the end of a list. */
    readListEnd: function() {
        this.readFieldEnd();
    },

    /** 
     * Deserializes the beginning of a set. 
     * @returns {AnonReadColBeginReturn}
     */
    readSetBegin: function(elemType, size) {
        return this.readListBegin(elemType, size);
    },

    /** Deserializes the end of a set. */
    readSetEnd: function() {
        return this.readListEnd();
    },

    /** Returns an object with a value property set to 
     *  False unless the next number in the protocol buffer 
     *  is 1, in which case the value property is True */
    readBool: function() {
        var r = this.readI32();

        if (r !== null && r.value == '1') {
            r.value = true;
        } else {
            r.value = false;
        }

        return r;
    },

    /** Returns the an object with a value property set to the 
        next value found in the protocol buffer */
    readByte: function() {
        return this.readI32();
    },

    /** Returns the an object with a value property set to the 
        next value found in the protocol buffer */
    readI16: function() {
        return this.readI32();
    },

    /** Returns the an object with a value property set to the 
        next value found in the protocol buffer */
    readI32: function(f) {
        if (f === undefined) {
            f = this.rstack[this.rstack.length - 1];
        }

        var r = {};

        if (f instanceof Array) {
            if (f.length === 0) {
                r.value = undefined;
            } else {
                r.value = f.shift();
            }
        } else if (f instanceof Object) {
           for (var i in f) {
                if (i === null) {
                  continue;
                }
                this.rstack.push(f[i]);
                delete f[i];

                r.value = i;
                break;
           }
        } else {
            r.value = f;
            this.rstack.pop();
        }

        return r;
    },

    /** Returns the an object with a value property set to the 
        next value found in the protocol buffer */
    readI64: function() {
        return this.readI32();
    },

    /** Returns the an object with a value property set to the 
        next value found in the protocol buffer */
    readDouble: function() {
        return this.readI32();
    },

    /** Returns the an object with a value property set to the 
        next value found in the protocol buffer */
    readString: function() {
        var r = this.readI32();
        return r;
    },

    /** Returns the an object with a value property set to the 
        next value found in the protocol buffer */
    readBinary: function() {
        return this.readString();
    },

    /** 
     * Method to arbitrarily skip over data */
    skip: function(type) {
        var ret, i;
        switch (type) {
            case Thrift.Type.STOP:
                return null;

            case Thrift.Type.BOOL:
                return this.readBool();

            case Thrift.Type.BYTE:
                return this.readByte();

            case Thrift.Type.I16:
                return this.readI16();

            case Thrift.Type.I32:
                return this.readI32();

            case Thrift.Type.I64:
                return this.readI64();

            case Thrift.Type.DOUBLE:
                return this.readDouble();

            case Thrift.Type.STRING:
                return this.readString();

            case Thrift.Type.STRUCT:
                this.readStructBegin();
                while (true) {
                    ret = this.readFieldBegin();
                    if (ret.ftype == Thrift.Type.STOP) {
                        break;
                    }
                    this.skip(ret.ftype);
                    this.readFieldEnd();
                }
                this.readStructEnd();
                return null;

            case Thrift.Type.MAP:
                ret = this.readMapBegin();
                for (i = 0; i < ret.size; i++) {
                    if (i > 0) {
                        if (this.rstack.length > this.rpos[this.rpos.length - 1] + 1) {
                            this.rstack.pop();
                        }
                    }
                    this.skip(ret.ktype);
                    this.skip(ret.vtype);
                }
                this.readMapEnd();
                return null;

            case Thrift.Type.SET:
                ret = this.readSetBegin();
                for (i = 0; i < ret.size; i++) {
                    this.skip(ret.etype);
                }
                this.readSetEnd();
                return null;

            case Thrift.Type.LIST:
                ret = this.readListBegin();
                for (i = 0; i < ret.size; i++) {
                    this.skip(ret.etype);
                }
                this.readListEnd();
                return null;
        }
    }
};


/**
 * Initializes a MutilplexProtocol Implementation as a Wrapper for Thrift.Protocol
 * @constructor
 */
Thrift.MultiplexProtocol = function (srvName, trans, strictRead, strictWrite) {
    Thrift.Protocol.call(this, trans, strictRead, strictWrite);
    this.serviceName = srvName;
};
Thrift.inherits(Thrift.MultiplexProtocol, Thrift.Protocol, 'multiplexProtocol');

/** Override writeMessageBegin method of prototype*/
Thrift.MultiplexProtocol.prototype.writeMessageBegin = function (name, type, seqid) {

    if (type === Thrift.MessageType.CALL || type === Thrift.MessageType.ONEWAY) {
        Thrift.Protocol.prototype.writeMessageBegin.call(this, this.serviceName + ":" + name, type, seqid);
    } else {
        Thrift.Protocol.prototype.writeMessageBegin.call(this, name, type, seqid);
    }
};

Thrift.Multiplexer = function () {
    this.seqid = 0;
};

/** Instantiates a multiplexed client for a specific service
 * @constructor
 * @param {String} serviceName - The transport to serialize to/from.
 * @param {Thrift.ServiceClient} SCl - The Service Client Class
 * @param {Thrift.Transport} transport - Thrift.Transport instance which provides remote host:port
 * @example
 *    var mp = new Thrift.Multiplexer();
 *    var transport = new Thrift.Transport("http://localhost:9090/foo.thrift");
 *    var protocol = new Thrift.Protocol(transport);
 *    var client = mp.createClient('AuthService', AuthServiceClient, transport);
*/
Thrift.Multiplexer.prototype.createClient = function (serviceName, SCl, transport) {
    if (SCl.Client) {
        SCl = SCl.Client;
    }
    var self = this;
    SCl.prototype.new_seqid = function () {
        self.seqid += 1;
        return self.seqid;
    };
    var client = new SCl(new Thrift.MultiplexProtocol(serviceName, transport));

    return client;
};



var copyList, copyMap;

copyList = function(lst, types) {

  if (!lst) {return lst; }

  var type;

  if (types.shift === undefined) {
    type = types;
  }
  else {
    type = types[0];
  }
  var Type = type;

  var len = lst.length, result = [], i, val;
  for (i = 0; i < len; i++) {
    val = lst[i];
    if (type === null) {
      result.push(val);
    }
    else if (type === copyMap || type === copyList) {
      result.push(type(val, types.slice(1)));
    }
    else {
      result.push(new Type(val));
    }
  }
  return result;
};

copyMap = function(obj, types){

  if (!obj) {return obj; }

  var type;

  if (types.shift === undefined) {
    type = types;
  }
  else {
    type = types[0];
  }
  var Type = type;

  var result = {}, val;
  for(var prop in obj) {
    if(obj.hasOwnProperty(prop)) {
      val = obj[prop];
      if (type === null) {
        result[prop] = val;
      }
      else if (type === copyMap || type === copyList) {
        result[prop] = type(val, types.slice(1));
      }
      else {
        result[prop] = new Type(val);
      }
    }
  }
  return result;
};

Thrift.copyMap = copyMap;
Thrift.copyList = copyList;

if (true) {
    module.exports = Thrift
}


/***/ }),

/***/ "../../../node_modules/bytebuffer/dist/ByteBufferAB.js":
/*!******************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/node_modules/bytebuffer/dist/ByteBufferAB.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
 Copyright 2013-2014 Daniel Wirtz <dcode@dcode.io>

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
 */

/**
 * @license ByteBuffer.js (c) 2015 Daniel Wirtz <dcode@dcode.io>
 * [BUILD] ByteBufferAB - Backing buffer: ArrayBuffer, Accessor: Uint8Array
 * Released under the Apache License, Version 2.0
 * see: https://github.com/dcodeIO/ByteBuffer.js for details
 */
(function(global, factory) {

    /* AMD */ if (true)
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! Long */ "../../../node_modules/long/dist/Long.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    /* CommonJS */ else {}

})(this, function(Long) {
    "use strict";

    /**
     * Constructs a new ByteBuffer.
     * @class The swiss army knife for binary data in JavaScript.
     * @exports ByteBuffer
     * @constructor
     * @param {number=} capacity Initial capacity. Defaults to {@link ByteBuffer.DEFAULT_CAPACITY}.
     * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to
     *  {@link ByteBuffer.DEFAULT_ENDIAN}.
     * @param {boolean=} noAssert Whether to skip assertions of offsets and values. Defaults to
     *  {@link ByteBuffer.DEFAULT_NOASSERT}.
     * @expose
     */
    var ByteBuffer = function(capacity, littleEndian, noAssert) {
        if (typeof capacity === 'undefined')
            capacity = ByteBuffer.DEFAULT_CAPACITY;
        if (typeof littleEndian === 'undefined')
            littleEndian = ByteBuffer.DEFAULT_ENDIAN;
        if (typeof noAssert === 'undefined')
            noAssert = ByteBuffer.DEFAULT_NOASSERT;
        if (!noAssert) {
            capacity = capacity | 0;
            if (capacity < 0)
                throw RangeError("Illegal capacity");
            littleEndian = !!littleEndian;
            noAssert = !!noAssert;
        }

        /**
         * Backing ArrayBuffer.
         * @type {!ArrayBuffer}
         * @expose
         */
        this.buffer = capacity === 0 ? EMPTY_BUFFER : new ArrayBuffer(capacity);

        /**
         * Uint8Array utilized to manipulate the backing buffer. Becomes `null` if the backing buffer has a capacity of `0`.
         * @type {?Uint8Array}
         * @expose
         */
        this.view = capacity === 0 ? null : new Uint8Array(this.buffer);

        /**
         * Absolute read/write offset.
         * @type {number}
         * @expose
         * @see ByteBuffer#flip
         * @see ByteBuffer#clear
         */
        this.offset = 0;

        /**
         * Marked offset.
         * @type {number}
         * @expose
         * @see ByteBuffer#mark
         * @see ByteBuffer#reset
         */
        this.markedOffset = -1;

        /**
         * Absolute limit of the contained data. Set to the backing buffer's capacity upon allocation.
         * @type {number}
         * @expose
         * @see ByteBuffer#flip
         * @see ByteBuffer#clear
         */
        this.limit = capacity;

        /**
         * Whether to use little endian byte order, defaults to `false` for big endian.
         * @type {boolean}
         * @expose
         */
        this.littleEndian = typeof littleEndian !== 'undefined' ? !!littleEndian : false;

        /**
         * Whether to skip assertions of offsets and values, defaults to `false`.
         * @type {boolean}
         * @expose
         */
        this.noAssert = !!noAssert;
    };

    /**
     * ByteBuffer version.
     * @type {string}
     * @const
     * @expose
     */
    ByteBuffer.VERSION = "4.1.0";

    /**
     * Little endian constant that can be used instead of its boolean value. Evaluates to `true`.
     * @type {boolean}
     * @const
     * @expose
     */
    ByteBuffer.LITTLE_ENDIAN = true;

    /**
     * Big endian constant that can be used instead of its boolean value. Evaluates to `false`.
     * @type {boolean}
     * @const
     * @expose
     */
    ByteBuffer.BIG_ENDIAN = false;

    /**
     * Default initial capacity of `16`.
     * @type {number}
     * @expose
     */
    ByteBuffer.DEFAULT_CAPACITY = 16;

    /**
     * Default endianess of `false` for big endian.
     * @type {boolean}
     * @expose
     */
    ByteBuffer.DEFAULT_ENDIAN = ByteBuffer.BIG_ENDIAN;

    /**
     * Default no assertions flag of `false`.
     * @type {boolean}
     * @expose
     */
    ByteBuffer.DEFAULT_NOASSERT = false;

    /**
     * A `Long` class for representing a 64-bit two's-complement integer value. May be `null` if Long.js has not been loaded
     *  and int64 support is not available.
     * @type {?Long}
     * @const
     * @see https://github.com/dcodeIO/Long.js
     * @expose
     */
    ByteBuffer.Long = Long || null;

    /**
     * @alias ByteBuffer.prototype
     * @inner
     */
    var ByteBufferPrototype = ByteBuffer.prototype;

    /**
     * An indicator used to reliably determine if an object is a ByteBuffer or not.
     * @type {boolean}
     * @const
     * @expose
     * @private
     */
    ByteBufferPrototype.__isByteBuffer__;

    Object.defineProperty(ByteBufferPrototype, "__isByteBuffer__", {
        value: true,
        enumerable: false,
        configurable: false
    });

    // helpers

    /**
     * @type {!ArrayBuffer}
     * @inner
     */
    var EMPTY_BUFFER = new ArrayBuffer(0);

    /**
     * String.fromCharCode reference for compile-time renaming.
     * @type {function(...number):string}
     * @inner
     */
    var stringFromCharCode = String.fromCharCode;

    /**
     * Creates a source function for a string.
     * @param {string} s String to read from
     * @returns {function():number|null} Source function returning the next char code respectively `null` if there are
     *  no more characters left.
     * @throws {TypeError} If the argument is invalid
     * @inner
     */
    function stringSource(s) {
        var i=0; return function() {
            return i < s.length ? s.charCodeAt(i++) : null;
        };
    }

    /**
     * Creates a destination function for a string.
     * @returns {function(number=):undefined|string} Destination function successively called with the next char code.
     *  Returns the final string when called without arguments.
     * @inner
     */
    function stringDestination() {
        var cs = [], ps = []; return function() {
            if (arguments.length === 0)
                return ps.join('')+stringFromCharCode.apply(String, cs);
            if (cs.length + arguments.length > 1024)
                ps.push(stringFromCharCode.apply(String, cs)),
                    cs.length = 0;
            Array.prototype.push.apply(cs, arguments);
        };
    }

    /**
     * Gets the accessor type.
     * @returns {Function} `Buffer` under node.js, `Uint8Array` respectively `DataView` in the browser (classes)
     * @expose
     */
    ByteBuffer.accessor = function() {
        return Uint8Array;
    };
    /**
     * Allocates a new ByteBuffer backed by a buffer of the specified capacity.
     * @param {number=} capacity Initial capacity. Defaults to {@link ByteBuffer.DEFAULT_CAPACITY}.
     * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to
     *  {@link ByteBuffer.DEFAULT_ENDIAN}.
     * @param {boolean=} noAssert Whether to skip assertions of offsets and values. Defaults to
     *  {@link ByteBuffer.DEFAULT_NOASSERT}.
     * @returns {!ByteBuffer}
     * @expose
     */
    ByteBuffer.allocate = function(capacity, littleEndian, noAssert) {
        return new ByteBuffer(capacity, littleEndian, noAssert);
    };

    /**
     * Concatenates multiple ByteBuffers into one.
     * @param {!Array.<!ByteBuffer|!ArrayBuffer|!Uint8Array|string>} buffers Buffers to concatenate
     * @param {(string|boolean)=} encoding String encoding if `buffers` contains a string ("base64", "hex", "binary",
     *  defaults to "utf8")
     * @param {boolean=} littleEndian Whether to use little or big endian byte order for the resulting ByteBuffer. Defaults
     *  to {@link ByteBuffer.DEFAULT_ENDIAN}.
     * @param {boolean=} noAssert Whether to skip assertions of offsets and values for the resulting ByteBuffer. Defaults to
     *  {@link ByteBuffer.DEFAULT_NOASSERT}.
     * @returns {!ByteBuffer} Concatenated ByteBuffer
     * @expose
     */
    ByteBuffer.concat = function(buffers, encoding, littleEndian, noAssert) {
        if (typeof encoding === 'boolean' || typeof encoding !== 'string') {
            noAssert = littleEndian;
            littleEndian = encoding;
            encoding = undefined;
        }
        var capacity = 0;
        for (var i=0, k=buffers.length, length; i<k; ++i) {
            if (!ByteBuffer.isByteBuffer(buffers[i]))
                buffers[i] = ByteBuffer.wrap(buffers[i], encoding);
            length = buffers[i].limit - buffers[i].offset;
            if (length > 0) capacity += length;
        }
        if (capacity === 0)
            return new ByteBuffer(0, littleEndian, noAssert);
        var bb = new ByteBuffer(capacity, littleEndian, noAssert),
            bi;
        i=0; while (i<k) {
            bi = buffers[i++];
            length = bi.limit - bi.offset;
            if (length <= 0) continue;
            bb.view.set(bi.view.subarray(bi.offset, bi.limit), bb.offset);
            bb.offset += length;
        }
        bb.limit = bb.offset;
        bb.offset = 0;
        return bb;
    };

    /**
     * Tests if the specified type is a ByteBuffer.
     * @param {*} bb ByteBuffer to test
     * @returns {boolean} `true` if it is a ByteBuffer, otherwise `false`
     * @expose
     */
    ByteBuffer.isByteBuffer = function(bb) {
        return (bb && bb["__isByteBuffer__"]) === true;
    };
    /**
     * Gets the backing buffer type.
     * @returns {Function} `Buffer` under node.js, `ArrayBuffer` in the browser (classes)
     * @expose
     */
    ByteBuffer.type = function() {
        return ArrayBuffer;
    };
    /**
     * Wraps a buffer or a string. Sets the allocated ByteBuffer's {@link ByteBuffer#offset} to `0` and its
     *  {@link ByteBuffer#limit} to the length of the wrapped data.
     * @param {!ByteBuffer|!ArrayBuffer|!Uint8Array|string|!Array.<number>} buffer Anything that can be wrapped
     * @param {(string|boolean)=} encoding String encoding if `buffer` is a string ("base64", "hex", "binary", defaults to
     *  "utf8")
     * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to
     *  {@link ByteBuffer.DEFAULT_ENDIAN}.
     * @param {boolean=} noAssert Whether to skip assertions of offsets and values. Defaults to
     *  {@link ByteBuffer.DEFAULT_NOASSERT}.
     * @returns {!ByteBuffer} A ByteBuffer wrapping `buffer`
     * @expose
     */
    ByteBuffer.wrap = function(buffer, encoding, littleEndian, noAssert) {
        if (typeof encoding !== 'string') {
            noAssert = littleEndian;
            littleEndian = encoding;
            encoding = undefined;
        }
        if (typeof buffer === 'string') {
            if (typeof encoding === 'undefined')
                encoding = "utf8";
            switch (encoding) {
                case "base64":
                    return ByteBuffer.fromBase64(buffer, littleEndian);
                case "hex":
                    return ByteBuffer.fromHex(buffer, littleEndian);
                case "binary":
                    return ByteBuffer.fromBinary(buffer, littleEndian);
                case "utf8":
                    return ByteBuffer.fromUTF8(buffer, littleEndian);
                case "debug":
                    return ByteBuffer.fromDebug(buffer, littleEndian);
                default:
                    throw Error("Unsupported encoding: "+encoding);
            }
        }
        if (buffer === null || typeof buffer !== 'object')
            throw TypeError("Illegal buffer");
        var bb;
        if (ByteBuffer.isByteBuffer(buffer)) {
            bb = ByteBufferPrototype.clone.call(buffer);
            bb.markedOffset = -1;
            return bb;
        }
        if (buffer instanceof Uint8Array) { // Extract ArrayBuffer from Uint8Array
            bb = new ByteBuffer(0, littleEndian, noAssert);
            if (buffer.length > 0) { // Avoid references to more than one EMPTY_BUFFER
                bb.buffer = buffer.buffer;
                bb.offset = buffer.byteOffset;
                bb.limit = buffer.byteOffset + buffer.byteLength;
                bb.view = new Uint8Array(buffer.buffer);
            }
        } else if (buffer instanceof ArrayBuffer) { // Reuse ArrayBuffer
            bb = new ByteBuffer(0, littleEndian, noAssert);
            if (buffer.byteLength > 0) {
                bb.buffer = buffer;
                bb.offset = 0;
                bb.limit = buffer.byteLength;
                bb.view = buffer.byteLength > 0 ? new Uint8Array(buffer) : null;
            }
        } else if (Object.prototype.toString.call(buffer) === "[object Array]") { // Create from octets
            bb = new ByteBuffer(buffer.length, littleEndian, noAssert);
            bb.limit = buffer.length;
            for (var i=0; i<buffer.length; ++i)
                bb.view[i] = buffer[i];
        } else
            throw TypeError("Illegal buffer"); // Otherwise fail
        return bb;
    };

    /**
     * Reads the specified number of bytes.
     * @param {number} length Number of bytes to read
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `length` if omitted.
     * @returns {!ByteBuffer}
     * @expose
     */
    ByteBufferPrototype.readBytes = function(length, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + length > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+length+") <= "+this.buffer.byteLength);
        }
        var slice = this.slice(offset, offset + length);
        if (relative) this.offset += length;
        return slice;
    };

    /**
     * Writes a payload of bytes. This is an alias of {@link ByteBuffer#append}.
     * @function
     * @param {!ByteBuffer|!ArrayBuffer|!Uint8Array|string} source Data to write. If `source` is a ByteBuffer, its offsets
     *  will be modified according to the performed read operation.
     * @param {(string|number)=} encoding Encoding if `data` is a string ("base64", "hex", "binary", defaults to "utf8")
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  written if omitted.
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.writeBytes = ByteBufferPrototype.append;

    // types/ints/int8

    /**
     * Writes an 8bit signed integer.
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.writeInt8 = function(value, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof value !== 'number' || value % 1 !== 0)
                throw TypeError("Illegal value: "+value+" (not an integer)");
            value |= 0;
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        offset += 1;
        var capacity0 = this.buffer.byteLength;
        if (offset > capacity0)
            this.resize((capacity0 *= 2) > offset ? capacity0 : offset);
        offset -= 1;
        this.view[offset] = value;
        if (relative) this.offset += 1;
        return this;
    };

    /**
     * Writes an 8bit signed integer. This is an alias of {@link ByteBuffer#writeInt8}.
     * @function
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.writeByte = ByteBufferPrototype.writeInt8;

    /**
     * Reads an 8bit signed integer.
     * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.
     * @returns {number} Value read
     * @expose
     */
    ByteBufferPrototype.readInt8 = function(offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 1 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+1+") <= "+this.buffer.byteLength);
        }
        var value = this.view[offset];
        if ((value & 0x80) === 0x80) value = -(0xFF - value + 1); // Cast to signed
        if (relative) this.offset += 1;
        return value;
    };

    /**
     * Reads an 8bit signed integer. This is an alias of {@link ByteBuffer#readInt8}.
     * @function
     * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.
     * @returns {number} Value read
     * @expose
     */
    ByteBufferPrototype.readByte = ByteBufferPrototype.readInt8;

    /**
     * Writes an 8bit unsigned integer.
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.writeUint8 = function(value, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof value !== 'number' || value % 1 !== 0)
                throw TypeError("Illegal value: "+value+" (not an integer)");
            value >>>= 0;
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        offset += 1;
        var capacity1 = this.buffer.byteLength;
        if (offset > capacity1)
            this.resize((capacity1 *= 2) > offset ? capacity1 : offset);
        offset -= 1;
        this.view[offset] = value;
        if (relative) this.offset += 1;
        return this;
    };

    /**
     * Writes an 8bit unsigned integer. This is an alias of {@link ByteBuffer#writeUint8}.
     * @function
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.writeUInt8 = ByteBufferPrototype.writeUint8;

    /**
     * Reads an 8bit unsigned integer.
     * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.
     * @returns {number} Value read
     * @expose
     */
    ByteBufferPrototype.readUint8 = function(offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 1 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+1+") <= "+this.buffer.byteLength);
        }
        var value = this.view[offset];
        if (relative) this.offset += 1;
        return value;
    };

    /**
     * Reads an 8bit unsigned integer. This is an alias of {@link ByteBuffer#readUint8}.
     * @function
     * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.
     * @returns {number} Value read
     * @expose
     */
    ByteBufferPrototype.readUInt8 = ByteBufferPrototype.readUint8;

    // types/ints/int16

    /**
     * Writes a 16bit signed integer.
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.
     * @throws {TypeError} If `offset` or `value` is not a valid number
     * @throws {RangeError} If `offset` is out of bounds
     * @expose
     */
    ByteBufferPrototype.writeInt16 = function(value, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof value !== 'number' || value % 1 !== 0)
                throw TypeError("Illegal value: "+value+" (not an integer)");
            value |= 0;
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        offset += 2;
        var capacity2 = this.buffer.byteLength;
        if (offset > capacity2)
            this.resize((capacity2 *= 2) > offset ? capacity2 : offset);
        offset -= 2;
        if (this.littleEndian) {
            this.view[offset+1] = (value & 0xFF00) >>> 8;
            this.view[offset  ] =  value & 0x00FF;
        } else {
            this.view[offset]   = (value & 0xFF00) >>> 8;
            this.view[offset+1] =  value & 0x00FF;
        }
        if (relative) this.offset += 2;
        return this;
    };

    /**
     * Writes a 16bit signed integer. This is an alias of {@link ByteBuffer#writeInt16}.
     * @function
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.
     * @throws {TypeError} If `offset` or `value` is not a valid number
     * @throws {RangeError} If `offset` is out of bounds
     * @expose
     */
    ByteBufferPrototype.writeShort = ByteBufferPrototype.writeInt16;

    /**
     * Reads a 16bit signed integer.
     * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.
     * @returns {number} Value read
     * @throws {TypeError} If `offset` is not a valid number
     * @throws {RangeError} If `offset` is out of bounds
     * @expose
     */
    ByteBufferPrototype.readInt16 = function(offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 2 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+2+") <= "+this.buffer.byteLength);
        }
        var value = 0;
        if (this.littleEndian) {
            value  = this.view[offset  ];
            value |= this.view[offset+1] << 8;
        } else {
            value  = this.view[offset  ] << 8;
            value |= this.view[offset+1];
        }
        if ((value & 0x8000) === 0x8000) value = -(0xFFFF - value + 1); // Cast to signed
        if (relative) this.offset += 2;
        return value;
    };

    /**
     * Reads a 16bit signed integer. This is an alias of {@link ByteBuffer#readInt16}.
     * @function
     * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.
     * @returns {number} Value read
     * @throws {TypeError} If `offset` is not a valid number
     * @throws {RangeError} If `offset` is out of bounds
     * @expose
     */
    ByteBufferPrototype.readShort = ByteBufferPrototype.readInt16;

    /**
     * Writes a 16bit unsigned integer.
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.
     * @throws {TypeError} If `offset` or `value` is not a valid number
     * @throws {RangeError} If `offset` is out of bounds
     * @expose
     */
    ByteBufferPrototype.writeUint16 = function(value, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof value !== 'number' || value % 1 !== 0)
                throw TypeError("Illegal value: "+value+" (not an integer)");
            value >>>= 0;
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        offset += 2;
        var capacity3 = this.buffer.byteLength;
        if (offset > capacity3)
            this.resize((capacity3 *= 2) > offset ? capacity3 : offset);
        offset -= 2;
        if (this.littleEndian) {
            this.view[offset+1] = (value & 0xFF00) >>> 8;
            this.view[offset  ] =  value & 0x00FF;
        } else {
            this.view[offset]   = (value & 0xFF00) >>> 8;
            this.view[offset+1] =  value & 0x00FF;
        }
        if (relative) this.offset += 2;
        return this;
    };

    /**
     * Writes a 16bit unsigned integer. This is an alias of {@link ByteBuffer#writeUint16}.
     * @function
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.
     * @throws {TypeError} If `offset` or `value` is not a valid number
     * @throws {RangeError} If `offset` is out of bounds
     * @expose
     */
    ByteBufferPrototype.writeUInt16 = ByteBufferPrototype.writeUint16;

    /**
     * Reads a 16bit unsigned integer.
     * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.
     * @returns {number} Value read
     * @throws {TypeError} If `offset` is not a valid number
     * @throws {RangeError} If `offset` is out of bounds
     * @expose
     */
    ByteBufferPrototype.readUint16 = function(offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 2 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+2+") <= "+this.buffer.byteLength);
        }
        var value = 0;
        if (this.littleEndian) {
            value  = this.view[offset  ];
            value |= this.view[offset+1] << 8;
        } else {
            value  = this.view[offset  ] << 8;
            value |= this.view[offset+1];
        }
        if (relative) this.offset += 2;
        return value;
    };

    /**
     * Reads a 16bit unsigned integer. This is an alias of {@link ByteBuffer#readUint16}.
     * @function
     * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.
     * @returns {number} Value read
     * @throws {TypeError} If `offset` is not a valid number
     * @throws {RangeError} If `offset` is out of bounds
     * @expose
     */
    ByteBufferPrototype.readUInt16 = ByteBufferPrototype.readUint16;

    // types/ints/int32

    /**
     * Writes a 32bit signed integer.
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
     * @expose
     */
    ByteBufferPrototype.writeInt32 = function(value, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof value !== 'number' || value % 1 !== 0)
                throw TypeError("Illegal value: "+value+" (not an integer)");
            value |= 0;
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        offset += 4;
        var capacity4 = this.buffer.byteLength;
        if (offset > capacity4)
            this.resize((capacity4 *= 2) > offset ? capacity4 : offset);
        offset -= 4;
        if (this.littleEndian) {
            this.view[offset+3] = (value >>> 24) & 0xFF;
            this.view[offset+2] = (value >>> 16) & 0xFF;
            this.view[offset+1] = (value >>>  8) & 0xFF;
            this.view[offset  ] =  value         & 0xFF;
        } else {
            this.view[offset  ] = (value >>> 24) & 0xFF;
            this.view[offset+1] = (value >>> 16) & 0xFF;
            this.view[offset+2] = (value >>>  8) & 0xFF;
            this.view[offset+3] =  value         & 0xFF;
        }
        if (relative) this.offset += 4;
        return this;
    };

    /**
     * Writes a 32bit signed integer. This is an alias of {@link ByteBuffer#writeInt32}.
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
     * @expose
     */
    ByteBufferPrototype.writeInt = ByteBufferPrototype.writeInt32;

    /**
     * Reads a 32bit signed integer.
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
     * @returns {number} Value read
     * @expose
     */
    ByteBufferPrototype.readInt32 = function(offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 4 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+4+") <= "+this.buffer.byteLength);
        }
        var value = 0;
        if (this.littleEndian) {
            value  = this.view[offset+2] << 16;
            value |= this.view[offset+1] <<  8;
            value |= this.view[offset  ];
            value += this.view[offset+3] << 24 >>> 0;
        } else {
            value  = this.view[offset+1] << 16;
            value |= this.view[offset+2] <<  8;
            value |= this.view[offset+3];
            value += this.view[offset  ] << 24 >>> 0;
        }
        value |= 0; // Cast to signed
        if (relative) this.offset += 4;
        return value;
    };

    /**
     * Reads a 32bit signed integer. This is an alias of {@link ByteBuffer#readInt32}.
     * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `4` if omitted.
     * @returns {number} Value read
     * @expose
     */
    ByteBufferPrototype.readInt = ByteBufferPrototype.readInt32;

    /**
     * Writes a 32bit unsigned integer.
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
     * @expose
     */
    ByteBufferPrototype.writeUint32 = function(value, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof value !== 'number' || value % 1 !== 0)
                throw TypeError("Illegal value: "+value+" (not an integer)");
            value >>>= 0;
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        offset += 4;
        var capacity5 = this.buffer.byteLength;
        if (offset > capacity5)
            this.resize((capacity5 *= 2) > offset ? capacity5 : offset);
        offset -= 4;
        if (this.littleEndian) {
            this.view[offset+3] = (value >>> 24) & 0xFF;
            this.view[offset+2] = (value >>> 16) & 0xFF;
            this.view[offset+1] = (value >>>  8) & 0xFF;
            this.view[offset  ] =  value         & 0xFF;
        } else {
            this.view[offset  ] = (value >>> 24) & 0xFF;
            this.view[offset+1] = (value >>> 16) & 0xFF;
            this.view[offset+2] = (value >>>  8) & 0xFF;
            this.view[offset+3] =  value         & 0xFF;
        }
        if (relative) this.offset += 4;
        return this;
    };

    /**
     * Writes a 32bit unsigned integer. This is an alias of {@link ByteBuffer#writeUint32}.
     * @function
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
     * @expose
     */
    ByteBufferPrototype.writeUInt32 = ByteBufferPrototype.writeUint32;

    /**
     * Reads a 32bit unsigned integer.
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
     * @returns {number} Value read
     * @expose
     */
    ByteBufferPrototype.readUint32 = function(offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 4 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+4+") <= "+this.buffer.byteLength);
        }
        var value = 0;
        if (this.littleEndian) {
            value  = this.view[offset+2] << 16;
            value |= this.view[offset+1] <<  8;
            value |= this.view[offset  ];
            value += this.view[offset+3] << 24 >>> 0;
        } else {
            value  = this.view[offset+1] << 16;
            value |= this.view[offset+2] <<  8;
            value |= this.view[offset+3];
            value += this.view[offset  ] << 24 >>> 0;
        }
        if (relative) this.offset += 4;
        return value;
    };

    /**
     * Reads a 32bit unsigned integer. This is an alias of {@link ByteBuffer#readUint32}.
     * @function
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
     * @returns {number} Value read
     * @expose
     */
    ByteBufferPrototype.readUInt32 = ByteBufferPrototype.readUint32;

    // types/ints/int64

    if (Long) {

        /**
         * Writes a 64bit signed integer.
         * @param {number|!Long} value Value to write
         * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
         * @returns {!ByteBuffer} this
         * @expose
         */
        ByteBufferPrototype.writeInt64 = function(value, offset) {
            var relative = typeof offset === 'undefined';
            if (relative) offset = this.offset;
            if (!this.noAssert) {
                if (typeof value === 'number')
                    value = Long.fromNumber(value);
                else if (typeof value === 'string')
                    value = Long.fromString(value);
                else if (!(value && value instanceof Long))
                    throw TypeError("Illegal value: "+value+" (not an integer or Long)");
                if (typeof offset !== 'number' || offset % 1 !== 0)
                    throw TypeError("Illegal offset: "+offset+" (not an integer)");
                offset >>>= 0;
                if (offset < 0 || offset + 0 > this.buffer.byteLength)
                    throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
            }
            if (typeof value === 'number')
                value = Long.fromNumber(value);
            else if (typeof value === 'string')
                value = Long.fromString(value);
            offset += 8;
            var capacity6 = this.buffer.byteLength;
            if (offset > capacity6)
                this.resize((capacity6 *= 2) > offset ? capacity6 : offset);
            offset -= 8;
            var lo = value.low,
                hi = value.high;
            if (this.littleEndian) {
                this.view[offset+3] = (lo >>> 24) & 0xFF;
                this.view[offset+2] = (lo >>> 16) & 0xFF;
                this.view[offset+1] = (lo >>>  8) & 0xFF;
                this.view[offset  ] =  lo         & 0xFF;
                offset += 4;
                this.view[offset+3] = (hi >>> 24) & 0xFF;
                this.view[offset+2] = (hi >>> 16) & 0xFF;
                this.view[offset+1] = (hi >>>  8) & 0xFF;
                this.view[offset  ] =  hi         & 0xFF;
            } else {
                this.view[offset  ] = (hi >>> 24) & 0xFF;
                this.view[offset+1] = (hi >>> 16) & 0xFF;
                this.view[offset+2] = (hi >>>  8) & 0xFF;
                this.view[offset+3] =  hi         & 0xFF;
                offset += 4;
                this.view[offset  ] = (lo >>> 24) & 0xFF;
                this.view[offset+1] = (lo >>> 16) & 0xFF;
                this.view[offset+2] = (lo >>>  8) & 0xFF;
                this.view[offset+3] =  lo         & 0xFF;
            }
            if (relative) this.offset += 8;
            return this;
        };

        /**
         * Writes a 64bit signed integer. This is an alias of {@link ByteBuffer#writeInt64}.
         * @param {number|!Long} value Value to write
         * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
         * @returns {!ByteBuffer} this
         * @expose
         */
        ByteBufferPrototype.writeLong = ByteBufferPrototype.writeInt64;

        /**
         * Reads a 64bit signed integer.
         * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
         * @returns {!Long}
         * @expose
         */
        ByteBufferPrototype.readInt64 = function(offset) {
            var relative = typeof offset === 'undefined';
            if (relative) offset = this.offset;
            if (!this.noAssert) {
                if (typeof offset !== 'number' || offset % 1 !== 0)
                    throw TypeError("Illegal offset: "+offset+" (not an integer)");
                offset >>>= 0;
                if (offset < 0 || offset + 8 > this.buffer.byteLength)
                    throw RangeError("Illegal offset: 0 <= "+offset+" (+"+8+") <= "+this.buffer.byteLength);
            }
            var lo = 0,
                hi = 0;
            if (this.littleEndian) {
                lo  = this.view[offset+2] << 16;
                lo |= this.view[offset+1] <<  8;
                lo |= this.view[offset  ];
                lo += this.view[offset+3] << 24 >>> 0;
                offset += 4;
                hi  = this.view[offset+2] << 16;
                hi |= this.view[offset+1] <<  8;
                hi |= this.view[offset  ];
                hi += this.view[offset+3] << 24 >>> 0;
            } else {
                hi  = this.view[offset+1] << 16;
                hi |= this.view[offset+2] <<  8;
                hi |= this.view[offset+3];
                hi += this.view[offset  ] << 24 >>> 0;
                offset += 4;
                lo  = this.view[offset+1] << 16;
                lo |= this.view[offset+2] <<  8;
                lo |= this.view[offset+3];
                lo += this.view[offset  ] << 24 >>> 0;
            }
            var value = new Long(lo, hi, false);
            if (relative) this.offset += 8;
            return value;
        };

        /**
         * Reads a 64bit signed integer. This is an alias of {@link ByteBuffer#readInt64}.
         * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
         * @returns {!Long}
         * @expose
         */
        ByteBufferPrototype.readLong = ByteBufferPrototype.readInt64;

        /**
         * Writes a 64bit unsigned integer.
         * @param {number|!Long} value Value to write
         * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
         * @returns {!ByteBuffer} this
         * @expose
         */
        ByteBufferPrototype.writeUint64 = function(value, offset) {
            var relative = typeof offset === 'undefined';
            if (relative) offset = this.offset;
            if (!this.noAssert) {
                if (typeof value === 'number')
                    value = Long.fromNumber(value);
                else if (typeof value === 'string')
                    value = Long.fromString(value);
                else if (!(value && value instanceof Long))
                    throw TypeError("Illegal value: "+value+" (not an integer or Long)");
                if (typeof offset !== 'number' || offset % 1 !== 0)
                    throw TypeError("Illegal offset: "+offset+" (not an integer)");
                offset >>>= 0;
                if (offset < 0 || offset + 0 > this.buffer.byteLength)
                    throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
            }
            if (typeof value === 'number')
                value = Long.fromNumber(value);
            else if (typeof value === 'string')
                value = Long.fromString(value);
            offset += 8;
            var capacity7 = this.buffer.byteLength;
            if (offset > capacity7)
                this.resize((capacity7 *= 2) > offset ? capacity7 : offset);
            offset -= 8;
            var lo = value.low,
                hi = value.high;
            if (this.littleEndian) {
                this.view[offset+3] = (lo >>> 24) & 0xFF;
                this.view[offset+2] = (lo >>> 16) & 0xFF;
                this.view[offset+1] = (lo >>>  8) & 0xFF;
                this.view[offset  ] =  lo         & 0xFF;
                offset += 4;
                this.view[offset+3] = (hi >>> 24) & 0xFF;
                this.view[offset+2] = (hi >>> 16) & 0xFF;
                this.view[offset+1] = (hi >>>  8) & 0xFF;
                this.view[offset  ] =  hi         & 0xFF;
            } else {
                this.view[offset  ] = (hi >>> 24) & 0xFF;
                this.view[offset+1] = (hi >>> 16) & 0xFF;
                this.view[offset+2] = (hi >>>  8) & 0xFF;
                this.view[offset+3] =  hi         & 0xFF;
                offset += 4;
                this.view[offset  ] = (lo >>> 24) & 0xFF;
                this.view[offset+1] = (lo >>> 16) & 0xFF;
                this.view[offset+2] = (lo >>>  8) & 0xFF;
                this.view[offset+3] =  lo         & 0xFF;
            }
            if (relative) this.offset += 8;
            return this;
        };

        /**
         * Writes a 64bit unsigned integer. This is an alias of {@link ByteBuffer#writeUint64}.
         * @function
         * @param {number|!Long} value Value to write
         * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
         * @returns {!ByteBuffer} this
         * @expose
         */
        ByteBufferPrototype.writeUInt64 = ByteBufferPrototype.writeUint64;

        /**
         * Reads a 64bit unsigned integer.
         * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
         * @returns {!Long}
         * @expose
         */
        ByteBufferPrototype.readUint64 = function(offset) {
            var relative = typeof offset === 'undefined';
            if (relative) offset = this.offset;
            if (!this.noAssert) {
                if (typeof offset !== 'number' || offset % 1 !== 0)
                    throw TypeError("Illegal offset: "+offset+" (not an integer)");
                offset >>>= 0;
                if (offset < 0 || offset + 8 > this.buffer.byteLength)
                    throw RangeError("Illegal offset: 0 <= "+offset+" (+"+8+") <= "+this.buffer.byteLength);
            }
            var lo = 0,
                hi = 0;
            if (this.littleEndian) {
                lo  = this.view[offset+2] << 16;
                lo |= this.view[offset+1] <<  8;
                lo |= this.view[offset  ];
                lo += this.view[offset+3] << 24 >>> 0;
                offset += 4;
                hi  = this.view[offset+2] << 16;
                hi |= this.view[offset+1] <<  8;
                hi |= this.view[offset  ];
                hi += this.view[offset+3] << 24 >>> 0;
            } else {
                hi  = this.view[offset+1] << 16;
                hi |= this.view[offset+2] <<  8;
                hi |= this.view[offset+3];
                hi += this.view[offset  ] << 24 >>> 0;
                offset += 4;
                lo  = this.view[offset+1] << 16;
                lo |= this.view[offset+2] <<  8;
                lo |= this.view[offset+3];
                lo += this.view[offset  ] << 24 >>> 0;
            }
            var value = new Long(lo, hi, true);
            if (relative) this.offset += 8;
            return value;
        };

        /**
         * Reads a 64bit unsigned integer. This is an alias of {@link ByteBuffer#readUint64}.
         * @function
         * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
         * @returns {!Long}
         * @expose
         */
        ByteBufferPrototype.readUInt64 = ByteBufferPrototype.readUint64;

    } // Long


    // types/floats/float32

    /*
     ieee754 - https://github.com/feross/ieee754

     The MIT License (MIT)

     Copyright (c) Feross Aboukhadijeh

     Permission is hereby granted, free of charge, to any person obtaining a copy
     of this software and associated documentation files (the "Software"), to deal
     in the Software without restriction, including without limitation the rights
     to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     copies of the Software, and to permit persons to whom the Software is
     furnished to do so, subject to the following conditions:

     The above copyright notice and this permission notice shall be included in
     all copies or substantial portions of the Software.

     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     THE SOFTWARE.
    */

    /**
     * Reads an IEEE754 float from a byte array.
     * @param {!Array} buffer
     * @param {number} offset
     * @param {boolean} isLE
     * @param {number} mLen
     * @param {number} nBytes
     * @returns {number}
     * @inner
     */
    function ieee754_read(buffer, offset, isLE, mLen, nBytes) {
        var e, m,
            eLen = nBytes * 8 - mLen - 1,
            eMax = (1 << eLen) - 1,
            eBias = eMax >> 1,
            nBits = -7,
            i = isLE ? (nBytes - 1) : 0,
            d = isLE ? -1 : 1,
            s = buffer[offset + i];

        i += d;

        e = s & ((1 << (-nBits)) - 1);
        s >>= (-nBits);
        nBits += eLen;
        for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

        m = e & ((1 << (-nBits)) - 1);
        e >>= (-nBits);
        nBits += mLen;
        for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

        if (e === 0) {
            e = 1 - eBias;
        } else if (e === eMax) {
            return m ? NaN : ((s ? -1 : 1) * Infinity);
        } else {
            m = m + Math.pow(2, mLen);
            e = e - eBias;
        }
        return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
    }

    /**
     * Writes an IEEE754 float to a byte array.
     * @param {!Array} buffer
     * @param {number} value
     * @param {number} offset
     * @param {boolean} isLE
     * @param {number} mLen
     * @param {number} nBytes
     * @inner
     */
    function ieee754_write(buffer, value, offset, isLE, mLen, nBytes) {
        var e, m, c,
            eLen = nBytes * 8 - mLen - 1,
            eMax = (1 << eLen) - 1,
            eBias = eMax >> 1,
            rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
            i = isLE ? 0 : (nBytes - 1),
            d = isLE ? 1 : -1,
            s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

        value = Math.abs(value);

        if (isNaN(value) || value === Infinity) {
            m = isNaN(value) ? 1 : 0;
            e = eMax;
        } else {
            e = Math.floor(Math.log(value) / Math.LN2);
            if (value * (c = Math.pow(2, -e)) < 1) {
                e--;
                c *= 2;
            }
            if (e + eBias >= 1) {
                value += rt / c;
            } else {
                value += rt * Math.pow(2, 1 - eBias);
            }
            if (value * c >= 2) {
                e++;
                c /= 2;
            }

            if (e + eBias >= eMax) {
                m = 0;
                e = eMax;
            } else if (e + eBias >= 1) {
                m = (value * c - 1) * Math.pow(2, mLen);
                e = e + eBias;
            } else {
                m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
                e = 0;
            }
        }

        for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

        e = (e << mLen) | m;
        eLen += mLen;
        for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

        buffer[offset + i - d] |= s * 128;
    }

    /**
     * Writes a 32bit float.
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.writeFloat32 = function(value, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof value !== 'number')
                throw TypeError("Illegal value: "+value+" (not a number)");
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        offset += 4;
        var capacity8 = this.buffer.byteLength;
        if (offset > capacity8)
            this.resize((capacity8 *= 2) > offset ? capacity8 : offset);
        offset -= 4;
        ieee754_write(this.view, value, offset, this.littleEndian, 23, 4);
        if (relative) this.offset += 4;
        return this;
    };

    /**
     * Writes a 32bit float. This is an alias of {@link ByteBuffer#writeFloat32}.
     * @function
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.writeFloat = ByteBufferPrototype.writeFloat32;

    /**
     * Reads a 32bit float.
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
     * @returns {number}
     * @expose
     */
    ByteBufferPrototype.readFloat32 = function(offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 4 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+4+") <= "+this.buffer.byteLength);
        }
        var value = ieee754_read(this.view, offset, this.littleEndian, 23, 4);
        if (relative) this.offset += 4;
        return value;
    };

    /**
     * Reads a 32bit float. This is an alias of {@link ByteBuffer#readFloat32}.
     * @function
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
     * @returns {number}
     * @expose
     */
    ByteBufferPrototype.readFloat = ByteBufferPrototype.readFloat32;

    // types/floats/float64

    /**
     * Writes a 64bit float.
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.writeFloat64 = function(value, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof value !== 'number')
                throw TypeError("Illegal value: "+value+" (not a number)");
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        offset += 8;
        var capacity9 = this.buffer.byteLength;
        if (offset > capacity9)
            this.resize((capacity9 *= 2) > offset ? capacity9 : offset);
        offset -= 8;
        ieee754_write(this.view, value, offset, this.littleEndian, 52, 8);
        if (relative) this.offset += 8;
        return this;
    };

    /**
     * Writes a 64bit float. This is an alias of {@link ByteBuffer#writeFloat64}.
     * @function
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.writeDouble = ByteBufferPrototype.writeFloat64;

    /**
     * Reads a 64bit float.
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
     * @returns {number}
     * @expose
     */
    ByteBufferPrototype.readFloat64 = function(offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 8 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+8+") <= "+this.buffer.byteLength);
        }
        var value = ieee754_read(this.view, offset, this.littleEndian, 52, 8);
        if (relative) this.offset += 8;
        return value;
    };

    /**
     * Reads a 64bit float. This is an alias of {@link ByteBuffer#readFloat64}.
     * @function
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
     * @returns {number}
     * @expose
     */
    ByteBufferPrototype.readDouble = ByteBufferPrototype.readFloat64;


    // types/varints/varint32

    /**
     * Maximum number of bytes required to store a 32bit base 128 variable-length integer.
     * @type {number}
     * @const
     * @expose
     */
    ByteBuffer.MAX_VARINT32_BYTES = 5;

    /**
     * Calculates the actual number of bytes required to store a 32bit base 128 variable-length integer.
     * @param {number} value Value to encode
     * @returns {number} Number of bytes required. Capped to {@link ByteBuffer.MAX_VARINT32_BYTES}
     * @expose
     */
    ByteBuffer.calculateVarint32 = function(value) {
        // ref: src/google/protobuf/io/coded_stream.cc
        value = value >>> 0;
             if (value < 1 << 7 ) return 1;
        else if (value < 1 << 14) return 2;
        else if (value < 1 << 21) return 3;
        else if (value < 1 << 28) return 4;
        else                      return 5;
    };

    /**
     * Zigzag encodes a signed 32bit integer so that it can be effectively used with varint encoding.
     * @param {number} n Signed 32bit integer
     * @returns {number} Unsigned zigzag encoded 32bit integer
     * @expose
     */
    ByteBuffer.zigZagEncode32 = function(n) {
        return (((n |= 0) << 1) ^ (n >> 31)) >>> 0; // ref: src/google/protobuf/wire_format_lite.h
    };

    /**
     * Decodes a zigzag encoded signed 32bit integer.
     * @param {number} n Unsigned zigzag encoded 32bit integer
     * @returns {number} Signed 32bit integer
     * @expose
     */
    ByteBuffer.zigZagDecode32 = function(n) {
        return ((n >>> 1) ^ -(n & 1)) | 0; // // ref: src/google/protobuf/wire_format_lite.h
    };

    /**
     * Writes a 32bit base 128 variable-length integer.
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  written if omitted.
     * @returns {!ByteBuffer|number} this if `offset` is omitted, else the actual number of bytes written
     * @expose
     */
    ByteBufferPrototype.writeVarint32 = function(value, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof value !== 'number' || value % 1 !== 0)
                throw TypeError("Illegal value: "+value+" (not an integer)");
            value |= 0;
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        var size = ByteBuffer.calculateVarint32(value),
            b;
        offset += size;
        var capacity10 = this.buffer.byteLength;
        if (offset > capacity10)
            this.resize((capacity10 *= 2) > offset ? capacity10 : offset);
        offset -= size;
        value >>>= 0;
        while (value >= 0x80) {
            b = (value & 0x7f) | 0x80;
            this.view[offset++] = b;
            value >>>= 7;
        }
        this.view[offset++] = value;
        if (relative) {
            this.offset = offset;
            return this;
        }
        return size;
    };

    /**
     * Writes a zig-zag encoded (signed) 32bit base 128 variable-length integer.
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  written if omitted.
     * @returns {!ByteBuffer|number} this if `offset` is omitted, else the actual number of bytes written
     * @expose
     */
    ByteBufferPrototype.writeVarint32ZigZag = function(value, offset) {
        return this.writeVarint32(ByteBuffer.zigZagEncode32(value), offset);
    };

    /**
     * Reads a 32bit base 128 variable-length integer.
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  written if omitted.
     * @returns {number|!{value: number, length: number}} The value read if offset is omitted, else the value read
     *  and the actual number of bytes read.
     * @throws {Error} If it's not a valid varint. Has a property `truncated = true` if there is not enough data available
     *  to fully decode the varint.
     * @expose
     */
    ByteBufferPrototype.readVarint32 = function(offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 1 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+1+") <= "+this.buffer.byteLength);
        }
        var c = 0,
            value = 0 >>> 0,
            b;
        do {
            if (!this.noAssert && offset > this.limit) {
                var err = Error("Truncated");
                err['truncated'] = true;
                throw err;
            }
            b = this.view[offset++];
            if (c < 5)
                value |= (b & 0x7f) << (7*c);
            ++c;
        } while ((b & 0x80) !== 0);
        value |= 0;
        if (relative) {
            this.offset = offset;
            return value;
        }
        return {
            "value": value,
            "length": c
        };
    };

    /**
     * Reads a zig-zag encoded (signed) 32bit base 128 variable-length integer.
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  written if omitted.
     * @returns {number|!{value: number, length: number}} The value read if offset is omitted, else the value read
     *  and the actual number of bytes read.
     * @throws {Error} If it's not a valid varint
     * @expose
     */
    ByteBufferPrototype.readVarint32ZigZag = function(offset) {
        var val = this.readVarint32(offset);
        if (typeof val === 'object')
            val["value"] = ByteBuffer.zigZagDecode32(val["value"]);
        else
            val = ByteBuffer.zigZagDecode32(val);
        return val;
    };

    // types/varints/varint64

    if (Long) {

        /**
         * Maximum number of bytes required to store a 64bit base 128 variable-length integer.
         * @type {number}
         * @const
         * @expose
         */
        ByteBuffer.MAX_VARINT64_BYTES = 10;

        /**
         * Calculates the actual number of bytes required to store a 64bit base 128 variable-length integer.
         * @param {number|!Long} value Value to encode
         * @returns {number} Number of bytes required. Capped to {@link ByteBuffer.MAX_VARINT64_BYTES}
         * @expose
         */
        ByteBuffer.calculateVarint64 = function(value) {
            if (typeof value === 'number')
                value = Long.fromNumber(value);
            else if (typeof value === 'string')
                value = Long.fromString(value);
            // ref: src/google/protobuf/io/coded_stream.cc
            var part0 = value.toInt() >>> 0,
                part1 = value.shiftRightUnsigned(28).toInt() >>> 0,
                part2 = value.shiftRightUnsigned(56).toInt() >>> 0;
            if (part2 == 0) {
                if (part1 == 0) {
                    if (part0 < 1 << 14)
                        return part0 < 1 << 7 ? 1 : 2;
                    else
                        return part0 < 1 << 21 ? 3 : 4;
                } else {
                    if (part1 < 1 << 14)
                        return part1 < 1 << 7 ? 5 : 6;
                    else
                        return part1 < 1 << 21 ? 7 : 8;
                }
            } else
                return part2 < 1 << 7 ? 9 : 10;
        };

        /**
         * Zigzag encodes a signed 64bit integer so that it can be effectively used with varint encoding.
         * @param {number|!Long} value Signed long
         * @returns {!Long} Unsigned zigzag encoded long
         * @expose
         */
        ByteBuffer.zigZagEncode64 = function(value) {
            if (typeof value === 'number')
                value = Long.fromNumber(value, false);
            else if (typeof value === 'string')
                value = Long.fromString(value, false);
            else if (value.unsigned !== false) value = value.toSigned();
            // ref: src/google/protobuf/wire_format_lite.h
            return value.shiftLeft(1).xor(value.shiftRight(63)).toUnsigned();
        };

        /**
         * Decodes a zigzag encoded signed 64bit integer.
         * @param {!Long|number} value Unsigned zigzag encoded long or JavaScript number
         * @returns {!Long} Signed long
         * @expose
         */
        ByteBuffer.zigZagDecode64 = function(value) {
            if (typeof value === 'number')
                value = Long.fromNumber(value, false);
            else if (typeof value === 'string')
                value = Long.fromString(value, false);
            else if (value.unsigned !== false) value = value.toSigned();
            // ref: src/google/protobuf/wire_format_lite.h
            return value.shiftRightUnsigned(1).xor(value.and(Long.ONE).toSigned().negate()).toSigned();
        };

        /**
         * Writes a 64bit base 128 variable-length integer.
         * @param {number|Long} value Value to write
         * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
         *  written if omitted.
         * @returns {!ByteBuffer|number} `this` if offset is omitted, else the actual number of bytes written.
         * @expose
         */
        ByteBufferPrototype.writeVarint64 = function(value, offset) {
            var relative = typeof offset === 'undefined';
            if (relative) offset = this.offset;
            if (!this.noAssert) {
                if (typeof value === 'number')
                    value = Long.fromNumber(value);
                else if (typeof value === 'string')
                    value = Long.fromString(value);
                else if (!(value && value instanceof Long))
                    throw TypeError("Illegal value: "+value+" (not an integer or Long)");
                if (typeof offset !== 'number' || offset % 1 !== 0)
                    throw TypeError("Illegal offset: "+offset+" (not an integer)");
                offset >>>= 0;
                if (offset < 0 || offset + 0 > this.buffer.byteLength)
                    throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
            }
            if (typeof value === 'number')
                value = Long.fromNumber(value, false);
            else if (typeof value === 'string')
                value = Long.fromString(value, false);
            else if (value.unsigned !== false) value = value.toSigned();
            var size = ByteBuffer.calculateVarint64(value),
                part0 = value.toInt() >>> 0,
                part1 = value.shiftRightUnsigned(28).toInt() >>> 0,
                part2 = value.shiftRightUnsigned(56).toInt() >>> 0;
            offset += size;
            var capacity11 = this.buffer.byteLength;
            if (offset > capacity11)
                this.resize((capacity11 *= 2) > offset ? capacity11 : offset);
            offset -= size;
            switch (size) {
                case 10: this.view[offset+9] = (part2 >>>  7) & 0x01;
                case 9 : this.view[offset+8] = size !== 9 ? (part2       ) | 0x80 : (part2       ) & 0x7F;
                case 8 : this.view[offset+7] = size !== 8 ? (part1 >>> 21) | 0x80 : (part1 >>> 21) & 0x7F;
                case 7 : this.view[offset+6] = size !== 7 ? (part1 >>> 14) | 0x80 : (part1 >>> 14) & 0x7F;
                case 6 : this.view[offset+5] = size !== 6 ? (part1 >>>  7) | 0x80 : (part1 >>>  7) & 0x7F;
                case 5 : this.view[offset+4] = size !== 5 ? (part1       ) | 0x80 : (part1       ) & 0x7F;
                case 4 : this.view[offset+3] = size !== 4 ? (part0 >>> 21) | 0x80 : (part0 >>> 21) & 0x7F;
                case 3 : this.view[offset+2] = size !== 3 ? (part0 >>> 14) | 0x80 : (part0 >>> 14) & 0x7F;
                case 2 : this.view[offset+1] = size !== 2 ? (part0 >>>  7) | 0x80 : (part0 >>>  7) & 0x7F;
                case 1 : this.view[offset  ] = size !== 1 ? (part0       ) | 0x80 : (part0       ) & 0x7F;
            }
            if (relative) {
                this.offset += size;
                return this;
            } else {
                return size;
            }
        };

        /**
         * Writes a zig-zag encoded 64bit base 128 variable-length integer.
         * @param {number|Long} value Value to write
         * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
         *  written if omitted.
         * @returns {!ByteBuffer|number} `this` if offset is omitted, else the actual number of bytes written.
         * @expose
         */
        ByteBufferPrototype.writeVarint64ZigZag = function(value, offset) {
            return this.writeVarint64(ByteBuffer.zigZagEncode64(value), offset);
        };

        /**
         * Reads a 64bit base 128 variable-length integer. Requires Long.js.
         * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
         *  read if omitted.
         * @returns {!Long|!{value: Long, length: number}} The value read if offset is omitted, else the value read and
         *  the actual number of bytes read.
         * @throws {Error} If it's not a valid varint
         * @expose
         */
        ByteBufferPrototype.readVarint64 = function(offset) {
            var relative = typeof offset === 'undefined';
            if (relative) offset = this.offset;
            if (!this.noAssert) {
                if (typeof offset !== 'number' || offset % 1 !== 0)
                    throw TypeError("Illegal offset: "+offset+" (not an integer)");
                offset >>>= 0;
                if (offset < 0 || offset + 1 > this.buffer.byteLength)
                    throw RangeError("Illegal offset: 0 <= "+offset+" (+"+1+") <= "+this.buffer.byteLength);
            }
            // ref: src/google/protobuf/io/coded_stream.cc
            var start = offset,
                part0 = 0,
                part1 = 0,
                part2 = 0,
                b  = 0;
            b = this.view[offset++]; part0  = (b & 0x7F)      ; if ( b & 0x80                                                   ) {
            b = this.view[offset++]; part0 |= (b & 0x7F) <<  7; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) {
            b = this.view[offset++]; part0 |= (b & 0x7F) << 14; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) {
            b = this.view[offset++]; part0 |= (b & 0x7F) << 21; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) {
            b = this.view[offset++]; part1  = (b & 0x7F)      ; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) {
            b = this.view[offset++]; part1 |= (b & 0x7F) <<  7; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) {
            b = this.view[offset++]; part1 |= (b & 0x7F) << 14; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) {
            b = this.view[offset++]; part1 |= (b & 0x7F) << 21; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) {
            b = this.view[offset++]; part2  = (b & 0x7F)      ; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) {
            b = this.view[offset++]; part2 |= (b & 0x7F) <<  7; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) {
            throw Error("Buffer overrun"); }}}}}}}}}}
            var value = Long.fromBits(part0 | (part1 << 28), (part1 >>> 4) | (part2) << 24, false);
            if (relative) {
                this.offset = offset;
                return value;
            } else {
                return {
                    'value': value,
                    'length': offset-start
                };
            }
        };

        /**
         * Reads a zig-zag encoded 64bit base 128 variable-length integer. Requires Long.js.
         * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
         *  read if omitted.
         * @returns {!Long|!{value: Long, length: number}} The value read if offset is omitted, else the value read and
         *  the actual number of bytes read.
         * @throws {Error} If it's not a valid varint
         * @expose
         */
        ByteBufferPrototype.readVarint64ZigZag = function(offset) {
            var val = this.readVarint64(offset);
            if (val && val['value'] instanceof Long)
                val["value"] = ByteBuffer.zigZagDecode64(val["value"]);
            else
                val = ByteBuffer.zigZagDecode64(val);
            return val;
        };

    } // Long


    // types/strings/cstring

    /**
     * Writes a NULL-terminated UTF8 encoded string. For this to work the specified string must not contain any NULL
     *  characters itself.
     * @param {string} str String to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  contained in `str` + 1 if omitted.
     * @returns {!ByteBuffer|number} this if offset is omitted, else the actual number of bytes written
     * @expose
     */
    ByteBufferPrototype.writeCString = function(str, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        var i,
            k = str.length;
        if (!this.noAssert) {
            if (typeof str !== 'string')
                throw TypeError("Illegal str: Not a string");
            for (i=0; i<k; ++i) {
                if (str.charCodeAt(i) === 0)
                    throw RangeError("Illegal str: Contains NULL-characters");
            }
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        // UTF8 strings do not contain zero bytes in between except for the zero character, so:
        k = utfx.calculateUTF16asUTF8(stringSource(str))[1];
        offset += k+1;
        var capacity12 = this.buffer.byteLength;
        if (offset > capacity12)
            this.resize((capacity12 *= 2) > offset ? capacity12 : offset);
        offset -= k+1;
        utfx.encodeUTF16toUTF8(stringSource(str), function(b) {
            this.view[offset++] = b;
        }.bind(this));
        this.view[offset++] = 0;
        if (relative) {
            this.offset = offset;
            return this;
        }
        return k;
    };

    /**
     * Reads a NULL-terminated UTF8 encoded string. For this to work the string read must not contain any NULL characters
     *  itself.
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  read if omitted.
     * @returns {string|!{string: string, length: number}} The string read if offset is omitted, else the string
     *  read and the actual number of bytes read.
     * @expose
     */
    ByteBufferPrototype.readCString = function(offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 1 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+1+") <= "+this.buffer.byteLength);
        }
        var start = offset,
            temp;
        // UTF8 strings do not contain zero bytes in between except for the zero character itself, so:
        var sd, b = -1;
        utfx.decodeUTF8toUTF16(function() {
            if (b === 0) return null;
            if (offset >= this.limit)
                throw RangeError("Illegal range: Truncated data, "+offset+" < "+this.limit);
            b = this.view[offset++];
            return b === 0 ? null : b;
        }.bind(this), sd = stringDestination(), true);
        if (relative) {
            this.offset = offset;
            return sd();
        } else {
            return {
                "string": sd(),
                "length": offset - start
            };
        }
    };

    // types/strings/istring

    /**
     * Writes a length as uint32 prefixed UTF8 encoded string.
     * @param {string} str String to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  written if omitted.
     * @returns {!ByteBuffer|number} `this` if `offset` is omitted, else the actual number of bytes written
     * @expose
     * @see ByteBuffer#writeVarint32
     */
    ByteBufferPrototype.writeIString = function(str, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof str !== 'string')
                throw TypeError("Illegal str: Not a string");
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        var start = offset,
            k;
        k = utfx.calculateUTF16asUTF8(stringSource(str), this.noAssert)[1];
        offset += 4+k;
        var capacity13 = this.buffer.byteLength;
        if (offset > capacity13)
            this.resize((capacity13 *= 2) > offset ? capacity13 : offset);
        offset -= 4+k;
        if (this.littleEndian) {
            this.view[offset+3] = (k >>> 24) & 0xFF;
            this.view[offset+2] = (k >>> 16) & 0xFF;
            this.view[offset+1] = (k >>>  8) & 0xFF;
            this.view[offset  ] =  k         & 0xFF;
        } else {
            this.view[offset  ] = (k >>> 24) & 0xFF;
            this.view[offset+1] = (k >>> 16) & 0xFF;
            this.view[offset+2] = (k >>>  8) & 0xFF;
            this.view[offset+3] =  k         & 0xFF;
        }
        offset += 4;
        utfx.encodeUTF16toUTF8(stringSource(str), function(b) {
            this.view[offset++] = b;
        }.bind(this));
        if (offset !== start + 4 + k)
            throw RangeError("Illegal range: Truncated data, "+offset+" == "+(offset+4+k));
        if (relative) {
            this.offset = offset;
            return this;
        }
        return offset - start;
    };

    /**
     * Reads a length as uint32 prefixed UTF8 encoded string.
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  read if omitted.
     * @returns {string|!{string: string, length: number}} The string read if offset is omitted, else the string
     *  read and the actual number of bytes read.
     * @expose
     * @see ByteBuffer#readVarint32
     */
    ByteBufferPrototype.readIString = function(offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 4 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+4+") <= "+this.buffer.byteLength);
        }
        var temp = 0,
            start = offset,
            str;
        if (this.littleEndian) {
            temp  = this.view[offset+2] << 16;
            temp |= this.view[offset+1] <<  8;
            temp |= this.view[offset  ];
            temp += this.view[offset+3] << 24 >>> 0;
        } else {
            temp  = this.view[offset+1] << 16;
            temp |= this.view[offset+2] <<  8;
            temp |= this.view[offset+3];
            temp += this.view[offset  ] << 24 >>> 0;
        }
        offset += 4;
        var k = offset + temp,
            sd;
        utfx.decodeUTF8toUTF16(function() {
            return offset < k ? this.view[offset++] : null;
        }.bind(this), sd = stringDestination(), this.noAssert);
        str = sd();
        if (relative) {
            this.offset = offset;
            return str;
        } else {
            return {
                'string': str,
                'length': offset - start
            };
        }
    };

    // types/strings/utf8string

    /**
     * Metrics representing number of UTF8 characters. Evaluates to `c`.
     * @type {string}
     * @const
     * @expose
     */
    ByteBuffer.METRICS_CHARS = 'c';

    /**
     * Metrics representing number of bytes. Evaluates to `b`.
     * @type {string}
     * @const
     * @expose
     */
    ByteBuffer.METRICS_BYTES = 'b';

    /**
     * Writes an UTF8 encoded string.
     * @param {string} str String to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} if omitted.
     * @returns {!ByteBuffer|number} this if offset is omitted, else the actual number of bytes written.
     * @expose
     */
    ByteBufferPrototype.writeUTF8String = function(str, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        var k;
        var start = offset;
        k = utfx.calculateUTF16asUTF8(stringSource(str))[1];
        offset += k;
        var capacity14 = this.buffer.byteLength;
        if (offset > capacity14)
            this.resize((capacity14 *= 2) > offset ? capacity14 : offset);
        offset -= k;
        utfx.encodeUTF16toUTF8(stringSource(str), function(b) {
            this.view[offset++] = b;
        }.bind(this));
        if (relative) {
            this.offset = offset;
            return this;
        }
        return offset - start;
    };

    /**
     * Writes an UTF8 encoded string. This is an alias of {@link ByteBuffer#writeUTF8String}.
     * @function
     * @param {string} str String to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} if omitted.
     * @returns {!ByteBuffer|number} this if offset is omitted, else the actual number of bytes written.
     * @expose
     */
    ByteBufferPrototype.writeString = ByteBufferPrototype.writeUTF8String;

    /**
     * Calculates the number of UTF8 characters of a string. JavaScript itself uses UTF-16, so that a string's
     *  `length` property does not reflect its actual UTF8 size if it contains code points larger than 0xFFFF.
     * @param {string} str String to calculate
     * @returns {number} Number of UTF8 characters
     * @expose
     */
    ByteBuffer.calculateUTF8Chars = function(str) {
        return utfx.calculateUTF16asUTF8(stringSource(str))[0];
    };

    /**
     * Calculates the number of UTF8 bytes of a string.
     * @param {string} str String to calculate
     * @returns {number} Number of UTF8 bytes
     * @expose
     */
    ByteBuffer.calculateUTF8Bytes = function(str) {
        return utfx.calculateUTF16asUTF8(stringSource(str))[1];
    };

    /**
     * Calculates the number of UTF8 bytes of a string. This is an alias of {@link ByteBuffer.calculateUTF8Bytes}.
     * @function
     * @param {string} str String to calculate
     * @returns {number} Number of UTF8 bytes
     * @expose
     */
    ByteBuffer.calculateString = ByteBuffer.calculateUTF8Bytes;

    /**
     * Reads an UTF8 encoded string.
     * @param {number} length Number of characters or bytes to read.
     * @param {string=} metrics Metrics specifying what `length` is meant to count. Defaults to
     *  {@link ByteBuffer.METRICS_CHARS}.
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  read if omitted.
     * @returns {string|!{string: string, length: number}} The string read if offset is omitted, else the string
     *  read and the actual number of bytes read.
     * @expose
     */
    ByteBufferPrototype.readUTF8String = function(length, metrics, offset) {
        if (typeof metrics === 'number') {
            offset = metrics;
            metrics = undefined;
        }
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (typeof metrics === 'undefined') metrics = ByteBuffer.METRICS_CHARS;
        if (!this.noAssert) {
            if (typeof length !== 'number' || length % 1 !== 0)
                throw TypeError("Illegal length: "+length+" (not an integer)");
            length |= 0;
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        var i = 0,
            start = offset,
            sd;
        if (metrics === ByteBuffer.METRICS_CHARS) { // The same for node and the browser
            sd = stringDestination();
            utfx.decodeUTF8(function() {
                return i < length && offset < this.limit ? this.view[offset++] : null;
            }.bind(this), function(cp) {
                ++i; utfx.UTF8toUTF16(cp, sd);
            });
            if (i !== length)
                throw RangeError("Illegal range: Truncated data, "+i+" == "+length);
            if (relative) {
                this.offset = offset;
                return sd();
            } else {
                return {
                    "string": sd(),
                    "length": offset - start
                };
            }
        } else if (metrics === ByteBuffer.METRICS_BYTES) {
            if (!this.noAssert) {
                if (typeof offset !== 'number' || offset % 1 !== 0)
                    throw TypeError("Illegal offset: "+offset+" (not an integer)");
                offset >>>= 0;
                if (offset < 0 || offset + length > this.buffer.byteLength)
                    throw RangeError("Illegal offset: 0 <= "+offset+" (+"+length+") <= "+this.buffer.byteLength);
            }
            var k = offset + length;
            utfx.decodeUTF8toUTF16(function() {
                return offset < k ? this.view[offset++] : null;
            }.bind(this), sd = stringDestination(), this.noAssert);
            if (offset !== k)
                throw RangeError("Illegal range: Truncated data, "+offset+" == "+k);
            if (relative) {
                this.offset = offset;
                return sd();
            } else {
                return {
                    'string': sd(),
                    'length': offset - start
                };
            }
        } else
            throw TypeError("Unsupported metrics: "+metrics);
    };

    /**
     * Reads an UTF8 encoded string. This is an alias of {@link ByteBuffer#readUTF8String}.
     * @function
     * @param {number} length Number of characters or bytes to read
     * @param {number=} metrics Metrics specifying what `n` is meant to count. Defaults to
     *  {@link ByteBuffer.METRICS_CHARS}.
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  read if omitted.
     * @returns {string|!{string: string, length: number}} The string read if offset is omitted, else the string
     *  read and the actual number of bytes read.
     * @expose
     */
    ByteBufferPrototype.readString = ByteBufferPrototype.readUTF8String;

    // types/strings/vstring

    /**
     * Writes a length as varint32 prefixed UTF8 encoded string.
     * @param {string} str String to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  written if omitted.
     * @returns {!ByteBuffer|number} `this` if `offset` is omitted, else the actual number of bytes written
     * @expose
     * @see ByteBuffer#writeVarint32
     */
    ByteBufferPrototype.writeVString = function(str, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof str !== 'string')
                throw TypeError("Illegal str: Not a string");
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        var start = offset,
            k, l;
        k = utfx.calculateUTF16asUTF8(stringSource(str), this.noAssert)[1];
        l = ByteBuffer.calculateVarint32(k);
        offset += l+k;
        var capacity15 = this.buffer.byteLength;
        if (offset > capacity15)
            this.resize((capacity15 *= 2) > offset ? capacity15 : offset);
        offset -= l+k;
        offset += this.writeVarint32(k, offset);
        utfx.encodeUTF16toUTF8(stringSource(str), function(b) {
            this.view[offset++] = b;
        }.bind(this));
        if (offset !== start+k+l)
            throw RangeError("Illegal range: Truncated data, "+offset+" == "+(offset+k+l));
        if (relative) {
            this.offset = offset;
            return this;
        }
        return offset - start;
    };

    /**
     * Reads a length as varint32 prefixed UTF8 encoded string.
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  read if omitted.
     * @returns {string|!{string: string, length: number}} The string read if offset is omitted, else the string
     *  read and the actual number of bytes read.
     * @expose
     * @see ByteBuffer#readVarint32
     */
    ByteBufferPrototype.readVString = function(offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 1 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+1+") <= "+this.buffer.byteLength);
        }
        var temp = this.readVarint32(offset),
            start = offset,
            str;
        offset += temp['length'];
        temp = temp['value'];
        var k = offset + temp,
            sd = stringDestination();
        utfx.decodeUTF8toUTF16(function() {
            return offset < k ? this.view[offset++] : null;
        }.bind(this), sd, this.noAssert);
        str = sd();
        if (relative) {
            this.offset = offset;
            return str;
        } else {
            return {
                'string': str,
                'length': offset - start
            };
        }
    };


    /**
     * Appends some data to this ByteBuffer. This will overwrite any contents behind the specified offset up to the appended
     *  data's length.
     * @param {!ByteBuffer|!ArrayBuffer|!Uint8Array|string} source Data to append. If `source` is a ByteBuffer, its offsets
     *  will be modified according to the performed read operation.
     * @param {(string|number)=} encoding Encoding if `data` is a string ("base64", "hex", "binary", defaults to "utf8")
     * @param {number=} offset Offset to append at. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  written if omitted.
     * @returns {!ByteBuffer} this
     * @expose
     * @example A relative `<01 02>03.append(<04 05>)` will result in `<01 02 04 05>, 04 05|`
     * @example An absolute `<01 02>03.append(04 05>, 1)` will result in `<01 04>05, 04 05|`
     */
    ByteBufferPrototype.append = function(source, encoding, offset) {
        if (typeof encoding === 'number' || typeof encoding !== 'string') {
            offset = encoding;
            encoding = undefined;
        }
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        if (!(source instanceof ByteBuffer))
            source = ByteBuffer.wrap(source, encoding);
        var length = source.limit - source.offset;
        if (length <= 0) return this; // Nothing to append
        offset += length;
        var capacity16 = this.buffer.byteLength;
        if (offset > capacity16)
            this.resize((capacity16 *= 2) > offset ? capacity16 : offset);
        offset -= length;
        this.view.set(source.view.subarray(source.offset, source.limit), offset);
        source.offset += length;
        if (relative) this.offset += length;
        return this;
    };

    /**
     * Appends this ByteBuffer's contents to another ByteBuffer. This will overwrite any contents at and after the
        specified offset up to the length of this ByteBuffer's data.
     * @param {!ByteBuffer} target Target ByteBuffer
     * @param {number=} offset Offset to append to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  read if omitted.
     * @returns {!ByteBuffer} this
     * @expose
     * @see ByteBuffer#append
     */
    ByteBufferPrototype.appendTo = function(target, offset) {
        target.append(this, offset);
        return this;
    };

    /**
     * Enables or disables assertions of argument types and offsets. Assertions are enabled by default but you can opt to
     *  disable them if your code already makes sure that everything is valid.
     * @param {boolean} assert `true` to enable assertions, otherwise `false`
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.assert = function(assert) {
        this.noAssert = !assert;
        return this;
    };

    /**
     * Gets the capacity of this ByteBuffer's backing buffer.
     * @returns {number} Capacity of the backing buffer
     * @expose
     */
    ByteBufferPrototype.capacity = function() {
        return this.buffer.byteLength;
    };
    /**
     * Clears this ByteBuffer's offsets by setting {@link ByteBuffer#offset} to `0` and {@link ByteBuffer#limit} to the
     *  backing buffer's capacity. Discards {@link ByteBuffer#markedOffset}.
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.clear = function() {
        this.offset = 0;
        this.limit = this.buffer.byteLength;
        this.markedOffset = -1;
        return this;
    };

    /**
     * Creates a cloned instance of this ByteBuffer, preset with this ByteBuffer's values for {@link ByteBuffer#offset},
     *  {@link ByteBuffer#markedOffset} and {@link ByteBuffer#limit}.
     * @param {boolean=} copy Whether to copy the backing buffer or to return another view on the same, defaults to `false`
     * @returns {!ByteBuffer} Cloned instance
     * @expose
     */
    ByteBufferPrototype.clone = function(copy) {
        var bb = new ByteBuffer(0, this.littleEndian, this.noAssert);
        if (copy) {
            bb.buffer = new ArrayBuffer(this.buffer.byteLength);
            bb.view = new Uint8Array(bb.buffer);
        } else {
            bb.buffer = this.buffer;
            bb.view = this.view;
        }
        bb.offset = this.offset;
        bb.markedOffset = this.markedOffset;
        bb.limit = this.limit;
        return bb;
    };

    /**
     * Compacts this ByteBuffer to be backed by a {@link ByteBuffer#buffer} of its contents' length. Contents are the bytes
     *  between {@link ByteBuffer#offset} and {@link ByteBuffer#limit}. Will set `offset = 0` and `limit = capacity` and
     *  adapt {@link ByteBuffer#markedOffset} to the same relative position if set.
     * @param {number=} begin Offset to start at, defaults to {@link ByteBuffer#offset}
     * @param {number=} end Offset to end at, defaults to {@link ByteBuffer#limit}
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.compact = function(begin, end) {
        if (typeof begin === 'undefined') begin = this.offset;
        if (typeof end === 'undefined') end = this.limit;
        if (!this.noAssert) {
            if (typeof begin !== 'number' || begin % 1 !== 0)
                throw TypeError("Illegal begin: Not an integer");
            begin >>>= 0;
            if (typeof end !== 'number' || end % 1 !== 0)
                throw TypeError("Illegal end: Not an integer");
            end >>>= 0;
            if (begin < 0 || begin > end || end > this.buffer.byteLength)
                throw RangeError("Illegal range: 0 <= "+begin+" <= "+end+" <= "+this.buffer.byteLength);
        }
        if (begin === 0 && end === this.buffer.byteLength)
            return this; // Already compacted
        var len = end - begin;
        if (len === 0) {
            this.buffer = EMPTY_BUFFER;
            this.view = null;
            if (this.markedOffset >= 0) this.markedOffset -= begin;
            this.offset = 0;
            this.limit = 0;
            return this;
        }
        var buffer = new ArrayBuffer(len);
        var view = new Uint8Array(buffer);
        view.set(this.view.subarray(begin, end));
        this.buffer = buffer;
        this.view = view;
        if (this.markedOffset >= 0) this.markedOffset -= begin;
        this.offset = 0;
        this.limit = len;
        return this;
    };

    /**
     * Creates a copy of this ByteBuffer's contents. Contents are the bytes between {@link ByteBuffer#offset} and
     *  {@link ByteBuffer#limit}.
     * @param {number=} begin Begin offset, defaults to {@link ByteBuffer#offset}.
     * @param {number=} end End offset, defaults to {@link ByteBuffer#limit}.
     * @returns {!ByteBuffer} Copy
     * @expose
     */
    ByteBufferPrototype.copy = function(begin, end) {
        if (typeof begin === 'undefined') begin = this.offset;
        if (typeof end === 'undefined') end = this.limit;
        if (!this.noAssert) {
            if (typeof begin !== 'number' || begin % 1 !== 0)
                throw TypeError("Illegal begin: Not an integer");
            begin >>>= 0;
            if (typeof end !== 'number' || end % 1 !== 0)
                throw TypeError("Illegal end: Not an integer");
            end >>>= 0;
            if (begin < 0 || begin > end || end > this.buffer.byteLength)
                throw RangeError("Illegal range: 0 <= "+begin+" <= "+end+" <= "+this.buffer.byteLength);
        }
        if (begin === end)
            return new ByteBuffer(0, this.littleEndian, this.noAssert);
        var capacity = end - begin,
            bb = new ByteBuffer(capacity, this.littleEndian, this.noAssert);
        bb.offset = 0;
        bb.limit = capacity;
        if (bb.markedOffset >= 0) bb.markedOffset -= begin;
        this.copyTo(bb, 0, begin, end);
        return bb;
    };

    /**
     * Copies this ByteBuffer's contents to another ByteBuffer. Contents are the bytes between {@link ByteBuffer#offset} and
     *  {@link ByteBuffer#limit}.
     * @param {!ByteBuffer} target Target ByteBuffer
     * @param {number=} targetOffset Offset to copy to. Will use and increase the target's {@link ByteBuffer#offset}
     *  by the number of bytes copied if omitted.
     * @param {number=} sourceOffset Offset to start copying from. Will use and increase {@link ByteBuffer#offset} by the
     *  number of bytes copied if omitted.
     * @param {number=} sourceLimit Offset to end copying from, defaults to {@link ByteBuffer#limit}
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.copyTo = function(target, targetOffset, sourceOffset, sourceLimit) {
        var relative,
            targetRelative;
        if (!this.noAssert) {
            if (!ByteBuffer.isByteBuffer(target))
                throw TypeError("Illegal target: Not a ByteBuffer");
        }
        targetOffset = (targetRelative = typeof targetOffset === 'undefined') ? target.offset : targetOffset | 0;
        sourceOffset = (relative = typeof sourceOffset === 'undefined') ? this.offset : sourceOffset | 0;
        sourceLimit = typeof sourceLimit === 'undefined' ? this.limit : sourceLimit | 0;

        if (targetOffset < 0 || targetOffset > target.buffer.byteLength)
            throw RangeError("Illegal target range: 0 <= "+targetOffset+" <= "+target.buffer.byteLength);
        if (sourceOffset < 0 || sourceLimit > this.buffer.byteLength)
            throw RangeError("Illegal source range: 0 <= "+sourceOffset+" <= "+this.buffer.byteLength);

        var len = sourceLimit - sourceOffset;
        if (len === 0)
            return target; // Nothing to copy

        target.ensureCapacity(targetOffset + len);

        target.view.set(this.view.subarray(sourceOffset, sourceLimit), targetOffset);

        if (relative) this.offset += len;
        if (targetRelative) target.offset += len;

        return this;
    };

    /**
     * Makes sure that this ByteBuffer is backed by a {@link ByteBuffer#buffer} of at least the specified capacity. If the
     *  current capacity is exceeded, it will be doubled. If double the current capacity is less than the required capacity,
     *  the required capacity will be used instead.
     * @param {number} capacity Required capacity
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.ensureCapacity = function(capacity) {
        var current = this.buffer.byteLength;
        if (current < capacity)
            return this.resize((current *= 2) > capacity ? current : capacity);
        return this;
    };

    /**
     * Overwrites this ByteBuffer's contents with the specified value. Contents are the bytes between
     *  {@link ByteBuffer#offset} and {@link ByteBuffer#limit}.
     * @param {number|string} value Byte value to fill with. If given as a string, the first character is used.
     * @param {number=} begin Begin offset. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  written if omitted. defaults to {@link ByteBuffer#offset}.
     * @param {number=} end End offset, defaults to {@link ByteBuffer#limit}.
     * @returns {!ByteBuffer} this
     * @expose
     * @example `someByteBuffer.clear().fill(0)` fills the entire backing buffer with zeroes
     */
    ByteBufferPrototype.fill = function(value, begin, end) {
        var relative = typeof begin === 'undefined';
        if (relative) begin = this.offset;
        if (typeof value === 'string' && value.length > 0)
            value = value.charCodeAt(0);
        if (typeof begin === 'undefined') begin = this.offset;
        if (typeof end === 'undefined') end = this.limit;
        if (!this.noAssert) {
            if (typeof value !== 'number' || value % 1 !== 0)
                throw TypeError("Illegal value: "+value+" (not an integer)");
            value |= 0;
            if (typeof begin !== 'number' || begin % 1 !== 0)
                throw TypeError("Illegal begin: Not an integer");
            begin >>>= 0;
            if (typeof end !== 'number' || end % 1 !== 0)
                throw TypeError("Illegal end: Not an integer");
            end >>>= 0;
            if (begin < 0 || begin > end || end > this.buffer.byteLength)
                throw RangeError("Illegal range: 0 <= "+begin+" <= "+end+" <= "+this.buffer.byteLength);
        }
        if (begin >= end)
            return this; // Nothing to fill
        while (begin < end) this.view[begin++] = value;
        if (relative) this.offset = begin;
        return this;
    };

    /**
     * Makes this ByteBuffer ready for a new sequence of write or relative read operations. Sets `limit = offset` and
     *  `offset = 0`. Make sure always to flip a ByteBuffer when all relative read or write operations are complete.
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.flip = function() {
        this.limit = this.offset;
        this.offset = 0;
        return this;
    };
    /**
     * Marks an offset on this ByteBuffer to be used later.
     * @param {number=} offset Offset to mark. Defaults to {@link ByteBuffer#offset}.
     * @returns {!ByteBuffer} this
     * @throws {TypeError} If `offset` is not a valid number
     * @throws {RangeError} If `offset` is out of bounds
     * @see ByteBuffer#reset
     * @expose
     */
    ByteBufferPrototype.mark = function(offset) {
        offset = typeof offset === 'undefined' ? this.offset : offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        this.markedOffset = offset;
        return this;
    };
    /**
     * Sets the byte order.
     * @param {boolean} littleEndian `true` for little endian byte order, `false` for big endian
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.order = function(littleEndian) {
        if (!this.noAssert) {
            if (typeof littleEndian !== 'boolean')
                throw TypeError("Illegal littleEndian: Not a boolean");
        }
        this.littleEndian = !!littleEndian;
        return this;
    };

    /**
     * Switches (to) little endian byte order.
     * @param {boolean=} littleEndian Defaults to `true`, otherwise uses big endian
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.LE = function(littleEndian) {
        this.littleEndian = typeof littleEndian !== 'undefined' ? !!littleEndian : true;
        return this;
    };

    /**
     * Switches (to) big endian byte order.
     * @param {boolean=} bigEndian Defaults to `true`, otherwise uses little endian
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.BE = function(bigEndian) {
        this.littleEndian = typeof bigEndian !== 'undefined' ? !bigEndian : false;
        return this;
    };
    /**
     * Prepends some data to this ByteBuffer. This will overwrite any contents before the specified offset up to the
     *  prepended data's length. If there is not enough space available before the specified `offset`, the backing buffer
     *  will be resized and its contents moved accordingly.
     * @param {!ByteBuffer|string|!ArrayBuffer} source Data to prepend. If `source` is a ByteBuffer, its offset will be
     *  modified according to the performed read operation.
     * @param {(string|number)=} encoding Encoding if `data` is a string ("base64", "hex", "binary", defaults to "utf8")
     * @param {number=} offset Offset to prepend at. Will use and decrease {@link ByteBuffer#offset} by the number of bytes
     *  prepended if omitted.
     * @returns {!ByteBuffer} this
     * @expose
     * @example A relative `00<01 02 03>.prepend(<04 05>)` results in `<04 05 01 02 03>, 04 05|`
     * @example An absolute `00<01 02 03>.prepend(<04 05>, 2)` results in `04<05 02 03>, 04 05|`
     */
    ByteBufferPrototype.prepend = function(source, encoding, offset) {
        if (typeof encoding === 'number' || typeof encoding !== 'string') {
            offset = encoding;
            encoding = undefined;
        }
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        if (!(source instanceof ByteBuffer))
            source = ByteBuffer.wrap(source, encoding);
        var len = source.limit - source.offset;
        if (len <= 0) return this; // Nothing to prepend
        var diff = len - offset;
        if (diff > 0) { // Not enough space before offset, so resize + move
            var buffer = new ArrayBuffer(this.buffer.byteLength + diff);
            var view = new Uint8Array(buffer);
            view.set(this.view.subarray(offset, this.buffer.byteLength), len);
            this.buffer = buffer;
            this.view = view;
            this.offset += diff;
            if (this.markedOffset >= 0) this.markedOffset += diff;
            this.limit += diff;
            offset += diff;
        } else {
            var arrayView = new Uint8Array(this.buffer);
        }
        this.view.set(source.view.subarray(source.offset, source.limit), offset - len);

        source.offset = source.limit;
        if (relative)
            this.offset -= len;
        return this;
    };

    /**
     * Prepends this ByteBuffer to another ByteBuffer. This will overwrite any contents before the specified offset up to the
     *  prepended data's length. If there is not enough space available before the specified `offset`, the backing buffer
     *  will be resized and its contents moved accordingly.
     * @param {!ByteBuffer} target Target ByteBuffer
     * @param {number=} offset Offset to prepend at. Will use and decrease {@link ByteBuffer#offset} by the number of bytes
     *  prepended if omitted.
     * @returns {!ByteBuffer} this
     * @expose
     * @see ByteBuffer#prepend
     */
    ByteBufferPrototype.prependTo = function(target, offset) {
        target.prepend(this, offset);
        return this;
    };
    /**
     * Prints debug information about this ByteBuffer's contents.
     * @param {function(string)=} out Output function to call, defaults to console.log
     * @expose
     */
    ByteBufferPrototype.printDebug = function(out) {
        if (typeof out !== 'function') out = console.log.bind(console);
        out(
            this.toString()+"\n"+
            "-------------------------------------------------------------------\n"+
            this.toDebug(/* columns */ true)
        );
    };

    /**
     * Gets the number of remaining readable bytes. Contents are the bytes between {@link ByteBuffer#offset} and
     *  {@link ByteBuffer#limit}, so this returns `limit - offset`.
     * @returns {number} Remaining readable bytes. May be negative if `offset > limit`.
     * @expose
     */
    ByteBufferPrototype.remaining = function() {
        return this.limit - this.offset;
    };
    /**
     * Resets this ByteBuffer's {@link ByteBuffer#offset}. If an offset has been marked through {@link ByteBuffer#mark}
     *  before, `offset` will be set to {@link ByteBuffer#markedOffset}, which will then be discarded. If no offset has been
     *  marked, sets `offset = 0`.
     * @returns {!ByteBuffer} this
     * @see ByteBuffer#mark
     * @expose
     */
    ByteBufferPrototype.reset = function() {
        if (this.markedOffset >= 0) {
            this.offset = this.markedOffset;
            this.markedOffset = -1;
        } else {
            this.offset = 0;
        }
        return this;
    };
    /**
     * Resizes this ByteBuffer to be backed by a buffer of at least the given capacity. Will do nothing if already that
     *  large or larger.
     * @param {number} capacity Capacity required
     * @returns {!ByteBuffer} this
     * @throws {TypeError} If `capacity` is not a number
     * @throws {RangeError} If `capacity < 0`
     * @expose
     */
    ByteBufferPrototype.resize = function(capacity) {
        if (!this.noAssert) {
            if (typeof capacity !== 'number' || capacity % 1 !== 0)
                throw TypeError("Illegal capacity: "+capacity+" (not an integer)");
            capacity |= 0;
            if (capacity < 0)
                throw RangeError("Illegal capacity: 0 <= "+capacity);
        }
        if (this.buffer.byteLength < capacity) {
            var buffer = new ArrayBuffer(capacity);
            var view = new Uint8Array(buffer);
            view.set(this.view);
            this.buffer = buffer;
            this.view = view;
        }
        return this;
    };
    /**
     * Reverses this ByteBuffer's contents.
     * @param {number=} begin Offset to start at, defaults to {@link ByteBuffer#offset}
     * @param {number=} end Offset to end at, defaults to {@link ByteBuffer#limit}
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.reverse = function(begin, end) {
        if (typeof begin === 'undefined') begin = this.offset;
        if (typeof end === 'undefined') end = this.limit;
        if (!this.noAssert) {
            if (typeof begin !== 'number' || begin % 1 !== 0)
                throw TypeError("Illegal begin: Not an integer");
            begin >>>= 0;
            if (typeof end !== 'number' || end % 1 !== 0)
                throw TypeError("Illegal end: Not an integer");
            end >>>= 0;
            if (begin < 0 || begin > end || end > this.buffer.byteLength)
                throw RangeError("Illegal range: 0 <= "+begin+" <= "+end+" <= "+this.buffer.byteLength);
        }
        if (begin === end)
            return this; // Nothing to reverse
        Array.prototype.reverse.call(this.view.subarray(begin, end));
        return this;
    };
    /**
     * Skips the next `length` bytes. This will just advance
     * @param {number} length Number of bytes to skip. May also be negative to move the offset back.
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.skip = function(length) {
        if (!this.noAssert) {
            if (typeof length !== 'number' || length % 1 !== 0)
                throw TypeError("Illegal length: "+length+" (not an integer)");
            length |= 0;
        }
        var offset = this.offset + length;
        if (!this.noAssert) {
            if (offset < 0 || offset > this.buffer.byteLength)
                throw RangeError("Illegal length: 0 <= "+this.offset+" + "+length+" <= "+this.buffer.byteLength);
        }
        this.offset = offset;
        return this;
    };

    /**
     * Slices this ByteBuffer by creating a cloned instance with `offset = begin` and `limit = end`.
     * @param {number=} begin Begin offset, defaults to {@link ByteBuffer#offset}.
     * @param {number=} end End offset, defaults to {@link ByteBuffer#limit}.
     * @returns {!ByteBuffer} Clone of this ByteBuffer with slicing applied, backed by the same {@link ByteBuffer#buffer}
     * @expose
     */
    ByteBufferPrototype.slice = function(begin, end) {
        if (typeof begin === 'undefined') begin = this.offset;
        if (typeof end === 'undefined') end = this.limit;
        if (!this.noAssert) {
            if (typeof begin !== 'number' || begin % 1 !== 0)
                throw TypeError("Illegal begin: Not an integer");
            begin >>>= 0;
            if (typeof end !== 'number' || end % 1 !== 0)
                throw TypeError("Illegal end: Not an integer");
            end >>>= 0;
            if (begin < 0 || begin > end || end > this.buffer.byteLength)
                throw RangeError("Illegal range: 0 <= "+begin+" <= "+end+" <= "+this.buffer.byteLength);
        }
        var bb = this.clone();
        bb.offset = begin;
        bb.limit = end;
        return bb;
    };
    /**
     * Returns a copy of the backing buffer that contains this ByteBuffer's contents. Contents are the bytes between
     *  {@link ByteBuffer#offset} and {@link ByteBuffer#limit}.
     * @param {boolean=} forceCopy If `true` returns a copy, otherwise returns a view referencing the same memory if
     *  possible. Defaults to `false`
     * @returns {!ArrayBuffer} Contents as an ArrayBuffer
     * @expose
     */
    ByteBufferPrototype.toBuffer = function(forceCopy) {
        var offset = this.offset,
            limit = this.limit;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: Not an integer");
            offset >>>= 0;
            if (typeof limit !== 'number' || limit % 1 !== 0)
                throw TypeError("Illegal limit: Not an integer");
            limit >>>= 0;
            if (offset < 0 || offset > limit || limit > this.buffer.byteLength)
                throw RangeError("Illegal range: 0 <= "+offset+" <= "+limit+" <= "+this.buffer.byteLength);
        }
        // NOTE: It's not possible to have another ArrayBuffer reference the same memory as the backing buffer. This is
        // possible with Uint8Array#subarray only, but we have to return an ArrayBuffer by contract. So:
        if (!forceCopy && offset === 0 && limit === this.buffer.byteLength)
            return this.buffer;
        if (offset === limit)
            return EMPTY_BUFFER;
        var buffer = new ArrayBuffer(limit - offset);
        new Uint8Array(buffer).set(new Uint8Array(this.buffer).subarray(offset, limit), 0);
        return buffer;
    };

    /**
     * Returns a raw buffer compacted to contain this ByteBuffer's contents. Contents are the bytes between
     *  {@link ByteBuffer#offset} and {@link ByteBuffer#limit}. This is an alias of {@link ByteBuffer#toBuffer}.
     * @function
     * @param {boolean=} forceCopy If `true` returns a copy, otherwise returns a view referencing the same memory.
     *  Defaults to `false`
     * @returns {!ArrayBuffer} Contents as an ArrayBuffer
     * @expose
     */
    ByteBufferPrototype.toArrayBuffer = ByteBufferPrototype.toBuffer;

    /**
     * Converts the ByteBuffer's contents to a string.
     * @param {string=} encoding Output encoding. Returns an informative string representation if omitted but also allows
     *  direct conversion to "utf8", "hex", "base64" and "binary" encoding. "debug" returns a hex representation with
     *  highlighted offsets.
     * @param {number=} begin Offset to begin at, defaults to {@link ByteBuffer#offset}
     * @param {number=} end Offset to end at, defaults to {@link ByteBuffer#limit}
     * @returns {string} String representation
     * @throws {Error} If `encoding` is invalid
     * @expose
     */
    ByteBufferPrototype.toString = function(encoding, begin, end) {
        if (typeof encoding === 'undefined')
            return "ByteBufferAB(offset="+this.offset+",markedOffset="+this.markedOffset+",limit="+this.limit+",capacity="+this.capacity()+")";
        if (typeof encoding === 'number')
            encoding = "utf8",
            begin = encoding,
            end = begin;
        switch (encoding) {
            case "utf8":
                return this.toUTF8(begin, end);
            case "base64":
                return this.toBase64(begin, end);
            case "hex":
                return this.toHex(begin, end);
            case "binary":
                return this.toBinary(begin, end);
            case "debug":
                return this.toDebug();
            case "columns":
                return this.toColumns();
            default:
                throw Error("Unsupported encoding: "+encoding);
        }
    };

    // lxiv-embeddable

    /**
     * lxiv-embeddable (c) 2014 Daniel Wirtz <dcode@dcode.io>
     * Released under the Apache License, Version 2.0
     * see: https://github.com/dcodeIO/lxiv for details
     */
    var lxiv = function() {
        "use strict";

        /**
         * lxiv namespace.
         * @type {!Object.<string,*>}
         * @exports lxiv
         */
        var lxiv = {};

        /**
         * Character codes for output.
         * @type {!Array.<number>}
         * @inner
         */
        var aout = [
            65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80,
            81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 97, 98, 99, 100, 101, 102,
            103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118,
            119, 120, 121, 122, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 43, 47
        ];

        /**
         * Character codes for input.
         * @type {!Array.<number>}
         * @inner
         */
        var ain = [];
        for (var i=0, k=aout.length; i<k; ++i)
            ain[aout[i]] = i;

        /**
         * Encodes bytes to base64 char codes.
         * @param {!function():number|null} src Bytes source as a function returning the next byte respectively `null` if
         *  there are no more bytes left.
         * @param {!function(number)} dst Characters destination as a function successively called with each encoded char
         *  code.
         */
        lxiv.encode = function(src, dst) {
            var b, t;
            while ((b = src()) !== null) {
                dst(aout[(b>>2)&0x3f]);
                t = (b&0x3)<<4;
                if ((b = src()) !== null) {
                    t |= (b>>4)&0xf;
                    dst(aout[(t|((b>>4)&0xf))&0x3f]);
                    t = (b&0xf)<<2;
                    if ((b = src()) !== null)
                        dst(aout[(t|((b>>6)&0x3))&0x3f]),
                        dst(aout[b&0x3f]);
                    else
                        dst(aout[t&0x3f]),
                        dst(61);
                } else
                    dst(aout[t&0x3f]),
                    dst(61),
                    dst(61);
            }
        };

        /**
         * Decodes base64 char codes to bytes.
         * @param {!function():number|null} src Characters source as a function returning the next char code respectively
         *  `null` if there are no more characters left.
         * @param {!function(number)} dst Bytes destination as a function successively called with the next byte.
         * @throws {Error} If a character code is invalid
         */
        lxiv.decode = function(src, dst) {
            var c, t1, t2;
            function fail(c) {
                throw Error("Illegal character code: "+c);
            }
            while ((c = src()) !== null) {
                t1 = ain[c];
                if (typeof t1 === 'undefined') fail(c);
                if ((c = src()) !== null) {
                    t2 = ain[c];
                    if (typeof t2 === 'undefined') fail(c);
                    dst((t1<<2)>>>0|(t2&0x30)>>4);
                    if ((c = src()) !== null) {
                        t1 = ain[c];
                        if (typeof t1 === 'undefined')
                            if (c === 61) break; else fail(c);
                        dst(((t2&0xf)<<4)>>>0|(t1&0x3c)>>2);
                        if ((c = src()) !== null) {
                            t2 = ain[c];
                            if (typeof t2 === 'undefined')
                                if (c === 61) break; else fail(c);
                            dst(((t1&0x3)<<6)>>>0|t2);
                        }
                    }
                }
            }
        };

        /**
         * Tests if a string is valid base64.
         * @param {string} str String to test
         * @returns {boolean} `true` if valid, otherwise `false`
         */
        lxiv.test = function(str) {
            return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(str);
        };

        return lxiv;
    }();

    // encodings/base64

    /**
     * Encodes this ByteBuffer's contents to a base64 encoded string.
     * @param {number=} begin Offset to begin at, defaults to {@link ByteBuffer#offset}.
     * @param {number=} end Offset to end at, defaults to {@link ByteBuffer#limit}.
     * @returns {string} Base64 encoded string
     * @throws {RangeError} If `begin` or `end` is out of bounds
     * @expose
     */
    ByteBufferPrototype.toBase64 = function(begin, end) {
        if (typeof begin === 'undefined')
            begin = this.offset;
        if (typeof end === 'undefined')
            end = this.limit;
        begin = begin | 0; end = end | 0;
        if (begin < 0 || end > this.capacity || begin > end)
            throw RangeError("begin, end");
        var sd; lxiv.encode(function() {
            return begin < end ? this.view[begin++] : null;
        }.bind(this), sd = stringDestination());
        return sd();
    };

    /**
     * Decodes a base64 encoded string to a ByteBuffer.
     * @param {string} str String to decode
     * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to
     *  {@link ByteBuffer.DEFAULT_ENDIAN}.
     * @returns {!ByteBuffer} ByteBuffer
     * @expose
     */
    ByteBuffer.fromBase64 = function(str, littleEndian) {
        if (typeof str !== 'string')
            throw TypeError("str");
        var bb = new ByteBuffer(str.length/4*3, littleEndian),
            i = 0;
        lxiv.decode(stringSource(str), function(b) {
            bb.view[i++] = b;
        });
        bb.limit = i;
        return bb;
    };

    /**
     * Encodes a binary string to base64 like `window.btoa` does.
     * @param {string} str Binary string
     * @returns {string} Base64 encoded string
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Window.btoa
     * @expose
     */
    ByteBuffer.btoa = function(str) {
        return ByteBuffer.fromBinary(str).toBase64();
    };

    /**
     * Decodes a base64 encoded string to binary like `window.atob` does.
     * @param {string} b64 Base64 encoded string
     * @returns {string} Binary string
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Window.atob
     * @expose
     */
    ByteBuffer.atob = function(b64) {
        return ByteBuffer.fromBase64(b64).toBinary();
    };

    // encodings/binary

    /**
     * Encodes this ByteBuffer to a binary encoded string, that is using only characters 0x00-0xFF as bytes.
     * @param {number=} begin Offset to begin at. Defaults to {@link ByteBuffer#offset}.
     * @param {number=} end Offset to end at. Defaults to {@link ByteBuffer#limit}.
     * @returns {string} Binary encoded string
     * @throws {RangeError} If `offset > limit`
     * @expose
     */
    ByteBufferPrototype.toBinary = function(begin, end) {
        if (typeof begin === 'undefined')
            begin = this.offset;
        if (typeof end === 'undefined')
            end = this.limit;
        begin |= 0; end |= 0;
        if (begin < 0 || end > this.capacity() || begin > end)
            throw RangeError("begin, end");
        if (begin === end)
            return "";
        var chars = [],
            parts = [];
        while (begin < end) {
            chars.push(this.view[begin++]);
            if (chars.length >= 1024)
                parts.push(String.fromCharCode.apply(String, chars)),
                chars = [];
        }
        return parts.join('') + String.fromCharCode.apply(String, chars);
    };

    /**
     * Decodes a binary encoded string, that is using only characters 0x00-0xFF as bytes, to a ByteBuffer.
     * @param {string} str String to decode
     * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to
     *  {@link ByteBuffer.DEFAULT_ENDIAN}.
     * @returns {!ByteBuffer} ByteBuffer
     * @expose
     */
    ByteBuffer.fromBinary = function(str, littleEndian) {
        if (typeof str !== 'string')
            throw TypeError("str");
        var i = 0,
            k = str.length,
            charCode,
            bb = new ByteBuffer(k, littleEndian);
        while (i<k) {
            charCode = str.charCodeAt(i);
            if (charCode > 0xff)
                throw RangeError("illegal char code: "+charCode);
            bb.view[i++] = charCode;
        }
        bb.limit = k;
        return bb;
    };

    // encodings/debug

    /**
     * Encodes this ByteBuffer to a hex encoded string with marked offsets. Offset symbols are:
     * * `<` : offset,
     * * `'` : markedOffset,
     * * `>` : limit,
     * * `|` : offset and limit,
     * * `[` : offset and markedOffset,
     * * `]` : markedOffset and limit,
     * * `!` : offset, markedOffset and limit
     * @param {boolean=} columns If `true` returns two columns hex + ascii, defaults to `false`
     * @returns {string|!Array.<string>} Debug string or array of lines if `asArray = true`
     * @expose
     * @example `>00'01 02<03` contains four bytes with `limit=0, markedOffset=1, offset=3`
     * @example `00[01 02 03>` contains four bytes with `offset=markedOffset=1, limit=4`
     * @example `00|01 02 03` contains four bytes with `offset=limit=1, markedOffset=-1`
     * @example `|` contains zero bytes with `offset=limit=0, markedOffset=-1`
     */
    ByteBufferPrototype.toDebug = function(columns) {
        var i = -1,
            k = this.buffer.byteLength,
            b,
            hex = "",
            asc = "",
            out = "";
        while (i<k) {
            if (i !== -1) {
                b = this.view[i];
                if (b < 0x10) hex += "0"+b.toString(16).toUpperCase();
                else hex += b.toString(16).toUpperCase();
                if (columns)
                    asc += b > 32 && b < 127 ? String.fromCharCode(b) : '.';
            }
            ++i;
            if (columns) {
                if (i > 0 && i % 16 === 0 && i !== k) {
                    while (hex.length < 3*16+3) hex += " ";
                    out += hex+asc+"\n";
                    hex = asc = "";
                }
            }
            if (i === this.offset && i === this.limit)
                hex += i === this.markedOffset ? "!" : "|";
            else if (i === this.offset)
                hex += i === this.markedOffset ? "[" : "<";
            else if (i === this.limit)
                hex += i === this.markedOffset ? "]" : ">";
            else
                hex += i === this.markedOffset ? "'" : (columns || (i !== 0 && i !== k) ? " " : "");
        }
        if (columns && hex !== " ") {
            while (hex.length < 3*16+3)
                hex += " ";
            out += hex + asc + "\n";
        }
        return columns ? out : hex;
    };

    /**
     * Decodes a hex encoded string with marked offsets to a ByteBuffer.
     * @param {string} str Debug string to decode (not be generated with `columns = true`)
     * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to
     *  {@link ByteBuffer.DEFAULT_ENDIAN}.
     * @param {boolean=} noAssert Whether to skip assertions of offsets and values. Defaults to
     *  {@link ByteBuffer.DEFAULT_NOASSERT}.
     * @returns {!ByteBuffer} ByteBuffer
     * @expose
     * @see ByteBuffer#toDebug
     */
    ByteBuffer.fromDebug = function(str, littleEndian, noAssert) {
        var k = str.length,
            bb = new ByteBuffer(((k+1)/3)|0, littleEndian, noAssert);
        var i = 0, j = 0, ch, b,
            rs = false, // Require symbol next
            ho = false, hm = false, hl = false, // Already has offset (ho), markedOffset (hm), limit (hl)?
            fail = false;
        while (i<k) {
            switch (ch = str.charAt(i++)) {
                case '!':
                    if (!noAssert) {
                        if (ho || hm || hl) {
                            fail = true;
                            break;
                        }
                        ho = hm = hl = true;
                    }
                    bb.offset = bb.markedOffset = bb.limit = j;
                    rs = false;
                    break;
                case '|':
                    if (!noAssert) {
                        if (ho || hl) {
                            fail = true;
                            break;
                        }
                        ho = hl = true;
                    }
                    bb.offset = bb.limit = j;
                    rs = false;
                    break;
                case '[':
                    if (!noAssert) {
                        if (ho || hm) {
                            fail = true;
                            break;
                        }
                        ho = hm = true;
                    }
                    bb.offset = bb.markedOffset = j;
                    rs = false;
                    break;
                case '<':
                    if (!noAssert) {
                        if (ho) {
                            fail = true;
                            break;
                        }
                        ho = true;
                    }
                    bb.offset = j;
                    rs = false;
                    break;
                case ']':
                    if (!noAssert) {
                        if (hl || hm) {
                            fail = true;
                            break;
                        }
                        hl = hm = true;
                    }
                    bb.limit = bb.markedOffset = j;
                    rs = false;
                    break;
                case '>':
                    if (!noAssert) {
                        if (hl) {
                            fail = true;
                            break;
                        }
                        hl = true;
                    }
                    bb.limit = j;
                    rs = false;
                    break;
                case "'":
                    if (!noAssert) {
                        if (hm) {
                            fail = true;
                            break;
                        }
                        hm = true;
                    }
                    bb.markedOffset = j;
                    rs = false;
                    break;
                case ' ':
                    rs = false;
                    break;
                default:
                    if (!noAssert) {
                        if (rs) {
                            fail = true;
                            break;
                        }
                    }
                    b = parseInt(ch+str.charAt(i++), 16);
                    if (!noAssert) {
                        if (isNaN(b) || b < 0 || b > 255)
                            throw TypeError("Illegal str: Not a debug encoded string");
                    }
                    bb.view[j++] = b;
                    rs = true;
            }
            if (fail)
                throw TypeError("Illegal str: Invalid symbol at "+i);
        }
        if (!noAssert) {
            if (!ho || !hl)
                throw TypeError("Illegal str: Missing offset or limit");
            if (j<bb.buffer.byteLength)
                throw TypeError("Illegal str: Not a debug encoded string (is it hex?) "+j+" < "+k);
        }
        return bb;
    };

    // encodings/hex

    /**
     * Encodes this ByteBuffer's contents to a hex encoded string.
     * @param {number=} begin Offset to begin at. Defaults to {@link ByteBuffer#offset}.
     * @param {number=} end Offset to end at. Defaults to {@link ByteBuffer#limit}.
     * @returns {string} Hex encoded string
     * @expose
     */
    ByteBufferPrototype.toHex = function(begin, end) {
        begin = typeof begin === 'undefined' ? this.offset : begin;
        end = typeof end === 'undefined' ? this.limit : end;
        if (!this.noAssert) {
            if (typeof begin !== 'number' || begin % 1 !== 0)
                throw TypeError("Illegal begin: Not an integer");
            begin >>>= 0;
            if (typeof end !== 'number' || end % 1 !== 0)
                throw TypeError("Illegal end: Not an integer");
            end >>>= 0;
            if (begin < 0 || begin > end || end > this.buffer.byteLength)
                throw RangeError("Illegal range: 0 <= "+begin+" <= "+end+" <= "+this.buffer.byteLength);
        }
        var out = new Array(end - begin),
            b;
        while (begin < end) {
            b = this.view[begin++];
            if (b < 0x10)
                out.push("0", b.toString(16));
            else out.push(b.toString(16));
        }
        return out.join('');
    };

    /**
     * Decodes a hex encoded string to a ByteBuffer.
     * @param {string} str String to decode
     * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to
     *  {@link ByteBuffer.DEFAULT_ENDIAN}.
     * @param {boolean=} noAssert Whether to skip assertions of offsets and values. Defaults to
     *  {@link ByteBuffer.DEFAULT_NOASSERT}.
     * @returns {!ByteBuffer} ByteBuffer
     * @expose
     */
    ByteBuffer.fromHex = function(str, littleEndian, noAssert) {
        if (!noAssert) {
            if (typeof str !== 'string')
                throw TypeError("Illegal str: Not a string");
            if (str.length % 2 !== 0)
                throw TypeError("Illegal str: Length not a multiple of 2");
        }
        var k = str.length,
            bb = new ByteBuffer((k / 2) | 0, littleEndian),
            b;
        for (var i=0, j=0; i<k; i+=2) {
            b = parseInt(str.substring(i, i+2), 16);
            if (!noAssert)
                if (!isFinite(b) || b < 0 || b > 255)
                    throw TypeError("Illegal str: Contains non-hex characters");
            bb.view[j++] = b;
        }
        bb.limit = j;
        return bb;
    };

    // utfx-embeddable

    /**
     * utfx-embeddable (c) 2014 Daniel Wirtz <dcode@dcode.io>
     * Released under the Apache License, Version 2.0
     * see: https://github.com/dcodeIO/utfx for details
     */
    var utfx = function() {
        "use strict";

        /**
         * utfx namespace.
         * @inner
         * @type {!Object.<string,*>}
         */
        var utfx = {};

        /**
         * Maximum valid code point.
         * @type {number}
         * @const
         */
        utfx.MAX_CODEPOINT = 0x10FFFF;

        /**
         * Encodes UTF8 code points to UTF8 bytes.
         * @param {(!function():number|null) | number} src Code points source, either as a function returning the next code point
         *  respectively `null` if there are no more code points left or a single numeric code point.
         * @param {!function(number)} dst Bytes destination as a function successively called with the next byte
         */
        utfx.encodeUTF8 = function(src, dst) {
            var cp = null;
            if (typeof src === 'number')
                cp = src,
                src = function() { return null; };
            while (cp !== null || (cp = src()) !== null) {
                if (cp < 0x80)
                    dst(cp&0x7F);
                else if (cp < 0x800)
                    dst(((cp>>6)&0x1F)|0xC0),
                    dst((cp&0x3F)|0x80);
                else if (cp < 0x10000)
                    dst(((cp>>12)&0x0F)|0xE0),
                    dst(((cp>>6)&0x3F)|0x80),
                    dst((cp&0x3F)|0x80);
                else
                    dst(((cp>>18)&0x07)|0xF0),
                    dst(((cp>>12)&0x3F)|0x80),
                    dst(((cp>>6)&0x3F)|0x80),
                    dst((cp&0x3F)|0x80);
                cp = null;
            }
        };

        /**
         * Decodes UTF8 bytes to UTF8 code points.
         * @param {!function():number|null} src Bytes source as a function returning the next byte respectively `null` if there
         *  are no more bytes left.
         * @param {!function(number)} dst Code points destination as a function successively called with each decoded code point.
         * @throws {RangeError} If a starting byte is invalid in UTF8
         * @throws {Error} If the last sequence is truncated. Has an array property `bytes` holding the
         *  remaining bytes.
         */
        utfx.decodeUTF8 = function(src, dst) {
            var a, b, c, d, fail = function(b) {
                b = b.slice(0, b.indexOf(null));
                var err = Error(b.toString());
                err.name = "TruncatedError";
                err['bytes'] = b;
                throw err;
            };
            while ((a = src()) !== null) {
                if ((a&0x80) === 0)
                    dst(a);
                else if ((a&0xE0) === 0xC0)
                    ((b = src()) === null) && fail([a, b]),
                    dst(((a&0x1F)<<6) | (b&0x3F));
                else if ((a&0xF0) === 0xE0)
                    ((b=src()) === null || (c=src()) === null) && fail([a, b, c]),
                    dst(((a&0x0F)<<12) | ((b&0x3F)<<6) | (c&0x3F));
                else if ((a&0xF8) === 0xF0)
                    ((b=src()) === null || (c=src()) === null || (d=src()) === null) && fail([a, b, c ,d]),
                    dst(((a&0x07)<<18) | ((b&0x3F)<<12) | ((c&0x3F)<<6) | (d&0x3F));
                else throw RangeError("Illegal starting byte: "+a);
            }
        };

        /**
         * Converts UTF16 characters to UTF8 code points.
         * @param {!function():number|null} src Characters source as a function returning the next char code respectively
         *  `null` if there are no more characters left.
         * @param {!function(number)} dst Code points destination as a function successively called with each converted code
         *  point.
         */
        utfx.UTF16toUTF8 = function(src, dst) {
            var c1, c2 = null;
            while (true) {
                if ((c1 = c2 !== null ? c2 : src()) === null)
                    break;
                if (c1 >= 0xD800 && c1 <= 0xDFFF) {
                    if ((c2 = src()) !== null) {
                        if (c2 >= 0xDC00 && c2 <= 0xDFFF) {
                            dst((c1-0xD800)*0x400+c2-0xDC00+0x10000);
                            c2 = null; continue;
                        }
                    }
                }
                dst(c1);
            }
            if (c2 !== null) dst(c2);
        };

        /**
         * Converts UTF8 code points to UTF16 characters.
         * @param {(!function():number|null) | number} src Code points source, either as a function returning the next code point
         *  respectively `null` if there are no more code points left or a single numeric code point.
         * @param {!function(number)} dst Characters destination as a function successively called with each converted char code.
         * @throws {RangeError} If a code point is out of range
         */
        utfx.UTF8toUTF16 = function(src, dst) {
            var cp = null;
            if (typeof src === 'number')
                cp = src, src = function() { return null; };
            while (cp !== null || (cp = src()) !== null) {
                if (cp <= 0xFFFF)
                    dst(cp);
                else
                    cp -= 0x10000,
                    dst((cp>>10)+0xD800),
                    dst((cp%0x400)+0xDC00);
                cp = null;
            }
        };

        /**
         * Converts and encodes UTF16 characters to UTF8 bytes.
         * @param {!function():number|null} src Characters source as a function returning the next char code respectively `null`
         *  if there are no more characters left.
         * @param {!function(number)} dst Bytes destination as a function successively called with the next byte.
         */
        utfx.encodeUTF16toUTF8 = function(src, dst) {
            utfx.UTF16toUTF8(src, function(cp) {
                utfx.encodeUTF8(cp, dst);
            });
        };

        /**
         * Decodes and converts UTF8 bytes to UTF16 characters.
         * @param {!function():number|null} src Bytes source as a function returning the next byte respectively `null` if there
         *  are no more bytes left.
         * @param {!function(number)} dst Characters destination as a function successively called with each converted char code.
         * @throws {RangeError} If a starting byte is invalid in UTF8
         * @throws {Error} If the last sequence is truncated. Has an array property `bytes` holding the remaining bytes.
         */
        utfx.decodeUTF8toUTF16 = function(src, dst) {
            utfx.decodeUTF8(src, function(cp) {
                utfx.UTF8toUTF16(cp, dst);
            });
        };

        /**
         * Calculates the byte length of an UTF8 code point.
         * @param {number} cp UTF8 code point
         * @returns {number} Byte length
         */
        utfx.calculateCodePoint = function(cp) {
            return (cp < 0x80) ? 1 : (cp < 0x800) ? 2 : (cp < 0x10000) ? 3 : 4;
        };

        /**
         * Calculates the number of UTF8 bytes required to store UTF8 code points.
         * @param {(!function():number|null)} src Code points source as a function returning the next code point respectively
         *  `null` if there are no more code points left.
         * @returns {number} The number of UTF8 bytes required
         */
        utfx.calculateUTF8 = function(src) {
            var cp, l=0;
            while ((cp = src()) !== null)
                l += (cp < 0x80) ? 1 : (cp < 0x800) ? 2 : (cp < 0x10000) ? 3 : 4;
            return l;
        };

        /**
         * Calculates the number of UTF8 code points respectively UTF8 bytes required to store UTF16 char codes.
         * @param {(!function():number|null)} src Characters source as a function returning the next char code respectively
         *  `null` if there are no more characters left.
         * @returns {!Array.<number>} The number of UTF8 code points at index 0 and the number of UTF8 bytes required at index 1.
         */
        utfx.calculateUTF16asUTF8 = function(src) {
            var n=0, l=0;
            utfx.UTF16toUTF8(src, function(cp) {
                ++n; l += (cp < 0x80) ? 1 : (cp < 0x800) ? 2 : (cp < 0x10000) ? 3 : 4;
            });
            return [n,l];
        };

        return utfx;
    }();

    // encodings/utf8

    /**
     * Encodes this ByteBuffer's contents between {@link ByteBuffer#offset} and {@link ByteBuffer#limit} to an UTF8 encoded
     *  string.
     * @returns {string} Hex encoded string
     * @throws {RangeError} If `offset > limit`
     * @expose
     */
    ByteBufferPrototype.toUTF8 = function(begin, end) {
        if (typeof begin === 'undefined') begin = this.offset;
        if (typeof end === 'undefined') end = this.limit;
        if (!this.noAssert) {
            if (typeof begin !== 'number' || begin % 1 !== 0)
                throw TypeError("Illegal begin: Not an integer");
            begin >>>= 0;
            if (typeof end !== 'number' || end % 1 !== 0)
                throw TypeError("Illegal end: Not an integer");
            end >>>= 0;
            if (begin < 0 || begin > end || end > this.buffer.byteLength)
                throw RangeError("Illegal range: 0 <= "+begin+" <= "+end+" <= "+this.buffer.byteLength);
        }
        var sd; try {
            utfx.decodeUTF8toUTF16(function() {
                return begin < end ? this.view[begin++] : null;
            }.bind(this), sd = stringDestination());
        } catch (e) {
            if (begin !== end)
                throw RangeError("Illegal range: Truncated data, "+begin+" != "+end);
        }
        return sd();
    };

    /**
     * Decodes an UTF8 encoded string to a ByteBuffer.
     * @param {string} str String to decode
     * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to
     *  {@link ByteBuffer.DEFAULT_ENDIAN}.
     * @param {boolean=} noAssert Whether to skip assertions of offsets and values. Defaults to
     *  {@link ByteBuffer.DEFAULT_NOASSERT}.
     * @returns {!ByteBuffer} ByteBuffer
     * @expose
     */
    ByteBuffer.fromUTF8 = function(str, littleEndian, noAssert) {
        if (!noAssert)
            if (typeof str !== 'string')
                throw TypeError("Illegal str: Not a string");
        var bb = new ByteBuffer(utfx.calculateUTF16asUTF8(stringSource(str), true)[1], littleEndian, noAssert),
            i = 0;
        utfx.encodeUTF16toUTF8(stringSource(str), function(b) {
            bb.view[i++] = b;
        });
        bb.limit = i;
        return bb;
    };

    return ByteBuffer;
});


/***/ }),

/***/ "../../../node_modules/events/events.js":
/*!***************************************************************!*\
  !*** /home/omar/Desktop/hivejs/node_modules/events/events.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  }

var ReflectOwnKeys
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
}

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function $getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return $getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = $getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  var args = [];
  for (var i = 0; i < arguments.length; i++) args.push(arguments[i]);
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    ReflectApply(this.listener, this.target, args);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      if (typeof listener !== 'function') {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
      }
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      if (typeof listener !== 'function') {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
      }

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}


/***/ }),

/***/ "../../../node_modules/inversify/dist/inversify.js":
/*!**************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/node_modules/inversify/dist/inversify.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var require;var require;/**
 * inversify v.1.0.2 - A lightweight IoC container written in TypeScript.
 * Copyright (c) 2015 Remo H. Jansen
 * MIT inversify.io/LICENSE
 * http://inversify.io
 */
!function(n){if(true)module.exports=n();else { var e; }}(function(){return function n(e,t,i){function r(u,p){if(!t[u]){if(!e[u]){var c="function"==typeof require&&require;if(!p&&c)return require(u,!0);if(o)return o(u,!0);var s=new Error("Cannot find module '"+u+"'");throw s.code="MODULE_NOT_FOUND",s}var f=t[u]={exports:{}};e[u][0].call(f.exports,function(n){var t=e[u][1][n];return r(t?t:n)},f,f.exports,n,e,t,i)}return t[u].exports}for(var o="function"==typeof require&&require,u=0;u<i.length;u++)r(i[u]);return r}({1:[function(n,e,t){var i=n("./kernel");t.Kernel=i.Kernel;var r=n("./type_binding");t.TypeBinding=r.TypeBinding;var o=n("./type_binding_scope");t.TypeBindingScopeEnum=o.TypeBindingScopeEnum},{"./kernel":2,"./type_binding":4,"./type_binding_scope":5}],2:[function(n,e,t){var i=n("./type_binding_scope"),r=n("./lookup"),o=function(){function n(){this._bindingDictionary=new r.Lookup}return n.prototype.bind=function(n){this._bindingDictionary.add(n.runtimeIdentifier,n)},n.prototype.unbind=function(n){try{this._bindingDictionary.remove(n)}catch(e){throw new Error("Could not resolve service "+n)}},n.prototype.unbindAll=function(){this._bindingDictionary=new r.Lookup},n.prototype.resolve=function(n){var e;if(!this._bindingDictionary.hasKey(n))return null;e=this._bindingDictionary.get(n);var t=e[0];if(t.scope===i.TypeBindingScopeEnum.Singleton&&null!==t.cache)return t.cache;var r=this._injectDependencies(t.implementationType);return t.cache=r,r},n.prototype._getConstructorArguments=function(n){var e,t,i,r,o,u;return o=/((\/\/.*$)|(\/\*[\s\S]*?\*\/))/gm,u=/([^\s,]+)/g,e=n.toString().replace(o,""),t=e.indexOf("(")+1,i=e.indexOf(")"),r="function"==typeof Map&&-1!==e.indexOf("class")&&-1===e.indexOf("constructor")?null:e.slice(t,i).match(u),null===r&&(r=[]),r},n.prototype._injectDependencies=function(n){var e=this._getConstructorArguments(n);if(0===e.length)return new n;for(var t=[],i=null,r=0;r<e.length;r++){var o=e[r];i=this.resolve(o),t.push(i)}return this._construct(n,t)},n.prototype._construct=function(n,e){return new(Function.prototype.bind.apply(n,[null].concat(e)))},n}();t.Kernel=o},{"./lookup":3,"./type_binding_scope":5}],3:[function(n,e,t){var i=function(){function n(n,e){this.key=n,this.value=new Array,this.value.push(e)}return n}(),r=function(){function n(){this._hashMap=new Array}return n.prototype.getIndexByKey=function(n){for(var e=-1,t=0;t<this._hashMap.length;t++){var i=this._hashMap[t];i.key===n&&(e=t)}return e},n.prototype.add=function(n,e){if(null===n||void 0===n)throw new Error("Argument Null");if(null===e||void 0===e)throw new Error("Argument Null");var t=this.getIndexByKey(n);if(-1!==t){var r=this._hashMap[t];r.key===n&&r.value.push(e)}else this._hashMap.push(new i(n,e))},n.prototype.get=function(n){if(null===n||void 0===n)throw new Error("Argument Null");var e=this.getIndexByKey(n);if(-1===e)throw new Error("Key Not Found");var t=this._hashMap[e];return t.key===n?t.value:void 0},n.prototype.remove=function(n){if(null===n||void 0===n)throw new Error("Argument Null");var e=this.getIndexByKey(n);if(-1===e)throw new Error("Key Not Found");this._hashMap.splice(e,1)},n.prototype.hasKey=function(n){if(null===n||void 0===n)throw new Error("Argument Null");var e=this.getIndexByKey(n);return-1!==e?!0:!1},n}();t.Lookup=r},{}],4:[function(n,e,t){var i=n("./type_binding_scope"),r=function(){function n(n,e,t){if(this.runtimeIdentifier=n,this.implementationType=e,this.cache=null,"undefined"==typeof t)this.scope=i.TypeBindingScopeEnum.Transient;else{if(!i.TypeBindingScopeEnum[t]){var r="Invalid scope type "+t;throw new Error(r)}this.scope=t}}return n}();t.TypeBinding=r},{"./type_binding_scope":5}],5:[function(n,e,t){var i;!function(n){n[n.Transient=0]="Transient",n[n.Singleton=1]="Singleton"}(i||(i={})),t.TypeBindingScopeEnum=i},{}]},{},[1])(1)});

/***/ }),

/***/ "../../../node_modules/long/dist/Long.js":
/*!****************************************************************!*\
  !*** /home/omar/Desktop/hivejs/node_modules/long/dist/Long.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
 Copyright 2013 Daniel Wirtz <dcode@dcode.io>
 Copyright 2009 The Closure Library Authors. All Rights Reserved.

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS-IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
 */

/**
 * @license Long.js (c) 2013 Daniel Wirtz <dcode@dcode.io>
 * Released under the Apache License, Version 2.0
 * see: https://github.com/dcodeIO/Long.js for details
 */
(function(global, factory) {

    /* AMD */ if (true)
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    /* CommonJS */ else {}

})(this, function() {
    "use strict";

    /**
     * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.
     *  See the from* functions below for more convenient ways of constructing Longs.
     * @exports Long
     * @class A Long class for representing a 64 bit two's-complement integer value.
     * @param {number} low The low (signed) 32 bits of the long
     * @param {number} high The high (signed) 32 bits of the long
     * @param {boolean=} unsigned Whether unsigned or not, defaults to `false` for signed
     * @constructor
     */
    function Long(low, high, unsigned) {

        /**
         * The low 32 bits as a signed value.
         * @type {number}
         * @expose
         */
        this.low = low|0;

        /**
         * The high 32 bits as a signed value.
         * @type {number}
         * @expose
         */
        this.high = high|0;

        /**
         * Whether unsigned or not.
         * @type {boolean}
         * @expose
         */
        this.unsigned = !!unsigned;
    }

    // The internal representation of a long is the two given signed, 32-bit values.
    // We use 32-bit pieces because these are the size of integers on which
    // Javascript performs bit-operations.  For operations like addition and
    // multiplication, we split each number into 16 bit pieces, which can easily be
    // multiplied within Javascript's floating-point representation without overflow
    // or change in sign.
    //
    // In the algorithms below, we frequently reduce the negative case to the
    // positive case by negating the input(s) and then post-processing the result.
    // Note that we must ALWAYS check specially whether those values are MIN_VALUE
    // (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as
    // a positive number, it overflows back into a negative).  Not handling this
    // case would often result in infinite recursion.
    //
    // Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*
    // methods on which they depend.

    /**
     * An indicator used to reliably determine if an object is a Long or not.
     * @type {boolean}
     * @const
     * @expose
     * @private
     */
    Long.__isLong__;

    Object.defineProperty(Long.prototype, "__isLong__", {
        value: true,
        enumerable: false,
        configurable: false
    });

    /**
     * Tests if the specified object is a Long.
     * @param {*} obj Object
     * @returns {boolean}
     * @expose
     */
    Long.isLong = function isLong(obj) {
        return (obj && obj["__isLong__"]) === true;
    };

    /**
     * A cache of the Long representations of small integer values.
     * @type {!Object}
     * @inner
     */
    var INT_CACHE = {};

    /**
     * A cache of the Long representations of small unsigned integer values.
     * @type {!Object}
     * @inner
     */
    var UINT_CACHE = {};

    /**
     * Returns a Long representing the given 32 bit integer value.
     * @param {number} value The 32 bit integer in question
     * @param {boolean=} unsigned Whether unsigned or not, defaults to `false` for signed
     * @returns {!Long} The corresponding Long value
     * @expose
     */
    Long.fromInt = function fromInt(value, unsigned) {
        var obj, cachedObj;
        if (!unsigned) {
            value = value | 0;
            if (-128 <= value && value < 128) {
                cachedObj = INT_CACHE[value];
                if (cachedObj)
                    return cachedObj;
            }
            obj = new Long(value, value < 0 ? -1 : 0, false);
            if (-128 <= value && value < 128)
                INT_CACHE[value] = obj;
            return obj;
        } else {
            value = value >>> 0;
            if (0 <= value && value < 256) {
                cachedObj = UINT_CACHE[value];
                if (cachedObj)
                    return cachedObj;
            }
            obj = new Long(value, (value | 0) < 0 ? -1 : 0, true);
            if (0 <= value && value < 256)
                UINT_CACHE[value] = obj;
            return obj;
        }
    };

    /**
     * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.
     * @param {number} value The number in question
     * @param {boolean=} unsigned Whether unsigned or not, defaults to `false` for signed
     * @returns {!Long} The corresponding Long value
     * @expose
     */
    Long.fromNumber = function fromNumber(value, unsigned) {
        unsigned = !!unsigned;
        if (isNaN(value) || !isFinite(value))
            return Long.ZERO;
        if (!unsigned && value <= -TWO_PWR_63_DBL)
            return Long.MIN_VALUE;
        if (!unsigned && value + 1 >= TWO_PWR_63_DBL)
            return Long.MAX_VALUE;
        if (unsigned && value >= TWO_PWR_64_DBL)
            return Long.MAX_UNSIGNED_VALUE;
        if (value < 0)
            return Long.fromNumber(-value, unsigned).negate();
        return new Long((value % TWO_PWR_32_DBL) | 0, (value / TWO_PWR_32_DBL) | 0, unsigned);
    };

    /**
     * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is
     *  assumed to use 32 bits.
     * @param {number} lowBits The low 32 bits
     * @param {number} highBits The high 32 bits
     * @param {boolean=} unsigned Whether unsigned or not, defaults to `false` for signed
     * @returns {!Long} The corresponding Long value
     * @expose
     */
    Long.fromBits = function fromBits(lowBits, highBits, unsigned) {
        return new Long(lowBits, highBits, unsigned);
    };

    /**
     * Returns a Long representation of the given string, written using the specified radix.
     * @param {string} str The textual representation of the Long
     * @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to `false` for signed
     * @param {number=} radix The radix in which the text is written (2-36), defaults to 10
     * @returns {!Long} The corresponding Long value
     * @expose
     */
    Long.fromString = function fromString(str, unsigned, radix) {
        if (str.length === 0)
            throw Error('number format error: empty string');
        if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity")
            return Long.ZERO;
        if (typeof unsigned === 'number') // For goog.math.long compatibility
            radix = unsigned,
            unsigned = false;
        radix = radix || 10;
        if (radix < 2 || 36 < radix)
            throw Error('radix out of range: ' + radix);

        var p;
        if ((p = str.indexOf('-')) > 0)
            throw Error('number format error: interior "-" character: ' + str);
        else if (p === 0)
            return Long.fromString(str.substring(1), unsigned, radix).negate();

        // Do several (8) digits each time through the loop, so as to
        // minimize the calls to the very expensive emulated div.
        var radixToPower = Long.fromNumber(Math.pow(radix, 8));

        var result = Long.ZERO;
        for (var i = 0; i < str.length; i += 8) {
            var size = Math.min(8, str.length - i);
            var value = parseInt(str.substring(i, i + size), radix);
            if (size < 8) {
                var power = Long.fromNumber(Math.pow(radix, size));
                result = result.multiply(power).add(Long.fromNumber(value));
            } else {
                result = result.multiply(radixToPower);
                result = result.add(Long.fromNumber(value));
            }
        }
        result.unsigned = unsigned;
        return result;
    };

    /**
     * Converts the specified value to a Long.
     * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val Value
     * @returns {!Long}
     * @expose
     */
    Long.fromValue = function fromValue(val) {
        if (val /* is compatible */ instanceof Long)
            return val;
        if (typeof val === 'number')
            return Long.fromNumber(val);
        if (typeof val === 'string')
            return Long.fromString(val);
        // Throws for non-objects, converts non-instanceof Long:
        return new Long(val.low, val.high, val.unsigned);
    };

    // NOTE: the compiler should inline these constant values below and then remove these variables, so there should be
    // no runtime penalty for these.

    /**
     * @type {number}
     * @const
     * @inner
     */
    var TWO_PWR_16_DBL = 1 << 16;

    /**
     * @type {number}
     * @const
     * @inner
     */
    var TWO_PWR_24_DBL = 1 << 24;

    /**
     * @type {number}
     * @const
     * @inner
     */
    var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;

    /**
     * @type {number}
     * @const
     * @inner
     */
    var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;

    /**
     * @type {number}
     * @const
     * @inner
     */
    var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;

    /**
     * @type {!Long}
     * @const
     * @inner
     */
    var TWO_PWR_24 = Long.fromInt(TWO_PWR_24_DBL);

    /**
     * Signed zero.
     * @type {!Long}
     * @expose
     */
    Long.ZERO = Long.fromInt(0);

    /**
     * Unsigned zero.
     * @type {!Long}
     * @expose
     */
    Long.UZERO = Long.fromInt(0, true);

    /**
     * Signed one.
     * @type {!Long}
     * @expose
     */
    Long.ONE = Long.fromInt(1);

    /**
     * Unsigned one.
     * @type {!Long}
     * @expose
     */
    Long.UONE = Long.fromInt(1, true);

    /**
     * Signed negative one.
     * @type {!Long}
     * @expose
     */
    Long.NEG_ONE = Long.fromInt(-1);

    /**
     * Maximum signed value.
     * @type {!Long}
     * @expose
     */
    Long.MAX_VALUE = Long.fromBits(0xFFFFFFFF|0, 0x7FFFFFFF|0, false);

    /**
     * Maximum unsigned value.
     * @type {!Long}
     * @expose
     */
    Long.MAX_UNSIGNED_VALUE = Long.fromBits(0xFFFFFFFF|0, 0xFFFFFFFF|0, true);

    /**
     * Minimum signed value.
     * @type {!Long}
     * @expose
     */
    Long.MIN_VALUE = Long.fromBits(0, 0x80000000|0, false);

    /**
     * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.
     * @returns {number}
     * @expose
     */
    Long.prototype.toInt = function toInt() {
        return this.unsigned ? this.low >>> 0 : this.low;
    };

    /**
     * Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).
     * @returns {number}
     * @expose
     */
    Long.prototype.toNumber = function toNumber() {
        if (this.unsigned) {
            return ((this.high >>> 0) * TWO_PWR_32_DBL) + (this.low >>> 0);
        }
        return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
    };

    /**
     * Converts the Long to a string written in the specified radix.
     * @param {number=} radix Radix (2-36), defaults to 10
     * @returns {string}
     * @override
     * @throws {RangeError} If `radix` is out of range
     * @expose
     */
    Long.prototype.toString = function toString(radix) {
        radix = radix || 10;
        if (radix < 2 || 36 < radix)
            throw RangeError('radix out of range: ' + radix);
        if (this.isZero())
            return '0';
        var rem;
        if (this.isNegative()) { // Unsigned Longs are never negative
            if (this.equals(Long.MIN_VALUE)) {
                // We need to change the Long value before it can be negated, so we remove
                // the bottom-most digit in this base and then recurse to do the rest.
                var radixLong = Long.fromNumber(radix);
                var div = this.divide(radixLong);
                rem = div.multiply(radixLong).subtract(this);
                return div.toString(radix) + rem.toInt().toString(radix);
            } else
                return '-' + this.negate().toString(radix);
        }

        // Do several (6) digits each time through the loop, so as to
        // minimize the calls to the very expensive emulated div.
        var radixToPower = Long.fromNumber(Math.pow(radix, 6), this.unsigned);
        rem = this;
        var result = '';
        while (true) {
            var remDiv = rem.divide(radixToPower),
                intval = rem.subtract(remDiv.multiply(radixToPower)).toInt() >>> 0,
                digits = intval.toString(radix);
            rem = remDiv;
            if (rem.isZero())
                return digits + result;
            else {
                while (digits.length < 6)
                    digits = '0' + digits;
                result = '' + digits + result;
            }
        }
    };

    /**
     * Gets the high 32 bits as a signed integer.
     * @returns {number} Signed high bits
     * @expose
     */
    Long.prototype.getHighBits = function getHighBits() {
        return this.high;
    };

    /**
     * Gets the high 32 bits as an unsigned integer.
     * @returns {number} Unsigned high bits
     * @expose
     */
    Long.prototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
        return this.high >>> 0;
    };

    /**
     * Gets the low 32 bits as a signed integer.
     * @returns {number} Signed low bits
     * @expose
     */
    Long.prototype.getLowBits = function getLowBits() {
        return this.low;
    };

    /**
     * Gets the low 32 bits as an unsigned integer.
     * @returns {number} Unsigned low bits
     * @expose
     */
    Long.prototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
        return this.low >>> 0;
    };

    /**
     * Gets the number of bits needed to represent the absolute value of this Long.
     * @returns {number}
     * @expose
     */
    Long.prototype.getNumBitsAbs = function getNumBitsAbs() {
        if (this.isNegative()) // Unsigned Longs are never negative
            return this.equals(Long.MIN_VALUE) ? 64 : this.negate().getNumBitsAbs();
        var val = this.high != 0 ? this.high : this.low;
        for (var bit = 31; bit > 0; bit--)
            if ((val & (1 << bit)) != 0)
                break;
        return this.high != 0 ? bit + 33 : bit + 1;
    };

    /**
     * Tests if this Long's value equals zero.
     * @returns {boolean}
     * @expose
     */
    Long.prototype.isZero = function isZero() {
        return this.high === 0 && this.low === 0;
    };

    /**
     * Tests if this Long's value is negative.
     * @returns {boolean}
     * @expose
     */
    Long.prototype.isNegative = function isNegative() {
        return !this.unsigned && this.high < 0;
    };

    /**
     * Tests if this Long's value is positive.
     * @returns {boolean}
     * @expose
     */
    Long.prototype.isPositive = function isPositive() {
        return this.unsigned || this.high >= 0;
    };

    /**
     * Tests if this Long's value is odd.
     * @returns {boolean}
     * @expose
     */
    Long.prototype.isOdd = function isOdd() {
        return (this.low & 1) === 1;
    };

    /**
     * Tests if this Long's value is even.
     * @returns {boolean}
     * @expose
     */
    Long.prototype.isEven = function isEven() {
        return (this.low & 1) === 0;
    };

    /**
     * Tests if this Long's value equals the specified's.
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     * @expose
     */
    Long.prototype.equals = function equals(other) {
        if (!Long.isLong(other))
            other = Long.fromValue(other);
        if (this.unsigned !== other.unsigned && (this.high >>> 31) === 1 && (other.high >>> 31) === 1)
            return false;
        return this.high === other.high && this.low === other.low;
    };

    /**
     * Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.
     * @function
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     * @expose
     */
    Long.eq = Long.prototype.equals;

    /**
     * Tests if this Long's value differs from the specified's.
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     * @expose
     */
    Long.prototype.notEquals = function notEquals(other) {
        return !this.equals(/* validates */ other);
    };

    /**
     * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
     * @function
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     * @expose
     */
    Long.neq = Long.prototype.notEquals;

    /**
     * Tests if this Long's value is less than the specified's.
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     * @expose
     */
    Long.prototype.lessThan = function lessThan(other) {
        return this.compare(/* validates */ other) < 0;
    };

    /**
     * Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.
     * @function
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     * @expose
     */
    Long.prototype.lt = Long.prototype.lessThan;

    /**
     * Tests if this Long's value is less than or equal the specified's.
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     * @expose
     */
    Long.prototype.lessThanOrEqual = function lessThanOrEqual(other) {
        return this.compare(/* validates */ other) <= 0;
    };

    /**
     * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
     * @function
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     * @expose
     */
    Long.prototype.lte = Long.prototype.lessThanOrEqual;

    /**
     * Tests if this Long's value is greater than the specified's.
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     * @expose
     */
    Long.prototype.greaterThan = function greaterThan(other) {
        return this.compare(/* validates */ other) > 0;
    };

    /**
     * Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.
     * @function
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     * @expose
     */
    Long.prototype.gt = Long.prototype.greaterThan;

    /**
     * Tests if this Long's value is greater than or equal the specified's.
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     * @expose
     */
    Long.prototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
        return this.compare(/* validates */ other) >= 0;
    };

    /**
     * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
     * @function
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     * @expose
     */
    Long.prototype.gte = Long.prototype.greaterThanOrEqual;

    /**
     * Compares this Long's value with the specified's.
     * @param {!Long|number|string} other Other value
     * @returns {number} 0 if they are the same, 1 if the this is greater and -1
     *  if the given one is greater
     * @expose
     */
    Long.prototype.compare = function compare(other) {
        if (!Long.isLong(other))
            other = Long.fromValue(other);
        if (this.equals(other))
            return 0;
        var thisNeg = this.isNegative(),
            otherNeg = other.isNegative();
        if (thisNeg && !otherNeg)
            return -1;
        if (!thisNeg && otherNeg)
            return 1;
        // At this point the sign bits are the same
        if (!this.unsigned)
            return this.subtract(other).isNegative() ? -1 : 1;
        // Both are positive if at least one is unsigned
        return (other.high >>> 0) > (this.high >>> 0) || (other.high === this.high && (other.low >>> 0) > (this.low >>> 0)) ? -1 : 1;
    };

    /**
     * Negates this Long's value.
     * @returns {!Long} Negated Long
     * @expose
     */
    Long.prototype.negate = function negate() {
        if (!this.unsigned && this.equals(Long.MIN_VALUE))
            return Long.MIN_VALUE;
        return this.not().add(Long.ONE);
    };

    /**
     * Negates this Long's value. This is an alias of {@link Long#negate}.
     * @function
     * @returns {!Long} Negated Long
     * @expose
     */
    Long.prototype.neg = Long.prototype.negate;

    /**
     * Returns the sum of this and the specified Long.
     * @param {!Long|number|string} addend Addend
     * @returns {!Long} Sum
     * @expose
     */
    Long.prototype.add = function add(addend) {
        if (!Long.isLong(addend))
            addend = Long.fromValue(addend);

        // Divide each number into 4 chunks of 16 bits, and then sum the chunks.

        var a48 = this.high >>> 16;
        var a32 = this.high & 0xFFFF;
        var a16 = this.low >>> 16;
        var a00 = this.low & 0xFFFF;

        var b48 = addend.high >>> 16;
        var b32 = addend.high & 0xFFFF;
        var b16 = addend.low >>> 16;
        var b00 = addend.low & 0xFFFF;

        var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
        c00 += a00 + b00;
        c16 += c00 >>> 16;
        c00 &= 0xFFFF;
        c16 += a16 + b16;
        c32 += c16 >>> 16;
        c16 &= 0xFFFF;
        c32 += a32 + b32;
        c48 += c32 >>> 16;
        c32 &= 0xFFFF;
        c48 += a48 + b48;
        c48 &= 0xFFFF;
        return Long.fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);
    };

    /**
     * Returns the difference of this and the specified Long.
     * @param {!Long|number|string} subtrahend Subtrahend
     * @returns {!Long} Difference
     * @expose
     */
    Long.prototype.subtract = function subtract(subtrahend) {
        if (!Long.isLong(subtrahend))
            subtrahend = Long.fromValue(subtrahend);
        return this.add(subtrahend.negate());
    };

    /**
     * Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.
     * @function
     * @param {!Long|number|string} subtrahend Subtrahend
     * @returns {!Long} Difference
     * @expose
     */
    Long.prototype.sub = Long.prototype.subtract;

    /**
     * Returns the product of this and the specified Long.
     * @param {!Long|number|string} multiplier Multiplier
     * @returns {!Long} Product
     * @expose
     */
    Long.prototype.multiply = function multiply(multiplier) {
        if (this.isZero())
            return Long.ZERO;
        if (!Long.isLong(multiplier))
            multiplier = Long.fromValue(multiplier);
        if (multiplier.isZero())
            return Long.ZERO;
        if (this.equals(Long.MIN_VALUE))
            return multiplier.isOdd() ? Long.MIN_VALUE : Long.ZERO;
        if (multiplier.equals(Long.MIN_VALUE))
            return this.isOdd() ? Long.MIN_VALUE : Long.ZERO;

        if (this.isNegative()) {
            if (multiplier.isNegative())
                return this.negate().multiply(multiplier.negate());
            else
                return this.negate().multiply(multiplier).negate();
        } else if (multiplier.isNegative())
            return this.multiply(multiplier.negate()).negate();

        // If both longs are small, use float multiplication
        if (this.lessThan(TWO_PWR_24) && multiplier.lessThan(TWO_PWR_24))
            return Long.fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);

        // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.
        // We can skip products that would overflow.

        var a48 = this.high >>> 16;
        var a32 = this.high & 0xFFFF;
        var a16 = this.low >>> 16;
        var a00 = this.low & 0xFFFF;

        var b48 = multiplier.high >>> 16;
        var b32 = multiplier.high & 0xFFFF;
        var b16 = multiplier.low >>> 16;
        var b00 = multiplier.low & 0xFFFF;

        var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
        c00 += a00 * b00;
        c16 += c00 >>> 16;
        c00 &= 0xFFFF;
        c16 += a16 * b00;
        c32 += c16 >>> 16;
        c16 &= 0xFFFF;
        c16 += a00 * b16;
        c32 += c16 >>> 16;
        c16 &= 0xFFFF;
        c32 += a32 * b00;
        c48 += c32 >>> 16;
        c32 &= 0xFFFF;
        c32 += a16 * b16;
        c48 += c32 >>> 16;
        c32 &= 0xFFFF;
        c32 += a00 * b32;
        c48 += c32 >>> 16;
        c32 &= 0xFFFF;
        c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
        c48 &= 0xFFFF;
        return Long.fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);
    };

    /**
     * Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.
     * @function
     * @param {!Long|number|string} multiplier Multiplier
     * @returns {!Long} Product
     * @expose
     */
    Long.prototype.mul = Long.prototype.multiply;

    /**
     * Returns this Long divided by the specified.
     * @param {!Long|number|string} divisor Divisor
     * @returns {!Long} Quotient
     * @expose
     */
    Long.prototype.divide = function divide(divisor) {
        if (!Long.isLong(divisor))
            divisor = Long.fromValue(divisor);
        if (divisor.isZero())
            throw(new Error('division by zero'));
        if (this.isZero())
            return this.unsigned ? Long.UZERO : Long.ZERO;
        var approx, rem, res;
        if (this.equals(Long.MIN_VALUE)) {
            if (divisor.equals(Long.ONE) || divisor.equals(Long.NEG_ONE))
                return Long.MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE
            else if (divisor.equals(Long.MIN_VALUE))
                return Long.ONE;
            else {
                // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.
                var halfThis = this.shiftRight(1);
                approx = halfThis.divide(divisor).shiftLeft(1);
                if (approx.equals(Long.ZERO)) {
                    return divisor.isNegative() ? Long.ONE : Long.NEG_ONE;
                } else {
                    rem = this.subtract(divisor.multiply(approx));
                    res = approx.add(rem.divide(divisor));
                    return res;
                }
            }
        } else if (divisor.equals(Long.MIN_VALUE))
            return this.unsigned ? Long.UZERO : Long.ZERO;
        if (this.isNegative()) {
            if (divisor.isNegative())
                return this.negate().divide(divisor.negate());
            return this.negate().divide(divisor).negate();
        } else if (divisor.isNegative())
            return this.divide(divisor.negate()).negate();

        // Repeat the following until the remainder is less than other:  find a
        // floating-point that approximates remainder / other *from below*, add this
        // into the result, and subtract it from the remainder.  It is critical that
        // the approximate value is less than or equal to the real value so that the
        // remainder never becomes negative.
        res = Long.ZERO;
        rem = this;
        while (rem.greaterThanOrEqual(divisor)) {
            // Approximate the result of division. This may be a little greater or
            // smaller than the actual value.
            approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));

            // We will tweak the approximate result by changing it in the 48-th digit or
            // the smallest non-fractional digit, whichever is larger.
            var log2 = Math.ceil(Math.log(approx) / Math.LN2),
                delta = (log2 <= 48) ? 1 : Math.pow(2, log2 - 48),

            // Decrease the approximation until it is smaller than the remainder.  Note
            // that if it is too large, the product overflows and is negative.
                approxRes = Long.fromNumber(approx),
                approxRem = approxRes.multiply(divisor);
            while (approxRem.isNegative() || approxRem.greaterThan(rem)) {
                approx -= delta;
                approxRes = Long.fromNumber(approx, this.unsigned);
                approxRem = approxRes.multiply(divisor);
            }

            // We know the answer can't be zero... and actually, zero would cause
            // infinite recursion since we would make no progress.
            if (approxRes.isZero())
                approxRes = Long.ONE;

            res = res.add(approxRes);
            rem = rem.subtract(approxRem);
        }
        return res;
    };

    /**
     * Returns this Long divided by the specified. This is an alias of {@link Long#divide}.
     * @function
     * @param {!Long|number|string} divisor Divisor
     * @returns {!Long} Quotient
     * @expose
     */
    Long.prototype.div = Long.prototype.divide;

    /**
     * Returns this Long modulo the specified.
     * @param {!Long|number|string} divisor Divisor
     * @returns {!Long} Remainder
     * @expose
     */
    Long.prototype.modulo = function modulo(divisor) {
        if (!Long.isLong(divisor))
            divisor = Long.fromValue(divisor);
        return this.subtract(this.divide(divisor).multiply(divisor));
    };

    /**
     * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
     * @function
     * @param {!Long|number|string} divisor Divisor
     * @returns {!Long} Remainder
     * @expose
     */
    Long.prototype.mod = Long.prototype.modulo;

    /**
     * Returns the bitwise NOT of this Long.
     * @returns {!Long}
     * @expose
     */
    Long.prototype.not = function not() {
        return Long.fromBits(~this.low, ~this.high, this.unsigned);
    };

    /**
     * Returns the bitwise AND of this Long and the specified.
     * @param {!Long|number|string} other Other Long
     * @returns {!Long}
     * @expose
     */
    Long.prototype.and = function and(other) {
        if (!Long.isLong(other))
            other = Long.fromValue(other);
        return Long.fromBits(this.low & other.low, this.high & other.high, this.unsigned);
    };

    /**
     * Returns the bitwise OR of this Long and the specified.
     * @param {!Long|number|string} other Other Long
     * @returns {!Long}
     * @expose
     */
    Long.prototype.or = function or(other) {
        if (!Long.isLong(other))
            other = Long.fromValue(other);
        return Long.fromBits(this.low | other.low, this.high | other.high, this.unsigned);
    };

    /**
     * Returns the bitwise XOR of this Long and the given one.
     * @param {!Long|number|string} other Other Long
     * @returns {!Long}
     * @expose
     */
    Long.prototype.xor = function xor(other) {
        if (!Long.isLong(other))
            other = Long.fromValue(other);
        return Long.fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
    };

    /**
     * Returns this Long with bits shifted to the left by the given amount.
     * @param {number|!Long} numBits Number of bits
     * @returns {!Long} Shifted Long
     * @expose
     */
    Long.prototype.shiftLeft = function shiftLeft(numBits) {
        if (Long.isLong(numBits))
            numBits = numBits.toInt();
        if ((numBits &= 63) === 0)
            return this;
        else if (numBits < 32)
            return Long.fromBits(this.low << numBits, (this.high << numBits) | (this.low >>> (32 - numBits)), this.unsigned);
        else
            return Long.fromBits(0, this.low << (numBits - 32), this.unsigned);
    };

    /**
     * Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.
     * @function
     * @param {number|!Long} numBits Number of bits
     * @returns {!Long} Shifted Long
     * @expose
     */
    Long.prototype.shl = Long.prototype.shiftLeft;

    /**
     * Returns this Long with bits arithmetically shifted to the right by the given amount.
     * @param {number|!Long} numBits Number of bits
     * @returns {!Long} Shifted Long
     * @expose
     */
    Long.prototype.shiftRight = function shiftRight(numBits) {
        if (Long.isLong(numBits))
            numBits = numBits.toInt();
        if ((numBits &= 63) === 0)
            return this;
        else if (numBits < 32)
            return Long.fromBits((this.low >>> numBits) | (this.high << (32 - numBits)), this.high >> numBits, this.unsigned);
        else
            return Long.fromBits(this.high >> (numBits - 32), this.high >= 0 ? 0 : -1, this.unsigned);
    };

    /**
     * Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.
     * @function
     * @param {number|!Long} numBits Number of bits
     * @returns {!Long} Shifted Long
     * @expose
     */
    Long.prototype.shr = Long.prototype.shiftRight;

    /**
     * Returns this Long with bits logically shifted to the right by the given amount.
     * @param {number|!Long} numBits Number of bits
     * @returns {!Long} Shifted Long
     * @expose
     */
    Long.prototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
        if (Long.isLong(numBits))
            numBits = numBits.toInt();
        numBits &= 63;
        if (numBits === 0)
            return this;
        else {
            var high = this.high;
            if (numBits < 32) {
                var low = this.low;
                return Long.fromBits((low >>> numBits) | (high << (32 - numBits)), high >>> numBits, this.unsigned);
            } else if (numBits === 32)
                return Long.fromBits(high, 0, this.unsigned);
            else
                return Long.fromBits(high >>> (numBits - 32), 0, this.unsigned);
        }
    };

    /**
     * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
     * @function
     * @param {number|!Long} numBits Number of bits
     * @returns {!Long} Shifted Long
     * @expose
     */
    Long.prototype.shru = Long.prototype.shiftRightUnsigned;

    /**
     * Converts this Long to signed.
     * @returns {!Long} Signed long
     * @expose
     */
    Long.prototype.toSigned = function toSigned() {
        if (!this.unsigned)
            return this;
        return new Long(this.low, this.high, false);
    };

    /**
     * Converts this Long to unsigned.
     * @returns {!Long} Unsigned long
     * @expose
     */
    Long.prototype.toUnsigned = function toUnsigned() {
        if (this.unsigned)
            return this;
        return new Long(this.low, this.high, true);
    };

    return Long;
});


/***/ }),

/***/ "../../../node_modules/parse-xsd-duration/dist/index.js":
/*!*******************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/node_modules/parse-xsd-duration/dist/index.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else { var mod; }
})(this, function (exports) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _emptyPeriod, _emptyTime;

  var UNITS = {
    YEAR: 31536000,
    MONTH: 2628000,
    DAY: 86400,
    HOUR: 3600,
    MINUTE: 60,
    SECOND: 1
  };

  var YEAR_UNIT = 'years';
  var MONTH_UNIT = 'months';
  var DAY_UNIT = 'days';
  var HOUR_UNIT = 'hours';
  var MINUTE_UNIT = 'minutes';
  var SECOND_UNIT = 'seconds';
  var IS_NEGATIVE_UNIT = 'isNegative';

  var emptyPeriod = (_emptyPeriod = {}, _emptyPeriod[YEAR_UNIT] = 0, _emptyPeriod[MONTH_UNIT] = 0, _emptyPeriod[DAY_UNIT] = 0, _emptyPeriod);

  var emptyTime = (_emptyTime = {}, _emptyTime[HOUR_UNIT] = 0, _emptyTime[MINUTE_UNIT] = 0, _emptyTime[SECOND_UNIT] = 0, _emptyTime);

  // Regex taken from https://www.w3.org/TR/xmlschema11-2/#duration-lexical-space
  var isValidXsdDuration = function isValidXsdDuration(str) {
    return (/^-?P((([0-9]+Y([0-9]+M)?([0-9]+D)?|([0-9]+M)([0-9]+D)?|([0-9]+D))(T(([0-9]+H)([0-9]+M)?([0-9]+(\.[0-9]+)?S)?|([0-9]+M)([0-9]+(\.[0-9]+)?S)?|([0-9]+(\.[0-9]+)?S)))?)|(T(([0-9]+H)([0-9]+M)?([0-9]+(\.[0-9]+)?S)?|([0-9]+M)([0-9]+(\.[0-9]+)?S)?|([0-9]+(\.[0-9]+)?S))))$/.test(str)
    );
  };
  var isNonEmptyString = function isNonEmptyString(input) {
    return typeof input === 'string' && input.length > 0;
  };
  var isNegative = function isNegative(str) {
    return str[0] === '-';
  };
  var stripFirstChar = function stripFirstChar(str) {
    return str.slice(1);
  };
  var unitToSeconds = function unitToSeconds(unit, amount) {
    return UNITS[unit.toUpperCase()] * amount;
  };

  var parseUnit = function parseUnit(unit, amount) {
    var amt = getNumber(amount);
    return unitToSeconds(unit, amt);
  };

  var getNumber = function getNumber(amount) {
    var amt = parseFloat(amount);
    if (isNaN(amt)) return 0;
    return amt;
  };

  var parsePeriod = function parsePeriod(period) {
    var _ref = /^(?:(\d+)Y)?(?:(\d+)M)?(?:(\d+)D)?$/g.exec(period) || [],
        year = _ref[1],
        month = _ref[2],
        day = _ref[3];

    return parseUnit('year', year) + parseUnit('month', month) + parseUnit('day', day);
  };

  var parsePeriodToObject = function parsePeriodToObject(period) {
    var _ref3;

    var _ref2 = /^(?:(\d+)Y)?(?:(\d+)M)?(?:(\d+)D)?$/g.exec(period) || [],
        years = _ref2[1],
        months = _ref2[2],
        days = _ref2[3];

    return _ref3 = {}, _ref3[YEAR_UNIT] = getNumber(years), _ref3[MONTH_UNIT] = getNumber(months), _ref3[DAY_UNIT] = getNumber(days), _ref3;
  };

  var parseTime = function parseTime(time) {
    var _ref4 = /^(?:(\d+)H)?(?:(\d+)M)?(?:(\d+(?:\.\d+)?)S)?$/g.exec(time) || [],
        hour = _ref4[1],
        minute = _ref4[2],
        second = _ref4[3];

    return parseUnit('hour', hour) + parseUnit('minute', minute) + parseUnit('second', second);
  };

  var parseTimeToObject = function parseTimeToObject(time) {
    var _ref6;

    var _ref5 = /^(?:(\d+)H)?(?:(\d+)M)?(?:(\d+(?:\.\d+)?)S)?$/g.exec(time) || [],
        hours = _ref5[1],
        minutes = _ref5[2],
        seconds = _ref5[3];

    return _ref6 = {}, _ref6[HOUR_UNIT] = getNumber(hours), _ref6[MINUTE_UNIT] = getNumber(minutes), _ref6[SECOND_UNIT] = getNumber(seconds), _ref6;
  };

  var parse = function parse(str) {
    var neg = isNegative(str);
    var duration = neg ? stripFirstChar(str) : str;
    var splitDuration = duration.split('T');
    var period = stripFirstChar(splitDuration[0]);
    var time = splitDuration[1];

    var output = 0;
    if (isNonEmptyString(period)) output += parsePeriod(period);
    if (isNonEmptyString(time)) output += parseTime(time);
    return neg ? -output : output;
  };

  var convertToObject = exports.convertToObject = function convertToObject(str) {
    var _output;

    var neg = isNegative(str);
    var duration = neg ? stripFirstChar(str) : str;
    var splitDuration = duration.split('T');
    var period = stripFirstChar(splitDuration[0]);
    var time = splitDuration[1];

    var output = (_output = {}, _output[IS_NEGATIVE_UNIT] = neg, _output);
    output = isNonEmptyString(period) ? Object.assign(output, parsePeriodToObject(period)) : Object.assign(output, emptyPeriod);
    output = isNonEmptyString(time) ? Object.assign(output, parseTimeToObject(time)) : Object.assign(output, emptyTime);
    return output;
  };

  var out = function out(input) {
    var toObject = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    // Throw error for non-string input
    if (typeof input !== 'string') {
      throw new TypeError('expected input to be a string');
    }
    // Return null for invalid input
    if (!isValidXsdDuration(input)) return null;
    // Parse valid input
    return toObject ? convertToObject(input) : parse(input);
  };

  exports.default = function (input, toObject) {
    return out(input, toObject);
  };
});
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../../node_modules/process/browser.js":
/*!*****************************************************************!*\
  !*** /home/omar/Desktop/hivejs/node_modules/process/browser.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "../../../node_modules/protobufjs/dist/ProtoBuf.js":
/*!**************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/node_modules/protobufjs/dist/ProtoBuf.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
 Copyright 2013 Daniel Wirtz <dcode@dcode.io>

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
 */

/**
 * @license ProtoBuf.js (c) 2013 Daniel Wirtz <dcode@dcode.io>
 * Released under the Apache License, Version 2.0
 * see: https://github.com/dcodeIO/ProtoBuf.js for details
 */
(function(global, factory) {

    /* AMD */ if (true)
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ByteBuffer */ "../../../node_modules/bytebuffer/dist/ByteBufferAB.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    /* CommonJS */ else {}

})(this, function(ByteBuffer, isCommonJS) {
    "use strict";

    /**
     * The ProtoBuf namespace.
     * @exports ProtoBuf
     * @namespace
     * @expose
     */
    var ProtoBuf = {};

    /**
     * @type {!function(new: ByteBuffer, ...[*])}
     * @expose
     */
    ProtoBuf.ByteBuffer = ByteBuffer;

    /**
     * @type {?function(new: Long, ...[*])}
     * @expose
     */
    ProtoBuf.Long = ByteBuffer.Long || null;

    /**
     * ProtoBuf.js version.
     * @type {string}
     * @const
     * @expose
     */
    ProtoBuf.VERSION = "4.1.3";

    /**
     * Wire types.
     * @type {Object.<string,number>}
     * @const
     * @expose
     */
    ProtoBuf.WIRE_TYPES = {};

    /**
     * Varint wire type.
     * @type {number}
     * @expose
     */
    ProtoBuf.WIRE_TYPES.VARINT = 0;

    /**
     * Fixed 64 bits wire type.
     * @type {number}
     * @const
     * @expose
     */
    ProtoBuf.WIRE_TYPES.BITS64 = 1;

    /**
     * Length delimited wire type.
     * @type {number}
     * @const
     * @expose
     */
    ProtoBuf.WIRE_TYPES.LDELIM = 2;

    /**
     * Start group wire type.
     * @type {number}
     * @const
     * @expose
     */
    ProtoBuf.WIRE_TYPES.STARTGROUP = 3;

    /**
     * End group wire type.
     * @type {number}
     * @const
     * @expose
     */
    ProtoBuf.WIRE_TYPES.ENDGROUP = 4;

    /**
     * Fixed 32 bits wire type.
     * @type {number}
     * @const
     * @expose
     */
    ProtoBuf.WIRE_TYPES.BITS32 = 5;

    /**
     * Packable wire types.
     * @type {!Array.<number>}
     * @const
     * @expose
     */
    ProtoBuf.PACKABLE_WIRE_TYPES = [
        ProtoBuf.WIRE_TYPES.VARINT,
        ProtoBuf.WIRE_TYPES.BITS64,
        ProtoBuf.WIRE_TYPES.BITS32
    ];

    /**
     * Types.
     * @dict
     * @type {!Object.<string,{name: string, wireType: number, defaultValue: *}>}
     * @const
     * @expose
     */
    ProtoBuf.TYPES = {
        // According to the protobuf spec.
        "int32": {
            name: "int32",
            wireType: ProtoBuf.WIRE_TYPES.VARINT,
            defaultValue: 0
        },
        "uint32": {
            name: "uint32",
            wireType: ProtoBuf.WIRE_TYPES.VARINT,
            defaultValue: 0
        },
        "sint32": {
            name: "sint32",
            wireType: ProtoBuf.WIRE_TYPES.VARINT,
            defaultValue: 0
        },
        "int64": {
            name: "int64",
            wireType: ProtoBuf.WIRE_TYPES.VARINT,
            defaultValue: ProtoBuf.Long ? ProtoBuf.Long.ZERO : undefined
        },
        "uint64": {
            name: "uint64",
            wireType: ProtoBuf.WIRE_TYPES.VARINT,
            defaultValue: ProtoBuf.Long ? ProtoBuf.Long.UZERO : undefined
        },
        "sint64": {
            name: "sint64",
            wireType: ProtoBuf.WIRE_TYPES.VARINT,
            defaultValue: ProtoBuf.Long ? ProtoBuf.Long.ZERO : undefined
        },
        "bool": {
            name: "bool",
            wireType: ProtoBuf.WIRE_TYPES.VARINT,
            defaultValue: false
        },
        "double": {
            name: "double",
            wireType: ProtoBuf.WIRE_TYPES.BITS64,
            defaultValue: 0
        },
        "string": {
            name: "string",
            wireType: ProtoBuf.WIRE_TYPES.LDELIM,
            defaultValue: ""
        },
        "bytes": {
            name: "bytes",
            wireType: ProtoBuf.WIRE_TYPES.LDELIM,
            defaultValue: null // overridden in the code, must be a unique instance
        },
        "fixed32": {
            name: "fixed32",
            wireType: ProtoBuf.WIRE_TYPES.BITS32,
            defaultValue: 0
        },
        "sfixed32": {
            name: "sfixed32",
            wireType: ProtoBuf.WIRE_TYPES.BITS32,
            defaultValue: 0
        },
        "fixed64": {
            name: "fixed64",
            wireType: ProtoBuf.WIRE_TYPES.BITS64,
            defaultValue:  ProtoBuf.Long ? ProtoBuf.Long.UZERO : undefined
        },
        "sfixed64": {
            name: "sfixed64",
            wireType: ProtoBuf.WIRE_TYPES.BITS64,
            defaultValue: ProtoBuf.Long ? ProtoBuf.Long.ZERO : undefined
        },
        "float": {
            name: "float",
            wireType: ProtoBuf.WIRE_TYPES.BITS32,
            defaultValue: 0
        },
        "enum": {
            name: "enum",
            wireType: ProtoBuf.WIRE_TYPES.VARINT,
            defaultValue: 0
        },
        "message": {
            name: "message",
            wireType: ProtoBuf.WIRE_TYPES.LDELIM,
            defaultValue: null
        },
        "group": {
            name: "group",
            wireType: ProtoBuf.WIRE_TYPES.STARTGROUP,
            defaultValue: null
        }
    };

    /**
     * Valid map key types.
     * @type {!Array.<!Object.<string,{name: string, wireType: number, defaultValue: *}>>}
     * @const
     * @expose
     */
    ProtoBuf.MAP_KEY_TYPES = [
        ProtoBuf.TYPES["int32"],
        ProtoBuf.TYPES["sint32"],
        ProtoBuf.TYPES["sfixed32"],
        ProtoBuf.TYPES["uint32"],
        ProtoBuf.TYPES["fixed32"],
        ProtoBuf.TYPES["int64"],
        ProtoBuf.TYPES["sint64"],
        ProtoBuf.TYPES["sfixed64"],
        ProtoBuf.TYPES["uint64"],
        ProtoBuf.TYPES["fixed64"],
        ProtoBuf.TYPES["bool"],
        ProtoBuf.TYPES["string"],
        ProtoBuf.TYPES["bytes"]
    ];

    /**
     * Minimum field id.
     * @type {number}
     * @const
     * @expose
     */
    ProtoBuf.ID_MIN = 1;

    /**
     * Maximum field id.
     * @type {number}
     * @const
     * @expose
     */
    ProtoBuf.ID_MAX = 0x1FFFFFFF;

    /**
     * If set to `true`, field names will be converted from underscore notation to camel case. Defaults to `false`.
     *  Must be set prior to parsing.
     * @type {boolean}
     * @expose
     */
    ProtoBuf.convertFieldsToCamelCase = false;

    /**
     * By default, messages are populated with (setX, set_x) accessors for each field. This can be disabled by
     *  setting this to `false` prior to building messages.
     * @type {boolean}
     * @expose
     */
    ProtoBuf.populateAccessors = true;

    /**
     * By default, messages are populated with default values if a field is not present on the wire. To disable
     *  this behavior, set this setting to `false`.
     * @type {boolean}
     * @expose
     */
    ProtoBuf.populateDefaults = true;

    /**
     * @alias ProtoBuf.Util
     * @expose
     */
    ProtoBuf.Util = (function() {
        "use strict";

        /**
         * ProtoBuf utilities.
         * @exports ProtoBuf.Util
         * @namespace
         */
        var Util = {};

        /**
         * Flag if running in node or not.
         * @type {boolean}
         * @const
         * @expose
         */
        Util.IS_NODE = !!(
            typeof process === 'object' && process+'' === '[object process]' && !process['browser']
        );

        /**
         * Constructs a XMLHttpRequest object.
         * @return {XMLHttpRequest}
         * @throws {Error} If XMLHttpRequest is not supported
         * @expose
         */
        Util.XHR = function() {
            // No dependencies please, ref: http://www.quirksmode.org/js/xmlhttp.html
            var XMLHttpFactories = [
                function () {return new XMLHttpRequest()},
                function () {return new ActiveXObject("Msxml2.XMLHTTP")},
                function () {return new ActiveXObject("Msxml3.XMLHTTP")},
                function () {return new ActiveXObject("Microsoft.XMLHTTP")}
            ];
            /** @type {?XMLHttpRequest} */
            var xhr = null;
            for (var i=0;i<XMLHttpFactories.length;i++) {
                try { xhr = XMLHttpFactories[i](); }
                catch (e) { continue; }
                break;
            }
            if (!xhr)
                throw Error("XMLHttpRequest is not supported");
            return xhr;
        };

        /**
         * Fetches a resource.
         * @param {string} path Resource path
         * @param {function(?string)=} callback Callback receiving the resource's contents. If omitted the resource will
         *   be fetched synchronously. If the request failed, contents will be null.
         * @return {?string|undefined} Resource contents if callback is omitted (null if the request failed), else undefined.
         * @expose
         */
        Util.fetch = function(path, callback) {
            if (callback && typeof callback != 'function')
                callback = null;
            if (Util.IS_NODE) {
                var fs = __webpack_require__(/*! fs */ "../../../scripts/build-project/empty.js");
                if (callback) {
                    fs.readFile(path, function(err, data) {
                        if (err)
                            callback(null);
                        else
                            callback(""+data);
                    });
                } else
                    try {
                        return fs.readFileSync(path);
                    } catch (e) {
                        return null;
                    }
            } else {
                var xhr = Util.XHR();
                xhr.open('GET', path, callback ? true : false);
                // xhr.setRequestHeader('User-Agent', 'XMLHTTP/1.0');
                xhr.setRequestHeader('Accept', 'text/plain');
                if (typeof xhr.overrideMimeType === 'function') xhr.overrideMimeType('text/plain');
                if (callback) {
                    xhr.onreadystatechange = function() {
                        if (xhr.readyState != 4) return;
                        if (/* remote */ xhr.status == 200 || /* local */ (xhr.status == 0 && typeof xhr.responseText === 'string'))
                            callback(xhr.responseText);
                        else
                            callback(null);
                    };
                    if (xhr.readyState == 4)
                        return;
                    xhr.send(null);
                } else {
                    xhr.send(null);
                    if (/* remote */ xhr.status == 200 || /* local */ (xhr.status == 0 && typeof xhr.responseText === 'string'))
                        return xhr.responseText;
                    return null;
                }
            }
        };

        /**
         * Converts a string to camel case.
         * @param {string} str
         * @returns {string}
         * @expose
         */
        Util.toCamelCase = function(str) {
            return str.replace(/_([a-zA-Z])/g, function ($0, $1) {
                return $1.toUpperCase();
            });
        };

        return Util;
    })();

    /**
     * Language expressions.
     * @type {!Object.<string,!RegExp>}
     * @expose
     */
    ProtoBuf.Lang = {

        // Characters always ending a statement
        DELIM: /[\s\{\}=;:\[\],'"\(\)<>]/g,

        // Field rules
        RULE: /^(?:required|optional|repeated|map)$/,

        // Field types
        TYPE: /^(?:double|float|int32|uint32|sint32|int64|uint64|sint64|fixed32|sfixed32|fixed64|sfixed64|bool|string|bytes)$/,

        // Names
        NAME: /^[a-zA-Z_][a-zA-Z_0-9]*$/,

        // Type definitions
        TYPEDEF: /^[a-zA-Z][a-zA-Z_0-9]*$/,

        // Type references
        TYPEREF: /^(?:\.?[a-zA-Z_][a-zA-Z_0-9]*)+$/,

        // Fully qualified type references
        FQTYPEREF: /^(?:\.[a-zA-Z][a-zA-Z_0-9]*)+$/,

        // All numbers
        NUMBER: /^-?(?:[1-9][0-9]*|0|0[xX][0-9a-fA-F]+|0[0-7]+|([0-9]*(\.[0-9]*)?([Ee][+-]?[0-9]+)?)|inf|nan)$/,

        // Decimal numbers
        NUMBER_DEC: /^(?:[1-9][0-9]*|0)$/,

        // Hexadecimal numbers
        NUMBER_HEX: /^0[xX][0-9a-fA-F]+$/,

        // Octal numbers
        NUMBER_OCT: /^0[0-7]+$/,

        // Floating point numbers
        NUMBER_FLT: /^([0-9]*(\.[0-9]*)?([Ee][+-]?[0-9]+)?|inf|nan)$/,

        // Booleans
        BOOL: /^(?:true|false)$/i,

        // Id numbers
        ID: /^(?:[1-9][0-9]*|0|0[xX][0-9a-fA-F]+|0[0-7]+)$/,

        // Negative id numbers (enum values)
        NEGID: /^\-?(?:[1-9][0-9]*|0|0[xX][0-9a-fA-F]+|0[0-7]+)$/,

        // Whitespaces
        WHITESPACE: /\s/,

        // All strings
        STRING: /(?:"([^"\\]*(?:\\.[^"\\]*)*)")|(?:'([^'\\]*(?:\\.[^'\\]*)*)')/g,

        // Double quoted strings
        STRING_DQ: /(?:"([^"\\]*(?:\\.[^"\\]*)*)")/g,

        // Single quoted strings
        STRING_SQ: /(?:'([^'\\]*(?:\\.[^'\\]*)*)')/g
    };

    /**
     * @alias ProtoBuf.DotProto
     * @expose
     */
    ProtoBuf.DotProto = (function(ProtoBuf, Lang) {
        "use strict";

        /**
         * Utilities to parse .proto files.
         * @exports ProtoBuf.DotProto
         * @namespace
         */
        var DotProto = {};

        /**
         * Constructs a new Tokenizer.
         * @exports ProtoBuf.DotProto.Tokenizer
         * @class prototype tokenizer
         * @param {string} proto Proto to tokenize
         * @constructor
         */
        var Tokenizer = function(proto) {

            /**
             * Source to parse.
             * @type {string}
             * @expose
             */
            this.source = proto+"";

            /**
             * Current index.
             * @type {number}
             * @expose
             */
            this.index = 0;

            /**
             * Current line.
             * @type {number}
             * @expose
             */
            this.line = 1;

            /**
             * Token stack.
             * @type {!Array.<string>}
             * @expose
             */
            this.stack = [];

            /**
             * Opening character of the current string read, if any.
             * @type {?string}
             * @private
             */
            this._stringOpen = null;
        };

        /**
         * @alias ProtoBuf.DotProto.Tokenizer.prototype
         * @inner
         */
        var TokenizerPrototype = Tokenizer.prototype;

        /**
         * Reads a string beginning at the current index.
         * @return {string}
         * @private
         */
        TokenizerPrototype._readString = function() {
            var re = this._stringOpen === '"'
                ? Lang.STRING_DQ
                : Lang.STRING_SQ;
            re.lastIndex = this.index - 1; // Include the open quote
            var match = re.exec(this.source);
            if (!match)
                throw Error("unterminated string");
            this.index = re.lastIndex;
            this.stack.push(this._stringOpen);
            this._stringOpen = null;
            return match[1];
        };

        /**
         * Gets the next token and advances by one.
         * @return {?string} Token or `null` on EOF
         * @expose
         */
        TokenizerPrototype.next = function() {
            if (this.stack.length > 0)
                return this.stack.shift();
            if (this.index >= this.source.length)
                return null;
            if (this._stringOpen !== null)
                return this._readString();

            var repeat,
                prev,
                next;
            do {
                repeat = false;

                // Strip white spaces
                while (Lang.WHITESPACE.test(next = this.source.charAt(this.index))) {
                    if (next === '\n')
                        ++this.line;
                    if (++this.index === this.source.length)
                        return null;
                }

                // Strip comments
                if (this.source.charAt(this.index) === '/') {
                    ++this.index;
                    if (this.source.charAt(this.index) === '/') { // Line
                        while (this.source.charAt(++this.index) !== '\n')
                            if (this.index == this.source.length)
                                return null;
                        ++this.index;
                        ++this.line;
                        repeat = true;
                    } else if ((next = this.source.charAt(this.index)) === '*') { /* Block */
                        do {
                            if (next === '\n')
                                ++this.line;
                            if (++this.index === this.source.length)
                                return null;
                            prev = next;
                            next = this.source.charAt(this.index);
                        } while (prev !== '*' || next !== '/');
                        ++this.index;
                        repeat = true;
                    } else
                        return '/';
                }
            } while (repeat);

            if (this.index === this.source.length)
                return null;

            // Read the next token
            var end = this.index;
            Lang.DELIM.lastIndex = 0;
            var delim = Lang.DELIM.test(this.source.charAt(end++));
            if (!delim)
                while(end < this.source.length && !Lang.DELIM.test(this.source.charAt(end)))
                    ++end;
            var token = this.source.substring(this.index, this.index = end);
            if (token === '"' || token === "'")
                this._stringOpen = token;
            return token;
        };

        /**
         * Peeks for the next token.
         * @return {?string} Token or `null` on EOF
         * @expose
         */
        TokenizerPrototype.peek = function() {
            if (this.stack.length === 0) {
                var token = this.next();
                if (token === null)
                    return null;
                this.stack.push(token);
            }
            return this.stack[0];
        };

        /**
         * Skips a specific token and throws if it differs.
         * @param {string} expected Expected token
         * @throws {Error} If the actual token differs
         */
        TokenizerPrototype.skip = function(expected) {
            var actual = this.next();
            if (actual !== expected)
                throw Error("illegal '"+actual+"', '"+expected+"' expected");
        };

        /**
         * Omits an optional token.
         * @param {string} expected Expected optional token
         * @returns {boolean} `true` if the token exists
         */
        TokenizerPrototype.omit = function(expected) {
            if (this.peek() === expected) {
                this.next();
                return true;
            }
            return false;
        };

        /**
         * Returns a string representation of this object.
         * @return {string} String representation as of "Tokenizer(index/length)"
         * @expose
         */
        TokenizerPrototype.toString = function() {
            return "Tokenizer ("+this.index+"/"+this.source.length+" at line "+this.line+")";
        };

        /**
         * @alias ProtoBuf.DotProto.Tokenizer
         * @expose
         */
        DotProto.Tokenizer = Tokenizer;

        /**
         * Constructs a new Parser.
         * @exports ProtoBuf.DotProto.Parser
         * @class prototype parser
         * @param {string} source Source
         * @constructor
         */
        var Parser = function(source) {

            /**
             * Tokenizer.
             * @type {!ProtoBuf.DotProto.Tokenizer}
             * @expose
             */
            this.tn = new Tokenizer(source);

            /**
             * Whether parsing proto3 or not.
             * @type {boolean}
             */
            this.proto3 = false;
        };

        /**
         * @alias ProtoBuf.DotProto.Parser.prototype
         * @inner
         */
        var ParserPrototype = Parser.prototype;

        /**
         * Parses the source.
         * @returns {!Object}
         * @throws {Error} If the source cannot be parsed
         * @expose
         */
        ParserPrototype.parse = function() {
            var topLevel = {
                "name": "[ROOT]", // temporary
                "package": null,
                "messages": [],
                "enums": [],
                "imports": [],
                "options": {},
                "services": []
                // "syntax": undefined
            };
            var token,
                head = true;
            try {
                while (token = this.tn.next()) {
                    switch (token) {
                        case 'package':
                            if (!head || topLevel["package"] !== null)
                                throw Error("unexpected 'package'");
                            token = this.tn.next();
                            if (!Lang.TYPEREF.test(token))
                                throw Error("illegal package name: " + token);
                            this.tn.skip(";");
                            topLevel["package"] = token;
                            break;
                        case 'import':
                            if (!head)
                                throw Error("unexpected 'import'");
                            token = this.tn.peek();
                            if (token === "public") // ignored
                                this.tn.next();
                            token = this._readString();
                            this.tn.skip(";");
                            topLevel["imports"].push(token);
                            break;
                        case 'syntax':
                            if (!head)
                                throw Error("unexpected 'syntax'");
                            this.tn.skip("=");
                            if ((topLevel["syntax"] = this._readString()) === "proto3")
                                this.proto3 = true;
                            this.tn.skip(";");
                            break;
                        case 'message':
                            this._parseMessage(topLevel, null);
                            head = false;
                            break;
                        case 'enum':
                            this._parseEnum(topLevel);
                            head = false;
                            break;
                        case 'option':
                            this._parseOption(topLevel);
                            break;
                        case 'service':
                            this._parseService(topLevel);
                            break;
                        case 'extend':
                            this._parseExtend(topLevel);
                            break;
                        default:
                            throw Error("unexpected '" + token + "'");
                    }
                }
            } catch (e) {
                e.message = "Parse error at line "+this.tn.line+": " + e.message;
                throw e;
            }
            delete topLevel["name"];
            return topLevel;
        };

        /**
         * Parses the specified source.
         * @returns {!Object}
         * @throws {Error} If the source cannot be parsed
         * @expose
         */
        Parser.parse = function(source) {
            return new Parser(source).parse();
        };

        // ----- Conversion ------

        /**
         * Converts a numerical string to an id.
         * @param {string} value
         * @param {boolean=} mayBeNegative
         * @returns {number}
         * @inner
         */
        function mkId(value, mayBeNegative) {
            var id = -1,
                sign = 1;
            if (value.charAt(0) == '-') {
                sign = -1;
                value = value.substring(1);
            }
            if (Lang.NUMBER_DEC.test(value))
                id = parseInt(value);
            else if (Lang.NUMBER_HEX.test(value))
                id = parseInt(value.substring(2), 16);
            else if (Lang.NUMBER_OCT.test(value))
                id = parseInt(value.substring(1), 8);
            else
                throw Error("illegal id value: " + (sign < 0 ? '-' : '') + value);
            id = (sign*id)|0; // Force to 32bit
            if (!mayBeNegative && id < 0)
                throw Error("illegal id value: " + (sign < 0 ? '-' : '') + value);
            return id;
        }

        /**
         * Converts a numerical string to a number.
         * @param {string} val
         * @returns {number}
         * @inner
         */
        function mkNumber(val) {
            var sign = 1;
            if (val.charAt(0) == '-') {
                sign = -1;
                val = val.substring(1);
            }
            if (Lang.NUMBER_DEC.test(val))
                return sign * parseInt(val, 10);
            else if (Lang.NUMBER_HEX.test(val))
                return sign * parseInt(val.substring(2), 16);
            else if (Lang.NUMBER_OCT.test(val))
                return sign * parseInt(val.substring(1), 8);
            else if (val === 'inf')
                return sign * Infinity;
            else if (val === 'nan')
                return NaN;
            else if (Lang.NUMBER_FLT.test(val))
                return sign * parseFloat(val);
            throw Error("illegal number value: " + (sign < 0 ? '-' : '') + val);
        }

        // ----- Reading ------

        /**
         * Reads a string.
         * @returns {string}
         * @private
         */
        ParserPrototype._readString = function() {
            var value = "",
                token,
                delim;
            do {
                delim = this.tn.next();
                if (delim !== "'" && delim !== '"')
                    throw Error("illegal string delimiter: "+delim);
                value += this.tn.next();
                this.tn.skip(delim);
                token = this.tn.peek();
            } while (token === '"' || token === '"'); // multi line?
            return value;
        };

        /**
         * Reads a value.
         * @param {boolean=} mayBeTypeRef
         * @returns {number|boolean|string}
         * @private
         */
        ParserPrototype._readValue = function(mayBeTypeRef) {
            var token = this.tn.peek(),
                value;
            if (token === '"' || token === "'")
                return this._readString();
            this.tn.next();
            if (Lang.NUMBER.test(token))
                return mkNumber(token);
            if (Lang.BOOL.test(token))
                return (token.toLowerCase() === 'true');
            if (mayBeTypeRef && Lang.TYPEREF.test(token))
                return token;
            throw Error("illegal value: "+token);

        };

        // ----- Parsing constructs -----

        /**
         * Parses a namespace option.
         * @param {!Object} parent Parent definition
         * @param {boolean=} isList
         * @private
         */
        ParserPrototype._parseOption = function(parent, isList) {
            var token = this.tn.next(),
                custom = false;
            if (token === '(') {
                custom = true;
                token = this.tn.next();
            }
            if (!Lang.TYPEREF.test(token))
                // we can allow options of the form google.protobuf.* since they will just get ignored anyways
                // if (!/google\.protobuf\./.test(token)) // FIXME: Why should that not be a valid typeref?
                    throw Error("illegal option name: "+token);
            var name = token;
            if (custom) { // (my_method_option).foo, (my_method_option), some_method_option, (foo.my_option).bar
                this.tn.skip(')');
                name = '('+name+')';
                token = this.tn.peek();
                if (Lang.FQTYPEREF.test(token)) {
                    name += token;
                    this.tn.next();
                }
            }
            this.tn.skip('=');
            this._parseOptionValue(parent, name);
            if (!isList)
                this.tn.skip(";");
        };

        /**
         * Sets an option on the specified options object.
         * @param {!Object.<string,*>} options
         * @param {string} name
         * @param {string|number|boolean} value
         * @inner
         */
        function setOption(options, name, value) {
            if (typeof options[name] === 'undefined')
                options[name] = value;
            else {
                if (!Array.isArray(options[name]))
                    options[name] = [ options[name] ];
                options[name].push(value);
            }
        }

        /**
         * Parses an option value.
         * @param {!Object} parent
         * @param {string} name
         * @private
         */
        ParserPrototype._parseOptionValue = function(parent, name) {
            var token = this.tn.peek();
            if (token !== '{') { // Plain value
                setOption(parent["options"], name, this._readValue(true));
            } else { // Aggregate options
                this.tn.skip("{");
                while ((token = this.tn.next()) !== '}') {
                    if (!Lang.NAME.test(token))
                        throw Error("illegal option name: " + name + "." + token);
                    if (this.tn.omit(":"))
                        setOption(parent["options"], name + "." + token, this._readValue(true));
                    else
                        this._parseOptionValue(parent, name + "." + token);
                }
            }
        };

        /**
         * Parses a service definition.
         * @param {!Object} parent Parent definition
         * @private
         */
        ParserPrototype._parseService = function(parent) {
            var token = this.tn.next();
            if (!Lang.NAME.test(token))
                throw Error("illegal service name at line "+this.tn.line+": "+token);
            var name = token;
            var svc = {
                "name": name,
                "rpc": {},
                "options": {}
            };
            this.tn.skip("{");
            while ((token = this.tn.next()) !== '}') {
                if (token === "option")
                    this._parseOption(svc);
                else if (token === 'rpc')
                    this._parseServiceRPC(svc);
                else
                    throw Error("illegal service token: "+token);
            }
            this.tn.omit(";");
            parent["services"].push(svc);
        };

        /**
         * Parses a RPC service definition of the form ['rpc', name, (request), 'returns', (response)].
         * @param {!Object} svc Service definition
         * @private
         */
        ParserPrototype._parseServiceRPC = function(svc) {
            var type = "rpc",
                token = this.tn.next();
            if (!Lang.NAME.test(token))
                throw Error("illegal rpc service method name: "+token);
            var name = token;
            var method = {
                "request": null,
                "response": null,
                "request_stream": false,
                "response_stream": false,
                "options": {}
            };
            this.tn.skip("(");
            token = this.tn.next();
            if (token.toLowerCase() === "stream") {
              method["request_stream"] = true;
              token = this.tn.next();
            }
            if (!Lang.TYPEREF.test(token))
                throw Error("illegal rpc service request type: "+token);
            method["request"] = token;
            this.tn.skip(")");
            token = this.tn.next();
            if (token.toLowerCase() !== "returns")
                throw Error("illegal rpc service request type delimiter: "+token);
            this.tn.skip("(");
            token = this.tn.next();
            if (token.toLowerCase() === "stream") {
              method["response_stream"] = true;
              token = this.tn.next();
            }
            method["response"] = token;
            this.tn.skip(")");
            token = this.tn.peek();
            if (token === '{') {
                this.tn.next();
                while ((token = this.tn.next()) !== '}') {
                    if (token === 'option')
                        this._parseOption(method);
                    else
                        throw Error("illegal rpc service token: " + token);
                }
                this.tn.omit(";");
            } else
                this.tn.skip(";");
            if (typeof svc[type] === 'undefined')
                svc[type] = {};
            svc[type][name] = method;
        };

        /**
         * Parses a message definition.
         * @param {!Object} parent Parent definition
         * @param {!Object=} fld Field definition if this is a group
         * @returns {!Object}
         * @private
         */
        ParserPrototype._parseMessage = function(parent, fld) {
            var isGroup = !!fld,
                token = this.tn.next();
            var msg = {
                "name": "",
                "fields": [],
                "enums": [],
                "messages": [],
                "options": {},
                "oneofs": {}
                // "extensions": undefined
            };
            if (!Lang.NAME.test(token))
                throw Error("illegal "+(isGroup ? "group" : "message")+" name: "+token);
            msg["name"] = token;
            if (isGroup) {
                this.tn.skip("=");
                fld["id"] = mkId(this.tn.next());
                msg["isGroup"] = true;
            }
            token = this.tn.peek();
            if (token === '[' && fld)
                this._parseFieldOptions(fld);
            this.tn.skip("{");
            while ((token = this.tn.next()) !== '}') {
                if (Lang.RULE.test(token))
                    this._parseMessageField(msg, token);
                else if (token === "oneof")
                    this._parseMessageOneOf(msg);
                else if (token === "enum")
                    this._parseEnum(msg);
                else if (token === "message")
                    this._parseMessage(msg);
                else if (token === "option")
                    this._parseOption(msg);
                else if (token === "extensions")
                    this._parseExtensions(msg);
                else if (token === "extend")
                    this._parseExtend(msg);
                else if (Lang.TYPEREF.test(token)) {
                    if (!this.proto3)
                        throw Error("illegal field rule: "+token);
                    this._parseMessageField(msg, "optional", token);
                } else
                    throw Error("illegal message token: "+token);
            }
            this.tn.omit(";");
            parent["messages"].push(msg);
            return msg;
        };

        /**
         * Parses a message field.
         * @param {!Object} msg Message definition
         * @param {string} rule Field rule
         * @param {string=} type Field type if already known (never known for maps)
         * @returns {!Object} Field descriptor
         * @private
         */
        ParserPrototype._parseMessageField = function(msg, rule, type) {
            if (!Lang.RULE.test(rule))
                throw Error("illegal message field rule: "+rule);
            var fld = {
                "rule": rule,
                "type": "",
                "name": "",
                "options": {},
                "id": 0
            };
            var token;
            if (rule === "map") {

                if (type)
                    throw Error("illegal type: " + type);
                this.tn.skip('<');
                token = this.tn.next();
                if (!Lang.TYPE.test(token) && !Lang.TYPEREF.test(token))
                    throw Error("illegal message field type: " + token);
                fld["keytype"] = token;
                this.tn.skip(',');
                token = this.tn.next();
                if (!Lang.TYPE.test(token) && !Lang.TYPEREF.test(token))
                    throw Error("illegal message field: " + token);
                fld["type"] = token;
                this.tn.skip('>');
                token = this.tn.next();
                if (!Lang.NAME.test(token))
                    throw Error("illegal message field name: " + token);
                fld["name"] = token;
                this.tn.skip("=");
                fld["id"] = mkId(this.tn.next());
                token = this.tn.peek();
                if (token === '[')
                    this._parseFieldOptions(fld);
                this.tn.skip(";");

            } else {

                type = typeof type !== 'undefined' ? type : this.tn.next();

                if (type === "group") {

                    // "A [legacy] group simply combines a nested message type and a field into a single declaration. In your
                    // code, you can treat this message just as if it had a Result type field called result (the latter name is
                    // converted to lower-case so that it does not conflict with the former)."
                    var grp = this._parseMessage(msg, fld);
                    if (!/^[A-Z]/.test(grp["name"]))
                        throw Error('illegal group name: '+grp["name"]);
                    fld["type"] = grp["name"];
                    fld["name"] = grp["name"].toLowerCase();
                    this.tn.omit(";");

                } else {

                    if (!Lang.TYPE.test(type) && !Lang.TYPEREF.test(type))
                        throw Error("illegal message field type: " + type);
                    fld["type"] = type;
                    token = this.tn.next();
                    if (!Lang.NAME.test(token))
                        throw Error("illegal message field name: " + token);
                    fld["name"] = token;
                    this.tn.skip("=");
                    fld["id"] = mkId(this.tn.next());
                    token = this.tn.peek();
                    if (token === "[")
                        this._parseFieldOptions(fld);
                    this.tn.skip(";");

                }
            }
            msg["fields"].push(fld);
            return fld;
        };

        /**
         * Parses a message oneof.
         * @param {!Object} msg Message definition
         * @private
         */
        ParserPrototype._parseMessageOneOf = function(msg) {
            var token = this.tn.next();
            if (!Lang.NAME.test(token))
                throw Error("illegal oneof name: "+token);
            var name = token,
                fld;
            var fields = [];
            this.tn.skip("{");
            while ((token = this.tn.next()) !== "}") {
                fld = this._parseMessageField(msg, "optional", token);
                fld["oneof"] = name;
                fields.push(fld["id"]);
            }
            this.tn.omit(";");
            msg["oneofs"][name] = fields;
        };

        /**
         * Parses a set of field option definitions.
         * @param {!Object} fld Field definition
         * @private
         */
        ParserPrototype._parseFieldOptions = function(fld) {
            this.tn.skip("[");
            var token,
                first = true;
            while ((token = this.tn.peek()) !== ']') {
                if (!first)
                    this.tn.skip(",");
                this._parseOption(fld, true);
                first = false;
            }
            this.tn.next();
        };

        /**
         * Parses an enum.
         * @param {!Object} msg Message definition
         * @private
         */
        ParserPrototype._parseEnum = function(msg) {
            var enm = {
                "name": "",
                "values": [],
                "options": {}
            };
            var token = this.tn.next();
            if (!Lang.NAME.test(token))
                throw Error("illegal name: "+token);
            enm["name"] = token;
            this.tn.skip("{");
            while ((token = this.tn.next()) !== '}') {
                if (token === "option")
                    this._parseOption(enm);
                else {
                    if (!Lang.NAME.test(token))
                        throw Error("illegal name: "+token);
                    this.tn.skip("=");
                    var val = {
                        "name": token,
                        "id": mkId(this.tn.next(), true)
                    };
                    token = this.tn.peek();
                    if (token === "[")
                        this._parseFieldOptions({ "options": {} });
                    this.tn.skip(";");
                    enm["values"].push(val);
                }
            }
            this.tn.omit(";");
            msg["enums"].push(enm);
        };

        /**
         * Parses an extensions statement.
         * @param {!Object} msg Message object
         * @private
         */
        ParserPrototype._parseExtensions = function(msg) {
            var token = this.tn.next(),
                range = [];
            if (token === "min")
                range.push(ProtoBuf.ID_MIN);
            else if (token === "max")
                range.push(ProtoBuf.ID_MAX);
            else
                range.push(mkNumber(token));
            this.tn.skip("to");
            token = this.tn.next();
            if (token === "min")
                range.push(ProtoBuf.ID_MIN);
            else if (token === "max")
                range.push(ProtoBuf.ID_MAX);
            else
                range.push(mkNumber(token));
            this.tn.skip(";");
            msg["extensions"] = range;
        };

        /**
         * Parses an extend block.
         * @param {!Object} parent Parent object
         * @private
         */
        ParserPrototype._parseExtend = function(parent) {
            var token = this.tn.next();
            if (!Lang.TYPEREF.test(token))
                throw Error("illegal extend reference: "+token);
            var ext = {
                "ref": token,
                "fields": []
            };
            this.tn.skip("{");
            while ((token = this.tn.next()) !== '}') {
                if (Lang.RULE.test(token))
                    this._parseMessageField(ext, token);
                else if (Lang.TYPEREF.test(token)) {
                    if (!this.proto3)
                        throw Error("illegal field rule: "+token);
                    this._parseMessageField(ext, "optional", token);
                } else
                    throw Error("illegal extend token: "+token);
            }
            this.tn.omit(";");
            parent["messages"].push(ext);
            return ext;
        };

        // ----- General -----

        /**
         * Returns a string representation of this parser.
         * @returns {string}
         */
        ParserPrototype.toString = function() {
            return "Parser at line "+this.tn.line;
        };

        /**
         * @alias ProtoBuf.DotProto.Parser
         * @expose
         */
        DotProto.Parser = Parser;

        return DotProto;

    })(ProtoBuf, ProtoBuf.Lang);

    /**
     * @alias ProtoBuf.Reflect
     * @expose
     */
    ProtoBuf.Reflect = (function(ProtoBuf) {
        "use strict";

        /**
         * Reflection types.
         * @exports ProtoBuf.Reflect
         * @namespace
         */
        var Reflect = {};

        /**
         * Constructs a Reflect base class.
         * @exports ProtoBuf.Reflect.T
         * @constructor
         * @abstract
         * @param {!ProtoBuf.Builder} builder Builder reference
         * @param {?ProtoBuf.Reflect.T} parent Parent object
         * @param {string} name Object name
         */
        var T = function(builder, parent, name) {

            /**
             * Builder reference.
             * @type {!ProtoBuf.Builder}
             * @expose
             */
            this.builder = builder;

            /**
             * Parent object.
             * @type {?ProtoBuf.Reflect.T}
             * @expose
             */
            this.parent = parent;

            /**
             * Object name in namespace.
             * @type {string}
             * @expose
             */
            this.name = name;

            /**
             * Fully qualified class name
             * @type {string}
             * @expose
             */
            this.className;
        };

        /**
         * @alias ProtoBuf.Reflect.T.prototype
         * @inner
         */
        var TPrototype = T.prototype;

        /**
         * Returns the fully qualified name of this object.
         * @returns {string} Fully qualified name as of ".PATH.TO.THIS"
         * @expose
         */
        TPrototype.fqn = function() {
            var name = this.name,
                ptr = this;
            do {
                ptr = ptr.parent;
                if (ptr == null)
                    break;
                name = ptr.name+"."+name;
            } while (true);
            return name;
        };

        /**
         * Returns a string representation of this Reflect object (its fully qualified name).
         * @param {boolean=} includeClass Set to true to include the class name. Defaults to false.
         * @return String representation
         * @expose
         */
        TPrototype.toString = function(includeClass) {
            return (includeClass ? this.className + " " : "") + this.fqn();
        };

        /**
         * Builds this type.
         * @throws {Error} If this type cannot be built directly
         * @expose
         */
        TPrototype.build = function() {
            throw Error(this.toString(true)+" cannot be built directly");
        };

        /**
         * @alias ProtoBuf.Reflect.T
         * @expose
         */
        Reflect.T = T;

        /**
         * Constructs a new Namespace.
         * @exports ProtoBuf.Reflect.Namespace
         * @param {!ProtoBuf.Builder} builder Builder reference
         * @param {?ProtoBuf.Reflect.Namespace} parent Namespace parent
         * @param {string} name Namespace name
         * @param {Object.<string,*>=} options Namespace options
         * @param {string?} syntax The syntax level of this definition (e.g., proto3)
         * @constructor
         * @extends ProtoBuf.Reflect.T
         */
        var Namespace = function(builder, parent, name, options, syntax) {
            T.call(this, builder, parent, name);

            /**
             * @override
             */
            this.className = "Namespace";

            /**
             * Children inside the namespace.
             * @type {!Array.<ProtoBuf.Reflect.T>}
             */
            this.children = [];

            /**
             * Options.
             * @type {!Object.<string, *>}
             */
            this.options = options || {};

            /**
             * Syntax level (e.g., proto2 or proto3).
             * @type {!string}
             */
            this.syntax = syntax || "proto2";
        };

        /**
         * @alias ProtoBuf.Reflect.Namespace.prototype
         * @inner
         */
        var NamespacePrototype = Namespace.prototype = Object.create(T.prototype);

        /**
         * Returns an array of the namespace's children.
         * @param {ProtoBuf.Reflect.T=} type Filter type (returns instances of this type only). Defaults to null (all children).
         * @return {Array.<ProtoBuf.Reflect.T>}
         * @expose
         */
        NamespacePrototype.getChildren = function(type) {
            type = type || null;
            if (type == null)
                return this.children.slice();
            var children = [];
            for (var i=0, k=this.children.length; i<k; ++i)
                if (this.children[i] instanceof type)
                    children.push(this.children[i]);
            return children;
        };

        /**
         * Adds a child to the namespace.
         * @param {ProtoBuf.Reflect.T} child Child
         * @throws {Error} If the child cannot be added (duplicate)
         * @expose
         */
        NamespacePrototype.addChild = function(child) {
            var other;
            if (other = this.getChild(child.name)) {
                // Try to revert camelcase transformation on collision
                if (other instanceof Message.Field && other.name !== other.originalName && this.getChild(other.originalName) === null)
                    other.name = other.originalName; // Revert previous first (effectively keeps both originals)
                else if (child instanceof Message.Field && child.name !== child.originalName && this.getChild(child.originalName) === null)
                    child.name = child.originalName;
                else
                    throw Error("Duplicate name in namespace "+this.toString(true)+": "+child.name);
            }
            this.children.push(child);
        };

        /**
         * Gets a child by its name or id.
         * @param {string|number} nameOrId Child name or id
         * @return {?ProtoBuf.Reflect.T} The child or null if not found
         * @expose
         */
        NamespacePrototype.getChild = function(nameOrId) {
            var key = typeof nameOrId === 'number' ? 'id' : 'name';
            for (var i=0, k=this.children.length; i<k; ++i)
                if (this.children[i][key] === nameOrId)
                    return this.children[i];
            return null;
        };

        /**
         * Resolves a reflect object inside of this namespace.
         * @param {string|!Array.<string>} qn Qualified name to resolve
         * @param {boolean=} excludeNonNamespace Excludes non-namespace types, defaults to `false`
         * @return {?ProtoBuf.Reflect.Namespace} The resolved type or null if not found
         * @expose
         */
        NamespacePrototype.resolve = function(qn, excludeNonNamespace) {
            var part = typeof qn === 'string' ? qn.split(".") : qn,
                ptr = this,
                i = 0;
            if (part[i] === "") { // Fully qualified name, e.g. ".My.Message'
                while (ptr.parent !== null)
                    ptr = ptr.parent;
                i++;
            }
            var child;
            do {
                do {
                    if (!(ptr instanceof Reflect.Namespace)) {
                        ptr = null;
                        break;
                    }
                    child = ptr.getChild(part[i]);
                    if (!child || !(child instanceof Reflect.T) || (excludeNonNamespace && !(child instanceof Reflect.Namespace))) {
                        ptr = null;
                        break;
                    }
                    ptr = child; i++;
                } while (i < part.length);
                if (ptr != null)
                    break; // Found
                // Else search the parent
                if (this.parent !== null)
                    return this.parent.resolve(qn, excludeNonNamespace);
            } while (ptr != null);
            return ptr;
        };

        /**
         * Determines the shortest qualified name of the specified type, if any, relative to this namespace.
         * @param {!ProtoBuf.Reflect.T} t Reflection type
         * @returns {string} The shortest qualified name or, if there is none, the fqn
         * @expose
         */
        NamespacePrototype.qn = function(t) {
            var part = [], ptr = t;
            do {
                part.unshift(ptr.name);
                ptr = ptr.parent;
            } while (ptr !== null);
            for (var len=1; len <= part.length; len++) {
                var qn = part.slice(part.length-len);
                if (t === this.resolve(qn, t instanceof Reflect.Namespace))
                    return qn.join(".");
            }
            return t.fqn();
        };

        /**
         * Builds the namespace and returns the runtime counterpart.
         * @return {Object.<string,Function|Object>} Runtime namespace
         * @expose
         */
        NamespacePrototype.build = function() {
            /** @dict */
            var ns = {};
            var children = this.children;
            for (var i=0, k=children.length, child; i<k; ++i) {
                child = children[i];
                if (child instanceof Namespace)
                    ns[child.name] = child.build();
            }
            if (Object.defineProperty)
                Object.defineProperty(ns, "$options", { "value": this.buildOpt() });
            return ns;
        };

        /**
         * Builds the namespace's '$options' property.
         * @return {Object.<string,*>}
         */
        NamespacePrototype.buildOpt = function() {
            var opt = {},
                keys = Object.keys(this.options);
            for (var i=0, k=keys.length; i<k; ++i) {
                var key = keys[i],
                    val = this.options[keys[i]];
                // TODO: Options are not resolved, yet.
                // if (val instanceof Namespace) {
                //     opt[key] = val.build();
                // } else {
                opt[key] = val;
                // }
            }
            return opt;
        };

        /**
         * Gets the value assigned to the option with the specified name.
         * @param {string=} name Returns the option value if specified, otherwise all options are returned.
         * @return {*|Object.<string,*>}null} Option value or NULL if there is no such option
         */
        NamespacePrototype.getOption = function(name) {
            if (typeof name === 'undefined')
                return this.options;
            return typeof this.options[name] !== 'undefined' ? this.options[name] : null;
        };

        /**
         * @alias ProtoBuf.Reflect.Namespace
         * @expose
         */
        Reflect.Namespace = Namespace;

        /**
         * Constructs a new Element implementation that checks and converts values for a
         * particular field type, as appropriate.
         *
         * An Element represents a single value: either the value of a singular field,
         * or a value contained in one entry of a repeated field or map field. This
         * class does not implement these higher-level concepts; it only encapsulates
         * the low-level typechecking and conversion.
         *
         * @exports ProtoBuf.Reflect.Element
         * @param {{name: string, wireType: number}} type Resolved data type
         * @param {ProtoBuf.Reflect.T|null} resolvedType Resolved type, if relevant
         * (e.g. submessage field).
         * @param {boolean} isMapKey Is this element a Map key? The value will be
         * converted to string form if so.
         * @param {string} syntax Syntax level of defining message type, e.g.,
         * proto2 or proto3.
         * @constructor
         */
        var Element = function(type, resolvedType, isMapKey, syntax) {

            /**
             * Element type, as a string (e.g., int32).
             * @type {{name: string, wireType: number}}
             */
            this.type = type;

            /**
             * Element type reference to submessage or enum definition, if needed.
             * @type {ProtoBuf.Reflect.T|null}
             */
            this.resolvedType = resolvedType;

            /**
             * Element is a map key.
             * @type {boolean}
             */
            this.isMapKey = isMapKey;

            /**
             * Syntax level of defining message type, e.g., proto2 or proto3.
             * @type {string}
             */
            this.syntax = syntax;

            if (isMapKey && ProtoBuf.MAP_KEY_TYPES.indexOf(type) < 0)
                throw Error("Invalid map key type: " + type.name);
        };

        var ElementPrototype = Element.prototype;

        /**
         * Obtains a (new) default value for the specified type.
         * @param type {string|{name: string, wireType: number}} Field type
         * @returns {*} Default value
         * @inner
         */
        function mkDefault(type) {
            if (typeof type === 'string')
                type = ProtoBuf.TYPES[type];
            if (typeof type.defaultValue === 'undefined')
                throw Error("default value for type "+type.name+" is not supported");
            if (type == ProtoBuf.TYPES["bytes"])
                return new ByteBuffer(0);
            return type.defaultValue;
        }

        /**
         * Returns the default value for this field in proto3.
         * @function
         * @param type {string|{name: string, wireType: number}} the field type
         * @returns {*} Default value
         */
        Element.defaultFieldValue = mkDefault;

        /**
         * Makes a Long from a value.
         * @param {{low: number, high: number, unsigned: boolean}|string|number} value Value
         * @param {boolean=} unsigned Whether unsigned or not, defaults to reuse it from Long-like objects or to signed for
         *  strings and numbers
         * @returns {!Long}
         * @throws {Error} If the value cannot be converted to a Long
         * @inner
         */
        function mkLong(value, unsigned) {
            if (value && typeof value.low === 'number' && typeof value.high === 'number' && typeof value.unsigned === 'boolean'
                && value.low === value.low && value.high === value.high)
                return new ProtoBuf.Long(value.low, value.high, typeof unsigned === 'undefined' ? value.unsigned : unsigned);
            if (typeof value === 'string')
                return ProtoBuf.Long.fromString(value, unsigned || false, 10);
            if (typeof value === 'number')
                return ProtoBuf.Long.fromNumber(value, unsigned || false);
            throw Error("not convertible to Long");
        }

        /**
         * Checks if the given value can be set for an element of this type (singular
         * field or one element of a repeated field or map).
         * @param {*} value Value to check
         * @return {*} Verified, maybe adjusted, value
         * @throws {Error} If the value cannot be verified for this element slot
         * @expose
         */
        ElementPrototype.verifyValue = function(value) {
            var fail = function(val, msg) {
                throw Error("Illegal value for "+this.toString(true)+" of type "+this.type.name+": "+val+" ("+msg+")");
            }.bind(this);
            switch (this.type) {
                // Signed 32bit
                case ProtoBuf.TYPES["int32"]:
                case ProtoBuf.TYPES["sint32"]:
                case ProtoBuf.TYPES["sfixed32"]:
                    // Account for !NaN: value === value
                    if (typeof value !== 'number' || (value === value && value % 1 !== 0))
                        fail(typeof value, "not an integer");
                    return value > 4294967295 ? value | 0 : value;

                // Unsigned 32bit
                case ProtoBuf.TYPES["uint32"]:
                case ProtoBuf.TYPES["fixed32"]:
                    if (typeof value !== 'number' || (value === value && value % 1 !== 0))
                        fail(typeof value, "not an integer");
                    return value < 0 ? value >>> 0 : value;

                // Signed 64bit
                case ProtoBuf.TYPES["int64"]:
                case ProtoBuf.TYPES["sint64"]:
                case ProtoBuf.TYPES["sfixed64"]: {
                    if (ProtoBuf.Long)
                        try {
                            return mkLong(value, false);
                        } catch (e) {
                            fail(typeof value, e.message);
                        }
                    else
                        fail(typeof value, "requires Long.js");
                }

                // Unsigned 64bit
                case ProtoBuf.TYPES["uint64"]:
                case ProtoBuf.TYPES["fixed64"]: {
                    if (ProtoBuf.Long)
                        try {
                            return mkLong(value, true);
                        } catch (e) {
                            fail(typeof value, e.message);
                        }
                    else
                        fail(typeof value, "requires Long.js");
                }

                // Bool
                case ProtoBuf.TYPES["bool"]:
                    if (typeof value !== 'boolean')
                        fail(typeof value, "not a boolean");
                    return value;

                // Float
                case ProtoBuf.TYPES["float"]:
                case ProtoBuf.TYPES["double"]:
                    if (typeof value !== 'number')
                        fail(typeof value, "not a number");
                    return value;

                // Length-delimited string
                case ProtoBuf.TYPES["string"]:
                    if (typeof value !== 'string' && !(value && value instanceof String))
                        fail(typeof value, "not a string");
                    return ""+value; // Convert String object to string

                // Length-delimited bytes
                case ProtoBuf.TYPES["bytes"]:
                    if (ByteBuffer.isByteBuffer(value))
                        return value;
                    return ByteBuffer.wrap(value, "base64");

                // Constant enum value
                case ProtoBuf.TYPES["enum"]: {
                    var values = this.resolvedType.getChildren(ProtoBuf.Reflect.Enum.Value);
                    for (i=0; i<values.length; i++)
                        if (values[i].name == value)
                            return values[i].id;
                        else if (values[i].id == value)
                            return values[i].id;

                    if (this.syntax === 'proto3') {
                        // proto3: just make sure it's an integer.
                        if (typeof value !== 'number' || (value === value && value % 1 !== 0))
                            fail(typeof value, "not an integer");
                        if (value > 4294967295 || value < 0)
                            fail(typeof value, "not in range for uint32")
                        return value;
                    } else {
                        // proto2 requires enum values to be valid.
                        fail(value, "not a valid enum value");
                    }
                }
                // Embedded message
                case ProtoBuf.TYPES["group"]:
                case ProtoBuf.TYPES["message"]: {
                    if (!value || typeof value !== 'object')
                        fail(typeof value, "object expected");
                    if (value instanceof this.resolvedType.clazz)
                        return value;
                    if (value instanceof ProtoBuf.Builder.Message) {
                        // Mismatched type: Convert to object (see: https://github.com/dcodeIO/ProtoBuf.js/issues/180)
                        var obj = {};
                        for (var i in value)
                            if (value.hasOwnProperty(i))
                                obj[i] = value[i];
                        value = obj;
                    }
                    // Else let's try to construct one from a key-value object
                    return new (this.resolvedType.clazz)(value); // May throw for a hundred of reasons
                }
            }

            // We should never end here
            throw Error("[INTERNAL] Illegal value for "+this.toString(true)+": "+value+" (undefined type "+this.type+")");
        };

        /**
         * Calculates the byte length of an element on the wire.
         * @param {number} id Field number
         * @param {*} value Field value
         * @returns {number} Byte length
         * @throws {Error} If the value cannot be calculated
         * @expose
         */
        ElementPrototype.calculateLength = function(id, value) {
            if (value === null) return 0; // Nothing to encode
            // Tag has already been written
            var n;
            switch (this.type) {
                case ProtoBuf.TYPES["int32"]:
                    return value < 0 ? ByteBuffer.calculateVarint64(value) : ByteBuffer.calculateVarint32(value);
                case ProtoBuf.TYPES["uint32"]:
                    return ByteBuffer.calculateVarint32(value);
                case ProtoBuf.TYPES["sint32"]:
                    return ByteBuffer.calculateVarint32(ByteBuffer.zigZagEncode32(value));
                case ProtoBuf.TYPES["fixed32"]:
                case ProtoBuf.TYPES["sfixed32"]:
                case ProtoBuf.TYPES["float"]:
                    return 4;
                case ProtoBuf.TYPES["int64"]:
                case ProtoBuf.TYPES["uint64"]:
                    return ByteBuffer.calculateVarint64(value);
                case ProtoBuf.TYPES["sint64"]:
                    return ByteBuffer.calculateVarint64(ByteBuffer.zigZagEncode64(value));
                case ProtoBuf.TYPES["fixed64"]:
                case ProtoBuf.TYPES["sfixed64"]:
                    return 8;
                case ProtoBuf.TYPES["bool"]:
                    return 1;
                case ProtoBuf.TYPES["enum"]:
                    return ByteBuffer.calculateVarint32(value);
                case ProtoBuf.TYPES["double"]:
                    return 8;
                case ProtoBuf.TYPES["string"]:
                    n = ByteBuffer.calculateUTF8Bytes(value);
                    return ByteBuffer.calculateVarint32(n) + n;
                case ProtoBuf.TYPES["bytes"]:
                    if (value.remaining() < 0)
                        throw Error("Illegal value for "+this.toString(true)+": "+value.remaining()+" bytes remaining");
                    return ByteBuffer.calculateVarint32(value.remaining()) + value.remaining();
                case ProtoBuf.TYPES["message"]:
                    n = this.resolvedType.calculate(value);
                    return ByteBuffer.calculateVarint32(n) + n;
                case ProtoBuf.TYPES["group"]:
                    n = this.resolvedType.calculate(value);
                    return n + ByteBuffer.calculateVarint32((id << 3) | ProtoBuf.WIRE_TYPES.ENDGROUP);
            }
            // We should never end here
            throw Error("[INTERNAL] Illegal value to encode in "+this.toString(true)+": "+value+" (unknown type)");
        };

        /**
         * Encodes a value to the specified buffer. Does not encode the key.
         * @param {number} id Field number
         * @param {*} value Field value
         * @param {ByteBuffer} buffer ByteBuffer to encode to
         * @return {ByteBuffer} The ByteBuffer for chaining
         * @throws {Error} If the value cannot be encoded
         * @expose
         */
        ElementPrototype.encodeValue = function(id, value, buffer) {
            if (value === null) return buffer; // Nothing to encode
            // Tag has already been written

            switch (this.type) {
                // 32bit signed varint
                case ProtoBuf.TYPES["int32"]:
                    // "If you use int32 or int64 as the type for a negative number, the resulting varint is always ten bytes
                    // long  it is, effectively, treated like a very large unsigned integer." (see #122)
                    if (value < 0)
                        buffer.writeVarint64(value);
                    else
                        buffer.writeVarint32(value);
                    break;

                // 32bit unsigned varint
                case ProtoBuf.TYPES["uint32"]:
                    buffer.writeVarint32(value);
                    break;

                // 32bit varint zig-zag
                case ProtoBuf.TYPES["sint32"]:
                    buffer.writeVarint32ZigZag(value);
                    break;

                // Fixed unsigned 32bit
                case ProtoBuf.TYPES["fixed32"]:
                    buffer.writeUint32(value);
                    break;

                // Fixed signed 32bit
                case ProtoBuf.TYPES["sfixed32"]:
                    buffer.writeInt32(value);
                    break;

                // 64bit varint as-is
                case ProtoBuf.TYPES["int64"]:
                case ProtoBuf.TYPES["uint64"]:
                    buffer.writeVarint64(value); // throws
                    break;

                // 64bit varint zig-zag
                case ProtoBuf.TYPES["sint64"]:
                    buffer.writeVarint64ZigZag(value); // throws
                    break;

                // Fixed unsigned 64bit
                case ProtoBuf.TYPES["fixed64"]:
                    buffer.writeUint64(value); // throws
                    break;

                // Fixed signed 64bit
                case ProtoBuf.TYPES["sfixed64"]:
                    buffer.writeInt64(value); // throws
                    break;

                // Bool
                case ProtoBuf.TYPES["bool"]:
                    if (typeof value === 'string')
                        buffer.writeVarint32(value.toLowerCase() === 'false' ? 0 : !!value);
                    else
                        buffer.writeVarint32(value ? 1 : 0);
                    break;

                // Constant enum value
                case ProtoBuf.TYPES["enum"]:
                    buffer.writeVarint32(value);
                    break;

                // 32bit float
                case ProtoBuf.TYPES["float"]:
                    buffer.writeFloat32(value);
                    break;

                // 64bit float
                case ProtoBuf.TYPES["double"]:
                    buffer.writeFloat64(value);
                    break;

                // Length-delimited string
                case ProtoBuf.TYPES["string"]:
                    buffer.writeVString(value);
                    break;

                // Length-delimited bytes
                case ProtoBuf.TYPES["bytes"]:
                    if (value.remaining() < 0)
                        throw Error("Illegal value for "+this.toString(true)+": "+value.remaining()+" bytes remaining");
                    var prevOffset = value.offset;
                    buffer.writeVarint32(value.remaining());
                    buffer.append(value);
                    value.offset = prevOffset;
                    break;

                // Embedded message
                case ProtoBuf.TYPES["message"]:
                    var bb = new ByteBuffer().LE();
                    this.resolvedType.encode(value, bb);
                    buffer.writeVarint32(bb.offset);
                    buffer.append(bb.flip());
                    break;

                // Legacy group
                case ProtoBuf.TYPES["group"]:
                    this.resolvedType.encode(value, buffer);
                    buffer.writeVarint32((id << 3) | ProtoBuf.WIRE_TYPES.ENDGROUP);
                    break;

                default:
                    // We should never end here
                    throw Error("[INTERNAL] Illegal value to encode in "+this.toString(true)+": "+value+" (unknown type)");
            }
            return buffer;
        };

        /**
         * Decode one element value from the specified buffer.
         * @param {ByteBuffer} buffer ByteBuffer to decode from
         * @param {number} wireType The field wire type
         * @param {number} id The field number
         * @return {*} Decoded value
         * @throws {Error} If the field cannot be decoded
         * @expose
         */
        ElementPrototype.decode = function(buffer, wireType, id) {
            if (wireType != this.type.wireType)
                throw Error("Unexpected wire type for element");

            var value, nBytes;
            switch (this.type) {
                // 32bit signed varint
                case ProtoBuf.TYPES["int32"]:
                    return buffer.readVarint32() | 0;

                // 32bit unsigned varint
                case ProtoBuf.TYPES["uint32"]:
                    return buffer.readVarint32() >>> 0;

                // 32bit signed varint zig-zag
                case ProtoBuf.TYPES["sint32"]:
                    return buffer.readVarint32ZigZag() | 0;

                // Fixed 32bit unsigned
                case ProtoBuf.TYPES["fixed32"]:
                    return buffer.readUint32() >>> 0;

                case ProtoBuf.TYPES["sfixed32"]:
                    return buffer.readInt32() | 0;

                // 64bit signed varint
                case ProtoBuf.TYPES["int64"]:
                    return buffer.readVarint64();

                // 64bit unsigned varint
                case ProtoBuf.TYPES["uint64"]:
                    return buffer.readVarint64().toUnsigned();

                // 64bit signed varint zig-zag
                case ProtoBuf.TYPES["sint64"]:
                    return buffer.readVarint64ZigZag();

                // Fixed 64bit unsigned
                case ProtoBuf.TYPES["fixed64"]:
                    return buffer.readUint64();

                // Fixed 64bit signed
                case ProtoBuf.TYPES["sfixed64"]:
                    return buffer.readInt64();

                // Bool varint
                case ProtoBuf.TYPES["bool"]:
                    return !!buffer.readVarint32();

                // Constant enum value (varint)
                case ProtoBuf.TYPES["enum"]:
                    // The following Builder.Message#set will already throw
                    return buffer.readVarint32();

                // 32bit float
                case ProtoBuf.TYPES["float"]:
                    return buffer.readFloat();

                // 64bit float
                case ProtoBuf.TYPES["double"]:
                    return buffer.readDouble();

                // Length-delimited string
                case ProtoBuf.TYPES["string"]:
                    return buffer.readVString();

                // Length-delimited bytes
                case ProtoBuf.TYPES["bytes"]: {
                    nBytes = buffer.readVarint32();
                    if (buffer.remaining() < nBytes)
                        throw Error("Illegal number of bytes for "+this.toString(true)+": "+nBytes+" required but got only "+buffer.remaining());
                    value = buffer.clone(); // Offset already set
                    value.limit = value.offset+nBytes;
                    buffer.offset += nBytes;
                    return value;
                }

                // Length-delimited embedded message
                case ProtoBuf.TYPES["message"]: {
                    nBytes = buffer.readVarint32();
                    return this.resolvedType.decode(buffer, nBytes);
                }

                // Legacy group
                case ProtoBuf.TYPES["group"]:
                    return this.resolvedType.decode(buffer, -1, id);
            }

            // We should never end here
            throw Error("[INTERNAL] Illegal decode type");
        };

        /**
         * Converts a value from a string to the canonical element type.
         *
         * Legal only when isMapKey is true.
         *
         * @param {string} str The string value
         * @returns {*} The value
         */
        ElementPrototype.valueFromString = function(str) {
            if (!this.isMapKey) {
                throw Error("valueFromString() called on non-map-key element");
            }

            switch (this.type) {
                case ProtoBuf.TYPES["int32"]:
                case ProtoBuf.TYPES["sint32"]:
                case ProtoBuf.TYPES["sfixed32"]:
                case ProtoBuf.TYPES["uint32"]:
                case ProtoBuf.TYPES["fixed32"]:
                    return this.verifyValue(parseInt(str));

                case ProtoBuf.TYPES["int64"]:
                case ProtoBuf.TYPES["sint64"]:
                case ProtoBuf.TYPES["sfixed64"]:
                case ProtoBuf.TYPES["uint64"]:
                case ProtoBuf.TYPES["fixed64"]:
                      // Long-based fields support conversions from string already.
                      return this.verifyValue(str);

                case ProtoBuf.TYPES["bool"]:
                      return str === "true";

                case ProtoBuf.TYPES["string"]:
                      return this.verifyValue(str);

                case ProtoBuf.TYPES["bytes"]:
                      return ByteBuffer.fromBinary(str);
            }
        };

        /**
         * Converts a value from the canonical element type to a string.
         *
         * It should be the case that `valueFromString(valueToString(val))` returns
         * a value equivalent to `verifyValue(val)` for every legal value of `val`
         * according to this element type.
         *
         * This may be used when the element must be stored or used as a string,
         * e.g., as a map key on an Object.
         *
         * Legal only when isMapKey is true.
         *
         * @param {*} val The value
         * @returns {string} The string form of the value.
         */
        ElementPrototype.valueToString = function(value) {
            if (!this.isMapKey) {
                throw Error("valueToString() called on non-map-key element");
            }

            if (this.type === ProtoBuf.TYPES["bytes"]) {
                return value.toString("binary");
            } else {
                return value.toString();
            }
        };

        /**
         * @alias ProtoBuf.Reflect.Element
         * @expose
         */
        Reflect.Element = Element;

        /**
         * Constructs a new Message.
         * @exports ProtoBuf.Reflect.Message
         * @param {!ProtoBuf.Builder} builder Builder reference
         * @param {!ProtoBuf.Reflect.Namespace} parent Parent message or namespace
         * @param {string} name Message name
         * @param {Object.<string,*>=} options Message options
         * @param {boolean=} isGroup `true` if this is a legacy group
         * @param {string?} syntax The syntax level of this definition (e.g., proto3)
         * @constructor
         * @extends ProtoBuf.Reflect.Namespace
         */
        var Message = function(builder, parent, name, options, isGroup, syntax) {
            Namespace.call(this, builder, parent, name, options, syntax);

            /**
             * @override
             */
            this.className = "Message";

            /**
             * Extensions range.
             * @type {!Array.<number>}
             * @expose
             */
            this.extensions = [ProtoBuf.ID_MIN, ProtoBuf.ID_MAX];

            /**
             * Runtime message class.
             * @type {?function(new:ProtoBuf.Builder.Message)}
             * @expose
             */
            this.clazz = null;

            /**
             * Whether this is a legacy group or not.
             * @type {boolean}
             * @expose
             */
            this.isGroup = !!isGroup;

            // The following cached collections are used to efficiently iterate over or look up fields when decoding.

            /**
             * Cached fields.
             * @type {?Array.<!ProtoBuf.Reflect.Message.Field>}
             * @private
             */
            this._fields = null;

            /**
             * Cached fields by id.
             * @type {?Object.<number,!ProtoBuf.Reflect.Message.Field>}
             * @private
             */
            this._fieldsById = null;

            /**
             * Cached fields by name.
             * @type {?Object.<string,!ProtoBuf.Reflect.Message.Field>}
             * @private
             */
            this._fieldsByName = null;
        };

        /**
         * @alias ProtoBuf.Reflect.Message.prototype
         * @inner
         */
        var MessagePrototype = Message.prototype = Object.create(Namespace.prototype);

        /**
         * Builds the message and returns the runtime counterpart, which is a fully functional class.
         * @see ProtoBuf.Builder.Message
         * @param {boolean=} rebuild Whether to rebuild or not, defaults to false
         * @return {ProtoBuf.Reflect.Message} Message class
         * @throws {Error} If the message cannot be built
         * @expose
         */
        MessagePrototype.build = function(rebuild) {
            if (this.clazz && !rebuild)
                return this.clazz;

            // Create the runtime Message class in its own scope
            var clazz = (function(ProtoBuf, T) {

                var fields = T.getChildren(ProtoBuf.Reflect.Message.Field),
                    oneofs = T.getChildren(ProtoBuf.Reflect.Message.OneOf);

                /**
                 * Constructs a new runtime Message.
                 * @name ProtoBuf.Builder.Message
                 * @class Barebone of all runtime messages.
                 * @param {!Object.<string,*>|string} values Preset values
                 * @param {...string} var_args
                 * @constructor
                 * @throws {Error} If the message cannot be created
                 */
                var Message = function(values, var_args) {
                    ProtoBuf.Builder.Message.call(this);

                    // Create virtual oneof properties
                    for (var i=0, k=oneofs.length; i<k; ++i)
                        this[oneofs[i].name] = null;
                    // Create fields and set default values
                    for (i=0, k=fields.length; i<k; ++i) {
                        var field = fields[i];
                        this[field.name] =
                            field.repeated ? [] :
                            (field.map ? new ProtoBuf.Map(field) : null);
                        if ((field.required || T.syntax === 'proto3') &&
                            field.defaultValue !== null)
                            this[field.name] = field.defaultValue;
                    }

                    if (arguments.length > 0) {
                        var value;
                        // Set field values from a values object
                        if (arguments.length === 1 && values !== null && typeof values === 'object' &&
                            /* not _another_ Message */ (typeof values.encode !== 'function' || values instanceof Message) &&
                            /* not a repeated field */ !Array.isArray(values) &&
                            /* not a Map */ !(values instanceof ProtoBuf.Map) &&
                            /* not a ByteBuffer */ !ByteBuffer.isByteBuffer(values) &&
                            /* not an ArrayBuffer */ !(values instanceof ArrayBuffer) &&
                            /* not a Long */ !(ProtoBuf.Long && values instanceof ProtoBuf.Long)) {
                            this.$set(values);
                        } else // Set field values from arguments, in declaration order
                            for (i=0, k=arguments.length; i<k; ++i)
                                if (typeof (value = arguments[i]) !== 'undefined')
                                    this.$set(fields[i].name, value); // May throw
                    }
                };

                /**
                 * @alias ProtoBuf.Builder.Message.prototype
                 * @inner
                 */
                var MessagePrototype = Message.prototype = Object.create(ProtoBuf.Builder.Message.prototype);

                /**
                 * Adds a value to a repeated field.
                 * @name ProtoBuf.Builder.Message#add
                 * @function
                 * @param {string} key Field name
                 * @param {*} value Value to add
                 * @param {boolean=} noAssert Whether to assert the value or not (asserts by default)
                 * @returns {!ProtoBuf.Builder.Message} this
                 * @throws {Error} If the value cannot be added
                 * @expose
                 */
                MessagePrototype.add = function(key, value, noAssert) {
                    var field = T._fieldsByName[key];
                    if (!noAssert) {
                        if (!field)
                            throw Error(this+"#"+key+" is undefined");
                        if (!(field instanceof ProtoBuf.Reflect.Message.Field))
                            throw Error(this+"#"+key+" is not a field: "+field.toString(true)); // May throw if it's an enum or embedded message
                        if (!field.repeated)
                            throw Error(this+"#"+key+" is not a repeated field");
                        value = field.verifyValue(value, true);
                    }
                    if (this[key] === null)
                        this[key] = [];
                    this[key].push(value);
                    return this;
                };

                /**
                 * Adds a value to a repeated field. This is an alias for {@link ProtoBuf.Builder.Message#add}.
                 * @name ProtoBuf.Builder.Message#$add
                 * @function
                 * @param {string} key Field name
                 * @param {*} value Value to add
                 * @param {boolean=} noAssert Whether to assert the value or not (asserts by default)
                 * @returns {!ProtoBuf.Builder.Message} this
                 * @throws {Error} If the value cannot be added
                 * @expose
                 */
                MessagePrototype.$add = MessagePrototype.add;

                /**
                 * Sets a field's value.
                 * @name ProtoBuf.Builder.Message#set
                 * @function
                 * @param {string|!Object.<string,*>} keyOrObj String key or plain object holding multiple values
                 * @param {(*|boolean)=} value Value to set if key is a string, otherwise omitted
                 * @param {boolean=} noAssert Whether to not assert for an actual field / proper value type, defaults to `false`
                 * @returns {!ProtoBuf.Builder.Message} this
                 * @throws {Error} If the value cannot be set
                 * @expose
                 */
                MessagePrototype.set = function(keyOrObj, value, noAssert) {
                    if (keyOrObj && typeof keyOrObj === 'object') {
                        noAssert = value;
                        for (var ikey in keyOrObj)
                            if (keyOrObj.hasOwnProperty(ikey) && typeof (value = keyOrObj[ikey]) !== 'undefined')
                                this.$set(ikey, value, noAssert);
                        return this;
                    }
                    var field = T._fieldsByName[keyOrObj];
                    if (!noAssert) {
                        if (!field)
                            throw Error(this+"#"+keyOrObj+" is not a field: undefined");
                        if (!(field instanceof ProtoBuf.Reflect.Message.Field))
                            throw Error(this+"#"+keyOrObj+" is not a field: "+field.toString(true));
                        this[field.name] = (value = field.verifyValue(value)); // May throw
                    } else
                        this[keyOrObj] = value;
                    if (field && field.oneof) { // Field is part of an OneOf (not a virtual OneOf field)
                        var currentField = this[field.oneof.name]; // Virtual field references currently set field
                        if (value !== null) {
                            if (currentField !== null && currentField !== field.name)
                                this[currentField] = null; // Clear currently set field
                            this[field.oneof.name] = field.name; // Point virtual field at this field
                        } else if (/* value === null && */currentField === keyOrObj)
                            this[field.oneof.name] = null; // Clear virtual field (current field explicitly cleared)
                    }
                    return this;
                };

                /**
                 * Sets a field's value. This is an alias for [@link ProtoBuf.Builder.Message#set}.
                 * @name ProtoBuf.Builder.Message#$set
                 * @function
                 * @param {string|!Object.<string,*>} keyOrObj String key or plain object holding multiple values
                 * @param {(*|boolean)=} value Value to set if key is a string, otherwise omitted
                 * @param {boolean=} noAssert Whether to not assert the value, defaults to `false`
                 * @throws {Error} If the value cannot be set
                 * @expose
                 */
                MessagePrototype.$set = MessagePrototype.set;

                /**
                 * Gets a field's value.
                 * @name ProtoBuf.Builder.Message#get
                 * @function
                 * @param {string} key Key
                 * @param {boolean=} noAssert Whether to not assert for an actual field, defaults to `false`
                 * @return {*} Value
                 * @throws {Error} If there is no such field
                 * @expose
                 */
                MessagePrototype.get = function(key, noAssert) {
                    if (noAssert)
                        return this[key];
                    var field = T._fieldsByName[key];
                    if (!field || !(field instanceof ProtoBuf.Reflect.Message.Field))
                        throw Error(this+"#"+key+" is not a field: undefined");
                    if (!(field instanceof ProtoBuf.Reflect.Message.Field))
                        throw Error(this+"#"+key+" is not a field: "+field.toString(true));
                    return this[field.name];
                };

                /**
                 * Gets a field's value. This is an alias for {@link ProtoBuf.Builder.Message#$get}.
                 * @name ProtoBuf.Builder.Message#$get
                 * @function
                 * @param {string} key Key
                 * @return {*} Value
                 * @throws {Error} If there is no such field
                 * @expose
                 */
                MessagePrototype.$get = MessagePrototype.get;

                // Getters and setters

                for (var i=0; i<fields.length; i++) {
                    var field = fields[i];
                    // no setters for extension fields as these are named by their fqn
                    if (field instanceof ProtoBuf.Reflect.Message.ExtensionField)
                        continue;

                    if (T.builder.options['populateAccessors'])
                        (function(field) {
                            // set/get[SomeValue]
                            var Name = field.originalName.replace(/(_[a-zA-Z])/g, function(match) {
                                return match.toUpperCase().replace('_','');
                            });
                            Name = Name.substring(0,1).toUpperCase() + Name.substring(1);

                            // set/get_[some_value] FIXME: Do we really need these?
                            var name = field.originalName.replace(/([A-Z])/g, function(match) {
                                return "_"+match;
                            });

                            /**
                             * The current field's unbound setter function.
                             * @function
                             * @param {*} value
                             * @param {boolean=} noAssert
                             * @returns {!ProtoBuf.Builder.Message}
                             * @inner
                             */
                            var setter = function(value, noAssert) {
                                this[field.name] = noAssert ? value : field.verifyValue(value);
                                return this;
                            };

                            /**
                             * The current field's unbound getter function.
                             * @function
                             * @returns {*}
                             * @inner
                             */
                            var getter = function() {
                                return this[field.name];
                            };

                            if (T.getChild("set"+Name) === null)
                                /**
                                 * Sets a value. This method is present for each field, but only if there is no name conflict with
                                 *  another field.
                                 * @name ProtoBuf.Builder.Message#set[SomeField]
                                 * @function
                                 * @param {*} value Value to set
                                 * @param {boolean=} noAssert Whether to not assert the value, defaults to `false`
                                 * @returns {!ProtoBuf.Builder.Message} this
                                 * @abstract
                                 * @throws {Error} If the value cannot be set
                                 */
                                MessagePrototype["set"+Name] = setter;

                            if (T.getChild("set_"+name) === null)
                                /**
                                 * Sets a value. This method is present for each field, but only if there is no name conflict with
                                 *  another field.
                                 * @name ProtoBuf.Builder.Message#set_[some_field]
                                 * @function
                                 * @param {*} value Value to set
                                 * @param {boolean=} noAssert Whether to not assert the value, defaults to `false`
                                 * @returns {!ProtoBuf.Builder.Message} this
                                 * @abstract
                                 * @throws {Error} If the value cannot be set
                                 */
                                MessagePrototype["set_"+name] = setter;

                            if (T.getChild("get"+Name) === null)
                                /**
                                 * Gets a value. This method is present for each field, but only if there is no name conflict with
                                 *  another field.
                                 * @name ProtoBuf.Builder.Message#get[SomeField]
                                 * @function
                                 * @abstract
                                 * @return {*} The value
                                 */
                                MessagePrototype["get"+Name] = getter;

                            if (T.getChild("get_"+name) === null)
                                /**
                                 * Gets a value. This method is present for each field, but only if there is no name conflict with
                                 *  another field.
                                 * @name ProtoBuf.Builder.Message#get_[some_field]
                                 * @function
                                 * @return {*} The value
                                 * @abstract
                                 */
                                MessagePrototype["get_"+name] = getter;

                        })(field);
                }

                // En-/decoding

                /**
                 * Encodes the message.
                 * @name ProtoBuf.Builder.Message#$encode
                 * @function
                 * @param {(!ByteBuffer|boolean)=} buffer ByteBuffer to encode to. Will create a new one and flip it if omitted.
                 * @param {boolean=} noVerify Whether to not verify field values, defaults to `false`
                 * @return {!ByteBuffer} Encoded message as a ByteBuffer
                 * @throws {Error} If the message cannot be encoded or if required fields are missing. The later still
                 *  returns the encoded ByteBuffer in the `encoded` property on the error.
                 * @expose
                 * @see ProtoBuf.Builder.Message#encode64
                 * @see ProtoBuf.Builder.Message#encodeHex
                 * @see ProtoBuf.Builder.Message#encodeAB
                 */
                MessagePrototype.encode = function(buffer, noVerify) {
                    if (typeof buffer === 'boolean')
                        noVerify = buffer,
                        buffer = undefined;
                    var isNew = false;
                    if (!buffer)
                        buffer = new ByteBuffer(),
                        isNew = true;
                    var le = buffer.littleEndian;
                    try {
                        T.encode(this, buffer.LE(), noVerify);
                        return (isNew ? buffer.flip() : buffer).LE(le);
                    } catch (e) {
                        buffer.LE(le);
                        throw(e);
                    }
                };

                /**
                 * Encodes a message using the specified data payload.
                 * @param {!Object.<string,*>} data Data payload
                 * @param {(!ByteBuffer|boolean)=} buffer ByteBuffer to encode to. Will create a new one and flip it if omitted.
                 * @param {boolean=} noVerify Whether to not verify field values, defaults to `false`
                 * @return {!ByteBuffer} Encoded message as a ByteBuffer
                 * @expose
                 */
                Message.encode = function(data, buffer, noVerify) {
                    return new Message(data).encode(buffer, noVerify);
                };

                /**
                 * Calculates the byte length of the message.
                 * @name ProtoBuf.Builder.Message#calculate
                 * @function
                 * @returns {number} Byte length
                 * @throws {Error} If the message cannot be calculated or if required fields are missing.
                 * @expose
                 */
                MessagePrototype.calculate = function() {
                    return T.calculate(this);
                };

                /**
                 * Encodes the varint32 length-delimited message.
                 * @name ProtoBuf.Builder.Message#encodeDelimited
                 * @function
                 * @param {(!ByteBuffer|boolean)=} buffer ByteBuffer to encode to. Will create a new one and flip it if omitted.
                 * @return {!ByteBuffer} Encoded message as a ByteBuffer
                 * @throws {Error} If the message cannot be encoded or if required fields are missing. The later still
                 *  returns the encoded ByteBuffer in the `encoded` property on the error.
                 * @expose
                 */
                MessagePrototype.encodeDelimited = function(buffer) {
                    var isNew = false;
                    if (!buffer)
                        buffer = new ByteBuffer(),
                        isNew = true;
                    var enc = new ByteBuffer().LE();
                    T.encode(this, enc).flip();
                    buffer.writeVarint32(enc.remaining());
                    buffer.append(enc);
                    return isNew ? buffer.flip() : buffer;
                };

                /**
                 * Directly encodes the message to an ArrayBuffer.
                 * @name ProtoBuf.Builder.Message#encodeAB
                 * @function
                 * @return {ArrayBuffer} Encoded message as ArrayBuffer
                 * @throws {Error} If the message cannot be encoded or if required fields are missing. The later still
                 *  returns the encoded ArrayBuffer in the `encoded` property on the error.
                 * @expose
                 */
                MessagePrototype.encodeAB = function() {
                    try {
                        return this.encode().toArrayBuffer();
                    } catch (e) {
                        if (e["encoded"]) e["encoded"] = e["encoded"].toArrayBuffer();
                        throw(e);
                    }
                };

                /**
                 * Returns the message as an ArrayBuffer. This is an alias for {@link ProtoBuf.Builder.Message#encodeAB}.
                 * @name ProtoBuf.Builder.Message#toArrayBuffer
                 * @function
                 * @return {ArrayBuffer} Encoded message as ArrayBuffer
                 * @throws {Error} If the message cannot be encoded or if required fields are missing. The later still
                 *  returns the encoded ArrayBuffer in the `encoded` property on the error.
                 * @expose
                 */
                MessagePrototype.toArrayBuffer = MessagePrototype.encodeAB;

                /**
                 * Directly encodes the message to a node Buffer.
                 * @name ProtoBuf.Builder.Message#encodeNB
                 * @function
                 * @return {!Buffer}
                 * @throws {Error} If the message cannot be encoded, not running under node.js or if required fields are
                 *  missing. The later still returns the encoded node Buffer in the `encoded` property on the error.
                 * @expose
                 */
                MessagePrototype.encodeNB = function() {
                    try {
                        return this.encode().toBuffer();
                    } catch (e) {
                        if (e["encoded"]) e["encoded"] = e["encoded"].toBuffer();
                        throw(e);
                    }
                };

                /**
                 * Returns the message as a node Buffer. This is an alias for {@link ProtoBuf.Builder.Message#encodeNB}.
                 * @name ProtoBuf.Builder.Message#toBuffer
                 * @function
                 * @return {!Buffer}
                 * @throws {Error} If the message cannot be encoded or if required fields are missing. The later still
                 *  returns the encoded node Buffer in the `encoded` property on the error.
                 * @expose
                 */
                MessagePrototype.toBuffer = MessagePrototype.encodeNB;

                /**
                 * Directly encodes the message to a base64 encoded string.
                 * @name ProtoBuf.Builder.Message#encode64
                 * @function
                 * @return {string} Base64 encoded string
                 * @throws {Error} If the underlying buffer cannot be encoded or if required fields are missing. The later
                 *  still returns the encoded base64 string in the `encoded` property on the error.
                 * @expose
                 */
                MessagePrototype.encode64 = function() {
                    try {
                        return this.encode().toBase64();
                    } catch (e) {
                        if (e["encoded"]) e["encoded"] = e["encoded"].toBase64();
                        throw(e);
                    }
                };

                /**
                 * Returns the message as a base64 encoded string. This is an alias for {@link ProtoBuf.Builder.Message#encode64}.
                 * @name ProtoBuf.Builder.Message#toBase64
                 * @function
                 * @return {string} Base64 encoded string
                 * @throws {Error} If the message cannot be encoded or if required fields are missing. The later still
                 *  returns the encoded base64 string in the `encoded` property on the error.
                 * @expose
                 */
                MessagePrototype.toBase64 = MessagePrototype.encode64;

                /**
                 * Directly encodes the message to a hex encoded string.
                 * @name ProtoBuf.Builder.Message#encodeHex
                 * @function
                 * @return {string} Hex encoded string
                 * @throws {Error} If the underlying buffer cannot be encoded or if required fields are missing. The later
                 *  still returns the encoded hex string in the `encoded` property on the error.
                 * @expose
                 */
                MessagePrototype.encodeHex = function() {
                    try {
                        return this.encode().toHex();
                    } catch (e) {
                        if (e["encoded"]) e["encoded"] = e["encoded"].toHex();
                        throw(e);
                    }
                };

                /**
                 * Returns the message as a hex encoded string. This is an alias for {@link ProtoBuf.Builder.Message#encodeHex}.
                 * @name ProtoBuf.Builder.Message#toHex
                 * @function
                 * @return {string} Hex encoded string
                 * @throws {Error} If the message cannot be encoded or if required fields are missing. The later still
                 *  returns the encoded hex string in the `encoded` property on the error.
                 * @expose
                 */
                MessagePrototype.toHex = MessagePrototype.encodeHex;

                /**
                 * Clones a message object or field value to a raw object.
                 * @param {*} obj Object to clone
                 * @param {boolean} binaryAsBase64 Whether to include binary data as base64 strings or as a buffer otherwise
                 * @param {boolean} longsAsStrings Whether to encode longs as strings
                 * @param {!ProtoBuf.Reflect.T=} resolvedType The resolved field type if a field
                 * @returns {*} Cloned object
                 * @inner
                 */
                function cloneRaw(obj, binaryAsBase64, longsAsStrings, resolvedType) {
                    if (obj === null || typeof obj !== 'object') {
                        // Convert enum values to their respective names
                        if (resolvedType && resolvedType instanceof ProtoBuf.Reflect.Enum) {
                            var name = ProtoBuf.Reflect.Enum.getName(resolvedType.object, obj);
                            if (name !== null)
                                return name;
                        }
                        // Pass-through string, number, boolean, null...
                        return obj;
                    }
                    // Convert ByteBuffers to raw buffer or strings
                    if (ByteBuffer.isByteBuffer(obj))
                        return binaryAsBase64 ? obj.toBase64() : obj.toBuffer();
                    // Convert Longs to proper objects or strings
                    if (ProtoBuf.Long.isLong(obj))
                        return longsAsStrings ? obj.toString() : ProtoBuf.Long.fromValue(obj);
                    var clone;
                    // Clone arrays
                    if (Array.isArray(obj)) {
                        clone = [];
                        obj.forEach(function(v, k) {
                            clone[k] = cloneRaw(v, binaryAsBase64, longsAsStrings, resolvedType);
                        });
                        return clone;
                    }
                    clone = {};
                    // Convert maps to objects
                    if (obj instanceof ProtoBuf.Map) {
                        var it = obj.entries();
                        for (var e = it.next(); !e.done; e = it.next())
                            clone[obj.keyElem.valueToString(e.value[0])] = cloneRaw(e.value[1], binaryAsBase64, longsAsStrings, obj.valueElem.resolvedType);
                        return clone;
                    }
                    // Everything else is a non-null object
                    var type = obj.$type,
                        field = undefined;
                    for (var i in obj)
                        if (obj.hasOwnProperty(i)) {
                            if (type && (field = type.getChild(i)))
                                clone[i] = cloneRaw(obj[i], binaryAsBase64, longsAsStrings, field.resolvedType);
                            else
                                clone[i] = cloneRaw(obj[i], binaryAsBase64, longsAsStrings);
                        }
                    return clone;
                }

                /**
                 * Returns the message's raw payload.
                 * @param {boolean=} binaryAsBase64 Whether to include binary data as base64 strings instead of Buffers, defaults to `false`
                 * @param {boolean} longsAsStrings Whether to encode longs as strings
                 * @returns {Object.<string,*>} Raw payload
                 * @expose
                 */
                MessagePrototype.toRaw = function(binaryAsBase64, longsAsStrings) {
                    return cloneRaw(this, !!binaryAsBase64, !!longsAsStrings, this.$type);
                };

                /**
                 * Encodes a message to JSON.
                 * @returns {string} JSON string
                 * @expose
                 */
                MessagePrototype.encodeJSON = function() {
                    return JSON.stringify(
                        cloneRaw(this,
                             /* binary-as-base64 */ true,
                             /* longs-as-strings */ true,
                             this.$type
                        )
                    );
                };

                /**
                 * Decodes a message from the specified buffer or string.
                 * @name ProtoBuf.Builder.Message.decode
                 * @function
                 * @param {!ByteBuffer|!ArrayBuffer|!Buffer|string} buffer Buffer to decode from
                 * @param {string=} enc Encoding if buffer is a string: hex, utf8 (not recommended), defaults to base64
                 * @return {!ProtoBuf.Builder.Message} Decoded message
                 * @throws {Error} If the message cannot be decoded or if required fields are missing. The later still
                 *  returns the decoded message with missing fields in the `decoded` property on the error.
                 * @expose
                 * @see ProtoBuf.Builder.Message.decode64
                 * @see ProtoBuf.Builder.Message.decodeHex
                 */
                Message.decode = function(buffer, enc) {
                    if (typeof buffer === 'string')
                        buffer = ByteBuffer.wrap(buffer, enc ? enc : "base64");
                    buffer = ByteBuffer.isByteBuffer(buffer) ? buffer : ByteBuffer.wrap(buffer); // May throw
                    var le = buffer.littleEndian;
                    try {
                        var msg = T.decode(buffer.LE());
                        buffer.LE(le);
                        return msg;
                    } catch (e) {
                        buffer.LE(le);
                        throw(e);
                    }
                };

                /**
                 * Decodes a varint32 length-delimited message from the specified buffer or string.
                 * @name ProtoBuf.Builder.Message.decodeDelimited
                 * @function
                 * @param {!ByteBuffer|!ArrayBuffer|!Buffer|string} buffer Buffer to decode from
                 * @param {string=} enc Encoding if buffer is a string: hex, utf8 (not recommended), defaults to base64
                 * @return {ProtoBuf.Builder.Message} Decoded message or `null` if not enough bytes are available yet
                 * @throws {Error} If the message cannot be decoded or if required fields are missing. The later still
                 *  returns the decoded message with missing fields in the `decoded` property on the error.
                 * @expose
                 */
                Message.decodeDelimited = function(buffer, enc) {
                    if (typeof buffer === 'string')
                        buffer = ByteBuffer.wrap(buffer, enc ? enc : "base64");
                    buffer = ByteBuffer.isByteBuffer(buffer) ? buffer : ByteBuffer.wrap(buffer); // May throw
                    if (buffer.remaining() < 1)
                        return null;
                    var off = buffer.offset,
                        len = buffer.readVarint32();
                    if (buffer.remaining() < len) {
                        buffer.offset = off;
                        return null;
                    }
                    try {
                        var msg = T.decode(buffer.slice(buffer.offset, buffer.offset + len).LE());
                        buffer.offset += len;
                        return msg;
                    } catch (err) {
                        buffer.offset += len;
                        throw err;
                    }
                };

                /**
                 * Decodes the message from the specified base64 encoded string.
                 * @name ProtoBuf.Builder.Message.decode64
                 * @function
                 * @param {string} str String to decode from
                 * @return {!ProtoBuf.Builder.Message} Decoded message
                 * @throws {Error} If the message cannot be decoded or if required fields are missing. The later still
                 *  returns the decoded message with missing fields in the `decoded` property on the error.
                 * @expose
                 */
                Message.decode64 = function(str) {
                    return Message.decode(str, "base64");
                };

                /**
                 * Decodes the message from the specified hex encoded string.
                 * @name ProtoBuf.Builder.Message.decodeHex
                 * @function
                 * @param {string} str String to decode from
                 * @return {!ProtoBuf.Builder.Message} Decoded message
                 * @throws {Error} If the message cannot be decoded or if required fields are missing. The later still
                 *  returns the decoded message with missing fields in the `decoded` property on the error.
                 * @expose
                 */
                Message.decodeHex = function(str) {
                    return Message.decode(str, "hex");
                };

                /**
                 * Decodes the message from a JSON string.
                 * @name ProtoBuf.Builder.Message.decodeJSON
                 * @function
                 * @param {string} str String to decode from
                 * @return {!ProtoBuf.Builder.Message} Decoded message
                 * @throws {Error} If the message cannot be decoded or if required fields are
                 * missing.
                 * @expose
                 */
                Message.decodeJSON = function(str) {
                    return new Message(JSON.parse(str));
                };

                // Utility

                /**
                 * Returns a string representation of this Message.
                 * @name ProtoBuf.Builder.Message#toString
                 * @function
                 * @return {string} String representation as of ".Fully.Qualified.MessageName"
                 * @expose
                 */
                MessagePrototype.toString = function() {
                    return T.toString();
                };

                // Properties

                /**
                 * Message options.
                 * @name ProtoBuf.Builder.Message.$options
                 * @type {Object.<string,*>}
                 * @expose
                 */
                var $optionsS; // cc needs this

                /**
                 * Message options.
                 * @name ProtoBuf.Builder.Message#$options
                 * @type {Object.<string,*>}
                 * @expose
                 */
                var $options;

                /**
                 * Reflection type.
                 * @name ProtoBuf.Builder.Message.$type
                 * @type {!ProtoBuf.Reflect.Message}
                 * @expose
                 */
                var $typeS;

                /**
                 * Reflection type.
                 * @name ProtoBuf.Builder.Message#$type
                 * @type {!ProtoBuf.Reflect.Message}
                 * @expose
                 */
                var $type;

                if (Object.defineProperty)
                    Object.defineProperty(Message, '$options', { "value": T.buildOpt() }),
                    Object.defineProperty(MessagePrototype, "$options", { "value": Message["$options"] }),
                    Object.defineProperty(Message, "$type", { "value": T }),
                    Object.defineProperty(MessagePrototype, "$type", { "value": T });

                return Message;

            })(ProtoBuf, this);

            // Static enums and prototyped sub-messages / cached collections
            this._fields = [];
            this._fieldsById = {};
            this._fieldsByName = {};
            for (var i=0, k=this.children.length, child; i<k; i++) {
                child = this.children[i];
                if (child instanceof Enum || child instanceof Message || child instanceof Service) {
                    if (clazz.hasOwnProperty(child.name))
                        throw Error("Illegal reflect child of "+this.toString(true)+": "+child.toString(true)+" cannot override static property '"+child.name+"'");
                    clazz[child.name] = child.build();
                } else if (child instanceof Message.Field)
                    child.build(),
                    this._fields.push(child),
                    this._fieldsById[child.id] = child,
                    this._fieldsByName[child.name] = child;
                else if (!(child instanceof Message.OneOf) && !(child instanceof Extension)) // Not built
                    throw Error("Illegal reflect child of "+this.toString(true)+": "+this.children[i].toString(true));
            }

            return this.clazz = clazz;
        };

        /**
         * Encodes a runtime message's contents to the specified buffer.
         * @param {!ProtoBuf.Builder.Message} message Runtime message to encode
         * @param {ByteBuffer} buffer ByteBuffer to write to
         * @param {boolean=} noVerify Whether to not verify field values, defaults to `false`
         * @return {ByteBuffer} The ByteBuffer for chaining
         * @throws {Error} If required fields are missing or the message cannot be encoded for another reason
         * @expose
         */
        MessagePrototype.encode = function(message, buffer, noVerify) {
            var fieldMissing = null,
                field;
            for (var i=0, k=this._fields.length, val; i<k; ++i) {
                field = this._fields[i];
                val = message[field.name];
                if (field.required && val === null) {
                    if (fieldMissing === null)
                        fieldMissing = field;
                } else
                    field.encode(noVerify ? val : field.verifyValue(val), buffer, message);
            }
            if (fieldMissing !== null) {
                var err = Error("Missing at least one required field for "+this.toString(true)+": "+fieldMissing);
                err["encoded"] = buffer; // Still expose what we got
                throw(err);
            }
            return buffer;
        };

        /**
         * Calculates a runtime message's byte length.
         * @param {!ProtoBuf.Builder.Message} message Runtime message to encode
         * @returns {number} Byte length
         * @throws {Error} If required fields are missing or the message cannot be calculated for another reason
         * @expose
         */
        MessagePrototype.calculate = function(message) {
            for (var n=0, i=0, k=this._fields.length, field, val; i<k; ++i) {
                field = this._fields[i];
                val = message[field.name];
                if (field.required && val === null)
                   throw Error("Missing at least one required field for "+this.toString(true)+": "+field);
                else
                    n += field.calculate(val, message);
            }
            return n;
        };

        /**
         * Skips all data until the end of the specified group has been reached.
         * @param {number} expectedId Expected GROUPEND id
         * @param {!ByteBuffer} buf ByteBuffer
         * @returns {boolean} `true` if a value as been skipped, `false` if the end has been reached
         * @throws {Error} If it wasn't possible to find the end of the group (buffer overrun or end tag mismatch)
         * @inner
         */
        function skipTillGroupEnd(expectedId, buf) {
            var tag = buf.readVarint32(), // Throws on OOB
                wireType = tag & 0x07,
                id = tag >>> 3;
            switch (wireType) {
                case ProtoBuf.WIRE_TYPES.VARINT:
                    do tag = buf.readUint8();
                    while ((tag & 0x80) === 0x80);
                    break;
                case ProtoBuf.WIRE_TYPES.BITS64:
                    buf.offset += 8;
                    break;
                case ProtoBuf.WIRE_TYPES.LDELIM:
                    tag = buf.readVarint32(); // reads the varint
                    buf.offset += tag;        // skips n bytes
                    break;
                case ProtoBuf.WIRE_TYPES.STARTGROUP:
                    skipTillGroupEnd(id, buf);
                    break;
                case ProtoBuf.WIRE_TYPES.ENDGROUP:
                    if (id === expectedId)
                        return false;
                    else
                        throw Error("Illegal GROUPEND after unknown group: "+id+" ("+expectedId+" expected)");
                case ProtoBuf.WIRE_TYPES.BITS32:
                    buf.offset += 4;
                    break;
                default:
                    throw Error("Illegal wire type in unknown group "+expectedId+": "+wireType);
            }
            return true;
        }

        /**
         * Decodes an encoded message and returns the decoded message.
         * @param {ByteBuffer} buffer ByteBuffer to decode from
         * @param {number=} length Message length. Defaults to decode all the available data.
         * @param {number=} expectedGroupEndId Expected GROUPEND id if this is a legacy group
         * @return {ProtoBuf.Builder.Message} Decoded message
         * @throws {Error} If the message cannot be decoded
         * @expose
         */
        MessagePrototype.decode = function(buffer, length, expectedGroupEndId) {
            length = typeof length === 'number' ? length : -1;
            var start = buffer.offset,
                msg = new (this.clazz)(),
                tag, wireType, id, field;
            while (buffer.offset < start+length || (length === -1 && buffer.remaining() > 0)) {
                tag = buffer.readVarint32();
                wireType = tag & 0x07;
                id = tag >>> 3;
                if (wireType === ProtoBuf.WIRE_TYPES.ENDGROUP) {
                    if (id !== expectedGroupEndId)
                        throw Error("Illegal group end indicator for "+this.toString(true)+": "+id+" ("+(expectedGroupEndId ? expectedGroupEndId+" expected" : "not a group")+")");
                    break;
                }
                if (!(field = this._fieldsById[id])) {
                    // "messages created by your new code can be parsed by your old code: old binaries simply ignore the new field when parsing."
                    switch (wireType) {
                        case ProtoBuf.WIRE_TYPES.VARINT:
                            buffer.readVarint32();
                            break;
                        case ProtoBuf.WIRE_TYPES.BITS32:
                            buffer.offset += 4;
                            break;
                        case ProtoBuf.WIRE_TYPES.BITS64:
                            buffer.offset += 8;
                            break;
                        case ProtoBuf.WIRE_TYPES.LDELIM:
                            var len = buffer.readVarint32();
                            buffer.offset += len;
                            break;
                        case ProtoBuf.WIRE_TYPES.STARTGROUP:
                            while (skipTillGroupEnd(id, buffer)) {}
                            break;
                        default:
                            throw Error("Illegal wire type for unknown field "+id+" in "+this.toString(true)+"#decode: "+wireType);
                    }
                    continue;
                }
                if (field.repeated && !field.options["packed"]) {
                    msg[field.name].push(field.decode(wireType, buffer));
                } else if (field.map) {
                    var keyval = field.decode(wireType, buffer);
                    msg[field.name].set(keyval[0], keyval[1]);
                } else {
                    msg[field.name] = field.decode(wireType, buffer);
                    if (field.oneof) { // Field is part of an OneOf (not a virtual OneOf field)
                        var currentField = msg[field.oneof.name]; // Virtual field references currently set field
                        if (currentField !== null && currentField !== field.name)
                            msg[currentField] = null; // Clear currently set field
                        msg[field.oneof.name] = field.name; // Point virtual field at this field
                    }
                }
            }

            // Check if all required fields are present and set default values for optional fields that are not
            for (var i=0, k=this._fields.length; i<k; ++i) {
                field = this._fields[i];
                if (msg[field.name] === null) {
                    if (this.syntax === "proto3") { // Proto3 sets default values by specification
                        msg[field.name] = field.defaultValue;
                    } else if (field.required) {
                        var err = Error("Missing at least one required field for " + this.toString(true) + ": " + field.name);
                        err["decoded"] = msg; // Still expose what we got
                        throw(err);
                    } else if (ProtoBuf.populateDefaults && field.defaultValue !== null)
                        msg[field.name] = field.defaultValue;
                }
            }
            return msg;
        };

        /**
         * @alias ProtoBuf.Reflect.Message
         * @expose
         */
        Reflect.Message = Message;

        /**
         * Constructs a new Message Field.
         * @exports ProtoBuf.Reflect.Message.Field
         * @param {!ProtoBuf.Builder} builder Builder reference
         * @param {!ProtoBuf.Reflect.Message} message Message reference
         * @param {string} rule Rule, one of requried, optional, repeated
         * @param {string?} keytype Key data type, if any.
         * @param {string} type Data type, e.g. int32
         * @param {string} name Field name
         * @param {number} id Unique field id
         * @param {Object.<string,*>=} options Options
         * @param {!ProtoBuf.Reflect.Message.OneOf=} oneof Enclosing OneOf
         * @param {string?} syntax The syntax level of this definition (e.g., proto3)
         * @constructor
         * @extends ProtoBuf.Reflect.T
         */
        var Field = function(builder, message, rule, keytype, type, name, id, options, oneof, syntax) {
            T.call(this, builder, message, name);

            /**
             * @override
             */
            this.className = "Message.Field";

            /**
             * Message field required flag.
             * @type {boolean}
             * @expose
             */
            this.required = rule === "required";

            /**
             * Message field repeated flag.
             * @type {boolean}
             * @expose
             */
            this.repeated = rule === "repeated";

            /**
             * Message field map flag.
             * @type {boolean}
             * @expose
             */
            this.map = rule === "map";

            /**
             * Message field key type. Type reference string if unresolved, protobuf
             * type if resolved. Valid only if this.map === true, null otherwise.
             * @type {string|{name: string, wireType: number}|null}
             * @expose
             */
            this.keyType = keytype || null;

            /**
             * Message field type. Type reference string if unresolved, protobuf type if
             * resolved. In a map field, this is the value type.
             * @type {string|{name: string, wireType: number}}
             * @expose
             */
            this.type = type;

            /**
             * Resolved type reference inside the global namespace.
             * @type {ProtoBuf.Reflect.T|null}
             * @expose
             */
            this.resolvedType = null;

            /**
             * Unique message field id.
             * @type {number}
             * @expose
             */
            this.id = id;

            /**
             * Message field options.
             * @type {!Object.<string,*>}
             * @dict
             * @expose
             */
            this.options = options || {};

            /**
             * Default value.
             * @type {*}
             * @expose
             */
            this.defaultValue = null;

            /**
             * Enclosing OneOf.
             * @type {?ProtoBuf.Reflect.Message.OneOf}
             * @expose
             */
            this.oneof = oneof || null;

            /**
             * Syntax level of this definition (e.g., proto3).
             * @type {string}
             * @expose
             */
            this.syntax = syntax || 'proto2';

            /**
             * Original field name.
             * @type {string}
             * @expose
             */
            this.originalName = this.name; // Used to revert camelcase transformation on naming collisions

            /**
             * Element implementation. Created in build() after types are resolved.
             * @type {ProtoBuf.Element}
             * @expose
             */
            this.element = null;

            /**
             * Key element implementation, for map fields. Created in build() after
             * types are resolved.
             * @type {ProtoBuf.Element}
             * @expose
             */
            this.keyElement = null;

            // Convert field names to camel case notation if the override is set
            if (this.builder.options['convertFieldsToCamelCase'] && !(this instanceof Message.ExtensionField))
                this.name = ProtoBuf.Util.toCamelCase(this.name);
        };

        /**
         * @alias ProtoBuf.Reflect.Message.Field.prototype
         * @inner
         */
        var FieldPrototype = Field.prototype = Object.create(T.prototype);

        /**
         * Builds the field.
         * @override
         * @expose
         */
        FieldPrototype.build = function() {
            this.element = new Element(this.type, this.resolvedType, false, this.syntax);
            if (this.map)
                this.keyElement = new Element(this.keyType, undefined, true, this.syntax);

            // In proto3, fields do not have field presence, and every field is set to
            // its type's default value ("", 0, 0.0, or false).
            if (this.syntax === 'proto3' && !this.repeated && !this.map)
                this.defaultValue = Element.defaultFieldValue(this.type);

            // Otherwise, default values are present when explicitly specified
            else if (typeof this.options['default'] !== 'undefined')
                this.defaultValue = this.verifyValue(this.options['default']);
        };

        /**
         * Checks if the given value can be set for this field.
         * @param {*} value Value to check
         * @param {boolean=} skipRepeated Whether to skip the repeated value check or not. Defaults to false.
         * @return {*} Verified, maybe adjusted, value
         * @throws {Error} If the value cannot be set for this field
         * @expose
         */
        FieldPrototype.verifyValue = function(value, skipRepeated) {
            skipRepeated = skipRepeated || false;
            var fail = function(val, msg) {
                throw Error("Illegal value for "+this.toString(true)+" of type "+this.type.name+": "+val+" ("+msg+")");
            }.bind(this);
            if (value === null) { // NULL values for optional fields
                if (this.required)
                    fail(typeof value, "required");
                if (this.syntax === 'proto3' && this.type !== ProtoBuf.TYPES["message"])
                    fail(typeof value, "proto3 field without field presence cannot be null");
                return null;
            }
            var i;
            if (this.repeated && !skipRepeated) { // Repeated values as arrays
                if (!Array.isArray(value))
                    value = [value];
                var res = [];
                for (i=0; i<value.length; i++)
                    res.push(this.element.verifyValue(value[i]));
                return res;
            }
            if (this.map && !skipRepeated) { // Map values as objects
                if (!(value instanceof ProtoBuf.Map)) {
                    // If not already a Map, attempt to convert.
                    if (!(value instanceof Object)) {
                        fail(typeof value,
                             "expected ProtoBuf.Map or raw object for map field");
                    }
                    return new ProtoBuf.Map(this, value);
                } else {
                    return value;
                }
            }
            // All non-repeated fields expect no array
            if (!this.repeated && Array.isArray(value))
                fail(typeof value, "no array expected");

            return this.element.verifyValue(value);
        };

        /**
         * Determines whether the field will have a presence on the wire given its
         * value.
         * @param {*} value Verified field value
         * @param {!ProtoBuf.Builder.Message} message Runtime message
         * @return {boolean} Whether the field will be present on the wire
         */
        FieldPrototype.hasWirePresence = function(value, message) {
            if (this.syntax !== 'proto3')
                return (value !== null);
            if (this.oneof && message[this.oneof.name] === this.name)
                return true;
            switch (this.type) {
                case ProtoBuf.TYPES["int32"]:
                case ProtoBuf.TYPES["sint32"]:
                case ProtoBuf.TYPES["sfixed32"]:
                case ProtoBuf.TYPES["uint32"]:
                case ProtoBuf.TYPES["fixed32"]:
                    return value !== 0;

                case ProtoBuf.TYPES["int64"]:
                case ProtoBuf.TYPES["sint64"]:
                case ProtoBuf.TYPES["sfixed64"]:
                case ProtoBuf.TYPES["uint64"]:
                case ProtoBuf.TYPES["fixed64"]:
                    return value.low !== 0 || value.high !== 0;

                case ProtoBuf.TYPES["bool"]:
                    return value;

                case ProtoBuf.TYPES["float"]:
                case ProtoBuf.TYPES["double"]:
                    return value !== 0.0;

                case ProtoBuf.TYPES["string"]:
                    return value.length > 0;

                case ProtoBuf.TYPES["bytes"]:
                    return value.remaining() > 0;

                case ProtoBuf.TYPES["enum"]:
                    return value !== 0;

                case ProtoBuf.TYPES["message"]:
                    return value !== null;
                default:
                    return true;
            }
        };

        /**
         * Encodes the specified field value to the specified buffer.
         * @param {*} value Verified field value
         * @param {ByteBuffer} buffer ByteBuffer to encode to
         * @param {!ProtoBuf.Builder.Message} message Runtime message
         * @return {ByteBuffer} The ByteBuffer for chaining
         * @throws {Error} If the field cannot be encoded
         * @expose
         */
        FieldPrototype.encode = function(value, buffer, message) {
            if (this.type === null || typeof this.type !== 'object')
                throw Error("[INTERNAL] Unresolved type in "+this.toString(true)+": "+this.type);
            if (value === null || (this.repeated && value.length == 0))
                return buffer; // Optional omitted
            try {
                if (this.repeated) {
                    var i;
                    // "Only repeated fields of primitive numeric types (types which use the varint, 32-bit, or 64-bit wire
                    // types) can be declared 'packed'."
                    if (this.options["packed"] && ProtoBuf.PACKABLE_WIRE_TYPES.indexOf(this.type.wireType) >= 0) {
                        // "All of the elements of the field are packed into a single key-value pair with wire type 2
                        // (length-delimited). Each element is encoded the same way it would be normally, except without a
                        // tag preceding it."
                        buffer.writeVarint32((this.id << 3) | ProtoBuf.WIRE_TYPES.LDELIM);
                        buffer.ensureCapacity(buffer.offset += 1); // We do not know the length yet, so let's assume a varint of length 1
                        var start = buffer.offset; // Remember where the contents begin
                        for (i=0; i<value.length; i++)
                            this.element.encodeValue(this.id, value[i], buffer);
                        var len = buffer.offset-start,
                            varintLen = ByteBuffer.calculateVarint32(len);
                        if (varintLen > 1) { // We need to move the contents
                            var contents = buffer.slice(start, buffer.offset);
                            start += varintLen-1;
                            buffer.offset = start;
                            buffer.append(contents);
                        }
                        buffer.writeVarint32(len, start-varintLen);
                    } else {
                        // "If your message definition has repeated elements (without the [packed=true] option), the encoded
                        // message has zero or more key-value pairs with the same tag number"
                        for (i=0; i<value.length; i++)
                            buffer.writeVarint32((this.id << 3) | this.type.wireType),
                            this.element.encodeValue(this.id, value[i], buffer);
                    }
                } else if (this.map) {
                    // Write out each map entry as a submessage.
                    value.forEach(function(val, key, m) {
                        // Compute the length of the submessage (key, val) pair.
                        var length =
                            ByteBuffer.calculateVarint32((1 << 3) | this.keyType.wireType) +
                            this.keyElement.calculateLength(1, key) +
                            ByteBuffer.calculateVarint32((2 << 3) | this.type.wireType) +
                            this.element.calculateLength(2, val);

                        // Submessage with wire type of length-delimited.
                        buffer.writeVarint32((this.id << 3) | ProtoBuf.WIRE_TYPES.LDELIM);
                        buffer.writeVarint32(length);

                        // Write out the key and val.
                        buffer.writeVarint32((1 << 3) | this.keyType.wireType);
                        this.keyElement.encodeValue(1, key, buffer);
                        buffer.writeVarint32((2 << 3) | this.type.wireType);
                        this.element.encodeValue(2, val, buffer);
                    }, this);
                } else {
                    if (this.hasWirePresence(value, message)) {
                        buffer.writeVarint32((this.id << 3) | this.type.wireType);
                        this.element.encodeValue(this.id, value, buffer);
                    }
                }
            } catch (e) {
                throw Error("Illegal value for "+this.toString(true)+": "+value+" ("+e+")");
            }
            return buffer;
        };

        /**
         * Calculates the length of this field's value on the network level.
         * @param {*} value Field value
         * @param {!ProtoBuf.Builder.Message} message Runtime message
         * @returns {number} Byte length
         * @expose
         */
        FieldPrototype.calculate = function(value, message) {
            value = this.verifyValue(value); // May throw
            if (this.type === null || typeof this.type !== 'object')
                throw Error("[INTERNAL] Unresolved type in "+this.toString(true)+": "+this.type);
            if (value === null || (this.repeated && value.length == 0))
                return 0; // Optional omitted
            var n = 0;
            try {
                if (this.repeated) {
                    var i, ni;
                    if (this.options["packed"] && ProtoBuf.PACKABLE_WIRE_TYPES.indexOf(this.type.wireType) >= 0) {
                        n += ByteBuffer.calculateVarint32((this.id << 3) | ProtoBuf.WIRE_TYPES.LDELIM);
                        ni = 0;
                        for (i=0; i<value.length; i++)
                            ni += this.element.calculateLength(this.id, value[i]);
                        n += ByteBuffer.calculateVarint32(ni);
                        n += ni;
                    } else {
                        for (i=0; i<value.length; i++)
                            n += ByteBuffer.calculateVarint32((this.id << 3) | this.type.wireType),
                            n += this.element.calculateLength(this.id, value[i]);
                    }
                } else if (this.map) {
                    // Each map entry becomes a submessage.
                    value.forEach(function(val, key, m) {
                        // Compute the length of the submessage (key, val) pair.
                        var length =
                            ByteBuffer.calculateVarint32((1 << 3) | this.keyType.wireType) +
                            this.keyElement.calculateLength(1, key) +
                            ByteBuffer.calculateVarint32((2 << 3) | this.type.wireType) +
                            this.element.calculateLength(2, val);

                        n += ByteBuffer.calculateVarint32((this.id << 3) | ProtoBuf.WIRE_TYPES.LDELIM);
                        n += ByteBuffer.calculateVarint32(length);
                        n += length;
                    }, this);
                } else {
                    if (this.hasWirePresence(value, message)) {
                        n += ByteBuffer.calculateVarint32((this.id << 3) | this.type.wireType);
                        n += this.element.calculateLength(this.id, value);
                    }
                }
            } catch (e) {
                throw Error("Illegal value for "+this.toString(true)+": "+value+" ("+e+")");
            }
            return n;
        };

        /**
         * Decode the field value from the specified buffer.
         * @param {number} wireType Leading wire type
         * @param {ByteBuffer} buffer ByteBuffer to decode from
         * @param {boolean=} skipRepeated Whether to skip the repeated check or not. Defaults to false.
         * @return {*} Decoded value: array for packed repeated fields, [key, value] for
         *             map fields, or an individual value otherwise.
         * @throws {Error} If the field cannot be decoded
         * @expose
         */
        FieldPrototype.decode = function(wireType, buffer, skipRepeated) {
            var value, nBytes;

            // We expect wireType to match the underlying type's wireType unless we see
            // a packed repeated field, or unless this is a map field.
            var wireTypeOK =
                (!this.map && wireType == this.type.wireType) ||
                (!skipRepeated && this.repeated && this.options["packed"] &&
                 wireType == ProtoBuf.WIRE_TYPES.LDELIM) ||
                (this.map && wireType == ProtoBuf.WIRE_TYPES.LDELIM);
            if (!wireTypeOK)
                throw Error("Illegal wire type for field "+this.toString(true)+": "+wireType+" ("+this.type.wireType+" expected)");

            // Handle packed repeated fields.
            if (wireType == ProtoBuf.WIRE_TYPES.LDELIM && this.repeated && this.options["packed"] && ProtoBuf.PACKABLE_WIRE_TYPES.indexOf(this.type.wireType) >= 0) {
                if (!skipRepeated) {
                    nBytes = buffer.readVarint32();
                    nBytes = buffer.offset + nBytes; // Limit
                    var values = [];
                    while (buffer.offset < nBytes)
                        values.push(this.decode(this.type.wireType, buffer, true));
                    return values;
                }
                // Read the next value otherwise...
            }

            // Handle maps.
            if (this.map) {
                // Read one (key, value) submessage, and return [key, value]
                var key = Element.defaultFieldValue(this.keyType);
                value = Element.defaultFieldValue(this.type);

                // Read the length
                nBytes = buffer.readVarint32();
                if (buffer.remaining() < nBytes)
                    throw Error("Illegal number of bytes for "+this.toString(true)+": "+nBytes+" required but got only "+buffer.remaining());

                // Get a sub-buffer of this key/value submessage
                var msgbuf = buffer.clone();
                msgbuf.limit = msgbuf.offset + nBytes;
                buffer.offset += nBytes;

                while (msgbuf.remaining() > 0) {
                    var tag = msgbuf.readVarint32();
                    wireType = tag & 0x07;
                    var id = tag >>> 3;
                    if (id === 1) {
                        key = this.keyElement.decode(msgbuf, wireType, id);
                    } else if (id === 2) {
                        value = this.element.decode(msgbuf, wireType, id);
                    } else {
                        throw Error("Unexpected tag in map field key/value submessage");
                    }
                }

                return [key, value];
            }

            // Handle singular and non-packed repeated field values.
            return this.element.decode(buffer, wireType, this.id);
        };

        /**
         * @alias ProtoBuf.Reflect.Message.Field
         * @expose
         */
        Reflect.Message.Field = Field;

        /**
         * Constructs a new Message ExtensionField.
         * @exports ProtoBuf.Reflect.Message.ExtensionField
         * @param {!ProtoBuf.Builder} builder Builder reference
         * @param {!ProtoBuf.Reflect.Message} message Message reference
         * @param {string} rule Rule, one of requried, optional, repeated
         * @param {string} type Data type, e.g. int32
         * @param {string} name Field name
         * @param {number} id Unique field id
         * @param {!Object.<string,*>=} options Options
         * @constructor
         * @extends ProtoBuf.Reflect.Message.Field
         */
        var ExtensionField = function(builder, message, rule, type, name, id, options) {
            Field.call(this, builder, message, rule, /* keytype = */ null, type, name, id, options);

            /**
             * Extension reference.
             * @type {!ProtoBuf.Reflect.Extension}
             * @expose
             */
            this.extension;
        };

        // Extends Field
        ExtensionField.prototype = Object.create(Field.prototype);

        /**
         * @alias ProtoBuf.Reflect.Message.ExtensionField
         * @expose
         */
        Reflect.Message.ExtensionField = ExtensionField;

        /**
         * Constructs a new Message OneOf.
         * @exports ProtoBuf.Reflect.Message.OneOf
         * @param {!ProtoBuf.Builder} builder Builder reference
         * @param {!ProtoBuf.Reflect.Message} message Message reference
         * @param {string} name OneOf name
         * @constructor
         * @extends ProtoBuf.Reflect.T
         */
        var OneOf = function(builder, message, name) {
            T.call(this, builder, message, name);

            /**
             * Enclosed fields.
             * @type {!Array.<!ProtoBuf.Reflect.Message.Field>}
             * @expose
             */
            this.fields = [];
        };

        /**
         * @alias ProtoBuf.Reflect.Message.OneOf
         * @expose
         */
        Reflect.Message.OneOf = OneOf;

        /**
         * Constructs a new Enum.
         * @exports ProtoBuf.Reflect.Enum
         * @param {!ProtoBuf.Builder} builder Builder reference
         * @param {!ProtoBuf.Reflect.T} parent Parent Reflect object
         * @param {string} name Enum name
         * @param {Object.<string,*>=} options Enum options
         * @param {string?} syntax The syntax level (e.g., proto3)
         * @constructor
         * @extends ProtoBuf.Reflect.Namespace
         */
        var Enum = function(builder, parent, name, options, syntax) {
            Namespace.call(this, builder, parent, name, options, syntax);

            /**
             * @override
             */
            this.className = "Enum";

            /**
             * Runtime enum object.
             * @type {Object.<string,number>|null}
             * @expose
             */
            this.object = null;
        };

        /**
         * Gets the string name of an enum value.
         * @param {!ProtoBuf.Builder.Enum} enm Runtime enum
         * @param {number} value Enum value
         * @returns {?string} Name or `null` if not present
         * @expose
         */
        Enum.getName = function(enm, value) {
            var keys = Object.keys(enm);
            for (var i=0, key; i<keys.length; ++i)
                if (enm[key = keys[i]] === value)
                    return key;
            return null;
        };

        /**
         * @alias ProtoBuf.Reflect.Enum.prototype
         * @inner
         */
        var EnumPrototype = Enum.prototype = Object.create(Namespace.prototype);

        /**
         * Builds this enum and returns the runtime counterpart.
         * @param {boolean} rebuild Whether to rebuild or not, defaults to false
         * @returns {!Object.<string,number>}
         * @expose
         */
        EnumPrototype.build = function(rebuild) {
            if (this.object && !rebuild)
                return this.object;
            var enm = new ProtoBuf.Builder.Enum(),
                values = this.getChildren(Enum.Value);
            for (var i=0, k=values.length; i<k; ++i)
                enm[values[i]['name']] = values[i]['id'];
            if (Object.defineProperty)
                Object.defineProperty(enm, '$options', {
                    "value": this.buildOpt(),
                    "enumerable": false
                });
            return this.object = enm;
        };

        /**
         * @alias ProtoBuf.Reflect.Enum
         * @expose
         */
        Reflect.Enum = Enum;

        /**
         * Constructs a new Enum Value.
         * @exports ProtoBuf.Reflect.Enum.Value
         * @param {!ProtoBuf.Builder} builder Builder reference
         * @param {!ProtoBuf.Reflect.Enum} enm Enum reference
         * @param {string} name Field name
         * @param {number} id Unique field id
         * @constructor
         * @extends ProtoBuf.Reflect.T
         */
        var Value = function(builder, enm, name, id) {
            T.call(this, builder, enm, name);

            /**
             * @override
             */
            this.className = "Enum.Value";

            /**
             * Unique enum value id.
             * @type {number}
             * @expose
             */
            this.id = id;
        };

        // Extends T
        Value.prototype = Object.create(T.prototype);

        /**
         * @alias ProtoBuf.Reflect.Enum.Value
         * @expose
         */
        Reflect.Enum.Value = Value;

        /**
         * An extension (field).
         * @exports ProtoBuf.Reflect.Extension
         * @constructor
         * @param {!ProtoBuf.Builder} builder Builder reference
         * @param {!ProtoBuf.Reflect.T} parent Parent object
         * @param {string} name Object name
         * @param {!ProtoBuf.Reflect.Message.Field} field Extension field
         */
        var Extension = function(builder, parent, name, field) {
            T.call(this, builder, parent, name);

            /**
             * Extended message field.
             * @type {!ProtoBuf.Reflect.Message.Field}
             * @expose
             */
            this.field = field;
        };

        // Extends T
        Extension.prototype = Object.create(T.prototype);

        /**
         * @alias ProtoBuf.Reflect.Extension
         * @expose
         */
        Reflect.Extension = Extension;

        /**
         * Constructs a new Service.
         * @exports ProtoBuf.Reflect.Service
         * @param {!ProtoBuf.Builder} builder Builder reference
         * @param {!ProtoBuf.Reflect.Namespace} root Root
         * @param {string} name Service name
         * @param {Object.<string,*>=} options Options
         * @constructor
         * @extends ProtoBuf.Reflect.Namespace
         */
        var Service = function(builder, root, name, options) {
            Namespace.call(this, builder, root, name, options);

            /**
             * @override
             */
            this.className = "Service";

            /**
             * Built runtime service class.
             * @type {?function(new:ProtoBuf.Builder.Service)}
             */
            this.clazz = null;
        };

        /**
         * @alias ProtoBuf.Reflect.Service.prototype
         * @inner
         */
        var ServicePrototype = Service.prototype = Object.create(Namespace.prototype);

        /**
         * Builds the service and returns the runtime counterpart, which is a fully functional class.
         * @see ProtoBuf.Builder.Service
         * @param {boolean=} rebuild Whether to rebuild or not
         * @return {Function} Service class
         * @throws {Error} If the message cannot be built
         * @expose
         */
        ServicePrototype.build = function(rebuild) {
            if (this.clazz && !rebuild)
                return this.clazz;

            // Create the runtime Service class in its own scope
            return this.clazz = (function(ProtoBuf, T) {

                /**
                 * Constructs a new runtime Service.
                 * @name ProtoBuf.Builder.Service
                 * @param {function(string, ProtoBuf.Builder.Message, function(Error, ProtoBuf.Builder.Message=))=} rpcImpl RPC implementation receiving the method name and the message
                 * @class Barebone of all runtime services.
                 * @constructor
                 * @throws {Error} If the service cannot be created
                 */
                var Service = function(rpcImpl) {
                    ProtoBuf.Builder.Service.call(this);

                    /**
                     * Service implementation.
                     * @name ProtoBuf.Builder.Service#rpcImpl
                     * @type {!function(string, ProtoBuf.Builder.Message, function(Error, ProtoBuf.Builder.Message=))}
                     * @expose
                     */
                    this.rpcImpl = rpcImpl || function(name, msg, callback) {
                        // This is what a user has to implement: A function receiving the method name, the actual message to
                        // send (type checked) and the callback that's either provided with the error as its first
                        // argument or null and the actual response message.
                        setTimeout(callback.bind(this, Error("Not implemented, see: https://github.com/dcodeIO/ProtoBuf.js/wiki/Services")), 0); // Must be async!
                    };
                };

                /**
                 * @alias ProtoBuf.Builder.Service.prototype
                 * @inner
                 */
                var ServicePrototype = Service.prototype = Object.create(ProtoBuf.Builder.Service.prototype);

                /**
                 * Asynchronously performs an RPC call using the given RPC implementation.
                 * @name ProtoBuf.Builder.Service.[Method]
                 * @function
                 * @param {!function(string, ProtoBuf.Builder.Message, function(Error, ProtoBuf.Builder.Message=))} rpcImpl RPC implementation
                 * @param {ProtoBuf.Builder.Message} req Request
                 * @param {function(Error, (ProtoBuf.Builder.Message|ByteBuffer|Buffer|string)=)} callback Callback receiving
                 *  the error if any and the response either as a pre-parsed message or as its raw bytes
                 * @abstract
                 */

                /**
                 * Asynchronously performs an RPC call using the instance's RPC implementation.
                 * @name ProtoBuf.Builder.Service#[Method]
                 * @function
                 * @param {ProtoBuf.Builder.Message} req Request
                 * @param {function(Error, (ProtoBuf.Builder.Message|ByteBuffer|Buffer|string)=)} callback Callback receiving
                 *  the error if any and the response either as a pre-parsed message or as its raw bytes
                 * @abstract
                 */

                var rpc = T.getChildren(ProtoBuf.Reflect.Service.RPCMethod);
                for (var i=0; i<rpc.length; i++) {
                    (function(method) {

                        // service#Method(message, callback)
                        ServicePrototype[method.name] = function(req, callback) {
                            try {
                                try {
                                    // If given as a buffer, decode the request. Will throw a TypeError if not a valid buffer.
                                    req = method.resolvedRequestType.clazz.decode(ByteBuffer.wrap(req));
                                } catch (err) {
                                    if (!(err instanceof TypeError))
                                        throw err;
                                }
                                if (req === null || typeof req !== 'object')
                                    throw Error("Illegal arguments");
                                if (!(req instanceof method.resolvedRequestType.clazz))
                                    req = new method.resolvedRequestType.clazz(req);
                                this.rpcImpl(method.fqn(), req, function(err, res) { // Assumes that this is properly async
                                    if (err) {
                                        callback(err);
                                        return;
                                    }
                                    try { res = method.resolvedResponseType.clazz.decode(res); } catch (notABuffer) {}
                                    if (!res || !(res instanceof method.resolvedResponseType.clazz)) {
                                        callback(Error("Illegal response type received in service method "+ T.name+"#"+method.name));
                                        return;
                                    }
                                    callback(null, res);
                                });
                            } catch (err) {
                                setTimeout(callback.bind(this, err), 0);
                            }
                        };

                        // Service.Method(rpcImpl, message, callback)
                        Service[method.name] = function(rpcImpl, req, callback) {
                            new Service(rpcImpl)[method.name](req, callback);
                        };

                        if (Object.defineProperty)
                            Object.defineProperty(Service[method.name], "$options", { "value": method.buildOpt() }),
                            Object.defineProperty(ServicePrototype[method.name], "$options", { "value": Service[method.name]["$options"] });
                    })(rpc[i]);
                }

                // Properties

                /**
                 * Service options.
                 * @name ProtoBuf.Builder.Service.$options
                 * @type {Object.<string,*>}
                 * @expose
                 */
                var $optionsS; // cc needs this

                /**
                 * Service options.
                 * @name ProtoBuf.Builder.Service#$options
                 * @type {Object.<string,*>}
                 * @expose
                 */
                var $options;

                /**
                 * Reflection type.
                 * @name ProtoBuf.Builder.Service.$type
                 * @type {!ProtoBuf.Reflect.Service}
                 * @expose
                 */
                var $typeS;

                /**
                 * Reflection type.
                 * @name ProtoBuf.Builder.Service#$type
                 * @type {!ProtoBuf.Reflect.Service}
                 * @expose
                 */
                var $type;

                if (Object.defineProperty)
                    Object.defineProperty(Service, "$options", { "value": T.buildOpt() }),
                    Object.defineProperty(ServicePrototype, "$options", { "value": Service["$options"] }),
                    Object.defineProperty(Service, "$type", { "value": T }),
                    Object.defineProperty(ServicePrototype, "$type", { "value": T });

                return Service;

            })(ProtoBuf, this);
        };

        /**
         * @alias ProtoBuf.Reflect.Service
         * @expose
         */
        Reflect.Service = Service;

        /**
         * Abstract service method.
         * @exports ProtoBuf.Reflect.Service.Method
         * @param {!ProtoBuf.Builder} builder Builder reference
         * @param {!ProtoBuf.Reflect.Service} svc Service
         * @param {string} name Method name
         * @param {Object.<string,*>=} options Options
         * @constructor
         * @extends ProtoBuf.Reflect.T
         */
        var Method = function(builder, svc, name, options) {
            T.call(this, builder, svc, name);

            /**
             * @override
             */
            this.className = "Service.Method";

            /**
             * Options.
             * @type {Object.<string, *>}
             * @expose
             */
            this.options = options || {};
        };

        /**
         * @alias ProtoBuf.Reflect.Service.Method.prototype
         * @inner
         */
        var MethodPrototype = Method.prototype = Object.create(T.prototype);

        /**
         * Builds the method's '$options' property.
         * @name ProtoBuf.Reflect.Service.Method#buildOpt
         * @function
         * @return {Object.<string,*>}
         */
        MethodPrototype.buildOpt = NamespacePrototype.buildOpt;

        /**
         * @alias ProtoBuf.Reflect.Service.Method
         * @expose
         */
        Reflect.Service.Method = Method;

        /**
         * RPC service method.
         * @exports ProtoBuf.Reflect.Service.RPCMethod
         * @param {!ProtoBuf.Builder} builder Builder reference
         * @param {!ProtoBuf.Reflect.Service} svc Service
         * @param {string} name Method name
         * @param {string} request Request message name
         * @param {string} response Response message name
         * @param {boolean} request_stream Whether requests are streamed
         * @param {boolean} response_stream Whether responses are streamed
         * @param {Object.<string,*>=} options Options
         * @constructor
         * @extends ProtoBuf.Reflect.Service.Method
         */
        var RPCMethod = function(builder, svc, name, request, response, request_stream, response_stream, options) {
            Method.call(this, builder, svc, name, options);

            /**
             * @override
             */
            this.className = "Service.RPCMethod";

            /**
             * Request message name.
             * @type {string}
             * @expose
             */
            this.requestName = request;

            /**
             * Response message name.
             * @type {string}
             * @expose
             */
            this.responseName = response;

            /**
             * Whether requests are streamed
             * @type {bool}
             * @expose
             */
            this.requestStream = request_stream;

            /**
             * Whether responses are streamed
             * @type {bool}
             * @expose
             */
            this.responseStream = response_stream;

            /**
             * Resolved request message type.
             * @type {ProtoBuf.Reflect.Message}
             * @expose
             */
            this.resolvedRequestType = null;

            /**
             * Resolved response message type.
             * @type {ProtoBuf.Reflect.Message}
             * @expose
             */
            this.resolvedResponseType = null;
        };

        // Extends Method
        RPCMethod.prototype = Object.create(Method.prototype);

        /**
         * @alias ProtoBuf.Reflect.Service.RPCMethod
         * @expose
         */
        Reflect.Service.RPCMethod = RPCMethod;

        return Reflect;

    })(ProtoBuf);

    /**
     * @alias ProtoBuf.Builder
     * @expose
     */
    ProtoBuf.Builder = (function(ProtoBuf, Lang, Reflect) {
        "use strict";

        /**
         * Constructs a new Builder.
         * @exports ProtoBuf.Builder
         * @class Provides the functionality to build protocol messages.
         * @param {Object.<string,*>=} options Options
         * @constructor
         */
        var Builder = function(options) {

            /**
             * Namespace.
             * @type {ProtoBuf.Reflect.Namespace}
             * @expose
             */
            this.ns = new Reflect.Namespace(this, null, ""); // Global namespace

            /**
             * Namespace pointer.
             * @type {ProtoBuf.Reflect.T}
             * @expose
             */
            this.ptr = this.ns;

            /**
             * Resolved flag.
             * @type {boolean}
             * @expose
             */
            this.resolved = false;

            /**
             * The current building result.
             * @type {Object.<string,ProtoBuf.Builder.Message|Object>|null}
             * @expose
             */
            this.result = null;

            /**
             * Imported files.
             * @type {Array.<string>}
             * @expose
             */
            this.files = {};

            /**
             * Import root override.
             * @type {?string}
             * @expose
             */
            this.importRoot = null;

            /**
             * Options.
             * @type {!Object.<string, *>}
             * @expose
             */
            this.options = options || {};
        };

        /**
         * @alias ProtoBuf.Builder.prototype
         * @inner
         */
        var BuilderPrototype = Builder.prototype;

        // ----- Definition tests -----

        /**
         * Tests if a definition most likely describes a message.
         * @param {!Object} def
         * @returns {boolean}
         * @expose
         */
        Builder.isMessage = function(def) {
            // Messages require a string name
            if (typeof def["name"] !== 'string')
                return false;
            // Messages do not contain values (enum) or rpc methods (service)
            if (typeof def["values"] !== 'undefined' || typeof def["rpc"] !== 'undefined')
                return false;
            return true;
        };

        /**
         * Tests if a definition most likely describes a message field.
         * @param {!Object} def
         * @returns {boolean}
         * @expose
         */
        Builder.isMessageField = function(def) {
            // Message fields require a string rule, name and type and an id
            if (typeof def["rule"] !== 'string' || typeof def["name"] !== 'string' || typeof def["type"] !== 'string' || typeof def["id"] === 'undefined')
                return false;
            return true;
        };

        /**
         * Tests if a definition most likely describes an enum.
         * @param {!Object} def
         * @returns {boolean}
         * @expose
         */
        Builder.isEnum = function(def) {
            // Enums require a string name
            if (typeof def["name"] !== 'string')
                return false;
            // Enums require at least one value
            if (typeof def["values"] === 'undefined' || !Array.isArray(def["values"]) || def["values"].length === 0)
                return false;
            return true;
        };

        /**
         * Tests if a definition most likely describes a service.
         * @param {!Object} def
         * @returns {boolean}
         * @expose
         */
        Builder.isService = function(def) {
            // Services require a string name and an rpc object
            if (typeof def["name"] !== 'string' || typeof def["rpc"] !== 'object' || !def["rpc"])
                return false;
            return true;
        };

        /**
         * Tests if a definition most likely describes an extended message
         * @param {!Object} def
         * @returns {boolean}
         * @expose
         */
        Builder.isExtend = function(def) {
            // Extends rquire a string ref
            if (typeof def["ref"] !== 'string')
                return false;
            return true;
        };

        // ----- Building -----

        /**
         * Resets the pointer to the root namespace.
         * @returns {!ProtoBuf.Builder} this
         * @expose
         */
        BuilderPrototype.reset = function() {
            this.ptr = this.ns;
            return this;
        };

        /**
         * Defines a namespace on top of the current pointer position and places the pointer on it.
         * @param {string} namespace
         * @return {!ProtoBuf.Builder} this
         * @expose
         */
        BuilderPrototype.define = function(namespace) {
            if (typeof namespace !== 'string' || !Lang.TYPEREF.test(namespace))
                throw Error("illegal namespace: "+namespace);
            namespace.split(".").forEach(function(part) {
                var ns = this.ptr.getChild(part);
                if (ns === null) // Keep existing
                    this.ptr.addChild(ns = new Reflect.Namespace(this, this.ptr, part));
                this.ptr = ns;
            }, this);
            return this;
        };

        /**
         * Creates the specified definitions at the current pointer position.
         * @param {!Array.<!Object>} defs Messages, enums or services to create
         * @returns {!ProtoBuf.Builder} this
         * @throws {Error} If a message definition is invalid
         * @expose
         */
        BuilderPrototype.create = function(defs) {
            if (!defs)
                return this; // Nothing to create
            if (!Array.isArray(defs))
                defs = [defs];
            else {
                if (defs.length === 0)
                    return this;
                defs = defs.slice();
            }

            // It's quite hard to keep track of scopes and memory here, so let's do this iteratively.
            var stack = [defs];
            while (stack.length > 0) {
                defs = stack.pop();

                if (!Array.isArray(defs)) // Stack always contains entire namespaces
                    throw Error("not a valid namespace: "+JSON.stringify(defs));

                while (defs.length > 0) {
                    var def = defs.shift(); // Namespaces always contain an array of messages, enums and services

                    if (Builder.isMessage(def)) {
                        var obj = new Reflect.Message(this, this.ptr, def["name"], def["options"], def["isGroup"], def["syntax"]);

                        // Create OneOfs
                        var oneofs = {};
                        if (def["oneofs"])
                            Object.keys(def["oneofs"]).forEach(function(name) {
                                obj.addChild(oneofs[name] = new Reflect.Message.OneOf(this, obj, name));
                            }, this);

                        // Create fields
                        if (def["fields"])
                            def["fields"].forEach(function(fld) {
                                if (obj.getChild(fld["id"]|0) !== null)
                                    throw Error("duplicate or invalid field id in "+obj.name+": "+fld['id']);
                                if (fld["options"] && typeof fld["options"] !== 'object')
                                    throw Error("illegal field options in "+obj.name+"#"+fld["name"]);
                                var oneof = null;
                                if (typeof fld["oneof"] === 'string' && !(oneof = oneofs[fld["oneof"]]))
                                    throw Error("illegal oneof in "+obj.name+"#"+fld["name"]+": "+fld["oneof"]);
                                fld = new Reflect.Message.Field(this, obj, fld["rule"], fld["keytype"], fld["type"], fld["name"], fld["id"], fld["options"], oneof, def["syntax"]);
                                if (oneof)
                                    oneof.fields.push(fld);
                                obj.addChild(fld);
                            }, this);

                        // Push children to stack
                        var subObj = [];
                        if (def["enums"])
                            def["enums"].forEach(function(enm) {
                                subObj.push(enm);
                            });
                        if (def["messages"])
                            def["messages"].forEach(function(msg) {
                                subObj.push(msg);
                            });
                        if (def["services"])
                            def["services"].forEach(function(svc) {
                                subObj.push(svc);
                            });

                        // Set extension range
                        if (def["extensions"]) {
                            obj.extensions = def["extensions"];
                            if (obj.extensions[0] < ProtoBuf.ID_MIN)
                                obj.extensions[0] = ProtoBuf.ID_MIN;
                            if (obj.extensions[1] > ProtoBuf.ID_MAX)
                                obj.extensions[1] = ProtoBuf.ID_MAX;
                        }

                        // Create on top of current namespace
                        this.ptr.addChild(obj);
                        if (subObj.length > 0) {
                            stack.push(defs); // Push the current level back
                            defs = subObj; // Continue processing sub level
                            subObj = null;
                            this.ptr = obj; // And move the pointer to this namespace
                            obj = null;
                            continue;
                        }
                        subObj = null;

                    } else if (Builder.isEnum(def)) {

                        obj = new Reflect.Enum(this, this.ptr, def["name"], def["options"], def["syntax"]);
                        def["values"].forEach(function(val) {
                            obj.addChild(new Reflect.Enum.Value(this, obj, val["name"], val["id"]));
                        }, this);
                        this.ptr.addChild(obj);

                    } else if (Builder.isService(def)) {

                        obj = new Reflect.Service(this, this.ptr, def["name"], def["options"]);
                        Object.keys(def["rpc"]).forEach(function(name) {
                            var mtd = def["rpc"][name];
                            obj.addChild(new Reflect.Service.RPCMethod(this, obj, name, mtd["request"], mtd["response"], !!mtd["request_stream"], !!mtd["response_stream"], mtd["options"]));
                        }, this);
                        this.ptr.addChild(obj);

                    } else if (Builder.isExtend(def)) {

                        obj = this.ptr.resolve(def["ref"], true);
                        if (obj) {
                            def["fields"].forEach(function(fld) {
                                if (obj.getChild(fld['id']|0) !== null)
                                    throw Error("duplicate extended field id in "+obj.name+": "+fld['id']);
                                if (fld['id'] < obj.extensions[0] || fld['id'] > obj.extensions[1])
                                    throw Error("illegal extended field id in "+obj.name+": "+fld['id']+" ("+obj.extensions.join(' to ')+" expected)");
                                // Convert extension field names to camel case notation if the override is set
                                var name = fld["name"];
                                if (this.options['convertFieldsToCamelCase'])
                                    name = ProtoBuf.Util.toCamelCase(name);
                                // see #161: Extensions use their fully qualified name as their runtime key and...
                                var field = new Reflect.Message.ExtensionField(this, obj, fld["rule"], fld["type"], this.ptr.fqn()+'.'+name, fld["id"], fld["options"]);
                                // ...are added on top of the current namespace as an extension which is used for
                                // resolving their type later on (the extension always keeps the original name to
                                // prevent naming collisions)
                                var ext = new Reflect.Extension(this, this.ptr, fld["name"], field);
                                field.extension = ext;
                                this.ptr.addChild(ext);
                                obj.addChild(field);
                            }, this);

                        } else if (!/\.?google\.protobuf\./.test(def["ref"])) // Silently skip internal extensions
                            throw Error("extended message "+def["ref"]+" is not defined");

                    } else
                        throw Error("not a valid definition: "+JSON.stringify(def));

                    def = null;
                    obj = null;
                }
                // Break goes here
                defs = null;
                this.ptr = this.ptr.parent; // Namespace done, continue at parent
            }
            this.resolved = false; // Require re-resolve
            this.result = null; // Require re-build
            return this;
        };

        /**
         * Propagates syntax to all children.
         * @param {!Object} parent
         * @inner
         */
        function propagateSyntax(parent) {
            if (parent['messages']) {
                parent['messages'].forEach(function(child) {
                    child["syntax"] = parent["syntax"];
                    propagateSyntax(child);
                });
            }
            if (parent['enums']) {
                parent['enums'].forEach(function(child) {
                    child["syntax"] = parent["syntax"];
                });
            }
        }

        /**
         * Imports another definition into this builder.
         * @param {Object.<string,*>} json Parsed import
         * @param {(string|{root: string, file: string})=} filename Imported file name
         * @returns {!ProtoBuf.Builder} this
         * @throws {Error} If the definition or file cannot be imported
         * @expose
         */
        BuilderPrototype["import"] = function(json, filename) {
            var delim = '/';

            // Make sure to skip duplicate imports

            if (typeof filename === 'string') {

                if (ProtoBuf.Util.IS_NODE)
                    filename = __webpack_require__(/*! path */ 0)['resolve'](filename);
                if (this.files[filename] === true)
                    return this.reset();
                this.files[filename] = true;

            } else if (typeof filename === 'object') { // Object with root, file.

                var root = filename.root;
                if (ProtoBuf.Util.IS_NODE)
                    root = __webpack_require__(/*! path */ 0)['resolve'](root);
                if (root.indexOf("\\") >= 0 || filename.file.indexOf("\\") >= 0)
                    delim = '\\';
                var fname = root + delim + filename.file;
                if (this.files[fname] === true)
                    return this.reset();
                this.files[fname] = true;
            }

            // Import imports

            if (json['imports'] && json['imports'].length > 0) {
                var importRoot,
                    resetRoot = false;

                if (typeof filename === 'object') { // If an import root is specified, override

                    this.importRoot = filename["root"]; resetRoot = true; // ... and reset afterwards
                    importRoot = this.importRoot;
                    filename = filename["file"];
                    if (importRoot.indexOf("\\") >= 0 || filename.indexOf("\\") >= 0)
                        delim = '\\';

                } else if (typeof filename === 'string') {

                    if (this.importRoot) // If import root is overridden, use it
                        importRoot = this.importRoot;
                    else { // Otherwise compute from filename
                        if (filename.indexOf("/") >= 0) { // Unix
                            importRoot = filename.replace(/\/[^\/]*$/, "");
                            if (/* /file.proto */ importRoot === "")
                                importRoot = "/";
                        } else if (filename.indexOf("\\") >= 0) { // Windows
                            importRoot = filename.replace(/\\[^\\]*$/, "");
                            delim = '\\';
                        } else
                            importRoot = ".";
                    }

                } else
                    importRoot = null;

                for (var i=0; i<json['imports'].length; i++) {
                    if (typeof json['imports'][i] === 'string') { // Import file
                        if (!importRoot)
                            throw Error("cannot determine import root");
                        var importFilename = json['imports'][i];
                        if (importFilename === "google/protobuf/descriptor.proto")
                            continue; // Not needed and therefore not used
                        importFilename = importRoot + delim + importFilename;
                        if (this.files[importFilename] === true)
                            continue; // Already imported
                        if (/\.proto$/i.test(importFilename) && !ProtoBuf.DotProto)       // If this is a light build
                            importFilename = importFilename.replace(/\.proto$/, ".json"); // always load the JSON file
                        var contents = ProtoBuf.Util.fetch(importFilename);
                        if (contents === null)
                            throw Error("failed to import '"+importFilename+"' in '"+filename+"': file not found");
                        if (/\.json$/i.test(importFilename)) // Always possible
                            this["import"](JSON.parse(contents+""), importFilename); // May throw
                        else
                            this["import"](ProtoBuf.DotProto.Parser.parse(contents), importFilename); // May throw
                    } else // Import structure
                        if (!filename)
                            this["import"](json['imports'][i]);
                        else if (/\.(\w+)$/.test(filename)) // With extension: Append _importN to the name portion to make it unique
                            this["import"](json['imports'][i], filename.replace(/^(.+)\.(\w+)$/, function($0, $1, $2) { return $1+"_import"+i+"."+$2; }));
                        else // Without extension: Append _importN to make it unique
                            this["import"](json['imports'][i], filename+"_import"+i);
                }
                if (resetRoot) // Reset import root override when all imports are done
                    this.importRoot = null;
            }

            // Import structures

            if (json['package'])
                this.define(json['package']);
            if (json['syntax'])
                propagateSyntax(json);
            var base = this.ptr;
            if (json['options'])
                Object.keys(json['options']).forEach(function(key) {
                    base.options[key] = json['options'][key];
                });
            if (json['messages'])
                this.create(json['messages']),
                this.ptr = base;
            if (json['enums'])
                this.create(json['enums']),
                this.ptr = base;
            if (json['services'])
                this.create(json['services']),
                this.ptr = base;
            if (json['extends'])
                this.create(json['extends']);

            return this.reset();
        };

        /**
         * Resolves all namespace objects.
         * @throws {Error} If a type cannot be resolved
         * @returns {!ProtoBuf.Builder} this
         * @expose
         */
        BuilderPrototype.resolveAll = function() {
            // Resolve all reflected objects
            var res;
            if (this.ptr == null || typeof this.ptr.type === 'object')
                return this; // Done (already resolved)

            if (this.ptr instanceof Reflect.Namespace) { // Resolve children

                this.ptr.children.forEach(function(child) {
                    this.ptr = child;
                    this.resolveAll();
                }, this);

            } else if (this.ptr instanceof Reflect.Message.Field) { // Resolve type

                if (!Lang.TYPE.test(this.ptr.type)) {
                    if (!Lang.TYPEREF.test(this.ptr.type))
                        throw Error("illegal type reference in "+this.ptr.toString(true)+": "+this.ptr.type);
                    res = (this.ptr instanceof Reflect.Message.ExtensionField ? this.ptr.extension.parent : this.ptr.parent).resolve(this.ptr.type, true);
                    if (!res)
                        throw Error("unresolvable type reference in "+this.ptr.toString(true)+": "+this.ptr.type);
                    this.ptr.resolvedType = res;
                    if (res instanceof Reflect.Enum) {
                        this.ptr.type = ProtoBuf.TYPES["enum"];
                        if (this.ptr.syntax === 'proto3' && res.syntax !== 'proto3')
                            throw Error("proto3 message cannot reference proto2 enum");
                    }
                    else if (res instanceof Reflect.Message)
                        this.ptr.type = res.isGroup ? ProtoBuf.TYPES["group"] : ProtoBuf.TYPES["message"];
                    else
                        throw Error("illegal type reference in "+this.ptr.toString(true)+": "+this.ptr.type);
                } else
                    this.ptr.type = ProtoBuf.TYPES[this.ptr.type];

                // If it's a map field, also resolve the key type. The key type can be only a numeric, string, or bool type
                // (i.e., no enums or messages), so we don't need to resolve against the current namespace.
                if (this.ptr.map) {
                    if (!Lang.TYPE.test(this.ptr.keyType))
                        throw Error("illegal key type for map field in "+this.ptr.toString(true)+": "+this.ptr.keyType);
                    this.ptr.keyType = ProtoBuf.TYPES[this.ptr.keyType];
                }

            } else if (this.ptr instanceof ProtoBuf.Reflect.Service.Method) {

                if (this.ptr instanceof ProtoBuf.Reflect.Service.RPCMethod) {
                    res = this.ptr.parent.resolve(this.ptr.requestName, true);
                    if (!res || !(res instanceof ProtoBuf.Reflect.Message))
                        throw Error("Illegal type reference in "+this.ptr.toString(true)+": "+this.ptr.requestName);
                    this.ptr.resolvedRequestType = res;
                    res = this.ptr.parent.resolve(this.ptr.responseName, true);
                    if (!res || !(res instanceof ProtoBuf.Reflect.Message))
                        throw Error("Illegal type reference in "+this.ptr.toString(true)+": "+this.ptr.responseName);
                    this.ptr.resolvedResponseType = res;
                } else // Should not happen as nothing else is implemented
                    throw Error("illegal service type in "+this.ptr.toString(true));

            } else if (
                !(this.ptr instanceof ProtoBuf.Reflect.Message.OneOf) && // Not built
                !(this.ptr instanceof ProtoBuf.Reflect.Extension) && // Not built
                !(this.ptr instanceof ProtoBuf.Reflect.Enum.Value) // Built in enum
            )
                throw Error("illegal object in namespace: "+typeof(this.ptr)+": "+this.ptr);

            return this.reset();
        };

        /**
         * Builds the protocol. This will first try to resolve all definitions and, if this has been successful,
         * return the built package.
         * @param {(string|Array.<string>)=} path Specifies what to return. If omitted, the entire namespace will be returned.
         * @returns {!ProtoBuf.Builder.Message|!Object.<string,*>}
         * @throws {Error} If a type could not be resolved
         * @expose
         */
        BuilderPrototype.build = function(path) {
            this.reset();
            if (!this.resolved)
                this.resolveAll(),
                this.resolved = true,
                this.result = null; // Require re-build
            if (this.result === null) // (Re-)Build
                this.result = this.ns.build();
            if (!path)
                return this.result;
            var part = typeof path === 'string' ? path.split(".") : path,
                ptr = this.result; // Build namespace pointer (no hasChild etc.)
            for (var i=0; i<part.length; i++)
                if (ptr[part[i]])
                    ptr = ptr[part[i]];
                else {
                    ptr = null;
                    break;
                }
            return ptr;
        };

        /**
         * Similar to {@link ProtoBuf.Builder#build}, but looks up the internal reflection descriptor.
         * @param {string=} path Specifies what to return. If omitted, the entire namespace wiil be returned.
         * @param {boolean=} excludeNonNamespace Excludes non-namespace types like fields, defaults to `false`
         * @returns {?ProtoBuf.Reflect.T} Reflection descriptor or `null` if not found
         */
        BuilderPrototype.lookup = function(path, excludeNonNamespace) {
            return path ? this.ns.resolve(path, excludeNonNamespace) : this.ns;
        };

        /**
         * Returns a string representation of this object.
         * @return {string} String representation as of "Builder"
         * @expose
         */
        BuilderPrototype.toString = function() {
            return "Builder";
        };

        // ----- Base classes -----
        // Exist for the sole purpose of being able to "... instanceof ProtoBuf.Builder.Message" etc.

        /**
         * @alias ProtoBuf.Builder.Message
         */
        Builder.Message = function() {};

        /**
         * @alias ProtoBuf.Builder.Enum
         */
        Builder.Enum = function() {};

        /**
         * @alias ProtoBuf.Builder.Message
         */
        Builder.Service = function() {};

        return Builder;

    })(ProtoBuf, ProtoBuf.Lang, ProtoBuf.Reflect);

    /**
     * @alias ProtoBuf.Map
     * @expose
     */
    ProtoBuf.Map = (function(ProtoBuf, Reflect) {
        "use strict";

        /**
         * Constructs a new Map. A Map is a container that is used to implement map
         * fields on message objects. It closely follows the ES6 Map API; however,
         * it is distinct because we do not want to depend on external polyfills or
         * on ES6 itself.
         *
         * @exports ProtoBuf.Map
         * @param {!ProtoBuf.Reflect.Field} field Map field
         * @param {Object.<string,*>=} contents Initial contents
         * @constructor
         */
        var Map = function(field, contents) {
            if (!field.map)
                throw Error("field is not a map");

            /**
             * The field corresponding to this map.
             * @type {!ProtoBuf.Reflect.Field}
             */
            this.field = field;

            /**
             * Element instance corresponding to key type.
             * @type {!ProtoBuf.Reflect.Element}
             */
            this.keyElem = new Reflect.Element(field.keyType, null, true, field.syntax);

            /**
             * Element instance corresponding to value type.
             * @type {!ProtoBuf.Reflect.Element}
             */
            this.valueElem = new Reflect.Element(field.type, field.resolvedType, false, field.syntax);

            /**
             * Internal map: stores mapping of (string form of key) -> (key, value)
             * pair.
             *
             * We provide map semantics for arbitrary key types, but we build on top
             * of an Object, which has only string keys. In order to avoid the need
             * to convert a string key back to its native type in many situations,
             * we store the native key value alongside the value. Thus, we only need
             * a one-way mapping from a key type to its string form that guarantees
             * uniqueness and equality (i.e., str(K1) === str(K2) if and only if K1
             * === K2).
             *
             * @type {!Object<string, {key: *, value: *}>}
             */
            this.map = {};

            /**
             * Returns the number of elements in the map.
             */
            Object.defineProperty(this, "size", {
                get: function() { return Object.keys(this.map).length; }
            });

            // Fill initial contents from a raw object.
            if (contents) {
                var keys = Object.keys(contents);
                for (var i = 0; i < keys.length; i++) {
                    var key = this.keyElem.valueFromString(keys[i]);
                    var val = this.valueElem.verifyValue(contents[keys[i]]);
                    this.map[this.keyElem.valueToString(key)] =
                        { key: key, value: val };
                }
            }
        };

        var MapPrototype = Map.prototype;

        /**
         * Helper: return an iterator over an array.
         * @param {!Array<*>} arr the array
         * @returns {!Object} an iterator
         * @inner
         */
        function arrayIterator(arr) {
            var idx = 0;
            return {
                next: function() {
                    if (idx < arr.length)
                        return { done: false, value: arr[idx++] };
                    return { done: true };
                }
            }
        }

        /**
         * Clears the map.
         */
        MapPrototype.clear = function() {
            this.map = {};
        };

        /**
         * Deletes a particular key from the map.
         * @returns {boolean} Whether any entry with this key was deleted.
         */
        MapPrototype["delete"] = function(key) {
            var keyValue = this.keyElem.valueToString(this.keyElem.verifyValue(key));
            var hadKey = keyValue in this.map;
            delete this.map[keyValue];
            return hadKey;
        };

        /**
         * Returns an iterator over [key, value] pairs in the map.
         * @returns {Object} The iterator
         */
        MapPrototype.entries = function() {
            var entries = [];
            var strKeys = Object.keys(this.map);
            for (var i = 0, entry; i < strKeys.length; i++)
                entries.push([(entry=this.map[strKeys[i]]).key, entry.value]);
            return arrayIterator(entries);
        };

        /**
         * Returns an iterator over keys in the map.
         * @returns {Object} The iterator
         */
        MapPrototype.keys = function() {
            var keys = [];
            var strKeys = Object.keys(this.map);
            for (var i = 0; i < strKeys.length; i++)
                keys.push(this.map[strKeys[i]].key);
            return arrayIterator(keys);
        };

        /**
         * Returns an iterator over values in the map.
         * @returns {!Object} The iterator
         */
        MapPrototype.values = function() {
            var values = [];
            var strKeys = Object.keys(this.map);
            for (var i = 0; i < strKeys.length; i++)
                values.push(this.map[strKeys[i]].value);
            return arrayIterator(values);
        };

        /**
         * Iterates over entries in the map, calling a function on each.
         * @param {function(this:*, *, *, *)} cb The callback to invoke with value, key, and map arguments.
         * @param {Object=} thisArg The `this` value for the callback
         */
        MapPrototype.forEach = function(cb, thisArg) {
            var strKeys = Object.keys(this.map);
            for (var i = 0, entry; i < strKeys.length; i++)
                cb.call(thisArg, (entry=this.map[strKeys[i]]).value, entry.key, this);
        };

        /**
         * Sets a key in the map to the given value.
         * @param {*} key The key
         * @param {*} value The value
         * @returns {!ProtoBuf.Map} The map instance
         */
        MapPrototype.set = function(key, value) {
            var keyValue = this.keyElem.verifyValue(key);
            var valValue = this.valueElem.verifyValue(value);
            this.map[this.keyElem.valueToString(keyValue)] =
                { key: keyValue, value: valValue };
            return this;
        };

        /**
         * Gets the value corresponding to a key in the map.
         * @param {*} key The key
         * @returns {*|undefined} The value, or `undefined` if key not present
         */
        MapPrototype.get = function(key) {
            var keyValue = this.keyElem.valueToString(this.keyElem.verifyValue(key));
            if (!(keyValue in this.map))
                return undefined;
            return this.map[keyValue].value;
        };

        /**
         * Determines whether the given key is present in the map.
         * @param {*} key The key
         * @returns {boolean} `true` if the key is present
         */
        MapPrototype.has = function(key) {
            var keyValue = this.keyElem.valueToString(this.keyElem.verifyValue(key));
            return (keyValue in this.map);
        };

        return Map;
    })(ProtoBuf, ProtoBuf.Reflect);


    /**
     * Loads a .proto string and returns the Builder.
     * @param {string} proto .proto file contents
     * @param {(ProtoBuf.Builder|string|{root: string, file: string})=} builder Builder to append to. Will create a new one if omitted.
     * @param {(string|{root: string, file: string})=} filename The corresponding file name if known. Must be specified for imports.
     * @return {ProtoBuf.Builder} Builder to create new messages
     * @throws {Error} If the definition cannot be parsed or built
     * @expose
     */
    ProtoBuf.loadProto = function(proto, builder, filename) {
        if (typeof builder === 'string' || (builder && typeof builder["file"] === 'string' && typeof builder["root"] === 'string'))
            filename = builder,
            builder = undefined;
        return ProtoBuf.loadJson(ProtoBuf.DotProto.Parser.parse(proto), builder, filename);
    };

    /**
     * Loads a .proto string and returns the Builder. This is an alias of {@link ProtoBuf.loadProto}.
     * @function
     * @param {string} proto .proto file contents
     * @param {(ProtoBuf.Builder|string)=} builder Builder to append to. Will create a new one if omitted.
     * @param {(string|{root: string, file: string})=} filename The corresponding file name if known. Must be specified for imports.
     * @return {ProtoBuf.Builder} Builder to create new messages
     * @throws {Error} If the definition cannot be parsed or built
     * @expose
     */
    ProtoBuf.protoFromString = ProtoBuf.loadProto; // Legacy

    /**
     * Loads a .proto file and returns the Builder.
     * @param {string|{root: string, file: string}} filename Path to proto file or an object specifying 'file' with
     *  an overridden 'root' path for all imported files.
     * @param {function(?Error, !ProtoBuf.Builder=)=} callback Callback that will receive `null` as the first and
     *  the Builder as its second argument on success, otherwise the error as its first argument. If omitted, the
     *  file will be read synchronously and this function will return the Builder.
     * @param {ProtoBuf.Builder=} builder Builder to append to. Will create a new one if omitted.
     * @return {?ProtoBuf.Builder|undefined} The Builder if synchronous (no callback specified, will be NULL if the
     *   request has failed), else undefined
     * @expose
     */
    ProtoBuf.loadProtoFile = function(filename, callback, builder) {
        if (callback && typeof callback === 'object')
            builder = callback,
            callback = null;
        else if (!callback || typeof callback !== 'function')
            callback = null;
        if (callback)
            return ProtoBuf.Util.fetch(typeof filename === 'string' ? filename : filename["root"]+"/"+filename["file"], function(contents) {
                if (contents === null) {
                    callback(Error("Failed to fetch file"));
                    return;
                }
                try {
                    callback(null, ProtoBuf.loadProto(contents, builder, filename));
                } catch (e) {
                    callback(e);
                }
            });
        var contents = ProtoBuf.Util.fetch(typeof filename === 'object' ? filename["root"]+"/"+filename["file"] : filename);
        return contents === null ? null : ProtoBuf.loadProto(contents, builder, filename);
    };

    /**
     * Loads a .proto file and returns the Builder. This is an alias of {@link ProtoBuf.loadProtoFile}.
     * @function
     * @param {string|{root: string, file: string}} filename Path to proto file or an object specifying 'file' with
     *  an overridden 'root' path for all imported files.
     * @param {function(?Error, !ProtoBuf.Builder=)=} callback Callback that will receive `null` as the first and
     *  the Builder as its second argument on success, otherwise the error as its first argument. If omitted, the
     *  file will be read synchronously and this function will return the Builder.
     * @param {ProtoBuf.Builder=} builder Builder to append to. Will create a new one if omitted.
     * @return {!ProtoBuf.Builder|undefined} The Builder if synchronous (no callback specified, will be NULL if the
     *   request has failed), else undefined
     * @expose
     */
    ProtoBuf.protoFromFile = ProtoBuf.loadProtoFile; // Legacy


    /**
     * Constructs a new empty Builder.
     * @param {Object.<string,*>=} options Builder options, defaults to global options set on ProtoBuf
     * @return {!ProtoBuf.Builder} Builder
     * @expose
     */
    ProtoBuf.newBuilder = function(options) {
        options = options || {};
        if (typeof options['convertFieldsToCamelCase'] === 'undefined')
            options['convertFieldsToCamelCase'] = ProtoBuf.convertFieldsToCamelCase;
        if (typeof options['populateAccessors'] === 'undefined')
            options['populateAccessors'] = ProtoBuf.populateAccessors;
        return new ProtoBuf.Builder(options);
    };

    /**
     * Loads a .json definition and returns the Builder.
     * @param {!*|string} json JSON definition
     * @param {(ProtoBuf.Builder|string|{root: string, file: string})=} builder Builder to append to. Will create a new one if omitted.
     * @param {(string|{root: string, file: string})=} filename The corresponding file name if known. Must be specified for imports.
     * @return {ProtoBuf.Builder} Builder to create new messages
     * @throws {Error} If the definition cannot be parsed or built
     * @expose
     */
    ProtoBuf.loadJson = function(json, builder, filename) {
        if (typeof builder === 'string' || (builder && typeof builder["file"] === 'string' && typeof builder["root"] === 'string'))
            filename = builder,
            builder = null;
        if (!builder || typeof builder !== 'object')
            builder = ProtoBuf.newBuilder();
        if (typeof json === 'string')
            json = JSON.parse(json);
        builder["import"](json, filename);
        builder.resolveAll();
        return builder;
    };

    /**
     * Loads a .json file and returns the Builder.
     * @param {string|!{root: string, file: string}} filename Path to json file or an object specifying 'file' with
     *  an overridden 'root' path for all imported files.
     * @param {function(?Error, !ProtoBuf.Builder=)=} callback Callback that will receive `null` as the first and
     *  the Builder as its second argument on success, otherwise the error as its first argument. If omitted, the
     *  file will be read synchronously and this function will return the Builder.
     * @param {ProtoBuf.Builder=} builder Builder to append to. Will create a new one if omitted.
     * @return {?ProtoBuf.Builder|undefined} The Builder if synchronous (no callback specified, will be NULL if the
     *   request has failed), else undefined
     * @expose
     */
    ProtoBuf.loadJsonFile = function(filename, callback, builder) {
        if (callback && typeof callback === 'object')
            builder = callback,
            callback = null;
        else if (!callback || typeof callback !== 'function')
            callback = null;
        if (callback)
            return ProtoBuf.Util.fetch(typeof filename === 'string' ? filename : filename["root"]+"/"+filename["file"], function(contents) {
                if (contents === null) {
                    callback(Error("Failed to fetch file"));
                    return;
                }
                try {
                    callback(null, ProtoBuf.loadJson(JSON.parse(contents), builder, filename));
                } catch (e) {
                    callback(e);
                }
            });
        var contents = ProtoBuf.Util.fetch(typeof filename === 'object' ? filename["root"]+"/"+filename["file"] : filename);
        return contents === null ? null : ProtoBuf.loadJson(JSON.parse(contents), builder, filename);
    };

    return ProtoBuf;
});

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../process/browser.js */ "../../../node_modules/process/browser.js")))

/***/ }),

/***/ "../../../node_modules/setimmediate/setImmediate.js":
/*!***************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/node_modules/setimmediate/setImmediate.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
    "use strict";

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var registerImmediate;

    function setImmediate(callback) {
      // Callback can either be a function or a string
      if (typeof callback !== "function") {
        callback = new Function("" + callback);
      }
      // Copy function arguments
      var args = new Array(arguments.length - 1);
      for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i + 1];
      }
      // Store and register the task
      var task = { callback: callback, args: args };
      tasksByHandle[nextHandle] = task;
      registerImmediate(nextHandle);
      return nextHandle++;
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function run(task) {
        var callback = task.callback;
        var args = task.args;
        switch (args.length) {
        case 0:
            callback();
            break;
        case 1:
            callback(args[0]);
            break;
        case 2:
            callback(args[0], args[1]);
            break;
        case 3:
            callback(args[0], args[1], args[2]);
            break;
        default:
            callback.apply(undefined, args);
            break;
        }
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(runIfPresent, 0, handle);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    run(task);
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function installNextTickImplementation() {
        registerImmediate = function(handle) {
            process.nextTick(function () { runIfPresent(handle); });
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function() {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function(event) {
            if (event.source === global &&
                typeof event.data === "string" &&
                event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        registerImmediate = function(handle) {
            global.postMessage(messagePrefix + handle, "*");
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function(event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        registerImmediate = function(handle) {
            channel.port2.postMessage(handle);
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        registerImmediate = function(handle) {
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
        };
    }

    function installSetTimeoutImplementation() {
        registerImmediate = function(handle) {
            setTimeout(runIfPresent, 0, handle);
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === "[object process]") {
        // For Node.js before 0.9
        installNextTickImplementation();

    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();

    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();

    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        // For IE 68
        installReadyStateChangeImplementation();

    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "../../../node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../process/browser.js */ "../../../node_modules/process/browser.js")))

/***/ }),

/***/ "../../../node_modules/sprintf-js/src/sprintf.js":
/*!************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/node_modules/sprintf-js/src/sprintf.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;/* global window, exports, define */

!function() {
    'use strict'

    var re = {
        not_string: /[^s]/,
        not_bool: /[^t]/,
        not_type: /[^T]/,
        not_primitive: /[^v]/,
        number: /[diefg]/,
        numeric_arg: /[bcdiefguxX]/,
        json: /[j]/,
        not_json: /[^j]/,
        text: /^[^\x25]+/,
        modulo: /^\x25{2}/,
        placeholder: /^\x25(?:([1-9]\d*)\$|\(([^)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-gijostTuvxX])/,
        key: /^([a-z_][a-z_\d]*)/i,
        key_access: /^\.([a-z_][a-z_\d]*)/i,
        index_access: /^\[(\d+)\]/,
        sign: /^[+-]/
    }

    function sprintf(key) {
        // `arguments` is not an array, but should be fine for this call
        return sprintf_format(sprintf_parse(key), arguments)
    }

    function vsprintf(fmt, argv) {
        return sprintf.apply(null, [fmt].concat(argv || []))
    }

    function sprintf_format(parse_tree, argv) {
        var cursor = 1, tree_length = parse_tree.length, arg, output = '', i, k, ph, pad, pad_character, pad_length, is_positive, sign
        for (i = 0; i < tree_length; i++) {
            if (typeof parse_tree[i] === 'string') {
                output += parse_tree[i]
            }
            else if (typeof parse_tree[i] === 'object') {
                ph = parse_tree[i] // convenience purposes only
                if (ph.keys) { // keyword argument
                    arg = argv[cursor]
                    for (k = 0; k < ph.keys.length; k++) {
                        if (arg == undefined) {
                            throw new Error(sprintf('[sprintf] Cannot access property "%s" of undefined value "%s"', ph.keys[k], ph.keys[k-1]))
                        }
                        arg = arg[ph.keys[k]]
                    }
                }
                else if (ph.param_no) { // positional argument (explicit)
                    arg = argv[ph.param_no]
                }
                else { // positional argument (implicit)
                    arg = argv[cursor++]
                }

                if (re.not_type.test(ph.type) && re.not_primitive.test(ph.type) && arg instanceof Function) {
                    arg = arg()
                }

                if (re.numeric_arg.test(ph.type) && (typeof arg !== 'number' && isNaN(arg))) {
                    throw new TypeError(sprintf('[sprintf] expecting number but found %T', arg))
                }

                if (re.number.test(ph.type)) {
                    is_positive = arg >= 0
                }

                switch (ph.type) {
                    case 'b':
                        arg = parseInt(arg, 10).toString(2)
                        break
                    case 'c':
                        arg = String.fromCharCode(parseInt(arg, 10))
                        break
                    case 'd':
                    case 'i':
                        arg = parseInt(arg, 10)
                        break
                    case 'j':
                        arg = JSON.stringify(arg, null, ph.width ? parseInt(ph.width) : 0)
                        break
                    case 'e':
                        arg = ph.precision ? parseFloat(arg).toExponential(ph.precision) : parseFloat(arg).toExponential()
                        break
                    case 'f':
                        arg = ph.precision ? parseFloat(arg).toFixed(ph.precision) : parseFloat(arg)
                        break
                    case 'g':
                        arg = ph.precision ? String(Number(arg.toPrecision(ph.precision))) : parseFloat(arg)
                        break
                    case 'o':
                        arg = (parseInt(arg, 10) >>> 0).toString(8)
                        break
                    case 's':
                        arg = String(arg)
                        arg = (ph.precision ? arg.substring(0, ph.precision) : arg)
                        break
                    case 't':
                        arg = String(!!arg)
                        arg = (ph.precision ? arg.substring(0, ph.precision) : arg)
                        break
                    case 'T':
                        arg = Object.prototype.toString.call(arg).slice(8, -1).toLowerCase()
                        arg = (ph.precision ? arg.substring(0, ph.precision) : arg)
                        break
                    case 'u':
                        arg = parseInt(arg, 10) >>> 0
                        break
                    case 'v':
                        arg = arg.valueOf()
                        arg = (ph.precision ? arg.substring(0, ph.precision) : arg)
                        break
                    case 'x':
                        arg = (parseInt(arg, 10) >>> 0).toString(16)
                        break
                    case 'X':
                        arg = (parseInt(arg, 10) >>> 0).toString(16).toUpperCase()
                        break
                }
                if (re.json.test(ph.type)) {
                    output += arg
                }
                else {
                    if (re.number.test(ph.type) && (!is_positive || ph.sign)) {
                        sign = is_positive ? '+' : '-'
                        arg = arg.toString().replace(re.sign, '')
                    }
                    else {
                        sign = ''
                    }
                    pad_character = ph.pad_char ? ph.pad_char === '0' ? '0' : ph.pad_char.charAt(1) : ' '
                    pad_length = ph.width - (sign + arg).length
                    pad = ph.width ? (pad_length > 0 ? pad_character.repeat(pad_length) : '') : ''
                    output += ph.align ? sign + arg + pad : (pad_character === '0' ? sign + pad + arg : pad + sign + arg)
                }
            }
        }
        return output
    }

    var sprintf_cache = Object.create(null)

    function sprintf_parse(fmt) {
        if (sprintf_cache[fmt]) {
            return sprintf_cache[fmt]
        }

        var _fmt = fmt, match, parse_tree = [], arg_names = 0
        while (_fmt) {
            if ((match = re.text.exec(_fmt)) !== null) {
                parse_tree.push(match[0])
            }
            else if ((match = re.modulo.exec(_fmt)) !== null) {
                parse_tree.push('%')
            }
            else if ((match = re.placeholder.exec(_fmt)) !== null) {
                if (match[2]) {
                    arg_names |= 1
                    var field_list = [], replacement_field = match[2], field_match = []
                    if ((field_match = re.key.exec(replacement_field)) !== null) {
                        field_list.push(field_match[1])
                        while ((replacement_field = replacement_field.substring(field_match[0].length)) !== '') {
                            if ((field_match = re.key_access.exec(replacement_field)) !== null) {
                                field_list.push(field_match[1])
                            }
                            else if ((field_match = re.index_access.exec(replacement_field)) !== null) {
                                field_list.push(field_match[1])
                            }
                            else {
                                throw new SyntaxError('[sprintf] failed to parse named argument key')
                            }
                        }
                    }
                    else {
                        throw new SyntaxError('[sprintf] failed to parse named argument key')
                    }
                    match[2] = field_list
                }
                else {
                    arg_names |= 2
                }
                if (arg_names === 3) {
                    throw new Error('[sprintf] mixing positional and named placeholders is not (yet) supported')
                }

                parse_tree.push(
                    {
                        placeholder: match[0],
                        param_no:    match[1],
                        keys:        match[2],
                        sign:        match[3],
                        pad_char:    match[4],
                        align:       match[5],
                        width:       match[6],
                        precision:   match[7],
                        type:        match[8]
                    }
                )
            }
            else {
                throw new SyntaxError('[sprintf] unexpected placeholder')
            }
            _fmt = _fmt.substring(match[0].length)
        }
        return sprintf_cache[fmt] = parse_tree
    }

    /**
     * export to either browser or node.js
     */
    /* eslint-disable quote-props */
    if (true) {
        exports['sprintf'] = sprintf
        exports['vsprintf'] = vsprintf
    }
    if (typeof window !== 'undefined') {
        window['sprintf'] = sprintf
        window['vsprintf'] = vsprintf

        if (true) {
            !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
                return {
                    'sprintf': sprintf,
                    'vsprintf': vsprintf
                }
            }).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
        }
    }
    /* eslint-enable quote-props */
}(); // eslint-disable-line


/***/ }),

/***/ "../../../node_modules/timers-browserify/main.js":
/*!************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/node_modules/timers-browserify/main.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var scope = (typeof global !== "undefined" && global) ||
            (typeof self !== "undefined" && self) ||
            window;
var apply = Function.prototype.apply;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(scope, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// setimmediate attaches itself to the global object
__webpack_require__(/*! setimmediate */ "../../../node_modules/setimmediate/setImmediate.js");
// On some exotic environments, it's not clear which object `setimmediate` was
// able to install onto.  Search each possibility in the same order as the
// `setimmediate` library.
exports.setImmediate = (typeof self !== "undefined" && self.setImmediate) ||
                       (typeof global !== "undefined" && global.setImmediate) ||
                       (this && this.setImmediate);
exports.clearImmediate = (typeof self !== "undefined" && self.clearImmediate) ||
                         (typeof global !== "undefined" && global.clearImmediate) ||
                         (this && this.clearImmediate);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "../../../node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "../../../node_modules/ua-parser-js/src/ua-parser.js":
/*!****************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/node_modules/ua-parser-js/src/ua-parser.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;/*!@license
 * UAParser.js v0.7.28
 * Lightweight JavaScript-based User-Agent string parser
 * https://github.com/faisalman/ua-parser-js
 *
 * Copyright  2012-2021 Faisal Salman <f@faisalman.com>
 * Licensed under MIT License
 */

(function (window, undefined) {

    'use strict';

    //////////////
    // Constants
    /////////////


    var LIBVERSION  = '0.7.28',
        EMPTY       = '',
        UNKNOWN     = '?',
        FUNC_TYPE   = 'function',
        UNDEF_TYPE  = 'undefined',
        OBJ_TYPE    = 'object',
        STR_TYPE    = 'string',
        MAJOR       = 'major', // deprecated
        MODEL       = 'model',
        NAME        = 'name',
        TYPE        = 'type',
        VENDOR      = 'vendor',
        VERSION     = 'version',
        ARCHITECTURE= 'architecture',
        CONSOLE     = 'console',
        MOBILE      = 'mobile',
        TABLET      = 'tablet',
        SMARTTV     = 'smarttv',
        WEARABLE    = 'wearable',
        EMBEDDED    = 'embedded',
        UA_MAX_LENGTH = 255;


    ///////////
    // Helper
    //////////


    var util = {
        extend : function (regexes, extensions) {
            var mergedRegexes = {};
            for (var i in regexes) {
                if (extensions[i] && extensions[i].length % 2 === 0) {
                    mergedRegexes[i] = extensions[i].concat(regexes[i]);
                } else {
                    mergedRegexes[i] = regexes[i];
                }
            }
            return mergedRegexes;
        },
        has : function (str1, str2) {
            return typeof str1 === STR_TYPE ? str2.toLowerCase().indexOf(str1.toLowerCase()) !== -1 : false;
        },
        lowerize : function (str) {
            return str.toLowerCase();
        },
        major : function (version) {
            return typeof(version) === STR_TYPE ? version.replace(/[^\d\.]/g,'').split(".")[0] : undefined;
        },
        trim : function (str, len) {
            str = str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');
            return typeof(len) === UNDEF_TYPE ? str : str.substring(0, UA_MAX_LENGTH);
        }
    };


    ///////////////
    // Map helper
    //////////////


    var mapper = {

        rgx : function (ua, arrays) {

            var i = 0, j, k, p, q, matches, match;

            // loop through all regexes maps
            while (i < arrays.length && !matches) {

                var regex = arrays[i],       // even sequence (0,2,4,..)
                    props = arrays[i + 1];   // odd sequence (1,3,5,..)
                j = k = 0;

                // try matching uastring with regexes
                while (j < regex.length && !matches) {

                    matches = regex[j++].exec(ua);

                    if (!!matches) {
                        for (p = 0; p < props.length; p++) {
                            match = matches[++k];
                            q = props[p];
                            // check if given property is actually array
                            if (typeof q === OBJ_TYPE && q.length > 0) {
                                if (q.length == 2) {
                                    if (typeof q[1] == FUNC_TYPE) {
                                        // assign modified match
                                        this[q[0]] = q[1].call(this, match);
                                    } else {
                                        // assign given value, ignore regex match
                                        this[q[0]] = q[1];
                                    }
                                } else if (q.length == 3) {
                                    // check whether function or regex
                                    if (typeof q[1] === FUNC_TYPE && !(q[1].exec && q[1].test)) {
                                        // call function (usually string mapper)
                                        this[q[0]] = match ? q[1].call(this, match, q[2]) : undefined;
                                    } else {
                                        // sanitize match using given regex
                                        this[q[0]] = match ? match.replace(q[1], q[2]) : undefined;
                                    }
                                } else if (q.length == 4) {
                                        this[q[0]] = match ? q[3].call(this, match.replace(q[1], q[2])) : undefined;
                                }
                            } else {
                                this[q] = match ? match : undefined;
                            }
                        }
                    }
                }
                i += 2;
            }
        },

        str : function (str, map) {

            for (var i in map) {
                // check if array
                if (typeof map[i] === OBJ_TYPE && map[i].length > 0) {
                    for (var j = 0; j < map[i].length; j++) {
                        if (util.has(map[i][j], str)) {
                            return (i === UNKNOWN) ? undefined : i;
                        }
                    }
                } else if (util.has(map[i], str)) {
                    return (i === UNKNOWN) ? undefined : i;
                }
            }
            return str;
        }
    };


    ///////////////
    // String map
    //////////////


    var maps = {

        browser : {
            // Safari < 3.0
            oldSafari : {
                version : {
                    '1.0'   : '/8',
                    '1.2'   : '/1',
                    '1.3'   : '/3',
                    '2.0'   : '/412',
                    '2.0.2' : '/416',
                    '2.0.3' : '/417',
                    '2.0.4' : '/419',
                    '?'     : '/'
                }
            },
            oldEdge : {
                version : {
                    '0.1'   : '12.',
                    '21'    : '13.',
                    '31'    : '14.',
                    '39'    : '15.',
                    '41'    : '16.',
                    '42'    : '17.',
                    '44'    : '18.'
                }
            }
        },

        os : {
            windows : {
                version : {
                    'ME'        : '4.90',
                    'NT 3.11'   : 'NT3.51',
                    'NT 4.0'    : 'NT4.0',
                    '2000'      : 'NT 5.0',
                    'XP'        : ['NT 5.1', 'NT 5.2'],
                    'Vista'     : 'NT 6.0',
                    '7'         : 'NT 6.1',
                    '8'         : 'NT 6.2',
                    '8.1'       : 'NT 6.3',
                    '10'        : ['NT 6.4', 'NT 10.0'],
                    'RT'        : 'ARM'
                }
            }
        }
    };


    //////////////
    // Regex map
    /////////////


    var regexes = {

        browser : [[

            /\b(?:crmo|crios)\/([\w\.]+)/i                                      // Chrome for Android/iOS
            ], [VERSION, [NAME, 'Chrome']], [
            /edg(?:e|ios|a)?\/([\w\.]+)/i                                       // Microsoft Edge
            ], [VERSION, [NAME, 'Edge']], [
            // breaking change (reserved for next major release):
            ///edge\/([\w\.]+)/i                                                  // Old Edge (Trident)
            //], [[VERSION, mapper.str, maps.browser.oldEdge.version], [NAME, 'Edge']], [

            // Presto based
            /(opera\smini)\/([\w\.-]+)/i,                                       // Opera Mini
            /(opera\s[mobiletab]{3,6})\b.+version\/([\w\.-]+)/i,                // Opera Mobi/Tablet
            /(opera)(?:.+version\/|[\/\s]+)([\w\.]+)/i,                         // Opera
            ], [NAME, VERSION], [
            /opios[\/\s]+([\w\.]+)/i                                            // Opera mini on iphone >= 8.0
            ], [VERSION, [NAME, 'Opera Mini']], [
            /\sopr\/([\w\.]+)/i                                                 // Opera Webkit
            ], [VERSION, [NAME, 'Opera']], [

            // Mixed
            /(kindle)\/([\w\.]+)/i,                                             // Kindle
            /(lunascape|maxthon|netfront|jasmine|blazer)[\/\s]?([\w\.]*)/i,     // Lunascape/Maxthon/Netfront/Jasmine/Blazer
            // Trident based
            /(avant\s|iemobile|slim)(?:browser)?[\/\s]?([\w\.]*)/i,             // Avant/IEMobile/SlimBrowser
            /(ba?idubrowser)[\/\s]?([\w\.]+)/i,                                 // Baidu Browser
            /(?:ms|\()(ie)\s([\w\.]+)/i,                                        // Internet Explorer

            // Webkit/KHTML based
            /(flock|rockmelt|midori|epiphany|silk|skyfire|ovibrowser|bolt|iron|vivaldi|iridium|phantomjs|bowser|quark|qupzilla|falkon)\/([\w\.-]+)/i,
                                                                                // Flock/RockMelt/Midori/Epiphany/Silk/Skyfire/Bolt/Iron/Iridium/PhantomJS/Bowser/QupZilla/Falkon
            /(rekonq|puffin|brave|whale|qqbrowserlite|qq)\/([\w\.]+)/i,         // Rekonq/Puffin/Brave/Whale/QQBrowserLite/QQ, aka ShouQ
            /(weibo)__([\d\.]+)/i                                               // Weibo
            ], [NAME, VERSION], [
            /(?:[\s\/]uc?\s?browser|(?:juc.+)ucweb)[\/\s]?([\w\.]+)/i           // UCBrowser
            ], [VERSION, [NAME, 'UCBrowser']], [
            /(?:windowswechat)?\sqbcore\/([\w\.]+)\b.*(?:windowswechat)?/i      // WeChat Desktop for Windows Built-in Browser
            ], [VERSION, [NAME, 'WeChat(Win) Desktop']], [
            /micromessenger\/([\w\.]+)/i                                        // WeChat
            ], [VERSION, [NAME, 'WeChat']], [
            /konqueror\/([\w\.]+)/i                                             // Konqueror
            ], [VERSION, [NAME, 'Konqueror']], [
            /trident.+rv[:\s]([\w\.]{1,9})\b.+like\sgecko/i                     // IE11
            ], [VERSION, [NAME, 'IE']], [
            /yabrowser\/([\w\.]+)/i                                             // Yandex
            ], [VERSION, [NAME, 'Yandex']], [
            /(avast|avg)\/([\w\.]+)/i                                           // Avast/AVG Secure Browser
            ], [[NAME, /(.+)/, '$1 Secure Browser'], VERSION], [
            /focus\/([\w\.]+)/i                                                 // Firefox Focus
            ], [VERSION, [NAME, 'Firefox Focus']], [
            /opt\/([\w\.]+)/i                                                   // Opera Touch
            ], [VERSION, [NAME, 'Opera Touch']], [
            /coc_coc_browser\/([\w\.]+)/i                                       // Coc Coc Browser
            ], [VERSION, [NAME, 'Coc Coc']], [
            /dolfin\/([\w\.]+)/i                                                // Dolphin
            ], [VERSION, [NAME, 'Dolphin']], [
            /coast\/([\w\.]+)/i                                                 // Opera Coast
            ], [VERSION, [NAME, 'Opera Coast']],
            [/xiaomi\/miuibrowser\/([\w\.]+)/i                                  // MIUI Browser
            ], [VERSION, [NAME, 'MIUI Browser']], [
            /fxios\/([\w\.-]+)/i                                                // Firefox for iOS
            ], [VERSION, [NAME, 'Firefox']], [
            /(qihu|qhbrowser|qihoobrowser|360browser)/i                         // 360
            ], [[NAME, '360 Browser']], [
            /(oculus|samsung|sailfish)browser\/([\w\.]+)/i
            ], [[NAME, /(.+)/, '$1 Browser'], VERSION], [                       // Oculus/Samsung/Sailfish Browser
            /(comodo_dragon)\/([\w\.]+)/i                                       // Comodo Dragon
            ], [[NAME, /_/g, ' '], VERSION], [
            /\s(electron)\/([\w\.]+)\ssafari/i,                                 // Electron-based App
            /(tesla)(?:\sqtcarbrowser|\/(20[12]\d\.[\w\.-]+))/i,                // Tesla
            /m?(qqbrowser|baiduboxapp|2345Explorer)[\/\s]?([\w\.]+)/i           // QQBrowser/Baidu App/2345 Browser
            ], [NAME, VERSION], [
            /(MetaSr)[\/\s]?([\w\.]+)/i,                                        // SouGouBrowser
            /(LBBROWSER)/i                                                      // LieBao Browser
            ], [NAME], [

            // WebView
            /;fbav\/([\w\.]+);/i                                                // Facebook App for iOS & Android with version
            ], [VERSION, [NAME, 'Facebook']], [
            /FBAN\/FBIOS|FB_IAB\/FB4A/i                                         // Facebook App for iOS & Android without version
            ], [[NAME, 'Facebook']], [
            /safari\s(line)\/([\w\.]+)/i,                                       // Line App for iOS
            /\b(line)\/([\w\.]+)\/iab/i,                                        // Line App for Android
            /(chromium|instagram)[\/\s]([\w\.-]+)/i                             // Chromium/Instagram
            ], [NAME, VERSION], [
            /\bgsa\/([\w\.]+)\s.*safari\//i                                     // Google Search Appliance on iOS
            ], [VERSION, [NAME, 'GSA']], [

            /headlesschrome(?:\/([\w\.]+)|\s)/i                                 // Chrome Headless
            ], [VERSION, [NAME, 'Chrome Headless']], [

            /\swv\).+(chrome)\/([\w\.]+)/i                                      // Chrome WebView
            ], [[NAME, 'Chrome WebView'], VERSION], [

            /droid.+\sversion\/([\w\.]+)\b.+(?:mobile\ssafari|safari)/i         // Android Browser
            ], [VERSION, [NAME, 'Android Browser']], [

            /(chrome|omniweb|arora|[tizenoka]{5}\s?browser)\/v?([\w\.]+)/i      // Chrome/OmniWeb/Arora/Tizen/Nokia
            ], [NAME, VERSION], [

            /version\/([\w\.]+)\s.*mobile\/\w+\s(safari)/i                      // Mobile Safari
            ], [VERSION, [NAME, 'Mobile Safari']], [
            /version\/([\w\.]+)\s.*(mobile\s?safari|safari)/i                   // Safari & Safari Mobile
            ], [VERSION, NAME], [
            /webkit.+?(mobile\s?safari|safari)(\/[\w\.]+)/i                     // Safari < 3.0
            ], [NAME, [VERSION, mapper.str, maps.browser.oldSafari.version]], [

            /(webkit|khtml)\/([\w\.]+)/i
            ], [NAME, VERSION], [

            // Gecko based
            /(navigator|netscape)\/([\w\.-]+)/i                                 // Netscape
            ], [[NAME, 'Netscape'], VERSION], [
            /ile\svr;\srv:([\w\.]+)\).+firefox/i                                // Firefox Reality
            ], [VERSION, [NAME, 'Firefox Reality']], [
            /ekiohf.+(flow)\/([\w\.]+)/i,                                       // Flow
            /(swiftfox)/i,                                                      // Swiftfox
            /(icedragon|iceweasel|camino|chimera|fennec|maemo\sbrowser|minimo|conkeror)[\/\s]?([\w\.\+]+)/i,
                                                                                // IceDragon/Iceweasel/Camino/Chimera/Fennec/Maemo/Minimo/Conkeror
            /(firefox|seamonkey|k-meleon|icecat|iceape|firebird|phoenix|palemoon|basilisk|waterfox)\/([\w\.-]+)$/i,
                                                                                // Firefox/SeaMonkey/K-Meleon/IceCat/IceApe/Firebird/Phoenix
            /(firefox)\/([\w\.]+)\s[\w\s\-]+\/[\w\.]+$/i,                       // Other Firefox-based
            /(mozilla)\/([\w\.]+)\s.+rv\:.+gecko\/\d+/i,                        // Mozilla

            // Other
            /(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf|sleipnir)[\/\s]?([\w\.]+)/i,
                                                                                // Polaris/Lynx/Dillo/iCab/Doris/Amaya/w3m/NetSurf/Sleipnir
            /(links)\s\(([\w\.]+)/i,                                            // Links
            /(gobrowser)\/?([\w\.]*)/i,                                         // GoBrowser
            /(ice\s?browser)\/v?([\w\._]+)/i,                                   // ICE Browser
            /(mosaic)[\/\s]([\w\.]+)/i                                          // Mosaic
            ], [NAME, VERSION]
        ],

        cpu : [[

            /(?:(amd|x(?:(?:86|64)[_-])?|wow|win)64)[;\)]/i                     // AMD64 (x64)
            ], [[ARCHITECTURE, 'amd64']], [

            /(ia32(?=;))/i                                                      // IA32 (quicktime)
            ], [[ARCHITECTURE, util.lowerize]], [

            /((?:i[346]|x)86)[;\)]/i                                            // IA32 (x86)
            ], [[ARCHITECTURE, 'ia32']], [

            /\b(aarch64|armv?8e?l?)\b/i                                         // ARM64
            ], [[ARCHITECTURE, 'arm64']], [

            /\b(arm(?:v[67])?ht?n?[fl]p?)\b/i                                   // ARMHF
            ], [[ARCHITECTURE, 'armhf']], [

            // PocketPC mistakenly identified as PowerPC
            /windows\s(ce|mobile);\sppc;/i
            ], [[ARCHITECTURE, 'arm']], [

            /((?:ppc|powerpc)(?:64)?)(?:\smac|;|\))/i                           // PowerPC
            ], [[ARCHITECTURE, /ower/, '', util.lowerize]], [

            /(sun4\w)[;\)]/i                                                    // SPARC
            ], [[ARCHITECTURE, 'sparc']], [

            /((?:avr32|ia64(?=;))|68k(?=\))|\barm(?:64|(?=v(?:[1-7]|[5-7]1)l?|;|eabi))|(?=atmel\s)avr|(?:irix|mips|sparc)(?:64)?\b|pa-risc)/i
                                                                                // IA64, 68K, ARM/64, AVR/32, IRIX/64, MIPS/64, SPARC/64, PA-RISC
            ], [[ARCHITECTURE, util.lowerize]]
        ],

        device : [[

            //////////////////////////
            // MOBILES & TABLETS
            // Ordered by popularity
            /////////////////////////

            // Samsung
            /\b(sch-i[89]0\d|shw-m380s|sm-[pt]\w{2,4}|gt-[pn]\d{2,4}|sgh-t8[56]9|nexus\s10)/i
            ], [MODEL, [VENDOR, 'Samsung'], [TYPE, TABLET]], [
            /\b((?:s[cgp]h|gt|sm)-\w+|galaxy\snexus)/i,
            /\ssamsung[\s-]([\w-]+)/i,
            /sec-(sgh\w+)/i
            ], [MODEL, [VENDOR, 'Samsung'], [TYPE, MOBILE]], [

            // Apple
            /\((ip(?:hone|od)[\s\w]*);/i                                        // iPod/iPhone
            ], [MODEL, [VENDOR, 'Apple'], [TYPE, MOBILE]], [
            /\((ipad);[\w\s\),;-]+apple/i,                                      // iPad
            /applecoremedia\/[\w\.]+\s\((ipad)/i,
            /\b(ipad)\d\d?,\d\d?[;\]].+ios/i
            ], [MODEL, [VENDOR, 'Apple'], [TYPE, TABLET]], [

            // Huawei
            /\b((?:agr|ags[23]|bah2?|sht?)-a?[lw]\d{2})/i,
            ], [MODEL, [VENDOR, 'Huawei'], [TYPE, TABLET]], [
            /d\/huawei([\w\s-]+)[;\)]/i,
            /\b(nexus\s6p|vog-[at]?l\d\d|ane-[at]?l[x\d]\d|eml-a?l\d\da?|lya-[at]?l\d[\dc]|clt-a?l\d\di?|ele-l\d\d)/i,
            /\b(\w{2,4}-[atu][ln][01259][019])[;\)\s]/i
            ], [MODEL, [VENDOR, 'Huawei'], [TYPE, MOBILE]], [

            // Xiaomi
            /\b(poco[\s\w]+)(?:\sbuild|\))/i,                                   // Xiaomi POCO
            /\b;\s(\w+)\sbuild\/hm\1/i,                                         // Xiaomi Hongmi 'numeric' models
            /\b(hm[\s\-_]?note?[\s_]?(?:\d\w)?)\sbuild/i,                       // Xiaomi Hongmi
            /\b(redmi[\s\-_]?(?:note|k)?[\w\s_]+)(?:\sbuild|\))/i,              // Xiaomi Redmi
            /\b(mi[\s\-_]?(?:a\d|one|one[\s_]plus|note lte)?[\s_]?(?:\d?\w?)[\s_]?(?:plus)?)\sbuild/i  // Xiaomi Mi
            ], [[MODEL, /_/g, ' '], [VENDOR, 'Xiaomi'], [TYPE, MOBILE]], [
            /\b(mi[\s\-_]?(?:pad)(?:[\w\s_]+))(?:\sbuild|\))/i                  // Mi Pad tablets
            ],[[MODEL, /_/g, ' '], [VENDOR, 'Xiaomi'], [TYPE, TABLET]], [

            // OPPO
            /;\s(\w+)\sbuild.+\soppo/i,
            /\s(cph[12]\d{3}|p(?:af|c[al]|d\w|e[ar])[mt]\d0|x9007)\b/i
            ], [MODEL, [VENDOR, 'OPPO'], [TYPE, MOBILE]], [

            // Vivo
            /\svivo\s(\w+)(?:\sbuild|\))/i,
            /\s(v[12]\d{3}\w?[at])(?:\sbuild|;)/i
            ], [MODEL, [VENDOR, 'Vivo'], [TYPE, MOBILE]], [

            // Realme
            /\s(rmx[12]\d{3})(?:\sbuild|;)/i
            ], [MODEL, [VENDOR, 'Realme'], [TYPE, MOBILE]], [

            // Motorola
            /\s(milestone|droid(?:[2-4x]|\s(?:bionic|x2|pro|razr))?:?(\s4g)?)\b[\w\s]+build\//i,
            /\smot(?:orola)?[\s-](\w*)/i,
            /((?:moto[\s\w\(\)]+|xt\d{3,4}|nexus\s6)(?=\sbuild|\)))/i
            ], [MODEL, [VENDOR, 'Motorola'], [TYPE, MOBILE]], [
            /\s(mz60\d|xoom[\s2]{0,2})\sbuild\//i
            ], [MODEL, [VENDOR, 'Motorola'], [TYPE, TABLET]], [

            // LG
            /((?=lg)?[vl]k\-?\d{3})\sbuild|\s3\.[\s\w;-]{10}lg?-([06cv9]{3,4})/i
            ], [MODEL, [VENDOR, 'LG'], [TYPE, TABLET]], [
            /(lm-?f100[nv]?|nexus\s[45])/i,
            /lg[e;\s\/-]+((?!browser|netcast)\w+)/i,
            /\blg(\-?[\d\w]+)\sbuild/i
            ], [MODEL, [VENDOR, 'LG'], [TYPE, MOBILE]], [

            // Lenovo
            /(ideatab[\w\-\s]+)/i,
            /lenovo\s?(s(?:5000|6000)(?:[\w-]+)|tab(?:[\s\w]+)|yt[\d\w-]{6}|tb[\d\w-]{6})/i        // Lenovo tablets
            ], [MODEL, [VENDOR, 'Lenovo'], [TYPE, TABLET]], [

            // Nokia
            /(?:maemo|nokia).*(n900|lumia\s\d+)/i,
            /nokia[\s_-]?([\w\.-]*)/i
            ], [[MODEL, /_/g, ' '], [VENDOR, 'Nokia'], [TYPE, MOBILE]], [

            // Google
            /droid.+;\s(pixel\sc)[\s)]/i                                        // Google Pixel C
            ], [MODEL, [VENDOR, 'Google'], [TYPE, TABLET]], [
            /droid.+;\s(pixel[\s\daxl]{0,6})(?:\sbuild|\))/i                    // Google Pixel
            ], [MODEL, [VENDOR, 'Google'], [TYPE, MOBILE]], [

            // Sony
            /droid.+\s([c-g]\d{4}|so[-l]\w+|xq-a\w[4-7][12])(?=\sbuild\/|\).+chrome\/(?![1-6]{0,1}\d\.))/i
            ], [MODEL, [VENDOR, 'Sony'], [TYPE, MOBILE]], [
            /sony\stablet\s[ps]\sbuild\//i,
            /(?:sony)?sgp\w+(?:\sbuild\/|\))/i
            ], [[MODEL, 'Xperia Tablet'], [VENDOR, 'Sony'], [TYPE, TABLET]], [

            // OnePlus
            /\s(kb2005|in20[12]5|be20[12][59])\b/i,
            /\ba000(1)\sbuild/i,                                                // OnePlus
            /\boneplus\s(a\d{4})[\s)]/i
            ], [MODEL, [VENDOR, 'OnePlus'], [TYPE, MOBILE]], [

            // Amazon
            /(alexa)webm/i,
            /(kf[a-z]{2}wi)(\sbuild\/|\))/i,                                    // Kindle Fire without Silk
            /(kf[a-z]+)(\sbuild\/|\)).+silk\//i                                 // Kindle Fire HD
            ], [MODEL, [VENDOR, 'Amazon'], [TYPE, TABLET]], [
            /(sd|kf)[0349hijorstuw]+(\sbuild\/|\)).+silk\//i                    // Fire Phone
            ], [[MODEL, 'Fire Phone'], [VENDOR, 'Amazon'], [TYPE, MOBILE]], [

            // BlackBerry
            /\((playbook);[\w\s\),;-]+(rim)/i                                   // BlackBerry PlayBook
            ], [MODEL, VENDOR, [TYPE, TABLET]], [
            /((?:bb[a-f]|st[hv])100-\d)/i,
            /\(bb10;\s(\w+)/i                                                   // BlackBerry 10
            ], [MODEL, [VENDOR, 'BlackBerry'], [TYPE, MOBILE]], [

            // Asus
            /(?:\b|asus_)(transfo[prime\s]{4,10}\s\w+|eeepc|slider\s\w+|nexus\s7|padfone|p00[cj])/i
            ], [MODEL, [VENDOR, 'ASUS'], [TYPE, TABLET]], [
            /\s(z[es]6[027][01][km][ls]|zenfone\s\d\w?)\b/i
            ], [MODEL, [VENDOR, 'ASUS'], [TYPE, MOBILE]], [

            // HTC
            /(nexus\s9)/i                                                       // HTC Nexus 9
            ], [MODEL, [VENDOR, 'HTC'], [TYPE, TABLET]], [
            /(htc)[;_\s-]{1,2}([\w\s]+(?=\)|\sbuild)|\w+)/i,                    // HTC

            // ZTE
            /(zte)-(\w*)/i,
            /(alcatel|geeksphone|nexian|panasonic|(?=;\s)sony)[_\s-]?([\w-]*)/i // Alcatel/GeeksPhone/Nexian/Panasonic/Sony
            ], [VENDOR, [MODEL, /_/g, ' '], [TYPE, MOBILE]], [

            // Acer
            /droid[x\d\.\s;]+\s([ab][1-7]\-?[0178a]\d\d?)/i
            ], [MODEL, [VENDOR, 'Acer'], [TYPE, TABLET]], [

            // Meizu
            /droid.+;\s(m[1-5]\snote)\sbuild/i,
            /\bmz-([\w-]{2,})/i
            ], [MODEL, [VENDOR, 'Meizu'], [TYPE, MOBILE]], [

            // MIXED
            /(blackberry|benq|palm(?=\-)|sonyericsson|acer|asus|dell|meizu|motorola|polytron)[\s_-]?([\w-]*)/i,
                                                                                // BlackBerry/BenQ/Palm/Sony-Ericsson/Acer/Asus/Dell/Meizu/Motorola/Polytron
            /(hp)\s([\w\s]+\w)/i,                                               // HP iPAQ
            /(asus)-?(\w+)/i,                                                   // Asus
            /(microsoft);\s(lumia[\s\w]+)/i,                                    // Microsoft Lumia
            /(lenovo)[_\s-]?([\w-]+)/i,                                         // Lenovo
            /linux;.+(jolla);/i,                                                // Jolla
            /droid.+;\s(oppo)\s?([\w\s]+)\sbuild/i                              // OPPO
            ], [VENDOR, MODEL, [TYPE, MOBILE]], [

            /(archos)\s(gamepad2?)/i,                                           // Archos
            /(hp).+(touchpad(?!.+tablet)|tablet)/i,                             // HP TouchPad
            /(kindle)\/([\w\.]+)/i,                                             // Kindle
            /\s(nook)[\w\s]+build\/(\w+)/i,                                     // Nook
            /(dell)\s(strea[kpr\s\d]*[\dko])/i,                                 // Dell Streak
            /[;\/]\s?(le[\s\-]+pan)[\s\-]+(\w{1,9})\sbuild/i,                   // Le Pan Tablets
            /[;\/]\s?(trinity)[\-\s]*(t\d{3})\sbuild/i,                         // Trinity Tablets
            /\b(gigaset)[\s\-]+(q\w{1,9})\sbuild/i,                             // Gigaset Tablets
            /\b(vodafone)\s([\w\s]+)(?:\)|\sbuild)/i                            // Vodafone
            ], [VENDOR, MODEL, [TYPE, TABLET]], [

            /\s(surface\sduo)\s/i                                               // Surface Duo
            ], [MODEL, [VENDOR, 'Microsoft'], [TYPE, TABLET]], [
            /droid\s[\d\.]+;\s(fp\du?)\sbuild/i
            ], [MODEL, [VENDOR, 'Fairphone'], [TYPE, MOBILE]], [
            /\s(u304aa)\sbuild/i                                                // AT&T
            ], [MODEL, [VENDOR, 'AT&T'], [TYPE, MOBILE]], [
            /sie-(\w*)/i                                                        // Siemens
            ], [MODEL, [VENDOR, 'Siemens'], [TYPE, MOBILE]], [
            /[;\/]\s?(rct\w+)\sbuild/i                                          // RCA Tablets
            ], [MODEL, [VENDOR, 'RCA'], [TYPE, TABLET]], [
            /[;\/\s](venue[\d\s]{2,7})\sbuild/i                                 // Dell Venue Tablets
            ], [MODEL, [VENDOR, 'Dell'], [TYPE, TABLET]], [
            /[;\/]\s?(q(?:mv|ta)\w+)\sbuild/i                                   // Verizon Tablet
            ], [MODEL, [VENDOR, 'Verizon'], [TYPE, TABLET]], [
            /[;\/]\s(?:barnes[&\s]+noble\s|bn[rt])([\w\s\+]*)\sbuild/i          // Barnes & Noble Tablet
            ], [MODEL, [VENDOR, 'Barnes & Noble'], [TYPE, TABLET]], [
            /[;\/]\s(tm\d{3}\w+)\sbuild/i
            ], [MODEL, [VENDOR, 'NuVision'], [TYPE, TABLET]], [
            /;\s(k88)\sbuild/i                                                  // ZTE K Series Tablet
            ], [MODEL, [VENDOR, 'ZTE'], [TYPE, TABLET]], [
            /;\s(nx\d{3}j)\sbuild/i                                             // ZTE Nubia
            ], [MODEL, [VENDOR, 'ZTE'], [TYPE, MOBILE]], [
            /[;\/]\s?(gen\d{3})\sbuild.*49h/i                                   // Swiss GEN Mobile
            ], [MODEL, [VENDOR, 'Swiss'], [TYPE, MOBILE]], [
            /[;\/]\s?(zur\d{3})\sbuild/i                                        // Swiss ZUR Tablet
            ], [MODEL, [VENDOR, 'Swiss'], [TYPE, TABLET]], [
            /[;\/]\s?((zeki)?tb.*\b)\sbuild/i                                   // Zeki Tablets
            ], [MODEL, [VENDOR, 'Zeki'], [TYPE, TABLET]], [
            /[;\/]\s([yr]\d{2})\sbuild/i,
            /[;\/]\s(dragon[\-\s]+touch\s|dt)(\w{5})\sbuild/i                   // Dragon Touch Tablet
            ], [[VENDOR, 'Dragon Touch'], MODEL, [TYPE, TABLET]], [
            /[;\/]\s?(ns-?\w{0,9})\sbuild/i                                     // Insignia Tablets
            ], [MODEL, [VENDOR, 'Insignia'], [TYPE, TABLET]], [
            /[;\/]\s?((nxa|Next)-?\w{0,9})\sbuild/i                             // NextBook Tablets
            ], [MODEL, [VENDOR, 'NextBook'], [TYPE, TABLET]], [
            /[;\/]\s?(xtreme\_)?(v(1[045]|2[015]|[3469]0|7[05]))\sbuild/i
            ], [[VENDOR, 'Voice'], MODEL, [TYPE, MOBILE]], [                    // Voice Xtreme Phones
            /[;\/]\s?(lvtel\-)?(v1[12])\sbuild/i                                // LvTel Phones
            ], [[VENDOR, 'LvTel'], MODEL, [TYPE, MOBILE]], [
            /;\s(ph-1)\s/i
            ], [MODEL, [VENDOR, 'Essential'], [TYPE, MOBILE]], [                // Essential PH-1
            /[;\/]\s?(v(100md|700na|7011|917g).*\b)\sbuild/i                    // Envizen Tablets
            ], [MODEL, [VENDOR, 'Envizen'], [TYPE, TABLET]], [
            /[;\/]\s?(trio[\s\w\-\.]+)\sbuild/i                                 // MachSpeed Tablets
            ], [MODEL, [VENDOR, 'MachSpeed'], [TYPE, TABLET]], [
            /[;\/]\s?tu_(1491)\sbuild/i                                         // Rotor Tablets
            ], [MODEL, [VENDOR, 'Rotor'], [TYPE, TABLET]], [
            /(shield[\w\s]+)\sbuild/i                                           // Nvidia Shield Tablets
            ], [MODEL, [VENDOR, 'Nvidia'], [TYPE, TABLET]], [
            /(sprint)\s(\w+)/i                                                  // Sprint Phones
            ], [VENDOR, MODEL, [TYPE, MOBILE]], [
            /(kin\.[onetw]{3})/i                                                // Microsoft Kin
            ], [[MODEL, /\./g, ' '], [VENDOR, 'Microsoft'], [TYPE, MOBILE]], [
            /droid\s[\d\.]+;\s(cc6666?|et5[16]|mc[239][23]x?|vc8[03]x?)\)/i     // Zebra
            ], [MODEL, [VENDOR, 'Zebra'], [TYPE, TABLET]], [
            /droid\s[\d\.]+;\s(ec30|ps20|tc[2-8]\d[kx])\)/i
            ], [MODEL, [VENDOR, 'Zebra'], [TYPE, MOBILE]], [

            ///////////////////
            // CONSOLES
            ///////////////////

            /\s(ouya)\s/i,                                                      // Ouya
            /(nintendo)\s([wids3utch]+)/i                                       // Nintendo
            ], [VENDOR, MODEL, [TYPE, CONSOLE]], [
            /droid.+;\s(shield)\sbuild/i                                        // Nvidia
            ], [MODEL, [VENDOR, 'Nvidia'], [TYPE, CONSOLE]], [
            /(playstation\s[345portablevi]+)/i                                  // Playstation
            ], [MODEL, [VENDOR, 'Sony'], [TYPE, CONSOLE]], [
            /[\s\(;](xbox(?:\sone)?(?!;\sxbox))[\s\);]/i                        // Microsoft Xbox
            ], [MODEL, [VENDOR, 'Microsoft'], [TYPE, CONSOLE]], [

            ///////////////////
            // SMARTTVS
            ///////////////////

            /smart-tv.+(samsung)/i                                              // Samsung
            ], [VENDOR, [TYPE, SMARTTV]], [
            /hbbtv.+maple;(\d+)/i
            ], [[MODEL, /^/, 'SmartTV'], [VENDOR, 'Samsung'], [TYPE, SMARTTV]], [
            /(?:linux;\snetcast.+smarttv|lg\snetcast\.tv-201\d)/i,              // LG SmartTV
            ], [[VENDOR, 'LG'], [TYPE, SMARTTV]], [
            /(apple)\s?tv/i                                                     // Apple TV
            ], [VENDOR, [MODEL, 'Apple TV'], [TYPE, SMARTTV]], [
            /crkey/i                                                            // Google Chromecast
            ], [[MODEL, 'Chromecast'], [VENDOR, 'Google'], [TYPE, SMARTTV]], [
            /droid.+aft([\w])(\sbuild\/|\))/i                                   // Fire TV
            ], [MODEL, [VENDOR, 'Amazon'], [TYPE, SMARTTV]], [
            /\(dtv[\);].+(aquos)/i                                              // Sharp
            ], [MODEL, [VENDOR, 'Sharp'], [TYPE, SMARTTV]], [
            /hbbtv\/\d+\.\d+\.\d+\s+\([\w\s]*;\s*(\w[^;]*);([^;]*)/i            // HbbTV devices
            ], [[VENDOR, util.trim], [MODEL, util.trim], [TYPE, SMARTTV]], [
            /[\s\/\(](android\s|smart[-\s]?|opera\s)tv[;\)\s]/i                 // SmartTV from Unidentified Vendors
            ], [[TYPE, SMARTTV]], [

            ///////////////////
            // WEARABLES
            ///////////////////

            /((pebble))app\/[\d\.]+\s/i                                         // Pebble
            ], [VENDOR, MODEL, [TYPE, WEARABLE]], [
            /droid.+;\s(glass)\s\d/i                                            // Google Glass
            ], [MODEL, [VENDOR, 'Google'], [TYPE, WEARABLE]], [
            /droid\s[\d\.]+;\s(wt63?0{2,3})\)/i
            ], [MODEL, [VENDOR, 'Zebra'], [TYPE, WEARABLE]], [

            ///////////////////
            // EMBEDDED
            ///////////////////

            /(tesla)(?:\sqtcarbrowser|\/20[12]\d\.[\w\.-]+)/i                   // Tesla
            ], [VENDOR, [TYPE, EMBEDDED]], [

            ////////////////////
            // MIXED (GENERIC)
            ///////////////////

            /droid .+?; ([^;]+?)(?: build|\) applewebkit).+? mobile safari/i    // Android Phones from Unidentified Vendors
            ], [MODEL, [TYPE, MOBILE]], [
            /droid .+?;\s([^;]+?)(?: build|\) applewebkit).+?(?! mobile) safari/i  // Android Tablets from Unidentified Vendors
            ], [MODEL, [TYPE, TABLET]], [
            /\s(tablet|tab)[;\/]/i,                                             // Unidentifiable Tablet
            /\s(mobile)(?:[;\/]|\ssafari)/i                                     // Unidentifiable Mobile
            ], [[TYPE, util.lowerize]], [
            /(android[\w\.\s\-]{0,9});.+build/i                                 // Generic Android Device
            ], [MODEL, [VENDOR, 'Generic']], [
            /(phone)/i
            ], [[TYPE, MOBILE]]
        ],

        engine : [[

            /windows.+\sedge\/([\w\.]+)/i                                       // EdgeHTML
            ], [VERSION, [NAME, 'EdgeHTML']], [

            /webkit\/537\.36.+chrome\/(?!27)([\w\.]+)/i                         // Blink
            ], [VERSION, [NAME, 'Blink']], [

            /(presto)\/([\w\.]+)/i,                                             // Presto
            /(webkit|trident|netfront|netsurf|amaya|lynx|w3m|goanna)\/([\w\.]+)/i, // WebKit/Trident/NetFront/NetSurf/Amaya/Lynx/w3m/Goanna
            /ekioh(flow)\/([\w\.]+)/i,                                          // Flow
            /(khtml|tasman|links)[\/\s]\(?([\w\.]+)/i,                          // KHTML/Tasman/Links
            /(icab)[\/\s]([23]\.[\d\.]+)/i                                      // iCab
            ], [NAME, VERSION], [

            /rv\:([\w\.]{1,9})\b.+(gecko)/i                                     // Gecko
            ], [VERSION, NAME]
        ],

        os : [[

            // Windows
            /microsoft\s(windows)\s(vista|xp)/i                                 // Windows (iTunes)
            ], [NAME, VERSION], [
            /(windows)\snt\s6\.2;\s(arm)/i,                                     // Windows RT
            /(windows\sphone(?:\sos)*)[\s\/]?([\d\.\s\w]*)/i,                   // Windows Phone
            /(windows\smobile|windows)[\s\/]?([ntce\d\.\s]+\w)(?!.+xbox)/i
            ], [NAME, [VERSION, mapper.str, maps.os.windows.version]], [
            /(win(?=3|9|n)|win\s9x\s)([nt\d\.]+)/i
            ], [[NAME, 'Windows'], [VERSION, mapper.str, maps.os.windows.version]], [

            // iOS/macOS
            /ip[honead]{2,4}\b(?:.*os\s([\w]+)\slike\smac|;\sopera)/i,          // iOS
            /cfnetwork\/.+darwin/i
            ], [[VERSION, /_/g, '.'], [NAME, 'iOS']], [
            /(mac\sos\sx)\s?([\w\s\.]*)/i,
            /(macintosh|mac(?=_powerpc)\s)(?!.+haiku)/i                         // Mac OS
            ], [[NAME, 'Mac OS'], [VERSION, /_/g, '.']], [

            // Mobile OSes                                                      // Android/WebOS/Palm/QNX/Bada/RIM/MeeGo/Contiki/Sailfish OS
            /(android|webos|palm\sos|qnx|bada|rim\stablet\sos|meego|sailfish|contiki)[\/\s-]?([\w\.]*)/i,
            /(blackberry)\w*\/([\w\.]*)/i,                                      // Blackberry
            /(tizen|kaios)[\/\s]([\w\.]+)/i,                                    // Tizen/KaiOS
            /\((series40);/i                                                    // Series 40
            ], [NAME, VERSION], [
            /\(bb(10);/i                                                        // BlackBerry 10
            ], [VERSION, [NAME, 'BlackBerry']], [
            /(?:symbian\s?os|symbos|s60(?=;)|series60)[\/\s-]?([\w\.]*)/i       // Symbian
            ], [VERSION, [NAME, 'Symbian']], [
            /mozilla.+\(mobile;.+gecko.+firefox/i                               // Firefox OS
            ], [[NAME, 'Firefox OS']], [
            /web0s;.+rt(tv)/i,
            /\b(?:hp)?wos(?:browser)?\/([\w\.]+)/i                              // WebOS
            ], [VERSION, [NAME, 'webOS']], [

            // Google Chromecast
            /crkey\/([\d\.]+)/i                                                 // Google Chromecast
            ], [VERSION, [NAME, 'Chromecast']], [
            /(cros)\s[\w]+\s([\w\.]+\w)/i                                       // Chromium OS
            ], [[NAME, 'Chromium OS'], VERSION],[

            // Console
            /(nintendo|playstation)\s([wids345portablevuch]+)/i,                // Nintendo/Playstation
            /(xbox);\s+xbox\s([^\);]+)/i,                                       // Microsoft Xbox (360, One, X, S, Series X, Series S)

            // GNU/Linux based
            /(mint)[\/\s\(\)]?(\w*)/i,                                          // Mint
            /(mageia|vectorlinux)[;\s]/i,                                       // Mageia/VectorLinux
            /(joli|[kxln]?ubuntu|debian|suse|opensuse|gentoo|arch(?=\slinux)|slackware|fedora|mandriva|centos|pclinuxos|redhat|zenwalk|linpus|raspbian)(?:\sgnu\/linux)?(?:\slinux)?[\/\s-]?(?!chrom|package)([\w\.-]*)/i,
                                                                                // Joli/Ubuntu/Debian/SUSE/Gentoo/Arch/Slackware
                                                                                // Fedora/Mandriva/CentOS/PCLinuxOS/RedHat/Zenwalk/Linpus
            /(hurd|linux)\s?([\w\.]*)/i,                                        // Hurd/Linux
            /(gnu)\s?([\w\.]*)/i,                                               // GNU

            // BSD based
            /\s([frentopc-]{0,4}bsd|dragonfly)\s?(?!amd|[ix346]{1,2}86)([\w\.]*)/i,  // FreeBSD/NetBSD/OpenBSD/PC-BSD/DragonFly
            /(haiku)\s(\w+)/i                                                   // Haiku
            ], [NAME, VERSION], [

            // Other
            /(sunos)\s?([\w\.\d]*)/i                                            // Solaris
            ], [[NAME, 'Solaris'], VERSION], [
            /((?:open)?solaris)[\/\s-]?([\w\.]*)/i,                             // Solaris
            /(aix)\s((\d)(?=\.|\)|\s)[\w\.])*/i,                                // AIX
            /(plan\s9|minix|beos|os\/2|amigaos|morphos|risc\sos|openvms|fuchsia)/i,  // Plan9/Minix/BeOS/OS2/AmigaOS/MorphOS/RISCOS/OpenVMS/Fuchsia
            /(unix)\s?([\w\.]*)/i                                               // UNIX
            ], [NAME, VERSION]
        ]
    };


    /////////////////
    // Constructor
    ////////////////
    var UAParser = function (ua, extensions) {

        if (typeof ua === 'object') {
            extensions = ua;
            ua = undefined;
        }

        if (!(this instanceof UAParser)) {
            return new UAParser(ua, extensions).getResult();
        }

        var _ua = ua || ((typeof window !== 'undefined' && window.navigator && window.navigator.userAgent) ? window.navigator.userAgent : EMPTY);
        var _rgxmap = extensions ? util.extend(regexes, extensions) : regexes;

        this.getBrowser = function () {
            var _browser = { name: undefined, version: undefined };
            mapper.rgx.call(_browser, _ua, _rgxmap.browser);
            _browser.major = util.major(_browser.version); // deprecated
            return _browser;
        };
        this.getCPU = function () {
            var _cpu = { architecture: undefined };
            mapper.rgx.call(_cpu, _ua, _rgxmap.cpu);
            return _cpu;
        };
        this.getDevice = function () {
            var _device = { vendor: undefined, model: undefined, type: undefined };
            mapper.rgx.call(_device, _ua, _rgxmap.device);
            return _device;
        };
        this.getEngine = function () {
            var _engine = { name: undefined, version: undefined };
            mapper.rgx.call(_engine, _ua, _rgxmap.engine);
            return _engine;
        };
        this.getOS = function () {
            var _os = { name: undefined, version: undefined };
            mapper.rgx.call(_os, _ua, _rgxmap.os);
            return _os;
        };
        this.getResult = function () {
            return {
                ua      : this.getUA(),
                browser : this.getBrowser(),
                engine  : this.getEngine(),
                os      : this.getOS(),
                device  : this.getDevice(),
                cpu     : this.getCPU()
            };
        };
        this.getUA = function () {
            return _ua;
        };
        this.setUA = function (ua) {
            _ua = (typeof ua === STR_TYPE && ua.length > UA_MAX_LENGTH) ? util.trim(ua, UA_MAX_LENGTH) : ua;
            return this;
        };
        this.setUA(_ua);
        return this;
    };

    UAParser.VERSION = LIBVERSION;
    UAParser.BROWSER = {
        NAME    : NAME,
        MAJOR   : MAJOR, // deprecated
        VERSION : VERSION
    };
    UAParser.CPU = {
        ARCHITECTURE : ARCHITECTURE
    };
    UAParser.DEVICE = {
        MODEL   : MODEL,
        VENDOR  : VENDOR,
        TYPE    : TYPE,
        CONSOLE : CONSOLE,
        MOBILE  : MOBILE,
        SMARTTV : SMARTTV,
        TABLET  : TABLET,
        WEARABLE: WEARABLE,
        EMBEDDED: EMBEDDED
    };
    UAParser.ENGINE = {
        NAME    : NAME,
        VERSION : VERSION
    };
    UAParser.OS = {
        NAME    : NAME,
        VERSION : VERSION
    };

    ///////////
    // Export
    //////////


    // check js environment
    if (typeof(exports) !== UNDEF_TYPE) {
        // nodejs env
        if (typeof module !== UNDEF_TYPE && module.exports) {
            exports = module.exports = UAParser;
        }
        exports.UAParser = UAParser;
    } else {
        // requirejs env (optional)
        if (true) {
            !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
                return UAParser;
            }).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
        } else {}
    }

    // jQuery/Zepto specific (optional)
    // Note:
    //   In AMD env the global scope should be kept clean, but jQuery is an exception.
    //   jQuery always exports to global scope, unless jQuery.noConflict(true) is used,
    //   and we should catch that.
    var $ = typeof window !== 'undefined' && (window.jQuery || window.Zepto);
    if ($ && !$.ua) {
        var parser = new UAParser();
        $.ua = parser.getResult();
        $.ua.get = function () {
            return parser.getUA();
        };
        $.ua.set = function (uastring) {
            parser.setUA(uastring);
            var result = parser.getResult();
            for (var prop in result) {
                $.ua[prop] = result[prop];
            }
        };
    }

})(typeof window === 'object' ? window : this);


/***/ }),

/***/ "../../../node_modules/urijs/src/URI.js":
/*!***************************************************************!*\
  !*** /home/omar/Desktop/hivejs/node_modules/urijs/src/URI.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * URI.js - Mutating URLs
 *
 * Version: 1.19.2
 *
 * Author: Rodney Rehm
 * Web: http://medialize.github.io/URI.js/
 *
 * Licensed under
 *   MIT License http://www.opensource.org/licenses/mit-license
 *
 */
(function (root, factory) {
  'use strict';
  // https://github.com/umdjs/umd/blob/master/returnExports.js
  if ( true && module.exports) {
    // Node
    module.exports = factory(__webpack_require__(/*! ./punycode */ "../../../scripts/build-project/empty.js"), __webpack_require__(/*! ./IPv6 */ "../../../scripts/build-project/empty.js"), __webpack_require__(/*! ./SecondLevelDomains */ "../../../scripts/build-project/empty.js"));
  } else if (true) {
    // AMD. Register as an anonymous module.
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./punycode */ "../../../scripts/build-project/empty.js"), __webpack_require__(/*! ./IPv6 */ "../../../scripts/build-project/empty.js"), __webpack_require__(/*! ./SecondLevelDomains */ "../../../scripts/build-project/empty.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}
}(this, function (punycode, IPv6, SLD, root) {
  'use strict';
  /*global location, escape, unescape */
  // FIXME: v2.0.0 renamce non-camelCase properties to uppercase
  /*jshint camelcase: false */

  // save current URI variable, if any
  var _URI = root && root.URI;

  function URI(url, base) {
    var _urlSupplied = arguments.length >= 1;
    var _baseSupplied = arguments.length >= 2;

    // Allow instantiation without the 'new' keyword
    if (!(this instanceof URI)) {
      if (_urlSupplied) {
        if (_baseSupplied) {
          return new URI(url, base);
        }

        return new URI(url);
      }

      return new URI();
    }

    if (url === undefined) {
      if (_urlSupplied) {
        throw new TypeError('undefined is not a valid argument for URI');
      }

      if (typeof location !== 'undefined') {
        url = location.href + '';
      } else {
        url = '';
      }
    }

    if (url === null) {
      if (_urlSupplied) {
        throw new TypeError('null is not a valid argument for URI');
      }
    }

    this.href(url);

    // resolve to base according to http://dvcs.w3.org/hg/url/raw-file/tip/Overview.html#constructor
    if (base !== undefined) {
      return this.absoluteTo(base);
    }

    return this;
  }

  function isInteger(value) {
    return /^[0-9]+$/.test(value);
  }

  URI.version = '1.19.2';

  var p = URI.prototype;
  var hasOwn = Object.prototype.hasOwnProperty;

  function escapeRegEx(string) {
    // https://github.com/medialize/URI.js/commit/85ac21783c11f8ccab06106dba9735a31a86924d#commitcomment-821963
    return string.replace(/([.*+?^=!:${}()|[\]\/\\])/g, '\\$1');
  }

  function getType(value) {
    // IE8 doesn't return [Object Undefined] but [Object Object] for undefined value
    if (value === undefined) {
      return 'Undefined';
    }

    return String(Object.prototype.toString.call(value)).slice(8, -1);
  }

  function isArray(obj) {
    return getType(obj) === 'Array';
  }

  function filterArrayValues(data, value) {
    var lookup = {};
    var i, length;

    if (getType(value) === 'RegExp') {
      lookup = null;
    } else if (isArray(value)) {
      for (i = 0, length = value.length; i < length; i++) {
        lookup[value[i]] = true;
      }
    } else {
      lookup[value] = true;
    }

    for (i = 0, length = data.length; i < length; i++) {
      /*jshint laxbreak: true */
      var _match = lookup && lookup[data[i]] !== undefined
        || !lookup && value.test(data[i]);
      /*jshint laxbreak: false */
      if (_match) {
        data.splice(i, 1);
        length--;
        i--;
      }
    }

    return data;
  }

  function arrayContains(list, value) {
    var i, length;

    // value may be string, number, array, regexp
    if (isArray(value)) {
      // Note: this can be optimized to O(n) (instead of current O(m * n))
      for (i = 0, length = value.length; i < length; i++) {
        if (!arrayContains(list, value[i])) {
          return false;
        }
      }

      return true;
    }

    var _type = getType(value);
    for (i = 0, length = list.length; i < length; i++) {
      if (_type === 'RegExp') {
        if (typeof list[i] === 'string' && list[i].match(value)) {
          return true;
        }
      } else if (list[i] === value) {
        return true;
      }
    }

    return false;
  }

  function arraysEqual(one, two) {
    if (!isArray(one) || !isArray(two)) {
      return false;
    }

    // arrays can't be equal if they have different amount of content
    if (one.length !== two.length) {
      return false;
    }

    one.sort();
    two.sort();

    for (var i = 0, l = one.length; i < l; i++) {
      if (one[i] !== two[i]) {
        return false;
      }
    }

    return true;
  }

  function trimSlashes(text) {
    var trim_expression = /^\/+|\/+$/g;
    return text.replace(trim_expression, '');
  }

  URI._parts = function() {
    return {
      protocol: null,
      username: null,
      password: null,
      hostname: null,
      urn: null,
      port: null,
      path: null,
      query: null,
      fragment: null,
      // state
      preventInvalidHostname: URI.preventInvalidHostname,
      duplicateQueryParameters: URI.duplicateQueryParameters,
      escapeQuerySpace: URI.escapeQuerySpace
    };
  };
  // state: throw on invalid hostname
  // see https://github.com/medialize/URI.js/pull/345
  // and https://github.com/medialize/URI.js/issues/354
  URI.preventInvalidHostname = false;
  // state: allow duplicate query parameters (a=1&a=1)
  URI.duplicateQueryParameters = false;
  // state: replaces + with %20 (space in query strings)
  URI.escapeQuerySpace = true;
  // static properties
  URI.protocol_expression = /^[a-z][a-z0-9.+-]*$/i;
  URI.idn_expression = /[^a-z0-9\._-]/i;
  URI.punycode_expression = /(xn--)/i;
  // well, 333.444.555.666 matches, but it sure ain't no IPv4 - do we care?
  URI.ip4_expression = /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/;
  // credits to Rich Brown
  // source: http://forums.intermapper.com/viewtopic.php?p=1096#1096
  // specification: http://www.ietf.org/rfc/rfc4291.txt
  URI.ip6_expression = /^\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(%.+)?\s*$/;
  // expression used is "gruber revised" (@gruber v2) determined to be the
  // best solution in a regex-golf we did a couple of ages ago at
  // * http://mathiasbynens.be/demo/url-regex
  // * http://rodneyrehm.de/t/url-regex.html
  URI.find_uri_expression = /\b((?:[a-z][\w-]+:(?:\/{1,3}|[a-z0-9%])|www\d{0,3}[.]|[a-z0-9.\-]+[.][a-z]{2,4}\/)(?:[^\s()<>]+|\(([^\s()<>]+|(\([^\s()<>]+\)))*\))+(?:\(([^\s()<>]+|(\([^\s()<>]+\)))*\)|[^\s`!()\[\]{};:'".,<>?]))/ig;
  URI.findUri = {
    // valid "scheme://" or "www."
    start: /\b(?:([a-z][a-z0-9.+-]*:\/\/)|www\.)/gi,
    // everything up to the next whitespace
    end: /[\s\r\n]|$/,
    // trim trailing punctuation captured by end RegExp
    trim: /[`!()\[\]{};:'".,<>?]+$/,
    // balanced parens inclusion (), [], {}, <>
    parens: /(\([^\)]*\)|\[[^\]]*\]|\{[^}]*\}|<[^>]*>)/g,
  };
  // http://www.iana.org/assignments/uri-schemes.html
  // http://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#Well-known_ports
  URI.defaultPorts = {
    http: '80',
    https: '443',
    ftp: '21',
    gopher: '70',
    ws: '80',
    wss: '443'
  };
  // list of protocols which always require a hostname
  URI.hostProtocols = [
    'http',
    'https'
  ];

  // allowed hostname characters according to RFC 3986
  // ALPHA DIGIT "-" "." "_" "~" "!" "$" "&" "'" "(" ")" "*" "+" "," ";" "=" %encoded
  // I've never seen a (non-IDN) hostname other than: ALPHA DIGIT . - _
  URI.invalid_hostname_characters = /[^a-zA-Z0-9\.\-:_]/;
  // map DOM Elements to their URI attribute
  URI.domAttributes = {
    'a': 'href',
    'blockquote': 'cite',
    'link': 'href',
    'base': 'href',
    'script': 'src',
    'form': 'action',
    'img': 'src',
    'area': 'href',
    'iframe': 'src',
    'embed': 'src',
    'source': 'src',
    'track': 'src',
    'input': 'src', // but only if type="image"
    'audio': 'src',
    'video': 'src'
  };
  URI.getDomAttribute = function(node) {
    if (!node || !node.nodeName) {
      return undefined;
    }

    var nodeName = node.nodeName.toLowerCase();
    // <input> should only expose src for type="image"
    if (nodeName === 'input' && node.type !== 'image') {
      return undefined;
    }

    return URI.domAttributes[nodeName];
  };

  function escapeForDumbFirefox36(value) {
    // https://github.com/medialize/URI.js/issues/91
    return escape(value);
  }

  // encoding / decoding according to RFC3986
  function strictEncodeURIComponent(string) {
    // see https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/encodeURIComponent
    return encodeURIComponent(string)
      .replace(/[!'()*]/g, escapeForDumbFirefox36)
      .replace(/\*/g, '%2A');
  }
  URI.encode = strictEncodeURIComponent;
  URI.decode = decodeURIComponent;
  URI.iso8859 = function() {
    URI.encode = escape;
    URI.decode = unescape;
  };
  URI.unicode = function() {
    URI.encode = strictEncodeURIComponent;
    URI.decode = decodeURIComponent;
  };
  URI.characters = {
    pathname: {
      encode: {
        // RFC3986 2.1: For consistency, URI producers and normalizers should
        // use uppercase hexadecimal digits for all percent-encodings.
        expression: /%(24|26|2B|2C|3B|3D|3A|40)/ig,
        map: {
          // -._~!'()*
          '%24': '$',
          '%26': '&',
          '%2B': '+',
          '%2C': ',',
          '%3B': ';',
          '%3D': '=',
          '%3A': ':',
          '%40': '@'
        }
      },
      decode: {
        expression: /[\/\?#]/g,
        map: {
          '/': '%2F',
          '?': '%3F',
          '#': '%23'
        }
      }
    },
    reserved: {
      encode: {
        // RFC3986 2.1: For consistency, URI producers and normalizers should
        // use uppercase hexadecimal digits for all percent-encodings.
        expression: /%(21|23|24|26|27|28|29|2A|2B|2C|2F|3A|3B|3D|3F|40|5B|5D)/ig,
        map: {
          // gen-delims
          '%3A': ':',
          '%2F': '/',
          '%3F': '?',
          '%23': '#',
          '%5B': '[',
          '%5D': ']',
          '%40': '@',
          // sub-delims
          '%21': '!',
          '%24': '$',
          '%26': '&',
          '%27': '\'',
          '%28': '(',
          '%29': ')',
          '%2A': '*',
          '%2B': '+',
          '%2C': ',',
          '%3B': ';',
          '%3D': '='
        }
      }
    },
    urnpath: {
      // The characters under `encode` are the characters called out by RFC 2141 as being acceptable
      // for usage in a URN. RFC2141 also calls out "-", ".", and "_" as acceptable characters, but
      // these aren't encoded by encodeURIComponent, so we don't have to call them out here. Also
      // note that the colon character is not featured in the encoding map; this is because URI.js
      // gives the colons in URNs semantic meaning as the delimiters of path segements, and so it
      // should not appear unencoded in a segment itself.
      // See also the note above about RFC3986 and capitalalized hex digits.
      encode: {
        expression: /%(21|24|27|28|29|2A|2B|2C|3B|3D|40)/ig,
        map: {
          '%21': '!',
          '%24': '$',
          '%27': '\'',
          '%28': '(',
          '%29': ')',
          '%2A': '*',
          '%2B': '+',
          '%2C': ',',
          '%3B': ';',
          '%3D': '=',
          '%40': '@'
        }
      },
      // These characters are the characters called out by RFC2141 as "reserved" characters that
      // should never appear in a URN, plus the colon character (see note above).
      decode: {
        expression: /[\/\?#:]/g,
        map: {
          '/': '%2F',
          '?': '%3F',
          '#': '%23',
          ':': '%3A'
        }
      }
    }
  };
  URI.encodeQuery = function(string, escapeQuerySpace) {
    var escaped = URI.encode(string + '');
    if (escapeQuerySpace === undefined) {
      escapeQuerySpace = URI.escapeQuerySpace;
    }

    return escapeQuerySpace ? escaped.replace(/%20/g, '+') : escaped;
  };
  URI.decodeQuery = function(string, escapeQuerySpace) {
    string += '';
    if (escapeQuerySpace === undefined) {
      escapeQuerySpace = URI.escapeQuerySpace;
    }

    try {
      return URI.decode(escapeQuerySpace ? string.replace(/\+/g, '%20') : string);
    } catch(e) {
      // we're not going to mess with weird encodings,
      // give up and return the undecoded original string
      // see https://github.com/medialize/URI.js/issues/87
      // see https://github.com/medialize/URI.js/issues/92
      return string;
    }
  };
  // generate encode/decode path functions
  var _parts = {'encode':'encode', 'decode':'decode'};
  var _part;
  var generateAccessor = function(_group, _part) {
    return function(string) {
      try {
        return URI[_part](string + '').replace(URI.characters[_group][_part].expression, function(c) {
          return URI.characters[_group][_part].map[c];
        });
      } catch (e) {
        // we're not going to mess with weird encodings,
        // give up and return the undecoded original string
        // see https://github.com/medialize/URI.js/issues/87
        // see https://github.com/medialize/URI.js/issues/92
        return string;
      }
    };
  };

  for (_part in _parts) {
    URI[_part + 'PathSegment'] = generateAccessor('pathname', _parts[_part]);
    URI[_part + 'UrnPathSegment'] = generateAccessor('urnpath', _parts[_part]);
  }

  var generateSegmentedPathFunction = function(_sep, _codingFuncName, _innerCodingFuncName) {
    return function(string) {
      // Why pass in names of functions, rather than the function objects themselves? The
      // definitions of some functions (but in particular, URI.decode) will occasionally change due
      // to URI.js having ISO8859 and Unicode modes. Passing in the name and getting it will ensure
      // that the functions we use here are "fresh".
      var actualCodingFunc;
      if (!_innerCodingFuncName) {
        actualCodingFunc = URI[_codingFuncName];
      } else {
        actualCodingFunc = function(string) {
          return URI[_codingFuncName](URI[_innerCodingFuncName](string));
        };
      }

      var segments = (string + '').split(_sep);

      for (var i = 0, length = segments.length; i < length; i++) {
        segments[i] = actualCodingFunc(segments[i]);
      }

      return segments.join(_sep);
    };
  };

  // This takes place outside the above loop because we don't want, e.g., encodeUrnPath functions.
  URI.decodePath = generateSegmentedPathFunction('/', 'decodePathSegment');
  URI.decodeUrnPath = generateSegmentedPathFunction(':', 'decodeUrnPathSegment');
  URI.recodePath = generateSegmentedPathFunction('/', 'encodePathSegment', 'decode');
  URI.recodeUrnPath = generateSegmentedPathFunction(':', 'encodeUrnPathSegment', 'decode');

  URI.encodeReserved = generateAccessor('reserved', 'encode');

  URI.parse = function(string, parts) {
    var pos;
    if (!parts) {
      parts = {
        preventInvalidHostname: URI.preventInvalidHostname
      };
    }
    // [protocol"://"[username[":"password]"@"]hostname[":"port]"/"?][path]["?"querystring]["#"fragment]

    // extract fragment
    pos = string.indexOf('#');
    if (pos > -1) {
      // escaping?
      parts.fragment = string.substring(pos + 1) || null;
      string = string.substring(0, pos);
    }

    // extract query
    pos = string.indexOf('?');
    if (pos > -1) {
      // escaping?
      parts.query = string.substring(pos + 1) || null;
      string = string.substring(0, pos);
    }

    // extract protocol
    if (string.substring(0, 2) === '//') {
      // relative-scheme
      parts.protocol = null;
      string = string.substring(2);
      // extract "user:pass@host:port"
      string = URI.parseAuthority(string, parts);
    } else {
      pos = string.indexOf(':');
      if (pos > -1) {
        parts.protocol = string.substring(0, pos) || null;
        if (parts.protocol && !parts.protocol.match(URI.protocol_expression)) {
          // : may be within the path
          parts.protocol = undefined;
        } else if (string.substring(pos + 1, pos + 3) === '//') {
          string = string.substring(pos + 3);

          // extract "user:pass@host:port"
          string = URI.parseAuthority(string, parts);
        } else {
          string = string.substring(pos + 1);
          parts.urn = true;
        }
      }
    }

    // what's left must be the path
    parts.path = string;

    // and we're done
    return parts;
  };
  URI.parseHost = function(string, parts) {
    if (!string) {
      string = '';
    }

    // Copy chrome, IE, opera backslash-handling behavior.
    // Back slashes before the query string get converted to forward slashes
    // See: https://github.com/joyent/node/blob/386fd24f49b0e9d1a8a076592a404168faeecc34/lib/url.js#L115-L124
    // See: https://code.google.com/p/chromium/issues/detail?id=25916
    // https://github.com/medialize/URI.js/pull/233
    string = string.replace(/\\/g, '/');

    // extract host:port
    var pos = string.indexOf('/');
    var bracketPos;
    var t;

    if (pos === -1) {
      pos = string.length;
    }

    if (string.charAt(0) === '[') {
      // IPv6 host - http://tools.ietf.org/html/draft-ietf-6man-text-addr-representation-04#section-6
      // I claim most client software breaks on IPv6 anyways. To simplify things, URI only accepts
      // IPv6+port in the format [2001:db8::1]:80 (for the time being)
      bracketPos = string.indexOf(']');
      parts.hostname = string.substring(1, bracketPos) || null;
      parts.port = string.substring(bracketPos + 2, pos) || null;
      if (parts.port === '/') {
        parts.port = null;
      }
    } else {
      var firstColon = string.indexOf(':');
      var firstSlash = string.indexOf('/');
      var nextColon = string.indexOf(':', firstColon + 1);
      if (nextColon !== -1 && (firstSlash === -1 || nextColon < firstSlash)) {
        // IPv6 host contains multiple colons - but no port
        // this notation is actually not allowed by RFC 3986, but we're a liberal parser
        parts.hostname = string.substring(0, pos) || null;
        parts.port = null;
      } else {
        t = string.substring(0, pos).split(':');
        parts.hostname = t[0] || null;
        parts.port = t[1] || null;
      }
    }

    if (parts.hostname && string.substring(pos).charAt(0) !== '/') {
      pos++;
      string = '/' + string;
    }

    if (parts.preventInvalidHostname) {
      URI.ensureValidHostname(parts.hostname, parts.protocol);
    }

    if (parts.port) {
      URI.ensureValidPort(parts.port);
    }

    return string.substring(pos) || '/';
  };
  URI.parseAuthority = function(string, parts) {
    string = URI.parseUserinfo(string, parts);
    return URI.parseHost(string, parts);
  };
  URI.parseUserinfo = function(string, parts) {
    // extract username:password
    var firstSlash = string.indexOf('/');
    var pos = string.lastIndexOf('@', firstSlash > -1 ? firstSlash : string.length - 1);
    var t;

    // authority@ must come before /path
    if (pos > -1 && (firstSlash === -1 || pos < firstSlash)) {
      t = string.substring(0, pos).split(':');
      parts.username = t[0] ? URI.decode(t[0]) : null;
      t.shift();
      parts.password = t[0] ? URI.decode(t.join(':')) : null;
      string = string.substring(pos + 1);
    } else {
      parts.username = null;
      parts.password = null;
    }

    return string;
  };
  URI.parseQuery = function(string, escapeQuerySpace) {
    if (!string) {
      return {};
    }

    // throw out the funky business - "?"[name"="value"&"]+
    string = string.replace(/&+/g, '&').replace(/^\?*&*|&+$/g, '');

    if (!string) {
      return {};
    }

    var items = {};
    var splits = string.split('&');
    var length = splits.length;
    var v, name, value;

    for (var i = 0; i < length; i++) {
      v = splits[i].split('=');
      name = URI.decodeQuery(v.shift(), escapeQuerySpace);
      // no "=" is null according to http://dvcs.w3.org/hg/url/raw-file/tip/Overview.html#collect-url-parameters
      value = v.length ? URI.decodeQuery(v.join('='), escapeQuerySpace) : null;

      if (hasOwn.call(items, name)) {
        if (typeof items[name] === 'string' || items[name] === null) {
          items[name] = [items[name]];
        }

        items[name].push(value);
      } else {
        items[name] = value;
      }
    }

    return items;
  };

  URI.build = function(parts) {
    var t = '';
    var requireAbsolutePath = false

    if (parts.protocol) {
      t += parts.protocol + ':';
    }

    if (!parts.urn && (t || parts.hostname)) {
      t += '//';
      requireAbsolutePath = true
    }

    t += (URI.buildAuthority(parts) || '');

    if (typeof parts.path === 'string') {
      if (parts.path.charAt(0) !== '/' && requireAbsolutePath) {
        t += '/';
      }

      t += parts.path;
    }

    if (typeof parts.query === 'string' && parts.query) {
      t += '?' + parts.query;
    }

    if (typeof parts.fragment === 'string' && parts.fragment) {
      t += '#' + parts.fragment;
    }
    return t;
  };
  URI.buildHost = function(parts) {
    var t = '';

    if (!parts.hostname) {
      return '';
    } else if (URI.ip6_expression.test(parts.hostname)) {
      t += '[' + parts.hostname + ']';
    } else {
      t += parts.hostname;
    }

    if (parts.port) {
      t += ':' + parts.port;
    }

    return t;
  };
  URI.buildAuthority = function(parts) {
    return URI.buildUserinfo(parts) + URI.buildHost(parts);
  };
  URI.buildUserinfo = function(parts) {
    var t = '';

    if (parts.username) {
      t += URI.encode(parts.username);
    }

    if (parts.password) {
      t += ':' + URI.encode(parts.password);
    }

    if (t) {
      t += '@';
    }

    return t;
  };
  URI.buildQuery = function(data, duplicateQueryParameters, escapeQuerySpace) {
    // according to http://tools.ietf.org/html/rfc3986 or http://labs.apache.org/webarch/uri/rfc/rfc3986.html
    // being -._~!$&'()*+,;=:@/? %HEX and alnum are allowed
    // the RFC explicitly states ?/foo being a valid use case, no mention of parameter syntax!
    // URI.js treats the query string as being application/x-www-form-urlencoded
    // see http://www.w3.org/TR/REC-html40/interact/forms.html#form-content-type

    var t = '';
    var unique, key, i, length;
    for (key in data) {
      if (hasOwn.call(data, key)) {
        if (isArray(data[key])) {
          unique = {};
          for (i = 0, length = data[key].length; i < length; i++) {
            if (data[key][i] !== undefined && unique[data[key][i] + ''] === undefined) {
              t += '&' + URI.buildQueryParameter(key, data[key][i], escapeQuerySpace);
              if (duplicateQueryParameters !== true) {
                unique[data[key][i] + ''] = true;
              }
            }
          }
        } else if (data[key] !== undefined) {
          t += '&' + URI.buildQueryParameter(key, data[key], escapeQuerySpace);
        }
      }
    }

    return t.substring(1);
  };
  URI.buildQueryParameter = function(name, value, escapeQuerySpace) {
    // http://www.w3.org/TR/REC-html40/interact/forms.html#form-content-type -- application/x-www-form-urlencoded
    // don't append "=" for null values, according to http://dvcs.w3.org/hg/url/raw-file/tip/Overview.html#url-parameter-serialization
    return URI.encodeQuery(name, escapeQuerySpace) + (value !== null ? '=' + URI.encodeQuery(value, escapeQuerySpace) : '');
  };

  URI.addQuery = function(data, name, value) {
    if (typeof name === 'object') {
      for (var key in name) {
        if (hasOwn.call(name, key)) {
          URI.addQuery(data, key, name[key]);
        }
      }
    } else if (typeof name === 'string') {
      if (data[name] === undefined) {
        data[name] = value;
        return;
      } else if (typeof data[name] === 'string') {
        data[name] = [data[name]];
      }

      if (!isArray(value)) {
        value = [value];
      }

      data[name] = (data[name] || []).concat(value);
    } else {
      throw new TypeError('URI.addQuery() accepts an object, string as the name parameter');
    }
  };

  URI.setQuery = function(data, name, value) {
    if (typeof name === 'object') {
      for (var key in name) {
        if (hasOwn.call(name, key)) {
          URI.setQuery(data, key, name[key]);
        }
      }
    } else if (typeof name === 'string') {
      data[name] = value === undefined ? null : value;
    } else {
      throw new TypeError('URI.setQuery() accepts an object, string as the name parameter');
    }
  };

  URI.removeQuery = function(data, name, value) {
    var i, length, key;

    if (isArray(name)) {
      for (i = 0, length = name.length; i < length; i++) {
        data[name[i]] = undefined;
      }
    } else if (getType(name) === 'RegExp') {
      for (key in data) {
        if (name.test(key)) {
          data[key] = undefined;
        }
      }
    } else if (typeof name === 'object') {
      for (key in name) {
        if (hasOwn.call(name, key)) {
          URI.removeQuery(data, key, name[key]);
        }
      }
    } else if (typeof name === 'string') {
      if (value !== undefined) {
        if (getType(value) === 'RegExp') {
          if (!isArray(data[name]) && value.test(data[name])) {
            data[name] = undefined;
          } else {
            data[name] = filterArrayValues(data[name], value);
          }
        } else if (data[name] === String(value) && (!isArray(value) || value.length === 1)) {
          data[name] = undefined;
        } else if (isArray(data[name])) {
          data[name] = filterArrayValues(data[name], value);
        }
      } else {
        data[name] = undefined;
      }
    } else {
      throw new TypeError('URI.removeQuery() accepts an object, string, RegExp as the first parameter');
    }
  };
  URI.hasQuery = function(data, name, value, withinArray) {
    switch (getType(name)) {
      case 'String':
        // Nothing to do here
        break;

      case 'RegExp':
        for (var key in data) {
          if (hasOwn.call(data, key)) {
            if (name.test(key) && (value === undefined || URI.hasQuery(data, key, value))) {
              return true;
            }
          }
        }

        return false;

      case 'Object':
        for (var _key in name) {
          if (hasOwn.call(name, _key)) {
            if (!URI.hasQuery(data, _key, name[_key])) {
              return false;
            }
          }
        }

        return true;

      default:
        throw new TypeError('URI.hasQuery() accepts a string, regular expression or object as the name parameter');
    }

    switch (getType(value)) {
      case 'Undefined':
        // true if exists (but may be empty)
        return name in data; // data[name] !== undefined;

      case 'Boolean':
        // true if exists and non-empty
        var _booly = Boolean(isArray(data[name]) ? data[name].length : data[name]);
        return value === _booly;

      case 'Function':
        // allow complex comparison
        return !!value(data[name], name, data);

      case 'Array':
        if (!isArray(data[name])) {
          return false;
        }

        var op = withinArray ? arrayContains : arraysEqual;
        return op(data[name], value);

      case 'RegExp':
        if (!isArray(data[name])) {
          return Boolean(data[name] && data[name].match(value));
        }

        if (!withinArray) {
          return false;
        }

        return arrayContains(data[name], value);

      case 'Number':
        value = String(value);
        /* falls through */
      case 'String':
        if (!isArray(data[name])) {
          return data[name] === value;
        }

        if (!withinArray) {
          return false;
        }

        return arrayContains(data[name], value);

      default:
        throw new TypeError('URI.hasQuery() accepts undefined, boolean, string, number, RegExp, Function as the value parameter');
    }
  };


  URI.joinPaths = function() {
    var input = [];
    var segments = [];
    var nonEmptySegments = 0;

    for (var i = 0; i < arguments.length; i++) {
      var url = new URI(arguments[i]);
      input.push(url);
      var _segments = url.segment();
      for (var s = 0; s < _segments.length; s++) {
        if (typeof _segments[s] === 'string') {
          segments.push(_segments[s]);
        }

        if (_segments[s]) {
          nonEmptySegments++;
        }
      }
    }

    if (!segments.length || !nonEmptySegments) {
      return new URI('');
    }

    var uri = new URI('').segment(segments);

    if (input[0].path() === '' || input[0].path().slice(0, 1) === '/') {
      uri.path('/' + uri.path());
    }

    return uri.normalize();
  };

  URI.commonPath = function(one, two) {
    var length = Math.min(one.length, two.length);
    var pos;

    // find first non-matching character
    for (pos = 0; pos < length; pos++) {
      if (one.charAt(pos) !== two.charAt(pos)) {
        pos--;
        break;
      }
    }

    if (pos < 1) {
      return one.charAt(0) === two.charAt(0) && one.charAt(0) === '/' ? '/' : '';
    }

    // revert to last /
    if (one.charAt(pos) !== '/' || two.charAt(pos) !== '/') {
      pos = one.substring(0, pos).lastIndexOf('/');
    }

    return one.substring(0, pos + 1);
  };

  URI.withinString = function(string, callback, options) {
    options || (options = {});
    var _start = options.start || URI.findUri.start;
    var _end = options.end || URI.findUri.end;
    var _trim = options.trim || URI.findUri.trim;
    var _parens = options.parens || URI.findUri.parens;
    var _attributeOpen = /[a-z0-9-]=["']?$/i;

    _start.lastIndex = 0;
    while (true) {
      var match = _start.exec(string);
      if (!match) {
        break;
      }

      var start = match.index;
      if (options.ignoreHtml) {
        // attribut(e=["']?$)
        var attributeOpen = string.slice(Math.max(start - 3, 0), start);
        if (attributeOpen && _attributeOpen.test(attributeOpen)) {
          continue;
        }
      }

      var end = start + string.slice(start).search(_end);
      var slice = string.slice(start, end);
      // make sure we include well balanced parens
      var parensEnd = -1;
      while (true) {
        var parensMatch = _parens.exec(slice);
        if (!parensMatch) {
          break;
        }

        var parensMatchEnd = parensMatch.index + parensMatch[0].length;
        parensEnd = Math.max(parensEnd, parensMatchEnd);
      }

      if (parensEnd > -1) {
        slice = slice.slice(0, parensEnd) + slice.slice(parensEnd).replace(_trim, '');
      } else {
        slice = slice.replace(_trim, '');
      }

      if (slice.length <= match[0].length) {
        // the extract only contains the starting marker of a URI,
        // e.g. "www" or "http://"
        continue;
      }

      if (options.ignore && options.ignore.test(slice)) {
        continue;
      }

      end = start + slice.length;
      var result = callback(slice, start, end, string);
      if (result === undefined) {
        _start.lastIndex = end;
        continue;
      }

      result = String(result);
      string = string.slice(0, start) + result + string.slice(end);
      _start.lastIndex = start + result.length;
    }

    _start.lastIndex = 0;
    return string;
  };

  URI.ensureValidHostname = function(v, protocol) {
    // Theoretically URIs allow percent-encoding in Hostnames (according to RFC 3986)
    // they are not part of DNS and therefore ignored by URI.js

    var hasHostname = !!v; // not null and not an empty string
    var hasProtocol = !!protocol;
    var rejectEmptyHostname = false;

    if (hasProtocol) {
      rejectEmptyHostname = arrayContains(URI.hostProtocols, protocol);
    }

    if (rejectEmptyHostname && !hasHostname) {
      throw new TypeError('Hostname cannot be empty, if protocol is ' + protocol);
    } else if (v && v.match(URI.invalid_hostname_characters)) {
      // test punycode
      if (!punycode) {
        throw new TypeError('Hostname "' + v + '" contains characters other than [A-Z0-9.-:_] and Punycode.js is not available');
      }
      if (punycode.toASCII(v).match(URI.invalid_hostname_characters)) {
        throw new TypeError('Hostname "' + v + '" contains characters other than [A-Z0-9.-:_]');
      }
    }
  };

  URI.ensureValidPort = function (v) {
    if (!v) {
      return;
    }

    var port = Number(v);
    if (isInteger(port) && (port > 0) && (port < 65536)) {
      return;
    }

    throw new TypeError('Port "' + v + '" is not a valid port');
  };

  // noConflict
  URI.noConflict = function(removeAll) {
    if (removeAll) {
      var unconflicted = {
        URI: this.noConflict()
      };

      if (root.URITemplate && typeof root.URITemplate.noConflict === 'function') {
        unconflicted.URITemplate = root.URITemplate.noConflict();
      }

      if (root.IPv6 && typeof root.IPv6.noConflict === 'function') {
        unconflicted.IPv6 = root.IPv6.noConflict();
      }

      if (root.SecondLevelDomains && typeof root.SecondLevelDomains.noConflict === 'function') {
        unconflicted.SecondLevelDomains = root.SecondLevelDomains.noConflict();
      }

      return unconflicted;
    } else if (root.URI === this) {
      root.URI = _URI;
    }

    return this;
  };

  p.build = function(deferBuild) {
    if (deferBuild === true) {
      this._deferred_build = true;
    } else if (deferBuild === undefined || this._deferred_build) {
      this._string = URI.build(this._parts);
      this._deferred_build = false;
    }

    return this;
  };

  p.clone = function() {
    return new URI(this);
  };

  p.valueOf = p.toString = function() {
    return this.build(false)._string;
  };


  function generateSimpleAccessor(_part){
    return function(v, build) {
      if (v === undefined) {
        return this._parts[_part] || '';
      } else {
        this._parts[_part] = v || null;
        this.build(!build);
        return this;
      }
    };
  }

  function generatePrefixAccessor(_part, _key){
    return function(v, build) {
      if (v === undefined) {
        return this._parts[_part] || '';
      } else {
        if (v !== null) {
          v = v + '';
          if (v.charAt(0) === _key) {
            v = v.substring(1);
          }
        }

        this._parts[_part] = v;
        this.build(!build);
        return this;
      }
    };
  }

  p.protocol = generateSimpleAccessor('protocol');
  p.username = generateSimpleAccessor('username');
  p.password = generateSimpleAccessor('password');
  p.hostname = generateSimpleAccessor('hostname');
  p.port = generateSimpleAccessor('port');
  p.query = generatePrefixAccessor('query', '?');
  p.fragment = generatePrefixAccessor('fragment', '#');

  p.search = function(v, build) {
    var t = this.query(v, build);
    return typeof t === 'string' && t.length ? ('?' + t) : t;
  };
  p.hash = function(v, build) {
    var t = this.fragment(v, build);
    return typeof t === 'string' && t.length ? ('#' + t) : t;
  };

  p.pathname = function(v, build) {
    if (v === undefined || v === true) {
      var res = this._parts.path || (this._parts.hostname ? '/' : '');
      return v ? (this._parts.urn ? URI.decodeUrnPath : URI.decodePath)(res) : res;
    } else {
      if (this._parts.urn) {
        this._parts.path = v ? URI.recodeUrnPath(v) : '';
      } else {
        this._parts.path = v ? URI.recodePath(v) : '/';
      }
      this.build(!build);
      return this;
    }
  };
  p.path = p.pathname;
  p.href = function(href, build) {
    var key;

    if (href === undefined) {
      return this.toString();
    }

    this._string = '';
    this._parts = URI._parts();

    var _URI = href instanceof URI;
    var _object = typeof href === 'object' && (href.hostname || href.path || href.pathname);
    if (href.nodeName) {
      var attribute = URI.getDomAttribute(href);
      href = href[attribute] || '';
      _object = false;
    }

    // window.location is reported to be an object, but it's not the sort
    // of object we're looking for:
    // * location.protocol ends with a colon
    // * location.query != object.search
    // * location.hash != object.fragment
    // simply serializing the unknown object should do the trick
    // (for location, not for everything...)
    if (!_URI && _object && href.pathname !== undefined) {
      href = href.toString();
    }

    if (typeof href === 'string' || href instanceof String) {
      this._parts = URI.parse(String(href), this._parts);
    } else if (_URI || _object) {
      var src = _URI ? href._parts : href;
      for (key in src) {
        if (key === 'query') { continue; }
        if (hasOwn.call(this._parts, key)) {
          this._parts[key] = src[key];
        }
      }
      if (src.query) {
        this.query(src.query, false);
      }
    } else {
      throw new TypeError('invalid input');
    }

    this.build(!build);
    return this;
  };

  // identification accessors
  p.is = function(what) {
    var ip = false;
    var ip4 = false;
    var ip6 = false;
    var name = false;
    var sld = false;
    var idn = false;
    var punycode = false;
    var relative = !this._parts.urn;

    if (this._parts.hostname) {
      relative = false;
      ip4 = URI.ip4_expression.test(this._parts.hostname);
      ip6 = URI.ip6_expression.test(this._parts.hostname);
      ip = ip4 || ip6;
      name = !ip;
      sld = name && SLD && SLD.has(this._parts.hostname);
      idn = name && URI.idn_expression.test(this._parts.hostname);
      punycode = name && URI.punycode_expression.test(this._parts.hostname);
    }

    switch (what.toLowerCase()) {
      case 'relative':
        return relative;

      case 'absolute':
        return !relative;

      // hostname identification
      case 'domain':
      case 'name':
        return name;

      case 'sld':
        return sld;

      case 'ip':
        return ip;

      case 'ip4':
      case 'ipv4':
      case 'inet4':
        return ip4;

      case 'ip6':
      case 'ipv6':
      case 'inet6':
        return ip6;

      case 'idn':
        return idn;

      case 'url':
        return !this._parts.urn;

      case 'urn':
        return !!this._parts.urn;

      case 'punycode':
        return punycode;
    }

    return null;
  };

  // component specific input validation
  var _protocol = p.protocol;
  var _port = p.port;
  var _hostname = p.hostname;

  p.protocol = function(v, build) {
    if (v) {
      // accept trailing ://
      v = v.replace(/:(\/\/)?$/, '');

      if (!v.match(URI.protocol_expression)) {
        throw new TypeError('Protocol "' + v + '" contains characters other than [A-Z0-9.+-] or doesn\'t start with [A-Z]');
      }
    }

    return _protocol.call(this, v, build);
  };
  p.scheme = p.protocol;
  p.port = function(v, build) {
    if (this._parts.urn) {
      return v === undefined ? '' : this;
    }

    if (v !== undefined) {
      if (v === 0) {
        v = null;
      }

      if (v) {
        v += '';
        if (v.charAt(0) === ':') {
          v = v.substring(1);
        }

        URI.ensureValidPort(v);
      }
    }
    return _port.call(this, v, build);
  };
  p.hostname = function(v, build) {
    if (this._parts.urn) {
      return v === undefined ? '' : this;
    }

    if (v !== undefined) {
      var x = { preventInvalidHostname: this._parts.preventInvalidHostname };
      var res = URI.parseHost(v, x);
      if (res !== '/') {
        throw new TypeError('Hostname "' + v + '" contains characters other than [A-Z0-9.-]');
      }

      v = x.hostname;
      if (this._parts.preventInvalidHostname) {
        URI.ensureValidHostname(v, this._parts.protocol);
      }
    }

    return _hostname.call(this, v, build);
  };

  // compound accessors
  p.origin = function(v, build) {
    if (this._parts.urn) {
      return v === undefined ? '' : this;
    }

    if (v === undefined) {
      var protocol = this.protocol();
      var authority = this.authority();
      if (!authority) {
        return '';
      }

      return (protocol ? protocol + '://' : '') + this.authority();
    } else {
      var origin = URI(v);
      this
        .protocol(origin.protocol())
        .authority(origin.authority())
        .build(!build);
      return this;
    }
  };
  p.host = function(v, build) {
    if (this._parts.urn) {
      return v === undefined ? '' : this;
    }

    if (v === undefined) {
      return this._parts.hostname ? URI.buildHost(this._parts) : '';
    } else {
      var res = URI.parseHost(v, this._parts);
      if (res !== '/') {
        throw new TypeError('Hostname "' + v + '" contains characters other than [A-Z0-9.-]');
      }

      this.build(!build);
      return this;
    }
  };
  p.authority = function(v, build) {
    if (this._parts.urn) {
      return v === undefined ? '' : this;
    }

    if (v === undefined) {
      return this._parts.hostname ? URI.buildAuthority(this._parts) : '';
    } else {
      var res = URI.parseAuthority(v, this._parts);
      if (res !== '/') {
        throw new TypeError('Hostname "' + v + '" contains characters other than [A-Z0-9.-]');
      }

      this.build(!build);
      return this;
    }
  };
  p.userinfo = function(v, build) {
    if (this._parts.urn) {
      return v === undefined ? '' : this;
    }

    if (v === undefined) {
      var t = URI.buildUserinfo(this._parts);
      return t ? t.substring(0, t.length -1) : t;
    } else {
      if (v[v.length-1] !== '@') {
        v += '@';
      }

      URI.parseUserinfo(v, this._parts);
      this.build(!build);
      return this;
    }
  };
  p.resource = function(v, build) {
    var parts;

    if (v === undefined) {
      return this.path() + this.search() + this.hash();
    }

    parts = URI.parse(v);
    this._parts.path = parts.path;
    this._parts.query = parts.query;
    this._parts.fragment = parts.fragment;
    this.build(!build);
    return this;
  };

  // fraction accessors
  p.subdomain = function(v, build) {
    if (this._parts.urn) {
      return v === undefined ? '' : this;
    }

    // convenience, return "www" from "www.example.org"
    if (v === undefined) {
      if (!this._parts.hostname || this.is('IP')) {
        return '';
      }

      // grab domain and add another segment
      var end = this._parts.hostname.length - this.domain().length - 1;
      return this._parts.hostname.substring(0, end) || '';
    } else {
      var e = this._parts.hostname.length - this.domain().length;
      var sub = this._parts.hostname.substring(0, e);
      var replace = new RegExp('^' + escapeRegEx(sub));

      if (v && v.charAt(v.length - 1) !== '.') {
        v += '.';
      }

      if (v.indexOf(':') !== -1) {
        throw new TypeError('Domains cannot contain colons');
      }

      if (v) {
        URI.ensureValidHostname(v, this._parts.protocol);
      }

      this._parts.hostname = this._parts.hostname.replace(replace, v);
      this.build(!build);
      return this;
    }
  };
  p.domain = function(v, build) {
    if (this._parts.urn) {
      return v === undefined ? '' : this;
    }

    if (typeof v === 'boolean') {
      build = v;
      v = undefined;
    }

    // convenience, return "example.org" from "www.example.org"
    if (v === undefined) {
      if (!this._parts.hostname || this.is('IP')) {
        return '';
      }

      // if hostname consists of 1 or 2 segments, it must be the domain
      var t = this._parts.hostname.match(/\./g);
      if (t && t.length < 2) {
        return this._parts.hostname;
      }

      // grab tld and add another segment
      var end = this._parts.hostname.length - this.tld(build).length - 1;
      end = this._parts.hostname.lastIndexOf('.', end -1) + 1;
      return this._parts.hostname.substring(end) || '';
    } else {
      if (!v) {
        throw new TypeError('cannot set domain empty');
      }

      if (v.indexOf(':') !== -1) {
        throw new TypeError('Domains cannot contain colons');
      }

      URI.ensureValidHostname(v, this._parts.protocol);

      if (!this._parts.hostname || this.is('IP')) {
        this._parts.hostname = v;
      } else {
        var replace = new RegExp(escapeRegEx(this.domain()) + '$');
        this._parts.hostname = this._parts.hostname.replace(replace, v);
      }

      this.build(!build);
      return this;
    }
  };
  p.tld = function(v, build) {
    if (this._parts.urn) {
      return v === undefined ? '' : this;
    }

    if (typeof v === 'boolean') {
      build = v;
      v = undefined;
    }

    // return "org" from "www.example.org"
    if (v === undefined) {
      if (!this._parts.hostname || this.is('IP')) {
        return '';
      }

      var pos = this._parts.hostname.lastIndexOf('.');
      var tld = this._parts.hostname.substring(pos + 1);

      if (build !== true && SLD && SLD.list[tld.toLowerCase()]) {
        return SLD.get(this._parts.hostname) || tld;
      }

      return tld;
    } else {
      var replace;

      if (!v) {
        throw new TypeError('cannot set TLD empty');
      } else if (v.match(/[^a-zA-Z0-9-]/)) {
        if (SLD && SLD.is(v)) {
          replace = new RegExp(escapeRegEx(this.tld()) + '$');
          this._parts.hostname = this._parts.hostname.replace(replace, v);
        } else {
          throw new TypeError('TLD "' + v + '" contains characters other than [A-Z0-9]');
        }
      } else if (!this._parts.hostname || this.is('IP')) {
        throw new ReferenceError('cannot set TLD on non-domain host');
      } else {
        replace = new RegExp(escapeRegEx(this.tld()) + '$');
        this._parts.hostname = this._parts.hostname.replace(replace, v);
      }

      this.build(!build);
      return this;
    }
  };
  p.directory = function(v, build) {
    if (this._parts.urn) {
      return v === undefined ? '' : this;
    }

    if (v === undefined || v === true) {
      if (!this._parts.path && !this._parts.hostname) {
        return '';
      }

      if (this._parts.path === '/') {
        return '/';
      }

      var end = this._parts.path.length - this.filename().length - 1;
      var res = this._parts.path.substring(0, end) || (this._parts.hostname ? '/' : '');

      return v ? URI.decodePath(res) : res;

    } else {
      var e = this._parts.path.length - this.filename().length;
      var directory = this._parts.path.substring(0, e);
      var replace = new RegExp('^' + escapeRegEx(directory));

      // fully qualifier directories begin with a slash
      if (!this.is('relative')) {
        if (!v) {
          v = '/';
        }

        if (v.charAt(0) !== '/') {
          v = '/' + v;
        }
      }

      // directories always end with a slash
      if (v && v.charAt(v.length - 1) !== '/') {
        v += '/';
      }

      v = URI.recodePath(v);
      this._parts.path = this._parts.path.replace(replace, v);
      this.build(!build);
      return this;
    }
  };
  p.filename = function(v, build) {
    if (this._parts.urn) {
      return v === undefined ? '' : this;
    }

    if (typeof v !== 'string') {
      if (!this._parts.path || this._parts.path === '/') {
        return '';
      }

      var pos = this._parts.path.lastIndexOf('/');
      var res = this._parts.path.substring(pos+1);

      return v ? URI.decodePathSegment(res) : res;
    } else {
      var mutatedDirectory = false;

      if (v.charAt(0) === '/') {
        v = v.substring(1);
      }

      if (v.match(/\.?\//)) {
        mutatedDirectory = true;
      }

      var replace = new RegExp(escapeRegEx(this.filename()) + '$');
      v = URI.recodePath(v);
      this._parts.path = this._parts.path.replace(replace, v);

      if (mutatedDirectory) {
        this.normalizePath(build);
      } else {
        this.build(!build);
      }

      return this;
    }
  };
  p.suffix = function(v, build) {
    if (this._parts.urn) {
      return v === undefined ? '' : this;
    }

    if (v === undefined || v === true) {
      if (!this._parts.path || this._parts.path === '/') {
        return '';
      }

      var filename = this.filename();
      var pos = filename.lastIndexOf('.');
      var s, res;

      if (pos === -1) {
        return '';
      }

      // suffix may only contain alnum characters (yup, I made this up.)
      s = filename.substring(pos+1);
      res = (/^[a-z0-9%]+$/i).test(s) ? s : '';
      return v ? URI.decodePathSegment(res) : res;
    } else {
      if (v.charAt(0) === '.') {
        v = v.substring(1);
      }

      var suffix = this.suffix();
      var replace;

      if (!suffix) {
        if (!v) {
          return this;
        }

        this._parts.path += '.' + URI.recodePath(v);
      } else if (!v) {
        replace = new RegExp(escapeRegEx('.' + suffix) + '$');
      } else {
        replace = new RegExp(escapeRegEx(suffix) + '$');
      }

      if (replace) {
        v = URI.recodePath(v);
        this._parts.path = this._parts.path.replace(replace, v);
      }

      this.build(!build);
      return this;
    }
  };
  p.segment = function(segment, v, build) {
    var separator = this._parts.urn ? ':' : '/';
    var path = this.path();
    var absolute = path.substring(0, 1) === '/';
    var segments = path.split(separator);

    if (segment !== undefined && typeof segment !== 'number') {
      build = v;
      v = segment;
      segment = undefined;
    }

    if (segment !== undefined && typeof segment !== 'number') {
      throw new Error('Bad segment "' + segment + '", must be 0-based integer');
    }

    if (absolute) {
      segments.shift();
    }

    if (segment < 0) {
      // allow negative indexes to address from the end
      segment = Math.max(segments.length + segment, 0);
    }

    if (v === undefined) {
      /*jshint laxbreak: true */
      return segment === undefined
        ? segments
        : segments[segment];
      /*jshint laxbreak: false */
    } else if (segment === null || segments[segment] === undefined) {
      if (isArray(v)) {
        segments = [];
        // collapse empty elements within array
        for (var i=0, l=v.length; i < l; i++) {
          if (!v[i].length && (!segments.length || !segments[segments.length -1].length)) {
            continue;
          }

          if (segments.length && !segments[segments.length -1].length) {
            segments.pop();
          }

          segments.push(trimSlashes(v[i]));
        }
      } else if (v || typeof v === 'string') {
        v = trimSlashes(v);
        if (segments[segments.length -1] === '') {
          // empty trailing elements have to be overwritten
          // to prevent results such as /foo//bar
          segments[segments.length -1] = v;
        } else {
          segments.push(v);
        }
      }
    } else {
      if (v) {
        segments[segment] = trimSlashes(v);
      } else {
        segments.splice(segment, 1);
      }
    }

    if (absolute) {
      segments.unshift('');
    }

    return this.path(segments.join(separator), build);
  };
  p.segmentCoded = function(segment, v, build) {
    var segments, i, l;

    if (typeof segment !== 'number') {
      build = v;
      v = segment;
      segment = undefined;
    }

    if (v === undefined) {
      segments = this.segment(segment, v, build);
      if (!isArray(segments)) {
        segments = segments !== undefined ? URI.decode(segments) : undefined;
      } else {
        for (i = 0, l = segments.length; i < l; i++) {
          segments[i] = URI.decode(segments[i]);
        }
      }

      return segments;
    }

    if (!isArray(v)) {
      v = (typeof v === 'string' || v instanceof String) ? URI.encode(v) : v;
    } else {
      for (i = 0, l = v.length; i < l; i++) {
        v[i] = URI.encode(v[i]);
      }
    }

    return this.segment(segment, v, build);
  };

  // mutating query string
  var q = p.query;
  p.query = function(v, build) {
    if (v === true) {
      return URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
    } else if (typeof v === 'function') {
      var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
      var result = v.call(this, data);
      this._parts.query = URI.buildQuery(result || data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
      this.build(!build);
      return this;
    } else if (v !== undefined && typeof v !== 'string') {
      this._parts.query = URI.buildQuery(v, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
      this.build(!build);
      return this;
    } else {
      return q.call(this, v, build);
    }
  };
  p.setQuery = function(name, value, build) {
    var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);

    if (typeof name === 'string' || name instanceof String) {
      data[name] = value !== undefined ? value : null;
    } else if (typeof name === 'object') {
      for (var key in name) {
        if (hasOwn.call(name, key)) {
          data[key] = name[key];
        }
      }
    } else {
      throw new TypeError('URI.addQuery() accepts an object, string as the name parameter');
    }

    this._parts.query = URI.buildQuery(data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
    if (typeof name !== 'string') {
      build = value;
    }

    this.build(!build);
    return this;
  };
  p.addQuery = function(name, value, build) {
    var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
    URI.addQuery(data, name, value === undefined ? null : value);
    this._parts.query = URI.buildQuery(data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
    if (typeof name !== 'string') {
      build = value;
    }

    this.build(!build);
    return this;
  };
  p.removeQuery = function(name, value, build) {
    var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
    URI.removeQuery(data, name, value);
    this._parts.query = URI.buildQuery(data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
    if (typeof name !== 'string') {
      build = value;
    }

    this.build(!build);
    return this;
  };
  p.hasQuery = function(name, value, withinArray) {
    var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
    return URI.hasQuery(data, name, value, withinArray);
  };
  p.setSearch = p.setQuery;
  p.addSearch = p.addQuery;
  p.removeSearch = p.removeQuery;
  p.hasSearch = p.hasQuery;

  // sanitizing URLs
  p.normalize = function() {
    if (this._parts.urn) {
      return this
        .normalizeProtocol(false)
        .normalizePath(false)
        .normalizeQuery(false)
        .normalizeFragment(false)
        .build();
    }

    return this
      .normalizeProtocol(false)
      .normalizeHostname(false)
      .normalizePort(false)
      .normalizePath(false)
      .normalizeQuery(false)
      .normalizeFragment(false)
      .build();
  };
  p.normalizeProtocol = function(build) {
    if (typeof this._parts.protocol === 'string') {
      this._parts.protocol = this._parts.protocol.toLowerCase();
      this.build(!build);
    }

    return this;
  };
  p.normalizeHostname = function(build) {
    if (this._parts.hostname) {
      if (this.is('IDN') && punycode) {
        this._parts.hostname = punycode.toASCII(this._parts.hostname);
      } else if (this.is('IPv6') && IPv6) {
        this._parts.hostname = IPv6.best(this._parts.hostname);
      }

      this._parts.hostname = this._parts.hostname.toLowerCase();
      this.build(!build);
    }

    return this;
  };
  p.normalizePort = function(build) {
    // remove port of it's the protocol's default
    if (typeof this._parts.protocol === 'string' && this._parts.port === URI.defaultPorts[this._parts.protocol]) {
      this._parts.port = null;
      this.build(!build);
    }

    return this;
  };
  p.normalizePath = function(build) {
    var _path = this._parts.path;
    if (!_path) {
      return this;
    }

    if (this._parts.urn) {
      this._parts.path = URI.recodeUrnPath(this._parts.path);
      this.build(!build);
      return this;
    }

    if (this._parts.path === '/') {
      return this;
    }

    _path = URI.recodePath(_path);

    var _was_relative;
    var _leadingParents = '';
    var _parent, _pos;

    // handle relative paths
    if (_path.charAt(0) !== '/') {
      _was_relative = true;
      _path = '/' + _path;
    }

    // handle relative files (as opposed to directories)
    if (_path.slice(-3) === '/..' || _path.slice(-2) === '/.') {
      _path += '/';
    }

    // resolve simples
    _path = _path
      .replace(/(\/(\.\/)+)|(\/\.$)/g, '/')
      .replace(/\/{2,}/g, '/');

    // remember leading parents
    if (_was_relative) {
      _leadingParents = _path.substring(1).match(/^(\.\.\/)+/) || '';
      if (_leadingParents) {
        _leadingParents = _leadingParents[0];
      }
    }

    // resolve parents
    while (true) {
      _parent = _path.search(/\/\.\.(\/|$)/);
      if (_parent === -1) {
        // no more ../ to resolve
        break;
      } else if (_parent === 0) {
        // top level cannot be relative, skip it
        _path = _path.substring(3);
        continue;
      }

      _pos = _path.substring(0, _parent).lastIndexOf('/');
      if (_pos === -1) {
        _pos = _parent;
      }
      _path = _path.substring(0, _pos) + _path.substring(_parent + 3);
    }

    // revert to relative
    if (_was_relative && this.is('relative')) {
      _path = _leadingParents + _path.substring(1);
    }

    this._parts.path = _path;
    this.build(!build);
    return this;
  };
  p.normalizePathname = p.normalizePath;
  p.normalizeQuery = function(build) {
    if (typeof this._parts.query === 'string') {
      if (!this._parts.query.length) {
        this._parts.query = null;
      } else {
        this.query(URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace));
      }

      this.build(!build);
    }

    return this;
  };
  p.normalizeFragment = function(build) {
    if (!this._parts.fragment) {
      this._parts.fragment = null;
      this.build(!build);
    }

    return this;
  };
  p.normalizeSearch = p.normalizeQuery;
  p.normalizeHash = p.normalizeFragment;

  p.iso8859 = function() {
    // expect unicode input, iso8859 output
    var e = URI.encode;
    var d = URI.decode;

    URI.encode = escape;
    URI.decode = decodeURIComponent;
    try {
      this.normalize();
    } finally {
      URI.encode = e;
      URI.decode = d;
    }
    return this;
  };

  p.unicode = function() {
    // expect iso8859 input, unicode output
    var e = URI.encode;
    var d = URI.decode;

    URI.encode = strictEncodeURIComponent;
    URI.decode = unescape;
    try {
      this.normalize();
    } finally {
      URI.encode = e;
      URI.decode = d;
    }
    return this;
  };

  p.readable = function() {
    var uri = this.clone();
    // removing username, password, because they shouldn't be displayed according to RFC 3986
    uri.username('').password('').normalize();
    var t = '';
    if (uri._parts.protocol) {
      t += uri._parts.protocol + '://';
    }

    if (uri._parts.hostname) {
      if (uri.is('punycode') && punycode) {
        t += punycode.toUnicode(uri._parts.hostname);
        if (uri._parts.port) {
          t += ':' + uri._parts.port;
        }
      } else {
        t += uri.host();
      }
    }

    if (uri._parts.hostname && uri._parts.path && uri._parts.path.charAt(0) !== '/') {
      t += '/';
    }

    t += uri.path(true);
    if (uri._parts.query) {
      var q = '';
      for (var i = 0, qp = uri._parts.query.split('&'), l = qp.length; i < l; i++) {
        var kv = (qp[i] || '').split('=');
        q += '&' + URI.decodeQuery(kv[0], this._parts.escapeQuerySpace)
          .replace(/&/g, '%26');

        if (kv[1] !== undefined) {
          q += '=' + URI.decodeQuery(kv[1], this._parts.escapeQuerySpace)
            .replace(/&/g, '%26');
        }
      }
      t += '?' + q.substring(1);
    }

    t += URI.decodeQuery(uri.hash(), true);
    return t;
  };

  // resolving relative and absolute URLs
  p.absoluteTo = function(base) {
    var resolved = this.clone();
    var properties = ['protocol', 'username', 'password', 'hostname', 'port'];
    var basedir, i, p;

    if (this._parts.urn) {
      throw new Error('URNs do not have any generally defined hierarchical components');
    }

    if (!(base instanceof URI)) {
      base = new URI(base);
    }

    if (resolved._parts.protocol) {
      // Directly returns even if this._parts.hostname is empty.
      return resolved;
    } else {
      resolved._parts.protocol = base._parts.protocol;
    }

    if (this._parts.hostname) {
      return resolved;
    }

    for (i = 0; (p = properties[i]); i++) {
      resolved._parts[p] = base._parts[p];
    }

    if (!resolved._parts.path) {
      resolved._parts.path = base._parts.path;
      if (!resolved._parts.query) {
        resolved._parts.query = base._parts.query;
      }
    } else {
      if (resolved._parts.path.substring(-2) === '..') {
        resolved._parts.path += '/';
      }

      if (resolved.path().charAt(0) !== '/') {
        basedir = base.directory();
        basedir = basedir ? basedir : base.path().indexOf('/') === 0 ? '/' : '';
        resolved._parts.path = (basedir ? (basedir + '/') : '') + resolved._parts.path;
        resolved.normalizePath();
      }
    }

    resolved.build();
    return resolved;
  };
  p.relativeTo = function(base) {
    var relative = this.clone().normalize();
    var relativeParts, baseParts, common, relativePath, basePath;

    if (relative._parts.urn) {
      throw new Error('URNs do not have any generally defined hierarchical components');
    }

    base = new URI(base).normalize();
    relativeParts = relative._parts;
    baseParts = base._parts;
    relativePath = relative.path();
    basePath = base.path();

    if (relativePath.charAt(0) !== '/') {
      throw new Error('URI is already relative');
    }

    if (basePath.charAt(0) !== '/') {
      throw new Error('Cannot calculate a URI relative to another relative URI');
    }

    if (relativeParts.protocol === baseParts.protocol) {
      relativeParts.protocol = null;
    }

    if (relativeParts.username !== baseParts.username || relativeParts.password !== baseParts.password) {
      return relative.build();
    }

    if (relativeParts.protocol !== null || relativeParts.username !== null || relativeParts.password !== null) {
      return relative.build();
    }

    if (relativeParts.hostname === baseParts.hostname && relativeParts.port === baseParts.port) {
      relativeParts.hostname = null;
      relativeParts.port = null;
    } else {
      return relative.build();
    }

    if (relativePath === basePath) {
      relativeParts.path = '';
      return relative.build();
    }

    // determine common sub path
    common = URI.commonPath(relativePath, basePath);

    // If the paths have nothing in common, return a relative URL with the absolute path.
    if (!common) {
      return relative.build();
    }

    var parents = baseParts.path
      .substring(common.length)
      .replace(/[^\/]*$/, '')
      .replace(/.*?\//g, '../');

    relativeParts.path = (parents + relativeParts.path.substring(common.length)) || './';

    return relative.build();
  };

  // comparing URIs
  p.equals = function(uri) {
    var one = this.clone();
    var two = new URI(uri);
    var one_map = {};
    var two_map = {};
    var checked = {};
    var one_query, two_query, key;

    one.normalize();
    two.normalize();

    // exact match
    if (one.toString() === two.toString()) {
      return true;
    }

    // extract query string
    one_query = one.query();
    two_query = two.query();
    one.query('');
    two.query('');

    // definitely not equal if not even non-query parts match
    if (one.toString() !== two.toString()) {
      return false;
    }

    // query parameters have the same length, even if they're permuted
    if (one_query.length !== two_query.length) {
      return false;
    }

    one_map = URI.parseQuery(one_query, this._parts.escapeQuerySpace);
    two_map = URI.parseQuery(two_query, this._parts.escapeQuerySpace);

    for (key in one_map) {
      if (hasOwn.call(one_map, key)) {
        if (!isArray(one_map[key])) {
          if (one_map[key] !== two_map[key]) {
            return false;
          }
        } else if (!arraysEqual(one_map[key], two_map[key])) {
          return false;
        }

        checked[key] = true;
      }
    }

    for (key in two_map) {
      if (hasOwn.call(two_map, key)) {
        if (!checked[key]) {
          // two contains a parameter not present in one
          return false;
        }
      }
    }

    return true;
  };

  // state
  p.preventInvalidHostname = function(v) {
    this._parts.preventInvalidHostname = !!v;
    return this;
  };

  p.duplicateQueryParameters = function(v) {
    this._parts.duplicateQueryParameters = !!v;
    return this;
  };

  p.escapeQuerySpace = function(v) {
    this._parts.escapeQuerySpace = !!v;
    return this;
  };

  return URI;
}));


/***/ }),

/***/ "../../../node_modules/url-toolkit/src/url-toolkit.js":
/*!*****************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/node_modules/url-toolkit/src/url-toolkit.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// see https://tools.ietf.org/html/rfc1808

(function (root) {
  var URL_REGEX =
    /^((?:[a-zA-Z0-9+\-.]+:)?)(\/\/[^\/?#]*)?((?:[^\/?#]*\/)*[^;?#]*)?(;[^?#]*)?(\?[^#]*)?(#[^]*)?$/;
  var FIRST_SEGMENT_REGEX = /^([^\/?#]*)([^]*)$/;
  var SLASH_DOT_REGEX = /(?:\/|^)\.(?=\/)/g;
  var SLASH_DOT_DOT_REGEX = /(?:\/|^)\.\.\/(?!\.\.\/)[^\/]*(?=\/)/g;

  var URLToolkit = {
    // If opts.alwaysNormalize is true then the path will always be normalized even when it starts with / or //
    // E.g
    // With opts.alwaysNormalize = false (default, spec compliant)
    // http://a.com/b/cd + /e/f/../g => http://a.com/e/f/../g
    // With opts.alwaysNormalize = true (not spec compliant)
    // http://a.com/b/cd + /e/f/../g => http://a.com/e/g
    buildAbsoluteURL: function (baseURL, relativeURL, opts) {
      opts = opts || {};
      // remove any remaining space and CRLF
      baseURL = baseURL.trim();
      relativeURL = relativeURL.trim();
      if (!relativeURL) {
        // 2a) If the embedded URL is entirely empty, it inherits the
        // entire base URL (i.e., is set equal to the base URL)
        // and we are done.
        if (!opts.alwaysNormalize) {
          return baseURL;
        }
        var basePartsForNormalise = URLToolkit.parseURL(baseURL);
        if (!basePartsForNormalise) {
          throw new Error('Error trying to parse base URL.');
        }
        basePartsForNormalise.path = URLToolkit.normalizePath(
          basePartsForNormalise.path
        );
        return URLToolkit.buildURLFromParts(basePartsForNormalise);
      }
      var relativeParts = URLToolkit.parseURL(relativeURL);
      if (!relativeParts) {
        throw new Error('Error trying to parse relative URL.');
      }
      if (relativeParts.scheme) {
        // 2b) If the embedded URL starts with a scheme name, it is
        // interpreted as an absolute URL and we are done.
        if (!opts.alwaysNormalize) {
          return relativeURL;
        }
        relativeParts.path = URLToolkit.normalizePath(relativeParts.path);
        return URLToolkit.buildURLFromParts(relativeParts);
      }
      var baseParts = URLToolkit.parseURL(baseURL);
      if (!baseParts) {
        throw new Error('Error trying to parse base URL.');
      }
      if (!baseParts.netLoc && baseParts.path && baseParts.path[0] !== '/') {
        // If netLoc missing and path doesn't start with '/', assume everthing before the first '/' is the netLoc
        // This causes 'example.com/a' to be handled as '//example.com/a' instead of '/example.com/a'
        var pathParts = FIRST_SEGMENT_REGEX.exec(baseParts.path);
        baseParts.netLoc = pathParts[1];
        baseParts.path = pathParts[2];
      }
      if (baseParts.netLoc && !baseParts.path) {
        baseParts.path = '/';
      }
      var builtParts = {
        // 2c) Otherwise, the embedded URL inherits the scheme of
        // the base URL.
        scheme: baseParts.scheme,
        netLoc: relativeParts.netLoc,
        path: null,
        params: relativeParts.params,
        query: relativeParts.query,
        fragment: relativeParts.fragment,
      };
      if (!relativeParts.netLoc) {
        // 3) If the embedded URL's <net_loc> is non-empty, we skip to
        // Step 7.  Otherwise, the embedded URL inherits the <net_loc>
        // (if any) of the base URL.
        builtParts.netLoc = baseParts.netLoc;
        // 4) If the embedded URL path is preceded by a slash "/", the
        // path is not relative and we skip to Step 7.
        if (relativeParts.path[0] !== '/') {
          if (!relativeParts.path) {
            // 5) If the embedded URL path is empty (and not preceded by a
            // slash), then the embedded URL inherits the base URL path
            builtParts.path = baseParts.path;
            // 5a) if the embedded URL's <params> is non-empty, we skip to
            // step 7; otherwise, it inherits the <params> of the base
            // URL (if any) and
            if (!relativeParts.params) {
              builtParts.params = baseParts.params;
              // 5b) if the embedded URL's <query> is non-empty, we skip to
              // step 7; otherwise, it inherits the <query> of the base
              // URL (if any) and we skip to step 7.
              if (!relativeParts.query) {
                builtParts.query = baseParts.query;
              }
            }
          } else {
            // 6) The last segment of the base URL's path (anything
            // following the rightmost slash "/", or the entire path if no
            // slash is present) is removed and the embedded URL's path is
            // appended in its place.
            var baseURLPath = baseParts.path;
            var newPath =
              baseURLPath.substring(0, baseURLPath.lastIndexOf('/') + 1) +
              relativeParts.path;
            builtParts.path = URLToolkit.normalizePath(newPath);
          }
        }
      }
      if (builtParts.path === null) {
        builtParts.path = opts.alwaysNormalize
          ? URLToolkit.normalizePath(relativeParts.path)
          : relativeParts.path;
      }
      return URLToolkit.buildURLFromParts(builtParts);
    },
    parseURL: function (url) {
      var parts = URL_REGEX.exec(url);
      if (!parts) {
        return null;
      }
      return {
        scheme: parts[1] || '',
        netLoc: parts[2] || '',
        path: parts[3] || '',
        params: parts[4] || '',
        query: parts[5] || '',
        fragment: parts[6] || '',
      };
    },
    normalizePath: function (path) {
      // The following operations are
      // then applied, in order, to the new path:
      // 6a) All occurrences of "./", where "." is a complete path
      // segment, are removed.
      // 6b) If the path ends with "." as a complete path segment,
      // that "." is removed.
      path = path.split('').reverse().join('').replace(SLASH_DOT_REGEX, '');
      // 6c) All occurrences of "<segment>/../", where <segment> is a
      // complete path segment not equal to "..", are removed.
      // Removal of these path segments is performed iteratively,
      // removing the leftmost matching pattern on each iteration,
      // until no matching pattern remains.
      // 6d) If the path ends with "<segment>/..", where <segment> is a
      // complete path segment not equal to "..", that
      // "<segment>/.." is removed.
      while (
        path.length !== (path = path.replace(SLASH_DOT_DOT_REGEX, '')).length
      ) {}
      return path.split('').reverse().join('');
    },
    buildURLFromParts: function (parts) {
      return (
        parts.scheme +
        parts.netLoc +
        parts.path +
        parts.params +
        parts.query +
        parts.fragment
      );
    },
  };

  if (true)
    module.exports = URLToolkit;
  else {}
})(this);


/***/ }),

/***/ "../../../node_modules/uuid/index.js":
/*!************************************************************!*\
  !*** /home/omar/Desktop/hivejs/node_modules/uuid/index.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var v1 = __webpack_require__(/*! ./v1 */ "../../../node_modules/uuid/v1.js");
var v4 = __webpack_require__(/*! ./v4 */ "../../../node_modules/uuid/v4.js");

var uuid = v4;
uuid.v1 = v1;
uuid.v4 = v4;

module.exports = uuid;


/***/ }),

/***/ "../../../node_modules/uuid/lib/bytesToUuid.js":
/*!**********************************************************************!*\
  !*** /home/omar/Desktop/hivejs/node_modules/uuid/lib/bytesToUuid.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
var byteToHex = [];
for (var i = 0; i < 256; ++i) {
  byteToHex[i] = (i + 0x100).toString(16).substr(1);
}

function bytesToUuid(buf, offset) {
  var i = offset || 0;
  var bth = byteToHex;
  // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4
  return ([bth[buf[i++]], bth[buf[i++]], 
	bth[buf[i++]], bth[buf[i++]], '-',
	bth[buf[i++]], bth[buf[i++]], '-',
	bth[buf[i++]], bth[buf[i++]], '-',
	bth[buf[i++]], bth[buf[i++]], '-',
	bth[buf[i++]], bth[buf[i++]],
	bth[buf[i++]], bth[buf[i++]],
	bth[buf[i++]], bth[buf[i++]]]).join('');
}

module.exports = bytesToUuid;


/***/ }),

/***/ "../../../node_modules/uuid/lib/rng-browser.js":
/*!**********************************************************************!*\
  !*** /home/omar/Desktop/hivejs/node_modules/uuid/lib/rng-browser.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// Unique ID creation requires a high quality random # generator.  In the
// browser this is a little complicated due to unknown quality of Math.random()
// and inconsistent support for the `crypto` API.  We do the best we can via
// feature-detection

// getRandomValues needs to be invoked in a context where "this" is a Crypto
// implementation. Also, find the complete implementation of crypto on IE11.
var getRandomValues = (typeof(crypto) != 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto)) ||
                      (typeof(msCrypto) != 'undefined' && typeof window.msCrypto.getRandomValues == 'function' && msCrypto.getRandomValues.bind(msCrypto));

if (getRandomValues) {
  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto
  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef

  module.exports = function whatwgRNG() {
    getRandomValues(rnds8);
    return rnds8;
  };
} else {
  // Math.random()-based (RNG)
  //
  // If all else fails, use Math.random().  It's fast, but is of unspecified
  // quality.
  var rnds = new Array(16);

  module.exports = function mathRNG() {
    for (var i = 0, r; i < 16; i++) {
      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;
      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
    }

    return rnds;
  };
}


/***/ }),

/***/ "../../../node_modules/uuid/v1.js":
/*!*********************************************************!*\
  !*** /home/omar/Desktop/hivejs/node_modules/uuid/v1.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var rng = __webpack_require__(/*! ./lib/rng */ "../../../node_modules/uuid/lib/rng-browser.js");
var bytesToUuid = __webpack_require__(/*! ./lib/bytesToUuid */ "../../../node_modules/uuid/lib/bytesToUuid.js");

// **`v1()` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html

var _nodeId;
var _clockseq;

// Previous uuid creation time
var _lastMSecs = 0;
var _lastNSecs = 0;

// See https://github.com/broofa/node-uuid for API details
function v1(options, buf, offset) {
  var i = buf && offset || 0;
  var b = buf || [];

  options = options || {};
  var node = options.node || _nodeId;
  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;

  // node and clockseq need to be initialized to random values if they're not
  // specified.  We do this lazily to minimize issues related to insufficient
  // system entropy.  See #189
  if (node == null || clockseq == null) {
    var seedBytes = rng();
    if (node == null) {
      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
      node = _nodeId = [
        seedBytes[0] | 0x01,
        seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]
      ];
    }
    if (clockseq == null) {
      // Per 4.2.2, randomize (14 bit) clockseq
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
    }
  }

  // UUID timestamps are 100 nano-second units since the Gregorian epoch,
  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.
  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();

  // Per 4.2.1.2, use count of uuid's generated during the current clock
  // cycle to simulate higher resolution clock
  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;

  // Time since last uuid creation (in msecs)
  var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;

  // Per 4.2.1.2, Bump clockseq on clock regression
  if (dt < 0 && options.clockseq === undefined) {
    clockseq = clockseq + 1 & 0x3fff;
  }

  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
  // time interval
  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
    nsecs = 0;
  }

  // Per 4.2.1.2 Throw error if too many uuids are requested
  if (nsecs >= 10000) {
    throw new Error('uuid.v1(): Can\'t create more than 10M uuids/sec');
  }

  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq;

  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch
  msecs += 12219292800000;

  // `time_low`
  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
  b[i++] = tl >>> 24 & 0xff;
  b[i++] = tl >>> 16 & 0xff;
  b[i++] = tl >>> 8 & 0xff;
  b[i++] = tl & 0xff;

  // `time_mid`
  var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;
  b[i++] = tmh >>> 8 & 0xff;
  b[i++] = tmh & 0xff;

  // `time_high_and_version`
  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version
  b[i++] = tmh >>> 16 & 0xff;

  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)
  b[i++] = clockseq >>> 8 | 0x80;

  // `clock_seq_low`
  b[i++] = clockseq & 0xff;

  // `node`
  for (var n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }

  return buf ? buf : bytesToUuid(b);
}

module.exports = v1;


/***/ }),

/***/ "../../../node_modules/uuid/v4.js":
/*!*********************************************************!*\
  !*** /home/omar/Desktop/hivejs/node_modules/uuid/v4.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var rng = __webpack_require__(/*! ./lib/rng */ "../../../node_modules/uuid/lib/rng-browser.js");
var bytesToUuid = __webpack_require__(/*! ./lib/bytesToUuid */ "../../../node_modules/uuid/lib/bytesToUuid.js");

function v4(options, buf, offset) {
  var i = buf && offset || 0;

  if (typeof(options) == 'string') {
    buf = options === 'binary' ? new Array(16) : null;
    options = null;
  }
  options = options || {};

  var rnds = options.random || (options.rng || rng)();

  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
  rnds[6] = (rnds[6] & 0x0f) | 0x40;
  rnds[8] = (rnds[8] & 0x3f) | 0x80;

  // Copy bytes to buffer, if provided
  if (buf) {
    for (var ii = 0; ii < 16; ++ii) {
      buf[i + ii] = rnds[ii];
    }
  }

  return buf || bytesToUuid(rnds);
}

module.exports = v4;


/***/ }),

/***/ "../../../node_modules/weak-map/weak-map.js":
/*!*******************************************************************!*\
  !*** /home/omar/Desktop/hivejs/node_modules/weak-map/weak-map.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// Copyright (C) 2011 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Install a leaky WeakMap emulation on platforms that
 * don't provide a built-in one.
 *
 * <p>Assumes that an ES5 platform where, if {@code WeakMap} is
 * already present, then it conforms to the anticipated ES6
 * specification. To run this file on an ES5 or almost ES5
 * implementation where the {@code WeakMap} specification does not
 * quite conform, run <code>repairES5.js</code> first.
 *
 * <p>Even though WeakMapModule is not global, the linter thinks it
 * is, which is why it is in the overrides list below.
 *
 * <p>NOTE: Before using this WeakMap emulation in a non-SES
 * environment, see the note below about hiddenRecord.
 *
 * @author Mark S. Miller
 * @requires crypto, ArrayBuffer, Uint8Array, navigator, console
 * @overrides WeakMap, ses, Proxy
 * @overrides WeakMapModule
 */

/**
 * This {@code WeakMap} emulation is observably equivalent to the
 * ES-Harmony WeakMap, but with leakier garbage collection properties.
 *
 * <p>As with true WeakMaps, in this emulation, a key does not
 * retain maps indexed by that key and (crucially) a map does not
 * retain the keys it indexes. A map by itself also does not retain
 * the values associated with that map.
 *
 * <p>However, the values associated with a key in some map are
 * retained so long as that key is retained and those associations are
 * not overridden. For example, when used to support membranes, all
 * values exported from a given membrane will live for the lifetime
 * they would have had in the absence of an interposed membrane. Even
 * when the membrane is revoked, all objects that would have been
 * reachable in the absence of revocation will still be reachable, as
 * far as the GC can tell, even though they will no longer be relevant
 * to ongoing computation.
 *
 * <p>The API implemented here is approximately the API as implemented
 * in FF6.0a1 and agreed to by MarkM, Andreas Gal, and Dave Herman,
 * rather than the offially approved proposal page. TODO(erights):
 * upgrade the ecmascript WeakMap proposal page to explain this API
 * change and present to EcmaScript committee for their approval.
 *
 * <p>The first difference between the emulation here and that in
 * FF6.0a1 is the presence of non enumerable {@code get___, has___,
 * set___, and delete___} methods on WeakMap instances to represent
 * what would be the hidden internal properties of a primitive
 * implementation. Whereas the FF6.0a1 WeakMap.prototype methods
 * require their {@code this} to be a genuine WeakMap instance (i.e.,
 * an object of {@code [[Class]]} "WeakMap}), since there is nothing
 * unforgeable about the pseudo-internal method names used here,
 * nothing prevents these emulated prototype methods from being
 * applied to non-WeakMaps with pseudo-internal methods of the same
 * names.
 *
 * <p>Another difference is that our emulated {@code
 * WeakMap.prototype} is not itself a WeakMap. A problem with the
 * current FF6.0a1 API is that WeakMap.prototype is itself a WeakMap
 * providing ambient mutability and an ambient communications
 * channel. Thus, if a WeakMap is already present and has this
 * problem, repairES5.js wraps it in a safe wrappper in order to
 * prevent access to this channel. (See
 * PATCH_MUTABLE_FROZEN_WEAKMAP_PROTO in repairES5.js).
 */

/**
 * If this is a full <a href=
 * "http://code.google.com/p/es-lab/wiki/SecureableES5"
 * >secureable ES5</a> platform and the ES-Harmony {@code WeakMap} is
 * absent, install an approximate emulation.
 *
 * <p>If WeakMap is present but cannot store some objects, use our approximate
 * emulation as a wrapper.
 *
 * <p>If this is almost a secureable ES5 platform, then WeakMap.js
 * should be run after repairES5.js.
 *
 * <p>See {@code WeakMap} for documentation of the garbage collection
 * properties of this WeakMap emulation.
 */
(function WeakMapModule() {
  "use strict";

  if (typeof ses !== 'undefined' && ses.ok && !ses.ok()) {
    // already too broken, so give up
    return;
  }

  /**
   * In some cases (current Firefox), we must make a choice betweeen a
   * WeakMap which is capable of using all varieties of host objects as
   * keys and one which is capable of safely using proxies as keys. See
   * comments below about HostWeakMap and DoubleWeakMap for details.
   *
   * This function (which is a global, not exposed to guests) marks a
   * WeakMap as permitted to do what is necessary to index all host
   * objects, at the cost of making it unsafe for proxies.
   *
   * Do not apply this function to anything which is not a genuine
   * fresh WeakMap.
   */
  function weakMapPermitHostObjects(map) {
    // identity of function used as a secret -- good enough and cheap
    if (map.permitHostObjects___) {
      map.permitHostObjects___(weakMapPermitHostObjects);
    }
  }
  if (typeof ses !== 'undefined') {
    ses.weakMapPermitHostObjects = weakMapPermitHostObjects;
  }

  // IE 11 has no Proxy but has a broken WeakMap such that we need to patch
  // it using DoubleWeakMap; this flag tells DoubleWeakMap so.
  var doubleWeakMapCheckSilentFailure = false;

  // Check if there is already a good-enough WeakMap implementation, and if so
  // exit without replacing it.
  if (typeof WeakMap === 'function') {
    var HostWeakMap = WeakMap;
    // There is a WeakMap -- is it good enough?
    if (typeof navigator !== 'undefined' &&
        /Firefox/.test(navigator.userAgent)) {
      // We're now *assuming not*, because as of this writing (2013-05-06)
      // Firefox's WeakMaps have a miscellany of objects they won't accept, and
      // we don't want to make an exhaustive list, and testing for just one
      // will be a problem if that one is fixed alone (as they did for Event).

      // If there is a platform that we *can* reliably test on, here's how to
      // do it:
      //  var problematic = ... ;
      //  var testHostMap = new HostWeakMap();
      //  try {
      //    testHostMap.set(problematic, 1);  // Firefox 20 will throw here
      //    if (testHostMap.get(problematic) === 1) {
      //      return;
      //    }
      //  } catch (e) {}

    } else {
      // IE 11 bug: WeakMaps silently fail to store frozen objects.
      var testMap = new HostWeakMap();
      var testObject = Object.freeze({});
      testMap.set(testObject, 1);
      if (testMap.get(testObject) !== 1) {
        doubleWeakMapCheckSilentFailure = true;
        // Fall through to installing our WeakMap.
      } else {
        module.exports = WeakMap;
        return;
      }
    }
  }

  var hop = Object.prototype.hasOwnProperty;
  var gopn = Object.getOwnPropertyNames;
  var defProp = Object.defineProperty;
  var isExtensible = Object.isExtensible;

  /**
   * Security depends on HIDDEN_NAME being both <i>unguessable</i> and
   * <i>undiscoverable</i> by untrusted code.
   *
   * <p>Given the known weaknesses of Math.random() on existing
   * browsers, it does not generate unguessability we can be confident
   * of.
   *
   * <p>It is the monkey patching logic in this file that is intended
   * to ensure undiscoverability. The basic idea is that there are
   * three fundamental means of discovering properties of an object:
   * The for/in loop, Object.keys(), and Object.getOwnPropertyNames(),
   * as well as some proposed ES6 extensions that appear on our
   * whitelist. The first two only discover enumerable properties, and
   * we only use HIDDEN_NAME to name a non-enumerable property, so the
   * only remaining threat should be getOwnPropertyNames and some
   * proposed ES6 extensions that appear on our whitelist. We monkey
   * patch them to remove HIDDEN_NAME from the list of properties they
   * returns.
   *
   * <p>TODO(erights): On a platform with built-in Proxies, proxies
   * could be used to trap and thereby discover the HIDDEN_NAME, so we
   * need to monkey patch Proxy.create, Proxy.createFunction, etc, in
   * order to wrap the provided handler with the real handler which
   * filters out all traps using HIDDEN_NAME.
   *
   * <p>TODO(erights): Revisit Mike Stay's suggestion that we use an
   * encapsulated function at a not-necessarily-secret name, which
   * uses the Stiegler shared-state rights amplification pattern to
   * reveal the associated value only to the WeakMap in which this key
   * is associated with that value. Since only the key retains the
   * function, the function can also remember the key without causing
   * leakage of the key, so this doesn't violate our general gc
   * goals. In addition, because the name need not be a guarded
   * secret, we could efficiently handle cross-frame frozen keys.
   */
  var HIDDEN_NAME_PREFIX = 'weakmap:';
  var HIDDEN_NAME = HIDDEN_NAME_PREFIX + 'ident:' + Math.random() + '___';

  if (typeof crypto !== 'undefined' &&
      typeof crypto.getRandomValues === 'function' &&
      typeof ArrayBuffer === 'function' &&
      typeof Uint8Array === 'function') {
    var ab = new ArrayBuffer(25);
    var u8s = new Uint8Array(ab);
    crypto.getRandomValues(u8s);
    HIDDEN_NAME = HIDDEN_NAME_PREFIX + 'rand:' +
      Array.prototype.map.call(u8s, function(u8) {
        return (u8 % 36).toString(36);
      }).join('') + '___';
  }

  function isNotHiddenName(name) {
    return !(
        name.substr(0, HIDDEN_NAME_PREFIX.length) == HIDDEN_NAME_PREFIX &&
        name.substr(name.length - 3) === '___');
  }

  /**
   * Monkey patch getOwnPropertyNames to avoid revealing the
   * HIDDEN_NAME.
   *
   * <p>The ES5.1 spec requires each name to appear only once, but as
   * of this writing, this requirement is controversial for ES6, so we
   * made this code robust against this case. If the resulting extra
   * search turns out to be expensive, we can probably relax this once
   * ES6 is adequately supported on all major browsers, iff no browser
   * versions we support at that time have relaxed this constraint
   * without providing built-in ES6 WeakMaps.
   */
  defProp(Object, 'getOwnPropertyNames', {
    value: function fakeGetOwnPropertyNames(obj) {
      return gopn(obj).filter(isNotHiddenName);
    }
  });

  /**
   * getPropertyNames is not in ES5 but it is proposed for ES6 and
   * does appear in our whitelist, so we need to clean it too.
   */
  if ('getPropertyNames' in Object) {
    var originalGetPropertyNames = Object.getPropertyNames;
    defProp(Object, 'getPropertyNames', {
      value: function fakeGetPropertyNames(obj) {
        return originalGetPropertyNames(obj).filter(isNotHiddenName);
      }
    });
  }

  /**
   * <p>To treat objects as identity-keys with reasonable efficiency
   * on ES5 by itself (i.e., without any object-keyed collections), we
   * need to add a hidden property to such key objects when we
   * can. This raises several issues:
   * <ul>
   * <li>Arranging to add this property to objects before we lose the
   *     chance, and
   * <li>Hiding the existence of this new property from most
   *     JavaScript code.
   * <li>Preventing <i>certification theft</i>, where one object is
   *     created falsely claiming to be the key of an association
   *     actually keyed by another object.
   * <li>Preventing <i>value theft</i>, where untrusted code with
   *     access to a key object but not a weak map nevertheless
   *     obtains access to the value associated with that key in that
   *     weak map.
   * </ul>
   * We do so by
   * <ul>
   * <li>Making the name of the hidden property unguessable, so "[]"
   *     indexing, which we cannot intercept, cannot be used to access
   *     a property without knowing the name.
   * <li>Making the hidden property non-enumerable, so we need not
   *     worry about for-in loops or {@code Object.keys},
   * <li>monkey patching those reflective methods that would
   *     prevent extensions, to add this hidden property first,
   * <li>monkey patching those methods that would reveal this
   *     hidden property.
   * </ul>
   * Unfortunately, because of same-origin iframes, we cannot reliably
   * add this hidden property before an object becomes
   * non-extensible. Instead, if we encounter a non-extensible object
   * without a hidden record that we can detect (whether or not it has
   * a hidden record stored under a name secret to us), then we just
   * use the key object itself to represent its identity in a brute
   * force leaky map stored in the weak map, losing all the advantages
   * of weakness for these.
   */
  function getHiddenRecord(key) {
    if (key !== Object(key)) {
      throw new TypeError('Not an object: ' + key);
    }
    var hiddenRecord = key[HIDDEN_NAME];
    if (hiddenRecord && hiddenRecord.key === key) { return hiddenRecord; }
    if (!isExtensible(key)) {
      // Weak map must brute force, as explained in doc-comment above.
      return void 0;
    }

    // The hiddenRecord and the key point directly at each other, via
    // the "key" and HIDDEN_NAME properties respectively. The key
    // field is for quickly verifying that this hidden record is an
    // own property, not a hidden record from up the prototype chain.
    //
    // NOTE: Because this WeakMap emulation is meant only for systems like
    // SES where Object.prototype is frozen without any numeric
    // properties, it is ok to use an object literal for the hiddenRecord.
    // This has two advantages:
    // * It is much faster in a performance critical place
    // * It avoids relying on Object.create(null), which had been
    //   problematic on Chrome 28.0.1480.0. See
    //   https://code.google.com/p/google-caja/issues/detail?id=1687
    hiddenRecord = { key: key };

    // When using this WeakMap emulation on platforms where
    // Object.prototype might not be frozen and Object.create(null) is
    // reliable, use the following two commented out lines instead.
    // hiddenRecord = Object.create(null);
    // hiddenRecord.key = key;

    // Please contact us if you need this to work on platforms where
    // Object.prototype might not be frozen and
    // Object.create(null) might not be reliable.

    try {
      defProp(key, HIDDEN_NAME, {
        value: hiddenRecord,
        writable: false,
        enumerable: false,
        configurable: false
      });
      return hiddenRecord;
    } catch (error) {
      // Under some circumstances, isExtensible seems to misreport whether
      // the HIDDEN_NAME can be defined.
      // The circumstances have not been isolated, but at least affect
      // Node.js v0.10.26 on TravisCI / Linux, but not the same version of
      // Node.js on OS X.
      return void 0;
    }
  }

  /**
   * Monkey patch operations that would make their argument
   * non-extensible.
   *
   * <p>The monkey patched versions throw a TypeError if their
   * argument is not an object, so it should only be done to functions
   * that should throw a TypeError anyway if their argument is not an
   * object.
   */
  (function(){
    var oldFreeze = Object.freeze;
    defProp(Object, 'freeze', {
      value: function identifyingFreeze(obj) {
        getHiddenRecord(obj);
        return oldFreeze(obj);
      }
    });
    var oldSeal = Object.seal;
    defProp(Object, 'seal', {
      value: function identifyingSeal(obj) {
        getHiddenRecord(obj);
        return oldSeal(obj);
      }
    });
    var oldPreventExtensions = Object.preventExtensions;
    defProp(Object, 'preventExtensions', {
      value: function identifyingPreventExtensions(obj) {
        getHiddenRecord(obj);
        return oldPreventExtensions(obj);
      }
    });
  })();

  function constFunc(func) {
    func.prototype = null;
    return Object.freeze(func);
  }

  var calledAsFunctionWarningDone = false;
  function calledAsFunctionWarning() {
    // Future ES6 WeakMap is currently (2013-09-10) expected to reject WeakMap()
    // but we used to permit it and do it ourselves, so warn only.
    if (!calledAsFunctionWarningDone && typeof console !== 'undefined') {
      calledAsFunctionWarningDone = true;
      console.warn('WeakMap should be invoked as new WeakMap(), not ' +
          'WeakMap(). This will be an error in the future.');
    }
  }

  var nextId = 0;

  var OurWeakMap = function() {
    if (!(this instanceof OurWeakMap)) {  // approximate test for new ...()
      calledAsFunctionWarning();
    }

    // We are currently (12/25/2012) never encountering any prematurely
    // non-extensible keys.
    var keys = []; // brute force for prematurely non-extensible keys.
    var values = []; // brute force for corresponding values.
    var id = nextId++;

    function get___(key, opt_default) {
      var index;
      var hiddenRecord = getHiddenRecord(key);
      if (hiddenRecord) {
        return id in hiddenRecord ? hiddenRecord[id] : opt_default;
      } else {
        index = keys.indexOf(key);
        return index >= 0 ? values[index] : opt_default;
      }
    }

    function has___(key) {
      var hiddenRecord = getHiddenRecord(key);
      if (hiddenRecord) {
        return id in hiddenRecord;
      } else {
        return keys.indexOf(key) >= 0;
      }
    }

    function set___(key, value) {
      var index;
      var hiddenRecord = getHiddenRecord(key);
      if (hiddenRecord) {
        hiddenRecord[id] = value;
      } else {
        index = keys.indexOf(key);
        if (index >= 0) {
          values[index] = value;
        } else {
          // Since some browsers preemptively terminate slow turns but
          // then continue computing with presumably corrupted heap
          // state, we here defensively get keys.length first and then
          // use it to update both the values and keys arrays, keeping
          // them in sync.
          index = keys.length;
          values[index] = value;
          // If we crash here, values will be one longer than keys.
          keys[index] = key;
        }
      }
      return this;
    }

    function delete___(key) {
      var hiddenRecord = getHiddenRecord(key);
      var index, lastIndex;
      if (hiddenRecord) {
        return id in hiddenRecord && delete hiddenRecord[id];
      } else {
        index = keys.indexOf(key);
        if (index < 0) {
          return false;
        }
        // Since some browsers preemptively terminate slow turns but
        // then continue computing with potentially corrupted heap
        // state, we here defensively get keys.length first and then use
        // it to update both the keys and the values array, keeping
        // them in sync. We update the two with an order of assignments,
        // such that any prefix of these assignments will preserve the
        // key/value correspondence, either before or after the delete.
        // Note that this needs to work correctly when index === lastIndex.
        lastIndex = keys.length - 1;
        keys[index] = void 0;
        // If we crash here, there's a void 0 in the keys array, but
        // no operation will cause a "keys.indexOf(void 0)", since
        // getHiddenRecord(void 0) will always throw an error first.
        values[index] = values[lastIndex];
        // If we crash here, values[index] cannot be found here,
        // because keys[index] is void 0.
        keys[index] = keys[lastIndex];
        // If index === lastIndex and we crash here, then keys[index]
        // is still void 0, since the aliasing killed the previous key.
        keys.length = lastIndex;
        // If we crash here, keys will be one shorter than values.
        values.length = lastIndex;
        return true;
      }
    }

    return Object.create(OurWeakMap.prototype, {
      get___:    { value: constFunc(get___) },
      has___:    { value: constFunc(has___) },
      set___:    { value: constFunc(set___) },
      delete___: { value: constFunc(delete___) }
    });
  };

  OurWeakMap.prototype = Object.create(Object.prototype, {
    get: {
      /**
       * Return the value most recently associated with key, or
       * opt_default if none.
       */
      value: function get(key, opt_default) {
        return this.get___(key, opt_default);
      },
      writable: true,
      configurable: true
    },

    has: {
      /**
       * Is there a value associated with key in this WeakMap?
       */
      value: function has(key) {
        return this.has___(key);
      },
      writable: true,
      configurable: true
    },

    set: {
      /**
       * Associate value with key in this WeakMap, overwriting any
       * previous association if present.
       */
      value: function set(key, value) {
        return this.set___(key, value);
      },
      writable: true,
      configurable: true
    },

    'delete': {
      /**
       * Remove any association for key in this WeakMap, returning
       * whether there was one.
       *
       * <p>Note that the boolean return here does not work like the
       * {@code delete} operator. The {@code delete} operator returns
       * whether the deletion succeeds at bringing about a state in
       * which the deleted property is absent. The {@code delete}
       * operator therefore returns true if the property was already
       * absent, whereas this {@code delete} method returns false if
       * the association was already absent.
       */
      value: function remove(key) {
        return this.delete___(key);
      },
      writable: true,
      configurable: true
    }
  });

  if (typeof HostWeakMap === 'function') {
    (function() {
      // If we got here, then the platform has a WeakMap but we are concerned
      // that it may refuse to store some key types. Therefore, make a map
      // implementation which makes use of both as possible.

      // In this mode we are always using double maps, so we are not proxy-safe.
      // This combination does not occur in any known browser, but we had best
      // be safe.
      if (doubleWeakMapCheckSilentFailure && typeof Proxy !== 'undefined') {
        Proxy = undefined;
      }

      function DoubleWeakMap() {
        if (!(this instanceof OurWeakMap)) {  // approximate test for new ...()
          calledAsFunctionWarning();
        }

        // Preferable, truly weak map.
        var hmap = new HostWeakMap();

        // Our hidden-property-based pseudo-weak-map. Lazily initialized in the
        // 'set' implementation; thus we can avoid performing extra lookups if
        // we know all entries actually stored are entered in 'hmap'.
        var omap = undefined;

        // Hidden-property maps are not compatible with proxies because proxies
        // can observe the hidden name and either accidentally expose it or fail
        // to allow the hidden property to be set. Therefore, we do not allow
        // arbitrary WeakMaps to switch to using hidden properties, but only
        // those which need the ability, and unprivileged code is not allowed
        // to set the flag.
        //
        // (Except in doubleWeakMapCheckSilentFailure mode in which case we
        // disable proxies.)
        var enableSwitching = false;

        function dget(key, opt_default) {
          if (omap) {
            return hmap.has(key) ? hmap.get(key)
                : omap.get___(key, opt_default);
          } else {
            return hmap.get(key, opt_default);
          }
        }

        function dhas(key) {
          return hmap.has(key) || (omap ? omap.has___(key) : false);
        }

        var dset;
        if (doubleWeakMapCheckSilentFailure) {
          dset = function(key, value) {
            hmap.set(key, value);
            if (!hmap.has(key)) {
              if (!omap) { omap = new OurWeakMap(); }
              omap.set(key, value);
            }
            return this;
          };
        } else {
          dset = function(key, value) {
            if (enableSwitching) {
              try {
                hmap.set(key, value);
              } catch (e) {
                if (!omap) { omap = new OurWeakMap(); }
                omap.set___(key, value);
              }
            } else {
              hmap.set(key, value);
            }
            return this;
          };
        }

        function ddelete(key) {
          var result = !!hmap['delete'](key);
          if (omap) { return omap.delete___(key) || result; }
          return result;
        }

        return Object.create(OurWeakMap.prototype, {
          get___:    { value: constFunc(dget) },
          has___:    { value: constFunc(dhas) },
          set___:    { value: constFunc(dset) },
          delete___: { value: constFunc(ddelete) },
          permitHostObjects___: { value: constFunc(function(token) {
            if (token === weakMapPermitHostObjects) {
              enableSwitching = true;
            } else {
              throw new Error('bogus call to permitHostObjects___');
            }
          })}
        });
      }
      DoubleWeakMap.prototype = OurWeakMap.prototype;
      module.exports = DoubleWeakMap;

      // define .constructor to hide OurWeakMap ctor
      Object.defineProperty(WeakMap.prototype, 'constructor', {
        value: WeakMap,
        enumerable: false,  // as default .constructor is
        configurable: true,
        writable: true
      });
    })();
  } else {
    // There is no host WeakMap, so we must use the emulation.

    // Emulated WeakMaps are incompatible with native proxies (because proxies
    // can observe the hidden name), so we must disable Proxy usage (in
    // ArrayLike and Domado, currently).
    if (typeof Proxy !== 'undefined') {
      Proxy = undefined;
    }

    module.exports = OurWeakMap;
  }
})();


/***/ }),

/***/ "../../../node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "../../../protocol/build/index.json":
/*!***********************************************************!*\
  !*** /home/omar/Desktop/hivejs/protocol/build/index.json ***!
  \***********************************************************/
/*! exports provided: package, messages, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"package\":\"HiveMsgs\",\"messages\":[{\"name\":\"Chunk\",\"fields\":[{\"rule\":\"required\",\"type\":\"int32\",\"name\":\"transferId\",\"id\":1},{\"rule\":\"required\",\"type\":\"int32\",\"name\":\"totalSize\",\"id\":2},{\"rule\":\"required\",\"type\":\"int32\",\"name\":\"chunkSize\",\"id\":3},{\"rule\":\"required\",\"type\":\"bytes\",\"name\":\"data\",\"id\":4},{\"rule\":\"optional\",\"type\":\"string\",\"name\":\"headers\",\"id\":5}]},{\"name\":\"Haves\",\"fields\":[{\"rule\":\"repeated\",\"type\":\"Have\",\"name\":\"have\",\"id\":1}]},{\"name\":\"Have\",\"fields\":[{\"rule\":\"required\",\"type\":\"string\",\"name\":\"fragmentId\",\"id\":1},{\"rule\":\"required\",\"type\":\"int32\",\"name\":\"size\",\"id\":2},{\"rule\":\"required\",\"type\":\"int32\",\"name\":\"type\",\"id\":3},{\"rule\":\"required\",\"type\":\"int32\",\"name\":\"id\",\"id\":4},{\"rule\":\"required\",\"type\":\"QualityLevel\",\"name\":\"qualityLevel\",\"id\":5},{\"rule\":\"required\",\"type\":\"int32\",\"name\":\"duration\",\"id\":6},{\"rule\":\"required\",\"type\":\"float\",\"name\":\"uploadScore\",\"id\":7}]},{\"name\":\"Ping\",\"fields\":[{\"rule\":\"required\",\"type\":\"string\",\"name\":\"id\",\"id\":1},{\"rule\":\"required\",\"type\":\"uint64\",\"name\":\"startTs\",\"id\":2}]},{\"name\":\"Pong\",\"fields\":[{\"rule\":\"required\",\"type\":\"string\",\"name\":\"id\",\"id\":1},{\"rule\":\"required\",\"type\":\"bytes\",\"name\":\"data\",\"id\":2},{\"rule\":\"required\",\"type\":\"int32\",\"name\":\"dataSize\",\"id\":3},{\"rule\":\"required\",\"type\":\"uint64\",\"name\":\"startTs\",\"id\":4}]},{\"name\":\"Request\",\"fields\":[{\"rule\":\"required\",\"type\":\"string\",\"name\":\"fragmentId\",\"id\":1},{\"rule\":\"required\",\"type\":\"int32\",\"name\":\"transferId\",\"id\":2}]},{\"name\":\"DoNotHave\",\"fields\":[{\"rule\":\"required\",\"type\":\"int32\",\"name\":\"transferId\",\"id\":1}]},{\"name\":\"NoPartners\",\"fields\":[{\"rule\":\"required\",\"type\":\"int32\",\"name\":\"transferId\",\"id\":1}]},{\"name\":\"Cancel\",\"fields\":[{\"rule\":\"required\",\"type\":\"int32\",\"name\":\"transferId\",\"id\":1}]},{\"name\":\"Ack\",\"fields\":[{\"rule\":\"optional\",\"type\":\"int32\",\"name\":\"transferId\",\"id\":1}]},{\"name\":\"Close\",\"fields\":[{\"rule\":\"required\",\"type\":\"int32\",\"name\":\"type\",\"id\":1}]},{\"name\":\"StreamCharacteristics\",\"fields\":[{\"rule\":\"required\",\"type\":\"int32\",\"name\":\"streamState\",\"id\":1},{\"rule\":\"required\",\"type\":\"QualityLevel\",\"name\":\"qualityLevel\",\"id\":2},{\"rule\":\"required\",\"type\":\"int32\",\"name\":\"delta\",\"id\":3}]},{\"name\":\"OutPartnershipRequest\",\"fields\":[{\"rule\":\"required\",\"type\":\"string\",\"name\":\"guid\",\"id\":1},{\"rule\":\"required\",\"type\":\"string\",\"name\":\"contextId\",\"id\":2},{\"rule\":\"required\",\"type\":\"string\",\"name\":\"p2pProtocolVersion\",\"id\":3},{\"rule\":\"optional\",\"type\":\"int32\",\"name\":\"internalAs\",\"id\":4},{\"rule\":\"optional\",\"type\":\"int32\",\"name\":\"externalAs\",\"id\":5},{\"rule\":\"optional\",\"type\":\"string\",\"name\":\"publicIpString\",\"id\":6},{\"rule\":\"optional\",\"type\":\"string\",\"name\":\"privateIpString\",\"id\":7},{\"rule\":\"required\",\"type\":\"string\",\"name\":\"reportingGuid\",\"id\":8},{\"rule\":\"repeated\",\"type\":\"StreamCharacteristics\",\"name\":\"streamCharacteristics\",\"id\":9},{\"rule\":\"optional\",\"type\":\"bool\",\"name\":\"isVpn\",\"id\":10}]},{\"name\":\"OutPartnershipResponse\",\"fields\":[{\"rule\":\"required\",\"type\":\"int32\",\"name\":\"accept\",\"id\":1},{\"rule\":\"optional\",\"type\":\"int32\",\"name\":\"internalAs\",\"id\":2},{\"rule\":\"optional\",\"type\":\"int32\",\"name\":\"externalAs\",\"id\":3},{\"rule\":\"optional\",\"type\":\"string\",\"name\":\"publicIpString\",\"id\":4},{\"rule\":\"optional\",\"type\":\"string\",\"name\":\"privateIpString\",\"id\":5},{\"rule\":\"optional\",\"type\":\"string\",\"name\":\"reportingGuid\",\"id\":6},{\"rule\":\"repeated\",\"type\":\"StreamCharacteristics\",\"name\":\"streamCharacteristics\",\"id\":7},{\"rule\":\"optional\",\"type\":\"bool\",\"name\":\"isVpn\",\"id\":8}]},{\"name\":\"PeerInfoMessage\",\"fields\":[{\"rule\":\"required\",\"type\":\"string\",\"name\":\"guid\",\"id\":1},{\"rule\":\"optional\",\"type\":\"string\",\"name\":\"publicIpString\",\"id\":2},{\"rule\":\"optional\",\"type\":\"string\",\"name\":\"privateIpString\",\"id\":3},{\"rule\":\"optional\",\"type\":\"int32\",\"name\":\"internalAs\",\"id\":4},{\"rule\":\"optional\",\"type\":\"int32\",\"name\":\"externalAs\",\"id\":5},{\"rule\":\"repeated\",\"type\":\"StreamCharacteristics\",\"name\":\"streamCharacteristics\",\"id\":6}]},{\"name\":\"UDPHandshakeMessage\",\"fields\":[{\"rule\":\"required\",\"type\":\"string\",\"name\":\"uuid\",\"id\":1},{\"rule\":\"required\",\"type\":\"string\",\"name\":\"streamId\",\"id\":2},{\"rule\":\"required\",\"type\":\"float\",\"name\":\"udpScore\",\"id\":3},{\"rule\":\"required\",\"type\":\"bool\",\"name\":\"isLeader\",\"id\":4}]},{\"name\":\"UDPHandshakeResponse\",\"fields\":[{\"rule\":\"required\",\"type\":\"string\",\"name\":\"accept\",\"id\":1}]},{\"name\":\"UDPSwitchLeadershipRequest\",\"fields\":[{\"rule\":\"required\",\"type\":\"string\",\"name\":\"uuid\",\"id\":1},{\"rule\":\"required\",\"type\":\"float\",\"name\":\"udpScore\",\"id\":2}]},{\"name\":\"UDPSwitchLeadershipAck\",\"fields\":[{\"rule\":\"required\",\"type\":\"bool\",\"name\":\"ok\",\"id\":1}]},{\"name\":\"QualityLevelMessage\",\"fields\":[{\"rule\":\"required\",\"type\":\"string\",\"name\":\"guid\",\"id\":1},{\"rule\":\"required\",\"type\":\"QualityLevel\",\"name\":\"qualityLevel\",\"id\":2}]},{\"name\":\"QualityLevel\",\"fields\":[{\"rule\":\"required\",\"type\":\"string\",\"name\":\"id\",\"id\":1},{\"rule\":\"required\",\"type\":\"int32\",\"name\":\"bitrate\",\"id\":2}]}]}");

/***/ }),

/***/ "../../../protocol/services/common_types.js":
/*!*******************************************************************!*\
  !*** /home/omar/Desktop/hivejs/protocol/services/common_types.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

//
// Autogenerated by Thrift Compiler (0.9.3)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//

var Thrift = __webpack_require__(/*! @hivestreaming/thrift */ "../../../node_modules/@hivestreaming/thrift/src/thrift.js");

var StreamType = window.StreamType = {
    "1": "LIVE",
    LIVE: 1,
    "2": "VOD",
    VOD: 2,
};
var StreamProtocol = window.StreamProtocol = {
    "1": "DASH",
    DASH: 1,
    "2": "HDS",
    HDS: 2,
    "3": "HLS",
    HLS: 3,
    "4": "SS",
    SS: 4,
};
var ClientType = window.ClientType = {
    "1": "JAVA",
    JAVA: 1,
    "2": "STATS_ONLY",
    STATS_ONLY: 2,
    "3": "JS_DIRECT",
    JS_DIRECT: 3,
    "4": "JS_PROXY",
    JS_PROXY: 4,
};
var ContentType = window.ContentType = {
    "1": "AUDIO",
    AUDIO: 1,
    "2": "VIDEO",
    VIDEO: 2,
};
var EventId = window.EventId = function (args) {
    this.partnerId = null;
    this.customerId = null;
    this.contentId = null;
    this.tags = null;
    if (args) {
        if (args.partnerId !== undefined && args.partnerId !== null) {
            this.partnerId = args.partnerId;
        }
        if (args.customerId !== undefined && args.customerId !== null) {
            this.customerId = args.customerId;
        }
        if (args.contentId !== undefined && args.contentId !== null) {
            this.contentId = args.contentId;
        }
        if (args.tags !== undefined && args.tags !== null) {
            this.tags = Thrift.copyList(args.tags, [null]);
        }
    }
};
EventId.prototype = {};
EventId.prototype.read = function (input) {
    input.readStructBegin();
    while (true) {
        var ret = input.readFieldBegin();
        var fname = ret.fname;
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
            break;
        }
        switch (fid) {
            case 1:
                if (ftype == Thrift.Type.STRING) {
                    this.partnerId = input.readString().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 2:
                if (ftype == Thrift.Type.STRING) {
                    this.customerId = input.readString().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 3:
                if (ftype == Thrift.Type.STRING) {
                    this.contentId = input.readString().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 4:
                if (ftype == Thrift.Type.LIST) {
                    var _size0 = 0;
                    var _rtmp34;
                    this.tags = [];
                    var _etype3 = 0;
                    _rtmp34 = input.readListBegin();
                    _etype3 = _rtmp34.etype;
                    _size0 = _rtmp34.size;
                    for (var _i5 = 0; _i5 < _size0; ++_i5) {
                        var elem6 = null;
                        elem6 = input.readString().value;
                        this.tags.push(elem6);
                    }
                    input.readListEnd();
                } else {
                    input.skip(ftype);
                }
                break;
            default:
                input.skip(ftype);
        }
        input.readFieldEnd();
    }
    input.readStructEnd();
    return;
};

EventId.prototype.write = function (output) {
    output.writeStructBegin("EventId");
    if (this.partnerId !== null && this.partnerId !== undefined) {
        output.writeFieldBegin("partnerId", Thrift.Type.STRING, 1);
        output.writeString(this.partnerId);
        output.writeFieldEnd();
    }
    if (this.customerId !== null && this.customerId !== undefined) {
        output.writeFieldBegin("customerId", Thrift.Type.STRING, 2);
        output.writeString(this.customerId);
        output.writeFieldEnd();
    }
    if (this.contentId !== null && this.contentId !== undefined) {
        output.writeFieldBegin("contentId", Thrift.Type.STRING, 3);
        output.writeString(this.contentId);
        output.writeFieldEnd();
    }
    if (this.tags !== null && this.tags !== undefined) {
        output.writeFieldBegin("tags", Thrift.Type.LIST, 4);
        output.writeListBegin(Thrift.Type.STRING, this.tags.length);
        for (var iter7 in this.tags) {
            if (this.tags.hasOwnProperty(iter7)) {
                iter7 = this.tags[iter7];
                output.writeString(iter7);
            }
        }
        output.writeListEnd();
        output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
};

var SnapshotInfo = window.SnapshotInfo = function (args) {
    this.timestamp = null;
    this.apiServer = null;
    this.clientIp = null;
    if (args) {
        if (args.timestamp !== undefined && args.timestamp !== null) {
            this.timestamp = args.timestamp;
        }
        if (args.apiServer !== undefined && args.apiServer !== null) {
            this.apiServer = args.apiServer;
        }
        if (args.clientIp !== undefined && args.clientIp !== null) {
            this.clientIp = args.clientIp;
        }
    }
};
SnapshotInfo.prototype = {};
SnapshotInfo.prototype.read = function (input) {
    input.readStructBegin();
    while (true) {
        var ret = input.readFieldBegin();
        var fname = ret.fname;
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
            break;
        }
        switch (fid) {
            case 1:
                if (ftype == Thrift.Type.I64) {
                    this.timestamp = input.readI64().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 2:
                if (ftype == Thrift.Type.STRING) {
                    this.apiServer = input.readString().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 3:
                if (ftype == Thrift.Type.STRING) {
                    this.clientIp = input.readString().value;
                } else {
                    input.skip(ftype);
                }
                break;
            default:
                input.skip(ftype);
        }
        input.readFieldEnd();
    }
    input.readStructEnd();
    return;
};

SnapshotInfo.prototype.write = function (output) {
    output.writeStructBegin("SnapshotInfo");
    if (this.timestamp !== null && this.timestamp !== undefined) {
        output.writeFieldBegin("timestamp", Thrift.Type.I64, 1);
        output.writeI64(this.timestamp);
        output.writeFieldEnd();
    }
    if (this.apiServer !== null && this.apiServer !== undefined) {
        output.writeFieldBegin("apiServer", Thrift.Type.STRING, 2);
        output.writeString(this.apiServer);
        output.writeFieldEnd();
    }
    if (this.clientIp !== null && this.clientIp !== undefined) {
        output.writeFieldBegin("clientIp", Thrift.Type.STRING, 3);
        output.writeString(this.clientIp);
        output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
};

var TestInfo = window.TestInfo = function (args) {
    this.testId = null;
    if (args) {
        if (args.testId !== undefined && args.testId !== null) {
            this.testId = args.testId;
        }
    }
};
TestInfo.prototype = {};
TestInfo.prototype.read = function (input) {
    input.readStructBegin();
    while (true) {
        var ret = input.readFieldBegin();
        var fname = ret.fname;
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
            break;
        }
        switch (fid) {
            case 1:
                if (ftype == Thrift.Type.STRING) {
                    this.testId = input.readString().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 0:
                input.skip(ftype);
                break;
            default:
                input.skip(ftype);
        }
        input.readFieldEnd();
    }
    input.readStructEnd();
    return;
};

TestInfo.prototype.write = function (output) {
    output.writeStructBegin("TestInfo");
    if (this.testId !== null && this.testId !== undefined) {
        output.writeFieldBegin("testId", Thrift.Type.STRING, 1);
        output.writeString(this.testId);
        output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
};

var InetAddress = window.InetAddress = function (args) {
    this.address = null;
    this.port = null;
    if (args) {
        if (args.address !== undefined && args.address !== null) {
            this.address = args.address;
        }
        if (args.port !== undefined && args.port !== null) {
            this.port = args.port;
        }
    }
};
InetAddress.prototype = {};
InetAddress.prototype.read = function (input) {
    input.readStructBegin();
    while (true) {
        var ret = input.readFieldBegin();
        var fname = ret.fname;
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
            break;
        }
        switch (fid) {
            case 1:
                if (ftype == Thrift.Type.STRING) {
                    this.address = input.readBinary().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 2:
                if (ftype == Thrift.Type.I32) {
                    this.port = input.readI32().value;
                } else {
                    input.skip(ftype);
                }
                break;
            default:
                input.skip(ftype);
        }
        input.readFieldEnd();
    }
    input.readStructEnd();
    return;
};

InetAddress.prototype.write = function (output) {
    output.writeStructBegin("InetAddress");
    if (this.address !== null && this.address !== undefined) {
        output.writeFieldBegin("address", Thrift.Type.STRING, 1);
        output.writeBinary(this.address);
        output.writeFieldEnd();
    }
    if (this.port !== null && this.port !== undefined) {
        output.writeFieldBegin("port", Thrift.Type.I32, 2);
        output.writeI32(this.port);
        output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
};


/***/ }),

/***/ "../../../protocol/services/locality_types.js":
/*!*********************************************************************!*\
  !*** /home/omar/Desktop/hivejs/protocol/services/locality_types.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

//
// Autogenerated by Thrift Compiler (0.12.0)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//
var Thrift = __webpack_require__(/*! @hivestreaming/thrift */ "../../../node_modules/@hivestreaming/thrift/src/thrift.js");

var CustomerInfo = window.CustomerInfo = function(args) {
  this.partnerId = null;
  this.customerId = null;
  if (args) {
    if (args.partnerId !== undefined && args.partnerId !== null) {
      this.partnerId = args.partnerId;
    }
    if (args.customerId !== undefined && args.customerId !== null) {
      this.customerId = args.customerId;
    }
  }
};
CustomerInfo.prototype = {};
CustomerInfo.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.partnerId = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRING) {
        this.customerId = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

CustomerInfo.prototype.write = function(output) {
  output.writeStructBegin('CustomerInfo');
  if (this.partnerId !== null && this.partnerId !== undefined) {
    output.writeFieldBegin('partnerId', Thrift.Type.STRING, 1);
    output.writeString(this.partnerId);
    output.writeFieldEnd();
  }
  if (this.customerId !== null && this.customerId !== undefined) {
    output.writeFieldBegin('customerId', Thrift.Type.STRING, 2);
    output.writeString(this.customerId);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var NetworkInfo = window.NetworkInfo = function(args) {
  this.privateIp = null;
  this.publicIp = null;
  if (args) {
    if (args.privateIp !== undefined && args.privateIp !== null) {
      this.privateIp = args.privateIp;
    }
    if (args.publicIp !== undefined && args.publicIp !== null) {
      this.publicIp = args.publicIp;
    }
  }
};
NetworkInfo.prototype = {};
NetworkInfo.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.privateIp = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRING) {
        this.publicIp = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

NetworkInfo.prototype.write = function(output) {
  output.writeStructBegin('NetworkInfo');
  if (this.privateIp !== null && this.privateIp !== undefined) {
    output.writeFieldBegin('privateIp', Thrift.Type.STRING, 1);
    output.writeString(this.privateIp);
    output.writeFieldEnd();
  }
  if (this.publicIp !== null && this.publicIp !== undefined) {
    output.writeFieldBegin('publicIp', Thrift.Type.STRING, 2);
    output.writeString(this.publicIp);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var PeerLocalityInfo = window.PeerLocalityInfo = function(args) {
  this.agentId = null;
  this.customerInfo = null;
  this.networkInfo = null;
  if (args) {
    if (args.agentId !== undefined && args.agentId !== null) {
      this.agentId = args.agentId;
    }
    if (args.customerInfo !== undefined && args.customerInfo !== null) {
      this.customerInfo = new CustomerInfo(args.customerInfo);
    }
    if (args.networkInfo !== undefined && args.networkInfo !== null) {
      this.networkInfo = new NetworkInfo(args.networkInfo);
    }
  }
};
PeerLocalityInfo.prototype = {};
PeerLocalityInfo.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.agentId = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.customerInfo = new CustomerInfo();
        this.customerInfo.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRUCT) {
        this.networkInfo = new NetworkInfo();
        this.networkInfo.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

PeerLocalityInfo.prototype.write = function(output) {
  output.writeStructBegin('PeerLocalityInfo');
  if (this.agentId !== null && this.agentId !== undefined) {
    output.writeFieldBegin('agentId', Thrift.Type.STRING, 1);
    output.writeString(this.agentId);
    output.writeFieldEnd();
  }
  if (this.customerInfo !== null && this.customerInfo !== undefined) {
    output.writeFieldBegin('customerInfo', Thrift.Type.STRUCT, 2);
    this.customerInfo.write(output);
    output.writeFieldEnd();
  }
  if (this.networkInfo !== null && this.networkInfo !== undefined) {
    output.writeFieldBegin('networkInfo', Thrift.Type.STRUCT, 3);
    this.networkInfo.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};


/***/ }),

/***/ "../../../protocol/services/metrics_types.js":
/*!********************************************************************!*\
  !*** /home/omar/Desktop/hivejs/protocol/services/metrics_types.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

//
// Autogenerated by Thrift Compiler (0.9.3)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//

var Thrift = __webpack_require__(/*! @hivestreaming/thrift */ "../../../node_modules/@hivestreaming/thrift/src/thrift.js");

var hive = window.hive;
if (typeof hive === "undefined") {
    hive = window.hive = {};
}
if (typeof hive.snapshots === "undefined") {
    hive.snapshots = {};
}
hive.snapshots.RequestType = {
    '1': 'PREFETCH',
    'PREFETCH': 1,
    '2': 'PLAYER',
    'PLAYER': 2
};
hive.snapshots.OriginType = {
    '1': 'CDN',
    'CDN': 1,
    '2': 'P2P',
    'P2P': 2,
    '3': 'CACHE',
    'CACHE': 3
};
hive.snapshots.Traffic = function (args) {
    this.reqN = null;
    this.respFallbackN = null;
    this.respFallbackErrN = null;
    this.respP2pN = null;
    this.reqOtherN = null;
    this.respFallbackOtherN = null;
    this.respFallbackOthertErrN = null;
    this.srcReqN = null;
    this.srcRespN = null;
    this.srcRespErrN = null;
    this.srcReqQt = null;
    this.srcRespQt = null;
    this.srcOverQt = null;
    this.srcOtherReqN = null;
    this.srcOtherRespN = null;
    this.srcOtherRespErrN = null;
    this.srcOtherReqQt = null;
    this.srcOtherRespQt = null;
    this.srcOtherOverQt = null;
    this.p2pSubReqN = null;
    this.p2pSubRespN = null;
    this.p2pSubRespPartN = null;
    this.p2pSubRespErrN = null;
    this.p2pSubRespExpN = null;
    this.p2pSubReqQt = null;
    this.p2pSubRespQt = null;
    this.p2pDirectQt = null;
    this.p2pRelayQt = null;
    this.p2pNatQt = null;
    this.p2pUdpbQt = null;
    this.fallAgentRespN = null;
    this.fallAgentPredHitN = null;
    this.fallAgentFailedRespN = null;
    this.fallAgentPredMissN = null;
    this.fallAgentPredPartialHitN = null;
    this.fallAgenTrafficSuccessQt = null;
    this.fallAgenTrafficFailureQt = null;
    this.p2pAgentPredHitN = null;
    this.p2pAgentPredMissN = null;
    this.p2pAgentPredPartialHitN = null;
    this.p2pAgenTrafficSuccessQt = null;
    this.p2pAgenTrafficFailureQt = null;
    this.respP2pOtherN = null;
    this.lCacheRespN = null;
    this.lCacheRespQt = null;
    this.p2pOutSiteLowPrio = null;
    if (args) {
        if (args.reqN !== undefined && args.reqN !== null) {
            this.reqN = args.reqN;
        }
        if (args.respFallbackN !== undefined && args.respFallbackN !== null) {
            this.respFallbackN = args.respFallbackN;
        }
        if (args.respFallbackErrN !== undefined && args.respFallbackErrN !== null) {
            this.respFallbackErrN = args.respFallbackErrN;
        }
        if (args.respP2pN !== undefined && args.respP2pN !== null) {
            this.respP2pN = args.respP2pN;
        }
        if (args.reqOtherN !== undefined && args.reqOtherN !== null) {
            this.reqOtherN = args.reqOtherN;
        }
        if (args.respFallbackOtherN !== undefined && args.respFallbackOtherN !== null) {
            this.respFallbackOtherN = args.respFallbackOtherN;
        }
        if (args.respFallbackOthertErrN !== undefined && args.respFallbackOthertErrN !== null) {
            this.respFallbackOthertErrN = args.respFallbackOthertErrN;
        }
        if (args.srcReqN !== undefined && args.srcReqN !== null) {
            this.srcReqN = args.srcReqN;
        }
        if (args.srcRespN !== undefined && args.srcRespN !== null) {
            this.srcRespN = args.srcRespN;
        }
        if (args.srcRespErrN !== undefined && args.srcRespErrN !== null) {
            this.srcRespErrN = args.srcRespErrN;
        }
        if (args.srcReqQt !== undefined && args.srcReqQt !== null) {
            this.srcReqQt = args.srcReqQt;
        }
        if (args.srcRespQt !== undefined && args.srcRespQt !== null) {
            this.srcRespQt = args.srcRespQt;
        }
        if (args.srcOverQt !== undefined && args.srcOverQt !== null) {
            this.srcOverQt = args.srcOverQt;
        }
        if (args.srcOtherReqN !== undefined && args.srcOtherReqN !== null) {
            this.srcOtherReqN = args.srcOtherReqN;
        }
        if (args.srcOtherRespN !== undefined && args.srcOtherRespN !== null) {
            this.srcOtherRespN = args.srcOtherRespN;
        }
        if (args.srcOtherRespErrN !== undefined && args.srcOtherRespErrN !== null) {
            this.srcOtherRespErrN = args.srcOtherRespErrN;
        }
        if (args.srcOtherReqQt !== undefined && args.srcOtherReqQt !== null) {
            this.srcOtherReqQt = args.srcOtherReqQt;
        }
        if (args.srcOtherRespQt !== undefined && args.srcOtherRespQt !== null) {
            this.srcOtherRespQt = args.srcOtherRespQt;
        }
        if (args.srcOtherOverQt !== undefined && args.srcOtherOverQt !== null) {
            this.srcOtherOverQt = args.srcOtherOverQt;
        }
        if (args.p2pSubReqN !== undefined && args.p2pSubReqN !== null) {
            this.p2pSubReqN = args.p2pSubReqN;
        }
        if (args.p2pSubRespN !== undefined && args.p2pSubRespN !== null) {
            this.p2pSubRespN = args.p2pSubRespN;
        }
        if (args.p2pSubRespPartN !== undefined && args.p2pSubRespPartN !== null) {
            this.p2pSubRespPartN = args.p2pSubRespPartN;
        }
        if (args.p2pSubRespErrN !== undefined && args.p2pSubRespErrN !== null) {
            this.p2pSubRespErrN = args.p2pSubRespErrN;
        }
        if (args.p2pSubRespExpN !== undefined && args.p2pSubRespExpN !== null) {
            this.p2pSubRespExpN = args.p2pSubRespExpN;
        }
        if (args.p2pSubReqQt !== undefined && args.p2pSubReqQt !== null) {
            this.p2pSubReqQt = args.p2pSubReqQt;
        }
        if (args.p2pSubRespQt !== undefined && args.p2pSubRespQt !== null) {
            this.p2pSubRespQt = args.p2pSubRespQt;
        }
        if (args.p2pDirectQt !== undefined && args.p2pDirectQt !== null) {
            this.p2pDirectQt = args.p2pDirectQt;
        }
        if (args.p2pRelayQt !== undefined && args.p2pRelayQt !== null) {
            this.p2pRelayQt = args.p2pRelayQt;
        }
        if (args.p2pNatQt !== undefined && args.p2pNatQt !== null) {
            this.p2pNatQt = args.p2pNatQt;
        }
        if (args.p2pUdpbQt !== undefined && args.p2pUdpbQt !== null) {
            this.p2pUdpbQt = args.p2pUdpbQt;
        }
        if (args.fallAgentRespN !== undefined && args.fallAgentRespN !== null) {
            this.fallAgentRespN = args.fallAgentRespN;
        }
        if (args.fallAgentPredHitN !== undefined && args.fallAgentPredHitN !== null) {
            this.fallAgentPredHitN = args.fallAgentPredHitN;
        }
        if (args.fallAgentFailedRespN !== undefined && args.fallAgentFailedRespN !== null) {
            this.fallAgentFailedRespN = args.fallAgentFailedRespN;
        }
        if (args.fallAgentPredMissN !== undefined && args.fallAgentPredMissN !== null) {
            this.fallAgentPredMissN = args.fallAgentPredMissN;
        }
        if (args.fallAgentPredPartialHitN !== undefined && args.fallAgentPredPartialHitN !== null) {
            this.fallAgentPredPartialHitN = args.fallAgentPredPartialHitN;
        }
        if (args.fallAgenTrafficSuccessQt !== undefined && args.fallAgenTrafficSuccessQt !== null) {
            this.fallAgenTrafficSuccessQt = args.fallAgenTrafficSuccessQt;
        }
        if (args.fallAgenTrafficFailureQt !== undefined && args.fallAgenTrafficFailureQt !== null) {
            this.fallAgenTrafficFailureQt = args.fallAgenTrafficFailureQt;
        }
        if (args.p2pAgentPredHitN !== undefined && args.p2pAgentPredHitN !== null) {
            this.p2pAgentPredHitN = args.p2pAgentPredHitN;
        }
        if (args.p2pAgentPredMissN !== undefined && args.p2pAgentPredMissN !== null) {
            this.p2pAgentPredMissN = args.p2pAgentPredMissN;
        }
        if (args.p2pAgentPredPartialHitN !== undefined && args.p2pAgentPredPartialHitN !== null) {
            this.p2pAgentPredPartialHitN = args.p2pAgentPredPartialHitN;
        }
        if (args.p2pAgenTrafficSuccessQt !== undefined && args.p2pAgenTrafficSuccessQt !== null) {
            this.p2pAgenTrafficSuccessQt = args.p2pAgenTrafficSuccessQt;
        }
        if (args.p2pAgenTrafficFailureQt !== undefined && args.p2pAgenTrafficFailureQt !== null) {
            this.p2pAgenTrafficFailureQt = args.p2pAgenTrafficFailureQt;
        }
        if (args.respP2pOtherN !== undefined && args.respP2pOtherN !== null) {
            this.respP2pOtherN = args.respP2pOtherN;
        }
        if (args.lCacheRespN !== undefined && args.lCacheRespN !== null) {
            this.lCacheRespN = args.lCacheRespN;
        }
        if (args.lCacheRespQt !== undefined && args.lCacheRespQt !== null) {
            this.lCacheRespQt = args.lCacheRespQt;
        }
        if (args.p2pOutSiteLowPrio !== undefined && args.p2pOutSiteLowPrio !== null) {
            this.p2pOutSiteLowPrio = args.p2pOutSiteLowPrio;
        }
    }
};
hive.snapshots.Traffic.prototype = {};
hive.snapshots.Traffic.prototype.read = function (input) {
    input.readStructBegin();
    while (true) {
        var ret = input.readFieldBegin();
        var fname = ret.fname;
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
            break;
        }
        switch (fid) {
            case 1:
                if (ftype == Thrift.Type.I32) {
                    this.reqN = input.readI32().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 2:
                if (ftype == Thrift.Type.DOUBLE) {
                    this.respFallbackN = input.readDouble().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 3:
                if (ftype == Thrift.Type.I32) {
                    this.respFallbackErrN = input.readI32().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 4:
                if (ftype == Thrift.Type.DOUBLE) {
                    this.respP2pN = input.readDouble().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 5:
                if (ftype == Thrift.Type.I32) {
                    this.reqOtherN = input.readI32().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 6:
                if (ftype == Thrift.Type.I32) {
                    this.respFallbackOtherN = input.readI32().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 7:
                if (ftype == Thrift.Type.I32) {
                    this.respFallbackOthertErrN = input.readI32().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 8:
                if (ftype == Thrift.Type.I32) {
                    this.srcReqN = input.readI32().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 9:
                if (ftype == Thrift.Type.I32) {
                    this.srcRespN = input.readI32().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 10:
                if (ftype == Thrift.Type.I32) {
                    this.srcRespErrN = input.readI32().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 11:
                if (ftype == Thrift.Type.I64) {
                    this.srcReqQt = input.readI64().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 12:
                if (ftype == Thrift.Type.I64) {
                    this.srcRespQt = input.readI64().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 13:
                if (ftype == Thrift.Type.I64) {
                    this.srcOverQt = input.readI64().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 14:
                if (ftype == Thrift.Type.I32) {
                    this.srcOtherReqN = input.readI32().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 15:
                if (ftype == Thrift.Type.I32) {
                    this.srcOtherRespN = input.readI32().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 16:
                if (ftype == Thrift.Type.I32) {
                    this.srcOtherRespErrN = input.readI32().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 17:
                if (ftype == Thrift.Type.I64) {
                    this.srcOtherReqQt = input.readI64().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 18:
                if (ftype == Thrift.Type.I64) {
                    this.srcOtherRespQt = input.readI64().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 19:
                if (ftype == Thrift.Type.I64) {
                    this.srcOtherOverQt = input.readI64().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 20:
                if (ftype == Thrift.Type.I32) {
                    this.p2pSubReqN = input.readI32().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 21:
                if (ftype == Thrift.Type.I32) {
                    this.p2pSubRespN = input.readI32().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 22:
                if (ftype == Thrift.Type.DOUBLE) {
                    this.p2pSubRespPartN = input.readDouble().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 23:
                if (ftype == Thrift.Type.DOUBLE) {
                    this.p2pSubRespErrN = input.readDouble().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 24:
                if (ftype == Thrift.Type.I32) {
                    this.p2pSubRespExpN = input.readI32().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 25:
                if (ftype == Thrift.Type.I64) {
                    this.p2pSubReqQt = input.readI64().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 26:
                if (ftype == Thrift.Type.I64) {
                    this.p2pSubRespQt = input.readI64().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 27:
                if (ftype == Thrift.Type.I64) {
                    this.p2pDirectQt = input.readI64().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 28:
                if (ftype == Thrift.Type.I64) {
                    this.p2pRelayQt = input.readI64().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 29:
                if (ftype == Thrift.Type.I64) {
                    this.p2pNatQt = input.readI64().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 30:
                if (ftype == Thrift.Type.I64) {
                    this.p2pUdpbQt = input.readI64().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 31:
                if (ftype == Thrift.Type.I32) {
                    this.fallAgentRespN = input.readI32().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 32:
                if (ftype == Thrift.Type.I32) {
                    this.fallAgentPredHitN = input.readI32().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 33:
                if (ftype == Thrift.Type.I32) {
                    this.fallAgentFailedRespN = input.readI32().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 34:
                if (ftype == Thrift.Type.I32) {
                    this.fallAgentPredMissN = input.readI32().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 35:
                if (ftype == Thrift.Type.I32) {
                    this.fallAgentPredPartialHitN = input.readI32().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 36:
                if (ftype == Thrift.Type.I64) {
                    this.fallAgenTrafficSuccessQt = input.readI64().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 37:
                if (ftype == Thrift.Type.I64) {
                    this.fallAgenTrafficFailureQt = input.readI64().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 38:
                if (ftype == Thrift.Type.I32) {
                    this.p2pAgentPredHitN = input.readI32().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 39:
                if (ftype == Thrift.Type.I32) {
                    this.p2pAgentPredMissN = input.readI32().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 40:
                if (ftype == Thrift.Type.I32) {
                    this.p2pAgentPredPartialHitN = input.readI32().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 41:
                if (ftype == Thrift.Type.I64) {
                    this.p2pAgenTrafficSuccessQt = input.readI64().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 42:
                if (ftype == Thrift.Type.I64) {
                    this.p2pAgenTrafficFailureQt = input.readI64().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 43:
                if (ftype == Thrift.Type.I32) {
                    this.respP2pOtherN = input.readI32().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 44:
                if (ftype == Thrift.Type.I32) {
                    this.lCacheRespN = input.readI32().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 45:
                if (ftype == Thrift.Type.I64) {
                    this.lCacheRespQt = input.readI64().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 46:
                if (ftype == Thrift.Type.I64) {
                    this.p2pOutSiteLowPrio = input.readI64().value;
                } else {
                    input.skip(ftype);
                }
                break;
            default:
                input.skip(ftype);
        }
        input.readFieldEnd();
    }
    input.readStructEnd();
    return;
};

hive.snapshots.Traffic.prototype.write = function (output) {
    output.writeStructBegin("Traffic");
    if (this.reqN !== null && this.reqN !== undefined) {
        output.writeFieldBegin("reqN", Thrift.Type.I32, 1);
        output.writeI32(this.reqN);
        output.writeFieldEnd();
    }
    if (this.respFallbackN !== null && this.respFallbackN !== undefined) {
        output.writeFieldBegin("respFallbackN", Thrift.Type.DOUBLE, 2);
        output.writeDouble(this.respFallbackN);
        output.writeFieldEnd();
    }
    if (this.respFallbackErrN !== null && this.respFallbackErrN !== undefined) {
        output.writeFieldBegin("respFallbackErrN", Thrift.Type.I32, 3);
        output.writeI32(this.respFallbackErrN);
        output.writeFieldEnd();
    }
    if (this.respP2pN !== null && this.respP2pN !== undefined) {
        output.writeFieldBegin("respP2pN", Thrift.Type.DOUBLE, 4);
        output.writeDouble(this.respP2pN);
        output.writeFieldEnd();
    }
    if (this.reqOtherN !== null && this.reqOtherN !== undefined) {
        output.writeFieldBegin("reqOtherN", Thrift.Type.I32, 5);
        output.writeI32(this.reqOtherN);
        output.writeFieldEnd();
    }
    if (this.respFallbackOtherN !== null && this.respFallbackOtherN !== undefined) {
        output.writeFieldBegin("respFallbackOtherN", Thrift.Type.I32, 6);
        output.writeI32(this.respFallbackOtherN);
        output.writeFieldEnd();
    }
    if (this.respFallbackOthertErrN !== null && this.respFallbackOthertErrN !== undefined) {
        output.writeFieldBegin("respFallbackOthertErrN", Thrift.Type.I32, 7);
        output.writeI32(this.respFallbackOthertErrN);
        output.writeFieldEnd();
    }
    if (this.srcReqN !== null && this.srcReqN !== undefined) {
        output.writeFieldBegin("srcReqN", Thrift.Type.I32, 8);
        output.writeI32(this.srcReqN);
        output.writeFieldEnd();
    }
    if (this.srcRespN !== null && this.srcRespN !== undefined) {
        output.writeFieldBegin("srcRespN", Thrift.Type.I32, 9);
        output.writeI32(this.srcRespN);
        output.writeFieldEnd();
    }
    if (this.srcRespErrN !== null && this.srcRespErrN !== undefined) {
        output.writeFieldBegin("srcRespErrN", Thrift.Type.I32, 10);
        output.writeI32(this.srcRespErrN);
        output.writeFieldEnd();
    }
    if (this.srcReqQt !== null && this.srcReqQt !== undefined) {
        output.writeFieldBegin("srcReqQt", Thrift.Type.I64, 11);
        output.writeI64(this.srcReqQt);
        output.writeFieldEnd();
    }
    if (this.srcRespQt !== null && this.srcRespQt !== undefined) {
        output.writeFieldBegin("srcRespQt", Thrift.Type.I64, 12);
        output.writeI64(this.srcRespQt);
        output.writeFieldEnd();
    }
    if (this.srcOverQt !== null && this.srcOverQt !== undefined) {
        output.writeFieldBegin("srcOverQt", Thrift.Type.I64, 13);
        output.writeI64(this.srcOverQt);
        output.writeFieldEnd();
    }
    if (this.srcOtherReqN !== null && this.srcOtherReqN !== undefined) {
        output.writeFieldBegin("srcOtherReqN", Thrift.Type.I32, 14);
        output.writeI32(this.srcOtherReqN);
        output.writeFieldEnd();
    }
    if (this.srcOtherRespN !== null && this.srcOtherRespN !== undefined) {
        output.writeFieldBegin("srcOtherRespN", Thrift.Type.I32, 15);
        output.writeI32(this.srcOtherRespN);
        output.writeFieldEnd();
    }
    if (this.srcOtherRespErrN !== null && this.srcOtherRespErrN !== undefined) {
        output.writeFieldBegin("srcOtherRespErrN", Thrift.Type.I32, 16);
        output.writeI32(this.srcOtherRespErrN);
        output.writeFieldEnd();
    }
    if (this.srcOtherReqQt !== null && this.srcOtherReqQt !== undefined) {
        output.writeFieldBegin("srcOtherReqQt", Thrift.Type.I64, 17);
        output.writeI64(this.srcOtherReqQt);
        output.writeFieldEnd();
    }
    if (this.srcOtherRespQt !== null && this.srcOtherRespQt !== undefined) {
        output.writeFieldBegin("srcOtherRespQt", Thrift.Type.I64, 18);
        output.writeI64(this.srcOtherRespQt);
        output.writeFieldEnd();
    }
    if (this.srcOtherOverQt !== null && this.srcOtherOverQt !== undefined) {
        output.writeFieldBegin("srcOtherOverQt", Thrift.Type.I64, 19);
        output.writeI64(this.srcOtherOverQt);
        output.writeFieldEnd();
    }
    if (this.p2pSubReqN !== null && this.p2pSubReqN !== undefined) {
        output.writeFieldBegin("p2pSubReqN", Thrift.Type.I32, 20);
        output.writeI32(this.p2pSubReqN);
        output.writeFieldEnd();
    }
    if (this.p2pSubRespN !== null && this.p2pSubRespN !== undefined) {
        output.writeFieldBegin("p2pSubRespN", Thrift.Type.I32, 21);
        output.writeI32(this.p2pSubRespN);
        output.writeFieldEnd();
    }
    if (this.p2pSubRespPartN !== null && this.p2pSubRespPartN !== undefined) {
        output.writeFieldBegin("p2pSubRespPartN", Thrift.Type.DOUBLE, 22);
        output.writeDouble(this.p2pSubRespPartN);
        output.writeFieldEnd();
    }
    if (this.p2pSubRespErrN !== null && this.p2pSubRespErrN !== undefined) {
        output.writeFieldBegin("p2pSubRespErrN", Thrift.Type.DOUBLE, 23);
        output.writeDouble(this.p2pSubRespErrN);
        output.writeFieldEnd();
    }
    if (this.p2pSubRespExpN !== null && this.p2pSubRespExpN !== undefined) {
        output.writeFieldBegin("p2pSubRespExpN", Thrift.Type.I32, 24);
        output.writeI32(this.p2pSubRespExpN);
        output.writeFieldEnd();
    }
    if (this.p2pSubReqQt !== null && this.p2pSubReqQt !== undefined) {
        output.writeFieldBegin("p2pSubReqQt", Thrift.Type.I64, 25);
        output.writeI64(this.p2pSubReqQt);
        output.writeFieldEnd();
    }
    if (this.p2pSubRespQt !== null && this.p2pSubRespQt !== undefined) {
        output.writeFieldBegin("p2pSubRespQt", Thrift.Type.I64, 26);
        output.writeI64(this.p2pSubRespQt);
        output.writeFieldEnd();
    }
    if (this.p2pDirectQt !== null && this.p2pDirectQt !== undefined) {
        output.writeFieldBegin("p2pDirectQt", Thrift.Type.I64, 27);
        output.writeI64(this.p2pDirectQt);
        output.writeFieldEnd();
    }
    if (this.p2pRelayQt !== null && this.p2pRelayQt !== undefined) {
        output.writeFieldBegin("p2pRelayQt", Thrift.Type.I64, 28);
        output.writeI64(this.p2pRelayQt);
        output.writeFieldEnd();
    }
    if (this.p2pNatQt !== null && this.p2pNatQt !== undefined) {
        output.writeFieldBegin("p2pNatQt", Thrift.Type.I64, 29);
        output.writeI64(this.p2pNatQt);
        output.writeFieldEnd();
    }
    if (this.p2pUdpbQt !== null && this.p2pUdpbQt !== undefined) {
        output.writeFieldBegin("p2pUdpbQt", Thrift.Type.I64, 30);
        output.writeI64(this.p2pUdpbQt);
        output.writeFieldEnd();
    }
    if (this.fallAgentRespN !== null && this.fallAgentRespN !== undefined) {
        output.writeFieldBegin("fallAgentRespN", Thrift.Type.I32, 31);
        output.writeI32(this.fallAgentRespN);
        output.writeFieldEnd();
    }
    if (this.fallAgentPredHitN !== null && this.fallAgentPredHitN !== undefined) {
        output.writeFieldBegin("fallAgentPredHitN", Thrift.Type.I32, 32);
        output.writeI32(this.fallAgentPredHitN);
        output.writeFieldEnd();
    }
    if (this.fallAgentFailedRespN !== null && this.fallAgentFailedRespN !== undefined) {
        output.writeFieldBegin("fallAgentFailedRespN", Thrift.Type.I32, 33);
        output.writeI32(this.fallAgentFailedRespN);
        output.writeFieldEnd();
    }
    if (this.fallAgentPredMissN !== null && this.fallAgentPredMissN !== undefined) {
        output.writeFieldBegin("fallAgentPredMissN", Thrift.Type.I32, 34);
        output.writeI32(this.fallAgentPredMissN);
        output.writeFieldEnd();
    }
    if (this.fallAgentPredPartialHitN !== null && this.fallAgentPredPartialHitN !== undefined) {
        output.writeFieldBegin("fallAgentPredPartialHitN", Thrift.Type.I32, 35);
        output.writeI32(this.fallAgentPredPartialHitN);
        output.writeFieldEnd();
    }
    if (this.fallAgenTrafficSuccessQt !== null && this.fallAgenTrafficSuccessQt !== undefined) {
        output.writeFieldBegin("fallAgenTrafficSuccessQt", Thrift.Type.I64, 36);
        output.writeI64(this.fallAgenTrafficSuccessQt);
        output.writeFieldEnd();
    }
    if (this.fallAgenTrafficFailureQt !== null && this.fallAgenTrafficFailureQt !== undefined) {
        output.writeFieldBegin("fallAgenTrafficFailureQt", Thrift.Type.I64, 37);
        output.writeI64(this.fallAgenTrafficFailureQt);
        output.writeFieldEnd();
    }
    if (this.p2pAgentPredHitN !== null && this.p2pAgentPredHitN !== undefined) {
        output.writeFieldBegin("p2pAgentPredHitN", Thrift.Type.I32, 38);
        output.writeI32(this.p2pAgentPredHitN);
        output.writeFieldEnd();
    }
    if (this.p2pAgentPredMissN !== null && this.p2pAgentPredMissN !== undefined) {
        output.writeFieldBegin("p2pAgentPredMissN", Thrift.Type.I32, 39);
        output.writeI32(this.p2pAgentPredMissN);
        output.writeFieldEnd();
    }
    if (this.p2pAgentPredPartialHitN !== null && this.p2pAgentPredPartialHitN !== undefined) {
        output.writeFieldBegin("p2pAgentPredPartialHitN", Thrift.Type.I32, 40);
        output.writeI32(this.p2pAgentPredPartialHitN);
        output.writeFieldEnd();
    }
    if (this.p2pAgenTrafficSuccessQt !== null && this.p2pAgenTrafficSuccessQt !== undefined) {
        output.writeFieldBegin("p2pAgenTrafficSuccessQt", Thrift.Type.I64, 41);
        output.writeI64(this.p2pAgenTrafficSuccessQt);
        output.writeFieldEnd();
    }
    if (this.p2pAgenTrafficFailureQt !== null && this.p2pAgenTrafficFailureQt !== undefined) {
        output.writeFieldBegin("p2pAgenTrafficFailureQt", Thrift.Type.I64, 42);
        output.writeI64(this.p2pAgenTrafficFailureQt);
        output.writeFieldEnd();
    }
    if (this.respP2pOtherN !== null && this.respP2pOtherN !== undefined) {
        output.writeFieldBegin("respP2pOtherN", Thrift.Type.I32, 43);
        output.writeI32(this.respP2pOtherN);
        output.writeFieldEnd();
    }
    if (this.lCacheRespN !== null && this.lCacheRespN !== undefined) {
        output.writeFieldBegin("lCacheRespN", Thrift.Type.I32, 44);
        output.writeI32(this.lCacheRespN);
        output.writeFieldEnd();
    }
    if (this.lCacheRespQt !== null && this.lCacheRespQt !== undefined) {
        output.writeFieldBegin("lCacheRespQt", Thrift.Type.I64, 45);
        output.writeI64(this.lCacheRespQt);
        output.writeFieldEnd();
    }
    if (this.p2pOutSiteLowPrio !== null && this.p2pOutSiteLowPrio !== undefined) {
        output.writeFieldBegin("p2pOutSiteLowPrio", Thrift.Type.I64, 46);
        output.writeI64(this.p2pOutSiteLowPrio);
        output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
};

hive.snapshots.FragmentMetadata = function (args) {
    this.url = null;
    this.size = null;
    this.duration = null;
    this.qualityLevelId = null;
    this.contentType = null;
    this.prefetched = null;
    this.downloadTime = null;
    if (args) {
        if (args.url !== undefined && args.url !== null) {
            this.url = args.url;
        }
        if (args.size !== undefined && args.size !== null) {
            this.size = args.size;
        }
        if (args.duration !== undefined && args.duration !== null) {
            this.duration = args.duration;
        }
        if (args.qualityLevelId !== undefined && args.qualityLevelId !== null) {
            this.qualityLevelId = args.qualityLevelId;
        }
        if (args.contentType !== undefined && args.contentType !== null) {
            this.contentType = args.contentType;
        }
        if (args.prefetched !== undefined && args.prefetched !== null) {
            this.prefetched = args.prefetched;
        }
        if (args.downloadTime !== undefined && args.downloadTime !== null) {
            this.downloadTime = args.downloadTime;
        }
    }
};
hive.snapshots.FragmentMetadata.prototype = {};
hive.snapshots.FragmentMetadata.prototype.read = function (input) {
    input.readStructBegin();
    while (true) {
        var ret = input.readFieldBegin();
        var fname = ret.fname;
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
            break;
        }
        switch (fid) {
            case 1:
                if (ftype == Thrift.Type.STRING) {
                    this.url = input.readString().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 2:
                if (ftype == Thrift.Type.I32) {
                    this.size = input.readI32().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 3:
                if (ftype == Thrift.Type.I32) {
                    this.duration = input.readI32().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 4:
                if (ftype == Thrift.Type.STRING) {
                    this.qualityLevelId = input.readString().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 5:
                if (ftype == Thrift.Type.I32) {
                    this.contentType = input.readI32().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 6:
                if (ftype == Thrift.Type.BOOL) {
                    this.prefetched = input.readBool().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 7:
                if (ftype == Thrift.Type.I32) {
                    this.downloadTime = input.readI32().value;
                } else {
                    input.skip(ftype);
                }
                break;
            default:
                input.skip(ftype);
        }
        input.readFieldEnd();
    }
    input.readStructEnd();
    return;
};

hive.snapshots.FragmentMetadata.prototype.write = function (output) {
    output.writeStructBegin("FragmentMetadata");
    if (this.url !== null && this.url !== undefined) {
        output.writeFieldBegin("url", Thrift.Type.STRING, 1);
        output.writeString(this.url);
        output.writeFieldEnd();
    }
    if (this.size !== null && this.size !== undefined) {
        output.writeFieldBegin("size", Thrift.Type.I32, 2);
        output.writeI32(this.size);
        output.writeFieldEnd();
    }
    if (this.duration !== null && this.duration !== undefined) {
        output.writeFieldBegin("duration", Thrift.Type.I32, 3);
        output.writeI32(this.duration);
        output.writeFieldEnd();
    }
    if (this.qualityLevelId !== null && this.qualityLevelId !== undefined) {
        output.writeFieldBegin("qualityLevelId", Thrift.Type.STRING, 4);
        output.writeString(this.qualityLevelId);
        output.writeFieldEnd();
    }
    if (this.contentType !== null && this.contentType !== undefined) {
        output.writeFieldBegin("contentType", Thrift.Type.I32, 5);
        output.writeI32(this.contentType);
        output.writeFieldEnd();
    }
    if (this.prefetched !== null && this.prefetched !== undefined) {
        output.writeFieldBegin("prefetched", Thrift.Type.BOOL, 6);
        output.writeBool(this.prefetched);
        output.writeFieldEnd();
    }
    if (this.downloadTime !== null && this.downloadTime !== undefined) {
        output.writeFieldBegin("downloadTime", Thrift.Type.I32, 7);
        output.writeI32(this.downloadTime);
        output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
};

hive.snapshots.FragmentDownload = function (args) {
    this.fragmentUrl = null;
    this.qualityLevelId = null;
    this.type = null;
    this.startTimestamp = null;
    this.endTimestamp = null;
    this.origin = null;
    if (args) {
        if (args.fragmentUrl !== undefined && args.fragmentUrl !== null) {
            this.fragmentUrl = args.fragmentUrl;
        }
        if (args.qualityLevelId !== undefined && args.qualityLevelId !== null) {
            this.qualityLevelId = args.qualityLevelId;
        }
        if (args.type !== undefined && args.type !== null) {
            this.type = args.type;
        }
        if (args.startTimestamp !== undefined && args.startTimestamp !== null) {
            this.startTimestamp = args.startTimestamp;
        }
        if (args.endTimestamp !== undefined && args.endTimestamp !== null) {
            this.endTimestamp = args.endTimestamp;
        }
        if (args.origin !== undefined && args.origin !== null) {
            this.origin = args.origin;
        }
    }
};
hive.snapshots.FragmentDownload.prototype = {};
hive.snapshots.FragmentDownload.prototype.read = function (input) {
    input.readStructBegin();
    while (true) {
        var ret = input.readFieldBegin();
        var fname = ret.fname;
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
            break;
        }
        switch (fid) {
            case 1:
                if (ftype == Thrift.Type.STRING) {
                    this.fragmentUrl = input.readString().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 2:
                if (ftype == Thrift.Type.STRING) {
                    this.qualityLevelId = input.readString().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 3:
                if (ftype == Thrift.Type.I32) {
                    this.type = input.readI32().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 4:
                if (ftype == Thrift.Type.I64) {
                    this.startTimestamp = input.readI64().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 5:
                if (ftype == Thrift.Type.I64) {
                    this.endTimestamp = input.readI64().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 6:
                if (ftype == Thrift.Type.I32) {
                    this.origin = input.readI32().value;
                } else {
                    input.skip(ftype);
                }
                break;
            default:
                input.skip(ftype);
        }
        input.readFieldEnd();
    }
    input.readStructEnd();
    return;
};

hive.snapshots.FragmentDownload.prototype.write = function (output) {
    output.writeStructBegin('FragmentDownload');
    if (this.fragmentUrl !== null && this.fragmentUrl !== undefined) {
        output.writeFieldBegin('fragmentUrl', Thrift.Type.STRING, 1);
        output.writeString(this.fragmentUrl);
        output.writeFieldEnd();
    }
    if (this.qualityLevelId !== null && this.qualityLevelId !== undefined) {
        output.writeFieldBegin('qualityLevelId', Thrift.Type.STRING, 2);
        output.writeString(this.qualityLevelId);
        output.writeFieldEnd();
    }
    if (this.type !== null && this.type !== undefined) {
        output.writeFieldBegin('type', Thrift.Type.I32, 3);
        output.writeI32(this.type);
        output.writeFieldEnd();
    }
    if (this.startTimestamp !== null && this.startTimestamp !== undefined) {
        output.writeFieldBegin('startTimestamp', Thrift.Type.I64, 4);
        output.writeI64(this.startTimestamp);
        output.writeFieldEnd();
    }
    if (this.endTimestamp !== null && this.endTimestamp !== undefined) {
        output.writeFieldBegin('endTimestamp', Thrift.Type.I64, 5);
        output.writeI64(this.endTimestamp);
        output.writeFieldEnd();
    }
    if (this.origin !== null && this.origin !== undefined) {
        output.writeFieldBegin('origin', Thrift.Type.I32, 6);
        output.writeI32(this.origin);
        output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
};

hive.snapshots.QualityLevel = function (args) {
    this.id = null;
    this.bitrates = null;
    this.width = null;
    this.height = null;
    this.label = null;
    this.filtered = null;
    if (args) {
        if (args.id !== undefined && args.id !== null) {
            this.id = args.id;
        }
        if (args.bitrates !== undefined && args.bitrates !== null) {
            this.bitrates = Thrift.copyList(args.bitrates, [null]);
        }
        if (args.width !== undefined && args.width !== null) {
            this.width = args.width;
        }
        if (args.height !== undefined && args.height !== null) {
            this.height = args.height;
        }
        if (args.label !== undefined && args.label !== null) {
            this.label = args.label;
        }
        if (args.filtered !== undefined && args.filtered !== null) {
            this.filtered = args.filtered;
        }
    }
};
hive.snapshots.QualityLevel.prototype = {};
hive.snapshots.QualityLevel.prototype.read = function (input) {
    input.readStructBegin();
    while (true) {
        var ret = input.readFieldBegin();
        var fname = ret.fname;
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
            break;
        }
        switch (fid) {
            case 1:
                if (ftype == Thrift.Type.STRING) {
                    this.id = input.readString().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 2:
                if (ftype == Thrift.Type.LIST) {
                    var _size0 = 0;
                    var _rtmp34;
                    this.bitrates = [];
                    var _etype3 = 0;
                    _rtmp34 = input.readListBegin();
                    _etype3 = _rtmp34.etype;
                    _size0 = _rtmp34.size;
                    for (var _i5 = 0; _i5 < _size0; ++_i5) {
                        var elem6 = null;
                        elem6 = input.readI32().value;
                        this.bitrates.push(elem6);
                    }
                    input.readListEnd();
                } else {
                    input.skip(ftype);
                }
                break;
            case 3:
                if (ftype == Thrift.Type.I32) {
                    this.width = input.readI32().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 4:
                if (ftype == Thrift.Type.I32) {
                    this.height = input.readI32().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 5:
                if (ftype == Thrift.Type.STRING) {
                    this.label = input.readString().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 6:
                if (ftype == Thrift.Type.BOOL) {
                    this.filtered = input.readBool().value;
                } else {
                    input.skip(ftype);
                }
                break;
            default:
                input.skip(ftype);
        }
        input.readFieldEnd();
    }
    input.readStructEnd();
    return;
};

hive.snapshots.QualityLevel.prototype.write = function (output) {
    output.writeStructBegin("QualityLevel");
    if (this.id !== null && this.id !== undefined) {
        output.writeFieldBegin("id", Thrift.Type.STRING, 1);
        output.writeString(this.id);
        output.writeFieldEnd();
    }
    if (this.bitrates !== null && this.bitrates !== undefined) {
        output.writeFieldBegin("bitrates", Thrift.Type.LIST, 2);
        output.writeListBegin(Thrift.Type.I32, this.bitrates.length);
        for (var iter7 in this.bitrates) {
            if (this.bitrates.hasOwnProperty(iter7)) {
                iter7 = this.bitrates[iter7];
                output.writeI32(iter7);
            }
        }
        output.writeListEnd();
        output.writeFieldEnd();
    }
    if (this.width !== null && this.width !== undefined) {
        output.writeFieldBegin("width", Thrift.Type.I32, 3);
        output.writeI32(this.width);
        output.writeFieldEnd();
    }
    if (this.height !== null && this.height !== undefined) {
        output.writeFieldBegin("height", Thrift.Type.I32, 4);
        output.writeI32(this.height);
        output.writeFieldEnd();
    }
    if (this.label !== null && this.label !== undefined) {
        output.writeFieldBegin("label", Thrift.Type.STRING, 5);
        output.writeString(this.label);
        output.writeFieldEnd();
    }
    if (this.filtered !== null && this.filtered !== undefined) {
        output.writeFieldBegin("filtered", Thrift.Type.BOOL, 6);
        output.writeBool(this.filtered);
        output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
};

hive.snapshots.Metrics = function (args) {
    this.upBW = null;
    this.downBW = null;
    this.memN = null;
    this.prtInN = null;
    this.prtOutN = null;
    this.initVideoBufQt = null;
    this.videoAvgBufQt = null;
    this.videoBufQt = null;
    this.videoBufN = null;
    this.initAudioBufQt = null;
    this.audioAvgBufQt = null;
    this.audioBufQt = null;
    this.audioBufN = null;
    this.bitrateUpN = null;
    this.bitrateDwnN = null;
    this.delay = null;
    this.delayEnforcement = null;
    this.lookupReqEstablished = null;
    this.lookupReqAccept = null;
    this.fallbackAvgTp = null;
    this.srcThroughput = null;
    this.diskReadTimeout = null;
    this.diskReadRate = null;
    this.diskStoreRate = null;
    this.diskRemoveRate = null;
    this.diskCacheSize = null;
    this.clientBufferMs = null;
    this.lookupTotal = null;
    this.lookupNotFound = null;
    this.lookupFailed = null;
    this.lookupLatency = null;
    this.trackerFailed = null;
    this.trackerLatency = null;
    this.snapshotFailed = null;
    this.snapshotLatency = null;
    this.sourceLatency = null;
    if (args) {
        if (args.upBW !== undefined && args.upBW !== null) {
            this.upBW = args.upBW;
        }
        if (args.downBW !== undefined && args.downBW !== null) {
            this.downBW = args.downBW;
        }
        if (args.memN !== undefined && args.memN !== null) {
            this.memN = args.memN;
        }
        if (args.prtInN !== undefined && args.prtInN !== null) {
            this.prtInN = args.prtInN;
        }
        if (args.prtOutN !== undefined && args.prtOutN !== null) {
            this.prtOutN = args.prtOutN;
        }
        if (args.initVideoBufQt !== undefined && args.initVideoBufQt !== null) {
            this.initVideoBufQt = args.initVideoBufQt;
        }
        if (args.videoAvgBufQt !== undefined && args.videoAvgBufQt !== null) {
            this.videoAvgBufQt = args.videoAvgBufQt;
        }
        if (args.videoBufQt !== undefined && args.videoBufQt !== null) {
            this.videoBufQt = args.videoBufQt;
        }
        if (args.videoBufN !== undefined && args.videoBufN !== null) {
            this.videoBufN = args.videoBufN;
        }
        if (args.initAudioBufQt !== undefined && args.initAudioBufQt !== null) {
            this.initAudioBufQt = args.initAudioBufQt;
        }
        if (args.audioAvgBufQt !== undefined && args.audioAvgBufQt !== null) {
            this.audioAvgBufQt = args.audioAvgBufQt;
        }
        if (args.audioBufQt !== undefined && args.audioBufQt !== null) {
            this.audioBufQt = args.audioBufQt;
        }
        if (args.audioBufN !== undefined && args.audioBufN !== null) {
            this.audioBufN = args.audioBufN;
        }
        if (args.bitrateUpN !== undefined && args.bitrateUpN !== null) {
            this.bitrateUpN = args.bitrateUpN;
        }
        if (args.bitrateDwnN !== undefined && args.bitrateDwnN !== null) {
            this.bitrateDwnN = args.bitrateDwnN;
        }
        if (args.delay !== undefined && args.delay !== null) {
            this.delay = args.delay;
        }
        if (args.delayEnforcement !== undefined && args.delayEnforcement !== null) {
            this.delayEnforcement = args.delayEnforcement;
        }
        if (args.lookupReqEstablished !== undefined && args.lookupReqEstablished !== null) {
            this.lookupReqEstablished = args.lookupReqEstablished;
        }
        if (args.lookupReqAccept !== undefined && args.lookupReqAccept !== null) {
            this.lookupReqAccept = args.lookupReqAccept;
        }
        if (args.fallbackAvgTp !== undefined && args.fallbackAvgTp !== null) {
            this.fallbackAvgTp = args.fallbackAvgTp;
        }
        if (args.srcThroughput !== undefined && args.srcThroughput !== null) {
            this.srcThroughput = args.srcThroughput;
        }
        if (args.diskReadTimeout !== undefined && args.diskReadTimeout !== null) {
            this.diskReadTimeout = args.diskReadTimeout;
        }
        if (args.diskReadRate !== undefined && args.diskReadRate !== null) {
            this.diskReadRate = args.diskReadRate;
        }
        if (args.diskStoreRate !== undefined && args.diskStoreRate !== null) {
            this.diskStoreRate = args.diskStoreRate;
        }
        if (args.diskRemoveRate !== undefined && args.diskRemoveRate !== null) {
            this.diskRemoveRate = args.diskRemoveRate;
        }
        if (args.diskCacheSize !== undefined && args.diskCacheSize !== null) {
            this.diskCacheSize = args.diskCacheSize;
        }
        if (args.clientBufferMs !== undefined && args.clientBufferMs !== null) {
            this.clientBufferMs = args.clientBufferMs;
        }
        if (args.lookupTotal !== undefined && args.lookupTotal !== null) {
            this.lookupTotal = args.lookupTotal;
        }
        if (args.lookupNotFound !== undefined && args.lookupNotFound !== null) {
            this.lookupNotFound = args.lookupNotFound;
        }
        if (args.lookupFailed !== undefined && args.lookupFailed !== null) {
            this.lookupFailed = args.lookupFailed;
        }
        if (args.lookupLatency !== undefined && args.lookupLatency !== null) {
            this.lookupLatency = args.lookupLatency;
        }
        if (args.trackerFailed !== undefined && args.trackerFailed !== null) {
            this.trackerFailed = args.trackerFailed;
        }
        if (args.trackerLatency !== undefined && args.trackerLatency !== null) {
            this.trackerLatency = args.trackerLatency;
        }
        if (args.snapshotFailed !== undefined && args.snapshotFailed !== null) {
            this.snapshotFailed = args.snapshotFailed;
        }
        if (args.snapshotLatency !== undefined && args.snapshotLatency !== null) {
            this.snapshotLatency = args.snapshotLatency;
        }
        if (args.sourceLatency !== undefined && args.sourceLatency !== null) {
            this.sourceLatency = args.sourceLatency;
        }
    }
};
hive.snapshots.Metrics.prototype = {};
hive.snapshots.Metrics.prototype.read = function (input) {
    input.readStructBegin();
    while (true) {
        var ret = input.readFieldBegin();
        var fname = ret.fname;
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
            break;
        }
        switch (fid) {
            case 1:
                if (ftype == Thrift.Type.I32) {
                    this.upBW = input.readI32().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 2:
                if (ftype == Thrift.Type.I32) {
                    this.downBW = input.readI32().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 3:
                if (ftype == Thrift.Type.I32) {
                    this.memN = input.readI32().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 4:
                if (ftype == Thrift.Type.I32) {
                    this.prtInN = input.readI32().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 5:
                if (ftype == Thrift.Type.I32) {
                    this.prtOutN = input.readI32().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 6:
                if (ftype == Thrift.Type.I64) {
                    this.initVideoBufQt = input.readI64().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 7:
                if (ftype == Thrift.Type.DOUBLE) {
                    this.videoAvgBufQt = input.readDouble().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 8:
                if (ftype == Thrift.Type.I64) {
                    this.videoBufQt = input.readI64().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 9:
                if (ftype == Thrift.Type.I32) {
                    this.videoBufN = input.readI32().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 10:
                if (ftype == Thrift.Type.I32) {
                    this.initAudioBufQt = input.readI32().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 11:
                if (ftype == Thrift.Type.DOUBLE) {
                    this.audioAvgBufQt = input.readDouble().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 12:
                if (ftype == Thrift.Type.I64) {
                    this.audioBufQt = input.readI64().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 13:
                if (ftype == Thrift.Type.I32) {
                    this.audioBufN = input.readI32().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 14:
                if (ftype == Thrift.Type.I32) {
                    this.bitrateUpN = input.readI32().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 15:
                if (ftype == Thrift.Type.I32) {
                    this.bitrateDwnN = input.readI32().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 16:
                if (ftype == Thrift.Type.I32) {
                    this.delay = input.readI32().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 17:
                if (ftype == Thrift.Type.I32) {
                    this.delayEnforcement = input.readI32().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 18:
                if (ftype == Thrift.Type.I32) {
                    this.lookupReqEstablished = input.readI32().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 19:
                if (ftype == Thrift.Type.I32) {
                    this.lookupReqAccept = input.readI32().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 20:
                if (ftype == Thrift.Type.DOUBLE) {
                    this.fallbackAvgTp = input.readDouble().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 21:
                if (ftype == Thrift.Type.DOUBLE) {
                    this.srcThroughput = input.readDouble().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 22:
                if (ftype == Thrift.Type.I32) {
                    this.diskReadTimeout = input.readI32().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 23:
                if (ftype == Thrift.Type.DOUBLE) {
                    this.diskReadRate = input.readDouble().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 24:
                if (ftype == Thrift.Type.DOUBLE) {
                    this.diskStoreRate = input.readDouble().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 25:
                if (ftype == Thrift.Type.DOUBLE) {
                    this.diskRemoveRate = input.readDouble().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 26:
                if (ftype == Thrift.Type.I64) {
                    this.diskCacheSize = input.readI64().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 27:
                if (ftype == Thrift.Type.I32) {
                    this.clientBufferMs = input.readI32().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 28:
                if (ftype == Thrift.Type.I32) {
                    this.lookupTotal = input.readI32().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 29:
                if (ftype == Thrift.Type.I32) {
                    this.lookupNotFound = input.readI32().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 30:
                if (ftype == Thrift.Type.I32) {
                    this.lookupFailed = input.readI32().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 31:
                if (ftype == Thrift.Type.I32) {
                    this.lookupLatency = input.readI32().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 32:
                if (ftype == Thrift.Type.I32) {
                    this.trackerFailed = input.readI32().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 33:
                if (ftype == Thrift.Type.I32) {
                    this.trackerLatency = input.readI32().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 34:
                if (ftype == Thrift.Type.I32) {
                    this.snapshotFailed = input.readI32().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 35:
                if (ftype == Thrift.Type.I32) {
                    this.snapshotLatency = input.readI32().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 36:
                if (ftype == Thrift.Type.I32) {
                    this.sourceLatency = input.readI32().value;
                } else {
                    input.skip(ftype);
                }
                break;
            default:
                input.skip(ftype);
        }
        input.readFieldEnd();
    }
    input.readStructEnd();
    return;
};

hive.snapshots.Metrics.prototype.write = function (output) {
    output.writeStructBegin("Metrics");
    if (this.upBW !== null && this.upBW !== undefined) {
        output.writeFieldBegin("upBW", Thrift.Type.I32, 1);
        output.writeI32(this.upBW);
        output.writeFieldEnd();
    }
    if (this.downBW !== null && this.downBW !== undefined) {
        output.writeFieldBegin("downBW", Thrift.Type.I32, 2);
        output.writeI32(this.downBW);
        output.writeFieldEnd();
    }
    if (this.memN !== null && this.memN !== undefined) {
        output.writeFieldBegin("memN", Thrift.Type.I32, 3);
        output.writeI32(this.memN);
        output.writeFieldEnd();
    }
    if (this.prtInN !== null && this.prtInN !== undefined) {
        output.writeFieldBegin("prtInN", Thrift.Type.I32, 4);
        output.writeI32(this.prtInN);
        output.writeFieldEnd();
    }
    if (this.prtOutN !== null && this.prtOutN !== undefined) {
        output.writeFieldBegin("prtOutN", Thrift.Type.I32, 5);
        output.writeI32(this.prtOutN);
        output.writeFieldEnd();
    }
    if (this.initVideoBufQt !== null && this.initVideoBufQt !== undefined) {
        output.writeFieldBegin("initVideoBufQt", Thrift.Type.I64, 6);
        output.writeI64(this.initVideoBufQt);
        output.writeFieldEnd();
    }
    if (this.videoAvgBufQt !== null && this.videoAvgBufQt !== undefined) {
        output.writeFieldBegin("videoAvgBufQt", Thrift.Type.DOUBLE, 7);
        output.writeDouble(this.videoAvgBufQt);
        output.writeFieldEnd();
    }
    if (this.videoBufQt !== null && this.videoBufQt !== undefined) {
        output.writeFieldBegin("videoBufQt", Thrift.Type.I64, 8);
        output.writeI64(this.videoBufQt);
        output.writeFieldEnd();
    }
    if (this.videoBufN !== null && this.videoBufN !== undefined) {
        output.writeFieldBegin("videoBufN", Thrift.Type.I32, 9);
        output.writeI32(this.videoBufN);
        output.writeFieldEnd();
    }
    if (this.initAudioBufQt !== null && this.initAudioBufQt !== undefined) {
        output.writeFieldBegin("initAudioBufQt", Thrift.Type.I32, 10);
        output.writeI32(this.initAudioBufQt);
        output.writeFieldEnd();
    }
    if (this.audioAvgBufQt !== null && this.audioAvgBufQt !== undefined) {
        output.writeFieldBegin("audioAvgBufQt", Thrift.Type.DOUBLE, 11);
        output.writeDouble(this.audioAvgBufQt);
        output.writeFieldEnd();
    }
    if (this.audioBufQt !== null && this.audioBufQt !== undefined) {
        output.writeFieldBegin("audioBufQt", Thrift.Type.I64, 12);
        output.writeI64(this.audioBufQt);
        output.writeFieldEnd();
    }
    if (this.audioBufN !== null && this.audioBufN !== undefined) {
        output.writeFieldBegin("audioBufN", Thrift.Type.I32, 13);
        output.writeI32(this.audioBufN);
        output.writeFieldEnd();
    }
    if (this.bitrateUpN !== null && this.bitrateUpN !== undefined) {
        output.writeFieldBegin("bitrateUpN", Thrift.Type.I32, 14);
        output.writeI32(this.bitrateUpN);
        output.writeFieldEnd();
    }
    if (this.bitrateDwnN !== null && this.bitrateDwnN !== undefined) {
        output.writeFieldBegin("bitrateDwnN", Thrift.Type.I32, 15);
        output.writeI32(this.bitrateDwnN);
        output.writeFieldEnd();
    }
    if (this.delay !== null && this.delay !== undefined) {
        output.writeFieldBegin("delay", Thrift.Type.I32, 16);
        output.writeI32(this.delay);
        output.writeFieldEnd();
    }
    if (this.delayEnforcement !== null && this.delayEnforcement !== undefined) {
        output.writeFieldBegin("delayEnforcement", Thrift.Type.I32, 17);
        output.writeI32(this.delayEnforcement);
        output.writeFieldEnd();
    }
    if (this.lookupReqEstablished !== null && this.lookupReqEstablished !== undefined) {
        output.writeFieldBegin("lookupReqEstablished", Thrift.Type.I32, 18);
        output.writeI32(this.lookupReqEstablished);
        output.writeFieldEnd();
    }
    if (this.lookupReqAccept !== null && this.lookupReqAccept !== undefined) {
        output.writeFieldBegin("lookupReqAccept", Thrift.Type.I32, 19);
        output.writeI32(this.lookupReqAccept);
        output.writeFieldEnd();
    }
    if (this.fallbackAvgTp !== null && this.fallbackAvgTp !== undefined) {
        output.writeFieldBegin("fallbackAvgTp", Thrift.Type.DOUBLE, 20);
        output.writeDouble(this.fallbackAvgTp);
        output.writeFieldEnd();
    }
    if (this.srcThroughput !== null && this.srcThroughput !== undefined) {
        output.writeFieldBegin("srcThroughput", Thrift.Type.DOUBLE, 21);
        output.writeDouble(this.srcThroughput);
        output.writeFieldEnd();
    }
    if (this.diskReadTimeout !== null && this.diskReadTimeout !== undefined) {
        output.writeFieldBegin("diskReadTimeout", Thrift.Type.I32, 22);
        output.writeI32(this.diskReadTimeout);
        output.writeFieldEnd();
    }
    if (this.diskReadRate !== null && this.diskReadRate !== undefined) {
        output.writeFieldBegin("diskReadRate", Thrift.Type.DOUBLE, 23);
        output.writeDouble(this.diskReadRate);
        output.writeFieldEnd();
    }
    if (this.diskStoreRate !== null && this.diskStoreRate !== undefined) {
        output.writeFieldBegin("diskStoreRate", Thrift.Type.DOUBLE, 24);
        output.writeDouble(this.diskStoreRate);
        output.writeFieldEnd();
    }
    if (this.diskRemoveRate !== null && this.diskRemoveRate !== undefined) {
        output.writeFieldBegin("diskRemoveRate", Thrift.Type.DOUBLE, 25);
        output.writeDouble(this.diskRemoveRate);
        output.writeFieldEnd();
    }
    if (this.diskCacheSize !== null && this.diskCacheSize !== undefined) {
        output.writeFieldBegin("diskCacheSize", Thrift.Type.I64, 26);
        output.writeI64(this.diskCacheSize);
        output.writeFieldEnd();
    }
    if (this.clientBufferMs !== null && this.clientBufferMs !== undefined) {
        output.writeFieldBegin("clientBufferMs", Thrift.Type.I32, 27);
        output.writeI32(this.clientBufferMs);
        output.writeFieldEnd();
    }
    if (this.lookupTotal !== null && this.lookupTotal !== undefined) {
        output.writeFieldBegin("lookupTotal", Thrift.Type.I32, 28);
        output.writeI32(this.lookupTotal);
        output.writeFieldEnd();
    }
    if (this.lookupNotFound !== null && this.lookupNotFound !== undefined) {
        output.writeFieldBegin("lookupNotFound", Thrift.Type.I32, 29);
        output.writeI32(this.lookupNotFound);
        output.writeFieldEnd();
    }
    if (this.lookupFailed !== null && this.lookupFailed !== undefined) {
        output.writeFieldBegin("lookupFailed", Thrift.Type.I32, 30);
        output.writeI32(this.lookupFailed);
        output.writeFieldEnd();
    }
    if (this.lookupLatency !== null && this.lookupLatency !== undefined) {
        output.writeFieldBegin("lookupLatency", Thrift.Type.I32, 31);
        output.writeI32(this.lookupLatency);
        output.writeFieldEnd();
    }
    if (this.trackerFailed !== null && this.trackerFailed !== undefined) {
        output.writeFieldBegin("trackerFailed", Thrift.Type.I32, 32);
        output.writeI32(this.trackerFailed);
        output.writeFieldEnd();
    }
    if (this.trackerLatency !== null && this.trackerLatency !== undefined) {
        output.writeFieldBegin("trackerLatency", Thrift.Type.I32, 33);
        output.writeI32(this.trackerLatency);
        output.writeFieldEnd();
    }
    if (this.snapshotFailed !== null && this.snapshotFailed !== undefined) {
        output.writeFieldBegin("snapshotFailed", Thrift.Type.I32, 34);
        output.writeI32(this.snapshotFailed);
        output.writeFieldEnd();
    }
    if (this.snapshotLatency !== null && this.snapshotLatency !== undefined) {
        output.writeFieldBegin("snapshotLatency", Thrift.Type.I32, 35);
        output.writeI32(this.snapshotLatency);
        output.writeFieldEnd();
    }
    if (this.sourceLatency !== null && this.sourceLatency !== undefined) {
        output.writeFieldBegin("sourceLatency", Thrift.Type.I32, 36);
        output.writeI32(this.sourceLatency);
        output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
};

hive.snapshots.PartnerTraffic = function (args) {
    this.p2pSuccReq = null;
    this.p2pFailReq = null;
    this.p2pPartReq = null;
    this.p2pSuccReceived = null;
    this.p2pSuccReceivedLow = null;
    this.p2pFailReceived = null;
    this.p2pSuccResp = null;
    this.p2pFailResp = null;
    this.p2pPartResp = null;
    this.p2pSuccSent = null;
    this.p2pSuccSentLow = null;
    this.p2pFailSent = null;
    if (args) {
        if (args.p2pSuccReq !== undefined && args.p2pSuccReq !== null) {
            this.p2pSuccReq = args.p2pSuccReq;
        }
        if (args.p2pFailReq !== undefined && args.p2pFailReq !== null) {
            this.p2pFailReq = args.p2pFailReq;
        }
        if (args.p2pPartReq !== undefined && args.p2pPartReq !== null) {
            this.p2pPartReq = args.p2pPartReq;
        }
        if (args.p2pSuccReceived !== undefined && args.p2pSuccReceived !== null) {
            this.p2pSuccReceived = args.p2pSuccReceived;
        }
        if (args.p2pSuccReceivedLow !== undefined && args.p2pSuccReceivedLow !== null) {
            this.p2pSuccReceivedLow = args.p2pSuccReceivedLow;
        }
        if (args.p2pFailReceived !== undefined && args.p2pFailReceived !== null) {
            this.p2pFailReceived = args.p2pFailReceived;
        }
        if (args.p2pSuccResp !== undefined && args.p2pSuccResp !== null) {
            this.p2pSuccResp = args.p2pSuccResp;
        }
        if (args.p2pFailResp !== undefined && args.p2pFailResp !== null) {
            this.p2pFailResp = args.p2pFailResp;
        }
        if (args.p2pPartResp !== undefined && args.p2pPartResp !== null) {
            this.p2pPartResp = args.p2pPartResp;
        }
        if (args.p2pSuccSent !== undefined && args.p2pSuccSent !== null) {
            this.p2pSuccSent = args.p2pSuccSent;
        }
        if (args.p2pSuccSentLow !== undefined && args.p2pSuccSentLow !== null) {
            this.p2pSuccSentLow = args.p2pSuccSentLow;
        }
        if (args.p2pFailSent !== undefined && args.p2pFailSent !== null) {
            this.p2pFailSent = args.p2pFailSent;
        }
    }
};
hive.snapshots.PartnerTraffic.prototype = {};
hive.snapshots.PartnerTraffic.prototype.read = function (input) {
    input.readStructBegin();
    while (true) {
        var ret = input.readFieldBegin();
        var fname = ret.fname;
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
            break;
        }
        switch (fid) {
            case 1:
                if (ftype == Thrift.Type.I64) {
                    this.p2pSuccReq = input.readI64().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 2:
                if (ftype == Thrift.Type.I64) {
                    this.p2pFailReq = input.readI64().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 3:
                if (ftype == Thrift.Type.I64) {
                    this.p2pPartReq = input.readI64().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 4:
                if (ftype == Thrift.Type.I64) {
                    this.p2pSuccReceived = input.readI64().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 5:
                if (ftype == Thrift.Type.I64) {
                    this.p2pSuccReceivedLow = input.readI64().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 10:
                if (ftype == Thrift.Type.I64) {
                    this.p2pFailReceived = input.readI64().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 6:
                if (ftype == Thrift.Type.I64) {
                    this.p2pSuccResp = input.readI64().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 11:
                if (ftype == Thrift.Type.I64) {
                    this.p2pFailResp = input.readI64().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 7:
                if (ftype == Thrift.Type.I64) {
                    this.p2pPartResp = input.readI64().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 8:
                if (ftype == Thrift.Type.I64) {
                    this.p2pSuccSent = input.readI64().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 9:
                if (ftype == Thrift.Type.I64) {
                    this.p2pSuccSentLow = input.readI64().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 12:
                if (ftype == Thrift.Type.I64) {
                    this.p2pFailSent = input.readI64().value;
                } else {
                    input.skip(ftype);
                }
                break;
            default:
                input.skip(ftype);
        }
        input.readFieldEnd();
    }
    input.readStructEnd();
    return;
};

hive.snapshots.PartnerTraffic.prototype.write = function (output) {
    output.writeStructBegin("PartnerTraffic");
    if (this.p2pSuccReq !== null && this.p2pSuccReq !== undefined) {
        output.writeFieldBegin("p2pSuccReq", Thrift.Type.I64, 1);
        output.writeI64(this.p2pSuccReq);
        output.writeFieldEnd();
    }
    if (this.p2pFailReq !== null && this.p2pFailReq !== undefined) {
        output.writeFieldBegin("p2pFailReq", Thrift.Type.I64, 2);
        output.writeI64(this.p2pFailReq);
        output.writeFieldEnd();
    }
    if (this.p2pPartReq !== null && this.p2pPartReq !== undefined) {
        output.writeFieldBegin("p2pPartReq", Thrift.Type.I64, 3);
        output.writeI64(this.p2pPartReq);
        output.writeFieldEnd();
    }
    if (this.p2pSuccReceived !== null && this.p2pSuccReceived !== undefined) {
        output.writeFieldBegin("p2pSuccReceived", Thrift.Type.I64, 4);
        output.writeI64(this.p2pSuccReceived);
        output.writeFieldEnd();
    }
    if (this.p2pSuccReceivedLow !== null && this.p2pSuccReceivedLow !== undefined) {
        output.writeFieldBegin("p2pSuccReceivedLow", Thrift.Type.I64, 5);
        output.writeI64(this.p2pSuccReceivedLow);
        output.writeFieldEnd();
    }
    if (this.p2pFailReceived !== null && this.p2pFailReceived !== undefined) {
        output.writeFieldBegin("p2pFailReceived", Thrift.Type.I64, 10);
        output.writeI64(this.p2pFailReceived);
        output.writeFieldEnd();
    }
    if (this.p2pSuccResp !== null && this.p2pSuccResp !== undefined) {
        output.writeFieldBegin("p2pSuccResp", Thrift.Type.I64, 6);
        output.writeI64(this.p2pSuccResp);
        output.writeFieldEnd();
    }
    if (this.p2pFailResp !== null && this.p2pFailResp !== undefined) {
        output.writeFieldBegin("p2pFailResp", Thrift.Type.I64, 11);
        output.writeI64(this.p2pFailResp);
        output.writeFieldEnd();
    }
    if (this.p2pPartResp !== null && this.p2pPartResp !== undefined) {
        output.writeFieldBegin("p2pPartResp", Thrift.Type.I64, 7);
        output.writeI64(this.p2pPartResp);
        output.writeFieldEnd();
    }
    if (this.p2pSuccSent !== null && this.p2pSuccSent !== undefined) {
        output.writeFieldBegin("p2pSuccSent", Thrift.Type.I64, 8);
        output.writeI64(this.p2pSuccSent);
        output.writeFieldEnd();
    }
    if (this.p2pSuccSentLow !== null && this.p2pSuccSentLow !== undefined) {
        output.writeFieldBegin("p2pSuccSentLow", Thrift.Type.I64, 9);
        output.writeI64(this.p2pSuccSentLow);
        output.writeFieldEnd();
    }
    if (this.p2pFailSent !== null && this.p2pFailSent !== undefined) {
        output.writeFieldBegin("p2pFailSent", Thrift.Type.I64, 12);
        output.writeI64(this.p2pFailSent);
        output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
};

hive.snapshots.PartnerMetrics = function (args) {
    this.rateReceived = null;
    this.rateSent = null;
    this.handshakeDelay = null;
    if (args) {
        if (args.rateReceived !== undefined && args.rateReceived !== null) {
            this.rateReceived = args.rateReceived;
        }
        if (args.rateSent !== undefined && args.rateSent !== null) {
            this.rateSent = args.rateSent;
        }
        if (args.handshakeDelay !== undefined && args.handshakeDelay !== null) {
            this.handshakeDelay = args.handshakeDelay;
        }
    }
};
hive.snapshots.PartnerMetrics.prototype = {};
hive.snapshots.PartnerMetrics.prototype.read = function (input) {
    input.readStructBegin();
    while (true) {
        var ret = input.readFieldBegin();
        var fname = ret.fname;
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
            break;
        }
        switch (fid) {
            case 1:
                if (ftype == Thrift.Type.DOUBLE) {
                    this.rateReceived = input.readDouble().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 2:
                if (ftype == Thrift.Type.DOUBLE) {
                    this.rateSent = input.readDouble().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 3:
                if (ftype == Thrift.Type.I64) {
                    this.handshakeDelay = input.readI64().value;
                } else {
                    input.skip(ftype);
                }
                break;
            default:
                input.skip(ftype);
        }
        input.readFieldEnd();
    }
    input.readStructEnd();
    return;
};

hive.snapshots.PartnerMetrics.prototype.write = function (output) {
    output.writeStructBegin("PartnerMetrics");
    if (this.rateReceived !== null && this.rateReceived !== undefined) {
        output.writeFieldBegin("rateReceived", Thrift.Type.DOUBLE, 1);
        output.writeDouble(this.rateReceived);
        output.writeFieldEnd();
    }
    if (this.rateSent !== null && this.rateSent !== undefined) {
        output.writeFieldBegin("rateSent", Thrift.Type.DOUBLE, 2);
        output.writeDouble(this.rateSent);
        output.writeFieldEnd();
    }
    if (this.handshakeDelay !== null && this.handshakeDelay !== undefined) {
        output.writeFieldBegin("handshakeDelay", Thrift.Type.I64, 3);
        output.writeI64(this.handshakeDelay);
        output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
};

hive.snapshots.ConnectivityInfo = function (args) {
    this.upBW = null;
    this.downBW = null;
    this.externalAs = null;
    this.internalAs = null;
    this.publicIp = null;
    this.privateIp = null;
    this.localityGroupId = null;
    this.isVpn = null;
    if (args) {
        if (args.upBW !== undefined && args.upBW !== null) {
            this.upBW = args.upBW;
        }
        if (args.downBW !== undefined && args.downBW !== null) {
            this.downBW = args.downBW;
        }
        if (args.externalAs !== undefined && args.externalAs !== null) {
            this.externalAs = args.externalAs;
        }
        if (args.internalAs !== undefined && args.internalAs !== null) {
            this.internalAs = args.internalAs;
        }
        if (args.publicIp !== undefined && args.publicIp !== null) {
            this.publicIp = args.publicIp;
        }
        if (args.privateIp !== undefined && args.privateIp !== null) {
            this.privateIp = args.privateIp;
        }
        if (args.localityGroupId !== undefined && args.localityGroupId !== null) {
            this.localityGroupId = args.localityGroupId;
        }
        if (args.isVpn !== undefined && args.isVpn !== null) {
            this.isVpn = args.isVpn;
        }
    }
};
hive.snapshots.ConnectivityInfo.prototype = {};
hive.snapshots.ConnectivityInfo.prototype.read = function (input) {
    input.readStructBegin();
    while (true) {
        var ret = input.readFieldBegin();
        var fname = ret.fname;
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
            break;
        }
        switch (fid) {
            case 1:
                if (ftype == Thrift.Type.I32) {
                    this.upBW = input.readI32().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 2:
                if (ftype == Thrift.Type.I32) {
                    this.downBW = input.readI32().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 3:
                if (ftype == Thrift.Type.I32) {
                    this.externalAs = input.readI32().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 4:
                if (ftype == Thrift.Type.I32) {
                    this.internalAs = input.readI32().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 5:
                if (ftype == Thrift.Type.STRING) {
                    this.publicIp = input.readString().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 6:
                if (ftype == Thrift.Type.STRING) {
                    this.privateIp = input.readString().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 7:
                if (ftype == Thrift.Type.I32) {
                    this.localityGroupId = input.readI32().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 8:
                if (ftype == Thrift.Type.BOOL) {
                    this.isVpn = input.readBool().value;
                } else {
                    input.skip(ftype);
                }
                break;
            default:
                input.skip(ftype);
        }
        input.readFieldEnd();
    }
    input.readStructEnd();
    return;
};

hive.snapshots.ConnectivityInfo.prototype.write = function (output) {
    output.writeStructBegin("ConnectivityInfo");
    if (this.upBW !== null && this.upBW !== undefined) {
        output.writeFieldBegin("upBW", Thrift.Type.I32, 1);
        output.writeI32(this.upBW);
        output.writeFieldEnd();
    }
    if (this.downBW !== null && this.downBW !== undefined) {
        output.writeFieldBegin("downBW", Thrift.Type.I32, 2);
        output.writeI32(this.downBW);
        output.writeFieldEnd();
    }
    if (this.externalAs !== null && this.externalAs !== undefined) {
        output.writeFieldBegin("externalAs", Thrift.Type.I32, 3);
        output.writeI32(this.externalAs);
        output.writeFieldEnd();
    }
    if (this.internalAs !== null && this.internalAs !== undefined) {
        output.writeFieldBegin("internalAs", Thrift.Type.I32, 4);
        output.writeI32(this.internalAs);
        output.writeFieldEnd();
    }
    if (this.publicIp !== null && this.publicIp !== undefined) {
        output.writeFieldBegin("publicIp", Thrift.Type.STRING, 5);
        output.writeString(this.publicIp);
        output.writeFieldEnd();
    }
    if (this.privateIp !== null && this.privateIp !== undefined) {
        output.writeFieldBegin("privateIp", Thrift.Type.STRING, 6);
        output.writeString(this.privateIp);
        output.writeFieldEnd();
    }
    if (this.localityGroupId !== null && this.localityGroupId !== undefined) {
        output.writeFieldBegin('localityGroupId', Thrift.Type.I32, 7);
        output.writeI32(this.localityGroupId);
        output.writeFieldEnd();
    }
    if (this.isVpn !== null && this.isVpn !== undefined) {
        output.writeFieldBegin("isVpn", Thrift.Type.BOOL, 8);
        output.writeBool(this.isVpn);
        output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
};

hive.snapshots.Partner = function (args) {
    this.connInfo = null;
    this.traffic = null;
    this.metrics = null;
    this.inPart = null;
    this.outPart = null;
    this.udp = null;
    if (args) {
        if (args.connInfo !== undefined && args.connInfo !== null) {
            this.connInfo = new hive.snapshots.ConnectivityInfo(args.connInfo);
        }
        if (args.traffic !== undefined && args.traffic !== null) {
            this.traffic = new hive.snapshots.PartnerTraffic(args.traffic);
        }
        if (args.metrics !== undefined && args.metrics !== null) {
            this.metrics = new hive.snapshots.PartnerMetrics(args.metrics);
        }
        if (args.inPart !== undefined && args.inPart !== null) {
            this.inPart = args.inPart;
        }
        if (args.outPart !== undefined && args.outPart !== null) {
            this.outPart = args.outPart;
        }
        if (args.udp !== undefined && args.udp !== null) {
            this.udp = args.udp;
        }
    }
};
hive.snapshots.Partner.prototype = {};
hive.snapshots.Partner.prototype.read = function (input) {
    input.readStructBegin();
    while (true) {
        var ret = input.readFieldBegin();
        var fname = ret.fname;
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
            break;
        }
        switch (fid) {
            case 1:
                if (ftype == Thrift.Type.STRUCT) {
                    this.connInfo = new hive.snapshots.ConnectivityInfo();
                    this.connInfo.read(input);
                } else {
                    input.skip(ftype);
                }
                break;
            case 2:
                if (ftype == Thrift.Type.STRUCT) {
                    this.traffic = new hive.snapshots.PartnerTraffic();
                    this.traffic.read(input);
                } else {
                    input.skip(ftype);
                }
                break;
            case 3:
                if (ftype == Thrift.Type.STRUCT) {
                    this.metrics = new hive.snapshots.PartnerMetrics();
                    this.metrics.read(input);
                } else {
                    input.skip(ftype);
                }
                break;
            case 4:
                if (ftype == Thrift.Type.BOOL) {
                    this.inPart = input.readBool().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 5:
                if (ftype == Thrift.Type.BOOL) {
                    this.outPart = input.readBool().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 6:
                if (ftype == Thrift.Type.BOOL) {
                    this.udp = input.readBool().value;
                } else {
                    input.skip(ftype);
                }
                break;
            default:
                input.skip(ftype);
        }
        input.readFieldEnd();
    }
    input.readStructEnd();
    return;
};

hive.snapshots.Partner.prototype.write = function (output) {
    output.writeStructBegin("Partner");
    if (this.connInfo !== null && this.connInfo !== undefined) {
        output.writeFieldBegin("connInfo", Thrift.Type.STRUCT, 1);
        this.connInfo.write(output);
        output.writeFieldEnd();
    }
    if (this.traffic !== null && this.traffic !== undefined) {
        output.writeFieldBegin("traffic", Thrift.Type.STRUCT, 2);
        this.traffic.write(output);
        output.writeFieldEnd();
    }
    if (this.metrics !== null && this.metrics !== undefined) {
        output.writeFieldBegin("metrics", Thrift.Type.STRUCT, 3);
        this.metrics.write(output);
        output.writeFieldEnd();
    }
    if (this.inPart !== null && this.inPart !== undefined) {
        output.writeFieldBegin("inPart", Thrift.Type.BOOL, 4);
        output.writeBool(this.inPart);
        output.writeFieldEnd();
    }
    if (this.outPart !== null && this.outPart !== undefined) {
        output.writeFieldBegin("outPart", Thrift.Type.BOOL, 5);
        output.writeBool(this.outPart);
        output.writeFieldEnd();
    }
    if (this.udp !== null && this.udp !== undefined) {
        output.writeFieldBegin("udp", Thrift.Type.BOOL, 6);
        output.writeBool(this.udp);
        output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
};

hive.snapshots.MetadataInfo = function (args) {
    this.timestamp = null;
    this.availableFragments = null;
    this.firstFragment = null;
    this.lastFragment = null;
    this.trimmedFragments = null;
    this.avgDuration = null;
    this.timescale = null;
    this.autogenerated = null;
    if (args) {
        if (args.timestamp !== undefined && args.timestamp !== null) {
            this.timestamp = args.timestamp;
        }
        if (args.availableFragments !== undefined && args.availableFragments !== null) {
            this.availableFragments = args.availableFragments;
        }
        if (args.firstFragment !== undefined && args.firstFragment !== null) {
            this.firstFragment = args.firstFragment;
        }
        if (args.lastFragment !== undefined && args.lastFragment !== null) {
            this.lastFragment = args.lastFragment;
        }
        if (args.trimmedFragments !== undefined && args.trimmedFragments !== null) {
            this.trimmedFragments = args.trimmedFragments;
        }
        if (args.avgDuration !== undefined && args.avgDuration !== null) {
            this.avgDuration = args.avgDuration;
        }
        if (args.timescale !== undefined && args.timescale !== null) {
            this.timescale = args.timescale;
        }
        if (args.autogenerated !== undefined && args.autogenerated !== null) {
            this.autogenerated = args.autogenerated;
        }
    }
};
hive.snapshots.MetadataInfo.prototype = {};
hive.snapshots.MetadataInfo.prototype.read = function (input) {
    input.readStructBegin();
    while (true) {
        var ret = input.readFieldBegin();
        var fname = ret.fname;
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
            break;
        }
        switch (fid) {
            case 1:
                if (ftype == Thrift.Type.I64) {
                    this.timestamp = input.readI64().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 2:
                if (ftype == Thrift.Type.I32) {
                    this.availableFragments = input.readI32().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 3:
                if (ftype == Thrift.Type.I64) {
                    this.firstFragment = input.readI64().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 4:
                if (ftype == Thrift.Type.I64) {
                    this.lastFragment = input.readI64().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 5:
                if (ftype == Thrift.Type.I32) {
                    this.trimmedFragments = input.readI32().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 6:
                if (ftype == Thrift.Type.I64) {
                    this.avgDuration = input.readI64().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 7:
                if (ftype == Thrift.Type.I64) {
                    this.timescale = input.readI64().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 8:
                if (ftype == Thrift.Type.BOOL) {
                    this.autogenerated = input.readBool().value;
                } else {
                    input.skip(ftype);
                }
                break;
            default:
                input.skip(ftype);
        }
        input.readFieldEnd();
    }
    input.readStructEnd();
    return;
};

hive.snapshots.MetadataInfo.prototype.write = function (output) {
    output.writeStructBegin("MetadataInfo");
    if (this.timestamp !== null && this.timestamp !== undefined) {
        output.writeFieldBegin("timestamp", Thrift.Type.I64, 1);
        output.writeI64(this.timestamp);
        output.writeFieldEnd();
    }
    if (this.availableFragments !== null && this.availableFragments !== undefined) {
        output.writeFieldBegin("availableFragments", Thrift.Type.I32, 2);
        output.writeI32(this.availableFragments);
        output.writeFieldEnd();
    }
    if (this.firstFragment !== null && this.firstFragment !== undefined) {
        output.writeFieldBegin("firstFragment", Thrift.Type.I64, 3);
        output.writeI64(this.firstFragment);
        output.writeFieldEnd();
    }
    if (this.lastFragment !== null && this.lastFragment !== undefined) {
        output.writeFieldBegin("lastFragment", Thrift.Type.I64, 4);
        output.writeI64(this.lastFragment);
        output.writeFieldEnd();
    }
    if (this.trimmedFragments !== null && this.trimmedFragments !== undefined) {
        output.writeFieldBegin("trimmedFragments", Thrift.Type.I32, 5);
        output.writeI32(this.trimmedFragments);
        output.writeFieldEnd();
    }
    if (this.avgDuration !== null && this.avgDuration !== undefined) {
        output.writeFieldBegin("avgDuration", Thrift.Type.I64, 6);
        output.writeI64(this.avgDuration);
        output.writeFieldEnd();
    }
    if (this.timescale !== null && this.timescale !== undefined) {
        output.writeFieldBegin("timescale", Thrift.Type.I64, 7);
        output.writeI64(this.timescale);
        output.writeFieldEnd();
    }
    if (this.autogenerated !== null && this.autogenerated !== undefined) {
        output.writeFieldBegin("autogenerated", Thrift.Type.BOOL, 8);
        output.writeBool(this.autogenerated);
        output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
};

hive.snapshots.TextTrack = function(args) {
    this.kind = null;
    this.label = null;
    this.language = null;
    if (args) {
        if (args.kind !== undefined && args.kind !== null) {
            this.kind = args.kind;
        }
        if (args.label !== undefined && args.label !== null) {
            this.label = args.label;
        }
        if (args.language !== undefined && args.language !== null) {
            this.language = args.language;
        }
    }
};
hive.snapshots.TextTrack.prototype = {};
hive.snapshots.TextTrack.prototype.read = function(input) {
    input.readStructBegin();
    while (true)
    {
        var ret = input.readFieldBegin();
        var fname = ret.fname;
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
            break;
        }
        switch (fid)
        {
            case 1:
            if (ftype == Thrift.Type.STRING) {
                this.kind = input.readString().value;
            } else {
                input.skip(ftype);
            }
            break;
            case 2:
            if (ftype == Thrift.Type.STRING) {
                this.label = input.readString().value;
            } else {
                input.skip(ftype);
            }
            break;
            case 3:
            if (ftype == Thrift.Type.STRING) {
                this.language = input.readString().value;
            } else {
                input.skip(ftype);
            }
            break;
            default:
            input.skip(ftype);
        }
        input.readFieldEnd();
    }
    input.readStructEnd();
    return;
};

hive.snapshots.TextTrack.prototype.write = function(output) {
    output.writeStructBegin('TextTrack');
    if (this.kind !== null && this.kind !== undefined) {
        output.writeFieldBegin('kind', Thrift.Type.STRING, 1);
        output.writeString(this.kind);
        output.writeFieldEnd();
    }
    if (this.label !== null && this.label !== undefined) {
        output.writeFieldBegin('label', Thrift.Type.STRING, 2);
        output.writeString(this.label);
        output.writeFieldEnd();
    }
    if (this.language !== null && this.language !== undefined) {
        output.writeFieldBegin('language', Thrift.Type.STRING, 3);
        output.writeString(this.language);
        output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
};

hive.snapshots.StreamInfo = function (args) {
    this.url = null;
    this.streamType = null;
    this.streamProtocol = null;
    this.duration = null;
    this.qualityLevels = null;
    this.metadataInfo = null;
    this.textTracks = null;
    if (args) {
        if (args.url !== undefined && args.url !== null) {
            this.url = args.url;
        }
        if (args.streamType !== undefined && args.streamType !== null) {
            this.streamType = args.streamType;
        }
        if (args.streamProtocol !== undefined && args.streamProtocol !== null) {
            this.streamProtocol = args.streamProtocol;
        }
        if (args.duration !== undefined && args.duration !== null) {
            this.duration = args.duration;
        }
        if (args.qualityLevels !== undefined && args.qualityLevels !== null) {
            this.qualityLevels = Thrift.copyList(args.qualityLevels, [hive.snapshots.QualityLevel]);
        }
        if (args.metadataInfo !== undefined && args.metadataInfo !== null) {
            this.metadataInfo = Thrift.copyList(args.metadataInfo, [hive.snapshots.MetadataInfo]);
        }
        if (args.metadataInfo !== undefined && args.metadataInfo !== null) {
            this.metadataInfo = Thrift.copyList(args.metadataInfo, [hive.snapshots.MetadataInfo]);
        }
        if (args.textTracks !== undefined && args.textTracks !== null) {
            this.textTracks = Thrift.copyList(args.textTracks, [hive.snapshots.TextTrack]);
        }
    }
};
hive.snapshots.StreamInfo.prototype = {};
hive.snapshots.StreamInfo.prototype.read = function (input) {
    input.readStructBegin();
    while (true) {
        var ret = input.readFieldBegin();
        var fname = ret.fname;
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
            break;
        }
        switch (fid) {
            case 1:
                if (ftype == Thrift.Type.STRING) {
                    this.url = input.readString().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 2:
                if (ftype == Thrift.Type.I32) {
                    this.streamType = input.readI32().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 3:
                if (ftype == Thrift.Type.I32) {
                    this.streamProtocol = input.readI32().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 4:
                if (ftype == Thrift.Type.I32) {
                    this.duration = input.readI32().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 5:
                if (ftype == Thrift.Type.LIST) {
                    var _size8 = 0;
                    var _rtmp312;
                    this.qualityLevels = [];
                    var _etype11 = 0;
                    _rtmp312 = input.readListBegin();
                    _etype11 = _rtmp312.etype;
                    _size8 = _rtmp312.size;
                    for (var _i13 = 0; _i13 < _size8; ++_i13) {
                        var elem14 = null;
                        elem14 = new hive.snapshots.QualityLevel();
                        elem14.read(input);
                        this.qualityLevels.push(elem14);
                    }
                    input.readListEnd();
                } else {
                    input.skip(ftype);
                }
                break;
            case 6:
                if (ftype == Thrift.Type.LIST) {
                    var _size15 = 0;
                    var _rtmp319;
                    this.metadataInfo = [];
                    var _etype18 = 0;
                    _rtmp319 = input.readListBegin();
                    _etype18 = _rtmp319.etype;
                    _size15 = _rtmp319.size;
                    for (var _i20 = 0; _i20 < _size15; ++_i20) {
                        var elem21 = null;
                        elem21 = new hive.snapshots.MetadataInfo();
                        elem21.read(input);
                        this.metadataInfo.push(elem21);
                    }
                    input.readListEnd();
                } else {
                    input.skip(ftype);
                }
                break;
            default:
                input.skip(ftype);
        }
        input.readFieldEnd();
    }
    input.readStructEnd();
    return;
};

hive.snapshots.StreamInfo.prototype.write = function (output) {
    output.writeStructBegin("StreamInfo");
    if (this.url !== null && this.url !== undefined) {
        output.writeFieldBegin("url", Thrift.Type.STRING, 1);
        output.writeString(this.url);
        output.writeFieldEnd();
    }
    if (this.streamType !== null && this.streamType !== undefined) {
        output.writeFieldBegin("streamType", Thrift.Type.I32, 2);
        output.writeI32(this.streamType);
        output.writeFieldEnd();
    }
    if (this.streamProtocol !== null && this.streamProtocol !== undefined) {
        output.writeFieldBegin("streamProtocol", Thrift.Type.I32, 3);
        output.writeI32(this.streamProtocol);
        output.writeFieldEnd();
    }
    if (this.duration !== null && this.duration !== undefined) {
        output.writeFieldBegin("duration", Thrift.Type.I32, 4);
        output.writeI32(this.duration);
        output.writeFieldEnd();
    }
    if (this.qualityLevels !== null && this.qualityLevels !== undefined) {
        output.writeFieldBegin("qualityLevels", Thrift.Type.LIST, 5);
        output.writeListBegin(Thrift.Type.STRUCT, this.qualityLevels.length);
        for (var iter22 in this.qualityLevels) {
            if (this.qualityLevels.hasOwnProperty(iter22)) {
                iter22 = this.qualityLevels[iter22];
                iter22.write(output);
            }
        }
        output.writeListEnd();
        output.writeFieldEnd();
    }
    if (this.metadataInfo !== null && this.metadataInfo !== undefined) {
        output.writeFieldBegin("metadataInfo", Thrift.Type.LIST, 6);
        output.writeListBegin(Thrift.Type.STRUCT, this.metadataInfo.length);
        for (var iter23 in this.metadataInfo) {
            if (this.metadataInfo.hasOwnProperty(iter23)) {
                iter23 = this.metadataInfo[iter23];
                iter23.write(output);
            }
        }
        output.writeListEnd();
        output.writeFieldEnd();
    }
    if (this.metadataInfo !== null && this.metadataInfo !== undefined) {
        output.writeFieldBegin('metadataInfo', Thrift.Type.LIST, 6);
        output.writeListBegin(Thrift.Type.STRUCT, this.metadataInfo.length);
        for (var iter23 in this.metadataInfo) {
            if (this.metadataInfo.hasOwnProperty(iter23)) {
                iter23 = this.metadataInfo[iter23];
                iter23.write(output);
            }
        }
        output.writeListEnd();
        output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
};

hive.snapshots.ClientInfo = function (args) {
    this.clientType = null;
    this.majorVersion = null;
    this.minorVersion = null;
    this.patchVersion = null;
    if (args) {
        if (args.clientType !== undefined && args.clientType !== null) {
            this.clientType = args.clientType;
        }
        if (args.majorVersion !== undefined && args.majorVersion !== null) {
            this.majorVersion = args.majorVersion;
        }
        if (args.minorVersion !== undefined && args.minorVersion !== null) {
            this.minorVersion = args.minorVersion;
        }
        if (args.patchVersion !== undefined && args.patchVersion !== null) {
            this.patchVersion = args.patchVersion;
        }
    }
};
hive.snapshots.ClientInfo.prototype = {};
hive.snapshots.ClientInfo.prototype.read = function (input) {
    input.readStructBegin();
    while (true) {
        var ret = input.readFieldBegin();
        var fname = ret.fname;
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
            break;
        }
        switch (fid) {
            case 1:
                if (ftype == Thrift.Type.I32) {
                    this.clientType = input.readI32().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 2:
                if (ftype == Thrift.Type.BYTE) {
                    this.majorVersion = input.readByte().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 3:
                if (ftype == Thrift.Type.BYTE) {
                    this.minorVersion = input.readByte().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 4:
                if (ftype == Thrift.Type.I16) {
                    this.patchVersion = input.readI16().value;
                } else {
                    input.skip(ftype);
                }
                break;
            default:
                input.skip(ftype);
        }
        input.readFieldEnd();
    }
    input.readStructEnd();
    return;
};

hive.snapshots.ClientInfo.prototype.write = function (output) {
    output.writeStructBegin("ClientInfo");
    if (this.clientType !== null && this.clientType !== undefined) {
        output.writeFieldBegin("clientType", Thrift.Type.I32, 1);
        output.writeI32(this.clientType);
        output.writeFieldEnd();
    }
    if (this.majorVersion !== null && this.majorVersion !== undefined) {
        output.writeFieldBegin("majorVersion", Thrift.Type.BYTE, 2);
        output.writeByte(this.majorVersion);
        output.writeFieldEnd();
    }
    if (this.minorVersion !== null && this.minorVersion !== undefined) {
        output.writeFieldBegin("minorVersion", Thrift.Type.BYTE, 3);
        output.writeByte(this.minorVersion);
        output.writeFieldEnd();
    }
    if (this.patchVersion !== null && this.patchVersion !== undefined) {
        output.writeFieldBegin("patchVersion", Thrift.Type.I16, 4);
        output.writeI16(this.patchVersion);
        output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
};

hive.snapshots.AgentInfo = function (args) {
    this.firstTierBitrates = null;
    this.secondTierBitrates = null;
    if (args) {
        if (args.firstTierBitrates !== undefined && args.firstTierBitrates !== null) {
            this.firstTierBitrates = Thrift.copyList(args.firstTierBitrates, [null]);
        }
        if (args.secondTierBitrates !== undefined && args.secondTierBitrates !== null) {
            this.secondTierBitrates = Thrift.copyList(args.secondTierBitrates, [null]);
        }
    }
};
hive.snapshots.AgentInfo.prototype = {};
hive.snapshots.AgentInfo.prototype.read = function (input) {
    input.readStructBegin();
    while (true) {
        var ret = input.readFieldBegin();
        var fname = ret.fname;
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
            break;
        }
        switch (fid) {
            case 1:
                if (ftype == Thrift.Type.SET) {
                    var _size24 = 0;
                    var _rtmp328;
                    this.firstTierBitrates = [];
                    var _etype27 = 0;
                    _rtmp328 = input.readSetBegin();
                    _etype27 = _rtmp328.etype;
                    _size24 = _rtmp328.size;
                    for (var _i29 = 0; _i29 < _size24; ++_i29) {
                        var elem30 = null;
                        elem30 = input.readI32().value;
                        this.firstTierBitrates.push(elem30);
                    }
                    input.readSetEnd();
                } else {
                    input.skip(ftype);
                }
                break;
            case 2:
                if (ftype == Thrift.Type.SET) {
                    var _size31 = 0;
                    var _rtmp335;
                    this.secondTierBitrates = [];
                    var _etype34 = 0;
                    _rtmp335 = input.readSetBegin();
                    _etype34 = _rtmp335.etype;
                    _size31 = _rtmp335.size;
                    for (var _i36 = 0; _i36 < _size31; ++_i36) {
                        var elem37 = null;
                        elem37 = input.readI32().value;
                        this.secondTierBitrates.push(elem37);
                    }
                    input.readSetEnd();
                } else {
                    input.skip(ftype);
                }
                break;
            default:
                input.skip(ftype);
        }
        input.readFieldEnd();
    }
    input.readStructEnd();
    return;
};

hive.snapshots.AgentInfo.prototype.write = function (output) {
    output.writeStructBegin("AgentInfo");
    if (this.firstTierBitrates !== null && this.firstTierBitrates !== undefined) {
        output.writeFieldBegin("firstTierBitrates", Thrift.Type.SET, 1);
        output.writeSetBegin(Thrift.Type.I32, this.firstTierBitrates.length);
        for (var iter38 in this.firstTierBitrates) {
            if (this.firstTierBitrates.hasOwnProperty(iter38)) {
                iter38 = this.firstTierBitrates[iter38];
                output.writeI32(iter38);
            }
        }
        output.writeSetEnd();
        output.writeFieldEnd();
    }
    if (this.secondTierBitrates !== null && this.secondTierBitrates !== undefined) {
        output.writeFieldBegin("secondTierBitrates", Thrift.Type.SET, 2);
        output.writeSetBegin(Thrift.Type.I32, this.secondTierBitrates.length);
        for (var iter39 in this.secondTierBitrates) {
            if (this.secondTierBitrates.hasOwnProperty(iter39)) {
                iter39 = this.secondTierBitrates[iter39];
                output.writeI32(iter39);
            }
        }
        output.writeSetEnd();
        output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
};

hive.snapshots.TrafficKey = function (args) {
    this.bitrate = null;
    this.AS = null;
    this.partnerGuid = null;
    this.qualityLevelId = null;
    if (args) {
        if (args.bitrate !== undefined && args.bitrate !== null) {
            this.bitrate = args.bitrate;
        }
        if (args.AS !== undefined && args.AS !== null) {
            this.AS = args.AS;
        }
        if (args.partnerGuid !== undefined && args.partnerGuid !== null) {
            this.partnerGuid = args.partnerGuid;
        }
        if (args.qualityLevelId !== undefined && args.qualityLevelId !== null) {
            this.qualityLevelId = args.qualityLevelId;
        }
    }
};
hive.snapshots.TrafficKey.prototype = {};
hive.snapshots.TrafficKey.prototype.read = function (input) {
    input.readStructBegin();
    while (true) {
        var ret = input.readFieldBegin();
        var fname = ret.fname;
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
            break;
        }
        switch (fid) {
            case 1:
                if (ftype == Thrift.Type.I32) {
                    this.bitrate = input.readI32().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 2:
                if (ftype == Thrift.Type.I32) {
                    this.AS = input.readI32().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 3:
                if (ftype == Thrift.Type.STRING) {
                    this.partnerGuid = input.readString().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 4:
                if (ftype == Thrift.Type.STRING) {
                    this.qualityLevelId = input.readString().value;
                } else {
                    input.skip(ftype);
                }
                break;
            default:
                input.skip(ftype);
        }
        input.readFieldEnd();
    }
    input.readStructEnd();
    return;
};

hive.snapshots.TrafficKey.prototype.write = function (output) {
    output.writeStructBegin("TrafficKey");
    if (this.bitrate !== null && this.bitrate !== undefined) {
        output.writeFieldBegin("bitrate", Thrift.Type.I32, 1);
        output.writeI32(this.bitrate);
        output.writeFieldEnd();
    }
    if (this.AS !== null && this.AS !== undefined) {
        output.writeFieldBegin("AS", Thrift.Type.I32, 2);
        output.writeI32(this.AS);
        output.writeFieldEnd();
    }
    if (this.partnerGuid !== null && this.partnerGuid !== undefined) {
        output.writeFieldBegin("partnerGuid", Thrift.Type.STRING, 3);
        output.writeString(this.partnerGuid);
        output.writeFieldEnd();
    }
    if (this.qualityLevelId !== null && this.qualityLevelId !== undefined) {
        output.writeFieldBegin("qualityLevelId", Thrift.Type.STRING, 4);
        output.writeString(this.qualityLevelId);
        output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
};

hive.snapshots.PartnerKey = function (args) {
    this.bitrate = null;
    this.AS = null;
    this.partnerGuid = null;
    this.qualityLevelId = null;
    if (args) {
        if (args.bitrate !== undefined && args.bitrate !== null) {
            this.bitrate = args.bitrate;
        }
        if (args.AS !== undefined && args.AS !== null) {
            this.AS = args.AS;
        }
        if (args.partnerGuid !== undefined && args.partnerGuid !== null) {
            this.partnerGuid = args.partnerGuid;
        }
        if (args.qualityLevelId !== undefined && args.qualityLevelId !== null) {
            this.qualityLevelId = args.qualityLevelId;
        }
    }
};
hive.snapshots.PartnerKey.prototype = {};
hive.snapshots.PartnerKey.prototype.read = function (input) {
    input.readStructBegin();
    while (true) {
        var ret = input.readFieldBegin();
        var fname = ret.fname;
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
            break;
        }
        switch (fid) {
            case 1:
                if (ftype == Thrift.Type.I32) {
                    this.bitrate = input.readI32().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 2:
                if (ftype == Thrift.Type.I32) {
                    this.AS = input.readI32().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 3:
                if (ftype == Thrift.Type.STRING) {
                    this.partnerGuid = input.readString().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 4:
                if (ftype == Thrift.Type.STRING) {
                    this.qualityLevelId = input.readString().value;
                } else {
                    input.skip(ftype);
                }
                break;
            default:
                input.skip(ftype);
        }
        input.readFieldEnd();
    }
    input.readStructEnd();
    return;
};

hive.snapshots.PartnerKey.prototype.write = function (output) {
    output.writeStructBegin("PartnerKey");
    if (this.bitrate !== null && this.bitrate !== undefined) {
        output.writeFieldBegin("bitrate", Thrift.Type.I32, 1);
        output.writeI32(this.bitrate);
        output.writeFieldEnd();
    }
    if (this.AS !== null && this.AS !== undefined) {
        output.writeFieldBegin("AS", Thrift.Type.I32, 2);
        output.writeI32(this.AS);
        output.writeFieldEnd();
    }
    if (this.partnerGuid !== null && this.partnerGuid !== undefined) {
        output.writeFieldBegin("partnerGuid", Thrift.Type.STRING, 3);
        output.writeString(this.partnerGuid);
        output.writeFieldEnd();
    }
    if (this.qualityLevelId !== null && this.qualityLevelId !== undefined) {
        output.writeFieldBegin("qualityLevelId", Thrift.Type.STRING, 4);
        output.writeString(this.qualityLevelId);
        output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
};

hive.snapshots.Player = function (args) {
    this.bufferingN = null;
    this.bufferingMs = null;
    this.initBufferingN = null;
    this.initBufferingMs = null;
    this.seekBufferingN = null;
    this.seekBufferingMs = null;
    this.playerBufferMs = null;
    this.playingTimeMs = null;
    this.playerVolume = null;
    this.captionLanguage = null;
    if (args) {
        if (args.bufferingN !== undefined && args.bufferingN !== null) {
            this.bufferingN = args.bufferingN;
        }
        if (args.bufferingMs !== undefined && args.bufferingMs !== null) {
            this.bufferingMs = args.bufferingMs;
        }
        if (args.initBufferingN !== undefined && args.initBufferingN !== null) {
            this.initBufferingN = args.initBufferingN;
        }
        if (args.initBufferingMs !== undefined && args.initBufferingMs !== null) {
            this.initBufferingMs = args.initBufferingMs;
        }
        if (args.seekBufferingN !== undefined && args.seekBufferingN !== null) {
            this.seekBufferingN = args.seekBufferingN;
        }
        if (args.seekBufferingMs !== undefined && args.seekBufferingMs !== null) {
            this.seekBufferingMs = args.seekBufferingMs;
        }
        if (args.playerBufferMs !== undefined && args.playerBufferMs !== null) {
            this.playerBufferMs = args.playerBufferMs;
        }
        if (args.playingTimeMs !== undefined && args.playingTimeMs !== null) {
            this.playingTimeMs = args.playingTimeMs;
        }
        if (args.playerVolume !== undefined && args.playerVolume !== null) {
            this.playerVolume = args.playerVolume;
        }
        if (args.captionLanguage !== undefined && args.captionLanguage !== null) {
            this.captionLanguage = args.captionLanguage;
        }
    }
};
hive.snapshots.Player.prototype = {};
hive.snapshots.Player.prototype.read = function (input) {
    input.readStructBegin();
    while (true) {
        var ret = input.readFieldBegin();
        var fname = ret.fname;
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
            break;
        }
        switch (fid) {
            case 1:
                if (ftype == Thrift.Type.I16) {
                    this.bufferingN = input.readI16().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 2:
                if (ftype == Thrift.Type.I32) {
                    this.bufferingMs = input.readI32().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 3:
                if (ftype == Thrift.Type.I16) {
                    this.initBufferingN = input.readI16().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 4:
                if (ftype == Thrift.Type.I32) {
                    this.initBufferingMs = input.readI32().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 5:
                if (ftype == Thrift.Type.I16) {
                    this.seekBufferingN = input.readI16().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 6:
                if (ftype == Thrift.Type.I32) {
                    this.seekBufferingMs = input.readI32().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 36:
                if (ftype == Thrift.Type.I32) {
                    this.playerBufferMs = input.readI32().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 37:
                if (ftype == Thrift.Type.I32) {
                    this.playingTimeMs = input.readI32().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 38:
                if (ftype == Thrift.Type.I16) {
                    this.playerVolume = input.readI16().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 39:
                if (ftype == Thrift.Type.STRING) {
                    this.captionLanguage = input.readString().value;
                } else {
                    input.skip(ftype);
                }
                break;
            default:
                input.skip(ftype);
        }
        input.readFieldEnd();
    }
    input.readStructEnd();
    return;
};

hive.snapshots.Player.prototype.write = function (output) {
    output.writeStructBegin("Player");
    if (this.bufferingN !== null && this.bufferingN !== undefined) {
        output.writeFieldBegin("bufferingN", Thrift.Type.I16, 1);
        output.writeI16(this.bufferingN);
        output.writeFieldEnd();
    }
    if (this.bufferingMs !== null && this.bufferingMs !== undefined) {
        output.writeFieldBegin("bufferingMs", Thrift.Type.I32, 2);
        output.writeI32(this.bufferingMs);
        output.writeFieldEnd();
    }
    if (this.initBufferingN !== null && this.initBufferingN !== undefined) {
        output.writeFieldBegin("initBufferingN", Thrift.Type.I16, 3);
        output.writeI16(this.initBufferingN);
        output.writeFieldEnd();
    }
    if (this.initBufferingMs !== null && this.initBufferingMs !== undefined) {
        output.writeFieldBegin("initBufferingMs", Thrift.Type.I32, 4);
        output.writeI32(this.initBufferingMs);
        output.writeFieldEnd();
    }
    if (this.seekBufferingN !== null && this.seekBufferingN !== undefined) {
        output.writeFieldBegin("seekBufferingN", Thrift.Type.I16, 5);
        output.writeI16(this.seekBufferingN);
        output.writeFieldEnd();
    }
    if (this.seekBufferingMs !== null && this.seekBufferingMs !== undefined) {
        output.writeFieldBegin("seekBufferingMs", Thrift.Type.I32, 6);
        output.writeI32(this.seekBufferingMs);
        output.writeFieldEnd();
    }
    if (this.playerBufferMs !== null && this.playerBufferMs !== undefined) {
        output.writeFieldBegin("playerBufferMs", Thrift.Type.I32, 36);
        output.writeI32(this.playerBufferMs);
        output.writeFieldEnd();
    }
    if (this.playingTimeMs !== null && this.playingTimeMs !== undefined) {
        output.writeFieldBegin("playingTimeMs", Thrift.Type.I32, 37);
        output.writeI32(this.playingTimeMs);
        output.writeFieldEnd();
    }
    if (this.playerVolume !== null && this.playerVolume !== undefined) {
        output.writeFieldBegin("playerVolume", Thrift.Type.I16, 38);
        output.writeI16(this.playerVolume);
        output.writeFieldEnd();
    }
    if (this.captionLanguage !== null && this.captionLanguage !== undefined) {
        output.writeFieldBegin('captionLanguage', Thrift.Type.STRING, 39);
        output.writeString(this.captionLanguage);
        output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
};

hive.snapshots.ResponseInfo = function (args) {
    this.statusCode = null;
    this.count = null;
    if (args) {
        if (args.statusCode !== undefined && args.statusCode !== null) {
            this.statusCode = args.statusCode;
        }
        if (args.count !== undefined && args.count !== null) {
            this.count = args.count;
        }
    }
};
hive.snapshots.ResponseInfo.prototype = {};
hive.snapshots.ResponseInfo.prototype.read = function (input) {
    input.readStructBegin();
    while (true) {
        var ret = input.readFieldBegin();
        var fname = ret.fname;
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
            break;
        }
        switch (fid) {
            case 1:
                if (ftype == Thrift.Type.I16) {
                    this.statusCode = input.readI16().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 2:
                if (ftype == Thrift.Type.I32) {
                    this.count = input.readI32().value;
                } else {
                    input.skip(ftype);
                }
                break;
            default:
                input.skip(ftype);
        }
        input.readFieldEnd();
    }
    input.readStructEnd();
    return;
};

hive.snapshots.ResponseInfo.prototype.write = function (output) {
    output.writeStructBegin("ResponseInfo");
    if (this.statusCode !== null && this.statusCode !== undefined) {
        output.writeFieldBegin("statusCode", Thrift.Type.I16, 1);
        output.writeI16(this.statusCode);
        output.writeFieldEnd();
    }
    if (this.count !== null && this.count !== undefined) {
        output.writeFieldBegin("count", Thrift.Type.I32, 2);
        output.writeI32(this.count);
        output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
};

hive.snapshots.ServiceResponseInfo = function (args) {
    this.source = null;
    if (args) {
        if (args.source !== undefined && args.source !== null) {
            this.source = Thrift.copyList(args.source, [hive.snapshots.ResponseInfo]);
        }
    }
};
hive.snapshots.ServiceResponseInfo.prototype = {};
hive.snapshots.ServiceResponseInfo.prototype.read = function (input) {
    input.readStructBegin();
    while (true) {
        var ret = input.readFieldBegin();
        var fname = ret.fname;
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
            break;
        }
        switch (fid) {
            case 1:
                if (ftype == Thrift.Type.LIST) {
                    var _size40 = 0;
                    var _rtmp344;
                    this.source = [];
                    var _etype43 = 0;
                    _rtmp344 = input.readListBegin();
                    _etype43 = _rtmp344.etype;
                    _size40 = _rtmp344.size;
                    for (var _i45 = 0; _i45 < _size40; ++_i45) {
                        var elem46 = null;
                        elem46 = new hive.snapshots.ResponseInfo();
                        elem46.read(input);
                        this.source.push(elem46);
                    }
                    input.readListEnd();
                } else {
                    input.skip(ftype);
                }
                break;
            case 0:
                input.skip(ftype);
                break;
            default:
                input.skip(ftype);
        }
        input.readFieldEnd();
    }
    input.readStructEnd();
    return;
};

hive.snapshots.ServiceResponseInfo.prototype.write = function (output) {
    output.writeStructBegin("ServiceResponseInfo");
    if (this.source !== null && this.source !== undefined) {
        output.writeFieldBegin("source", Thrift.Type.LIST, 1);
        output.writeListBegin(Thrift.Type.STRUCT, this.source.length);
        for (var iter47 in this.source) {
            if (this.source.hasOwnProperty(iter47)) {
                iter47 = this.source[iter47];
                iter47.write(output);
            }
        }
        output.writeListEnd();
        output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
};

hive.snapshots.MetricSnapshot = function (args) {
    this.timestamp = null;
    this.guid = null;
    this.eventId = null;
    this.streamInfo = null;
    this.metrics = null;
    this.traffic = null;
    this.snapshotInfo = null;
    this.agentInfo = null;
    this.connInfo = null;
    this.partners = null;
    this.player = null;
    this.client = null;
    this.sessionId = null;
    this.responseInfo = null;
    this.testInfo = null;
    this.clientId = null;
    this.fragments = null;
    this.fetchedFragments = null;
    if (args) {
        if (args.timestamp !== undefined && args.timestamp !== null) {
            this.timestamp = args.timestamp;
        }
        if (args.guid !== undefined && args.guid !== null) {
            this.guid = args.guid;
        }
        if (args.eventId !== undefined && args.eventId !== null) {
            this.eventId = new EventId(args.eventId);
        }
        if (args.streamInfo !== undefined && args.streamInfo !== null) {
            this.streamInfo = new hive.snapshots.StreamInfo(args.streamInfo);
        }
        if (args.metrics !== undefined && args.metrics !== null) {
            this.metrics = new hive.snapshots.Metrics(args.metrics);
        }
        if (args.traffic !== undefined && args.traffic !== null) {
            this.traffic = args.traffic;
        }
        if (args.snapshotInfo !== undefined && args.snapshotInfo !== null) {
            this.snapshotInfo = new SnapshotInfo(args.snapshotInfo);
        }
        if (args.agentInfo !== undefined && args.agentInfo !== null) {
            this.agentInfo = new hive.snapshots.AgentInfo(args.agentInfo);
        }
        if (args.connInfo !== undefined && args.connInfo !== null) {
            this.connInfo = new hive.snapshots.ConnectivityInfo(args.connInfo);
        }
        if (args.partners !== undefined && args.partners !== null) {
            this.partners = args.partners;
            // this.partners = Thrift.copyMap(args.partners, [hive.snapshots.Partner]);
        }
        if (args.player !== undefined && args.player !== null) {
            this.player = new hive.snapshots.Player(args.player);
        }
        if (args.client !== undefined && args.client !== null) {
            this.client = new hive.snapshots.ClientInfo(args.client);
        }
        if (args.sessionId !== undefined && args.sessionId !== null) {
            this.sessionId = args.sessionId;
        }
        if (args.responseInfo !== undefined && args.responseInfo !== null) {
            this.responseInfo = new hive.snapshots.ServiceResponseInfo(args.responseInfo);
        }
        if (args.testInfo !== undefined && args.testInfo !== null) {
            this.testInfo = new TestInfo(args.testInfo);
        }
        if (args.clientId !== undefined && args.clientId !== null) {
            this.clientId = args.clientId;
        }
        if (args.fragments !== undefined && args.fragments !== null) {
            this.fragments = Thrift.copyList(args.fragments, [hive.snapshots.FragmentMetadata]);
        }
        if (args.fetchedFragments !== undefined && args.fetchedFragments !== null) {
            this.fetchedFragments =  args.fetchedFragments;
        }
    }
};
hive.snapshots.MetricSnapshot.prototype = {};
hive.snapshots.MetricSnapshot.prototype.read = function (input) {
    input.readStructBegin();
    while (true) {
        var ret = input.readFieldBegin();
        var fname = ret.fname;
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
            break;
        }
        switch (fid) {
            case 1:
                if (ftype == Thrift.Type.I64) {
                    this.timestamp = input.readI64().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 2:
                if (ftype == Thrift.Type.STRING) {
                    this.guid = input.readString().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 3:
                if (ftype == Thrift.Type.STRUCT) {
                    this.eventId = new EventId();
                    this.eventId.read(input);
                } else {
                    input.skip(ftype);
                }
                break;
            case 4:
                if (ftype == Thrift.Type.STRUCT) {
                    this.streamInfo = new hive.snapshots.StreamInfo();
                    this.streamInfo.read(input);
                } else {
                    input.skip(ftype);
                }
                break;
            case 5:
                if (ftype == Thrift.Type.STRUCT) {
                    this.metrics = new hive.snapshots.Metrics();
                    this.metrics.read(input);
                } else {
                    input.skip(ftype);
                }
                break;
            case 6:
                if (ftype == Thrift.Type.MAP) {
                    var _size48 = 0;
                    var _rtmp352;
                    this.traffic = {};
                    var _ktype49 = 0;
                    var _vtype50 = 0;
                    _rtmp352 = input.readMapBegin();
                    _ktype49 = _rtmp352.ktype;
                    _vtype50 = _rtmp352.vtype;
                    _size48 = _rtmp352.size;
                    for (var _i53 = 0; _i53 < _size48; ++_i53) {
                        if (_i53 > 0) {
                            if (input.rstack.length > input.rpos[input.rpos.length - 1] + 1) {
                                input.rstack.pop();
                            }
                        }
                        var key54 = null;
                        var val55 = null;
                        key54 = new hive.snapshots.TrafficKey();
                        key54.read(input);
                        val55 = new hive.snapshots.Traffic();
                        val55.read(input);
                        this.traffic[key54] = val55;
                    }
                    input.readMapEnd();
                } else {
                    input.skip(ftype);
                }
                break;
            case 7:
                if (ftype == Thrift.Type.STRUCT) {
                    this.snapshotInfo = new SnapshotInfo();
                    this.snapshotInfo.read(input);
                } else {
                    input.skip(ftype);
                }
                break;
            case 8:
                if (ftype == Thrift.Type.STRUCT) {
                    this.agentInfo = new hive.snapshots.AgentInfo();
                    this.agentInfo.read(input);
                } else {
                    input.skip(ftype);
                }
                break;
            case 9:
                if (ftype == Thrift.Type.STRUCT) {
                    this.connInfo = new hive.snapshots.ConnectivityInfo();
                    this.connInfo.read(input);
                } else {
                    input.skip(ftype);
                }
                break;
            case 10:
                if (ftype == Thrift.Type.MAP) {
                    var _size56 = 0;
                    var _rtmp360;
                    this.partners = {};
                    var _ktype57 = 0;
                    var _vtype58 = 0;
                    _rtmp360 = input.readMapBegin();
                    _ktype57 = _rtmp360.ktype;
                    _vtype58 = _rtmp360.vtype;
                    _size56 = _rtmp360.size;
                    for (var _i61 = 0; _i61 < _size56; ++_i61) {
                        if (_i61 > 0) {
                            if (input.rstack.length > input.rpos[input.rpos.length - 1] + 1) {
                                input.rstack.pop();
                            }
                        }
                        var key62 = null;
                        var val63 = null;
                        key62 = new hive.snapshots.PartnerKey();
                        key62.read(input);
                        val63 = new hive.snapshots.Partner();
                        val63.read(input);
                        this.partners[key62] = val63;
                    }
                    input.readMapEnd();
                } else {
                    input.skip(ftype);
                }
                break;
            case 11:
                if (ftype == Thrift.Type.STRUCT) {
                    this.player = new hive.snapshots.Player();
                    this.player.read(input);
                } else {
                    input.skip(ftype);
                }
                break;
            case 12:
                if (ftype == Thrift.Type.STRUCT) {
                    this.client = new hive.snapshots.ClientInfo();
                    this.client.read(input);
                } else {
                    input.skip(ftype);
                }
                break;
            case 13:
                if (ftype == Thrift.Type.STRING) {
                    this.sessionId = input.readString().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 14:
                if (ftype == Thrift.Type.STRUCT) {
                    this.responseInfo = new hive.snapshots.ServiceResponseInfo();
                    this.responseInfo.read(input);
                } else {
                    input.skip(ftype);
                }
                break;
            case 15:
                if (ftype == Thrift.Type.STRUCT) {
                    this.testInfo = new TestInfo();
                    this.testInfo.read(input);
                } else {
                    input.skip(ftype);
                }
                break;
            case 16:
                if (ftype == Thrift.Type.I64) {
                    this.clientId = input.readI64().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 17:
                if (ftype == Thrift.Type.LIST) {
                    var _size64 = 0;
                    var _rtmp368;
                    this.fragments = [];
                    var _etype67 = 0;
                    _rtmp368 = input.readListBegin();
                    _etype67 = _rtmp368.etype;
                    _size64 = _rtmp368.size;
                    for (var _i69 = 0; _i69 < _size64; ++_i69) {
                        var elem70 = null;
                        elem70 = new hive.snapshots.FragmentMetadata();
                        elem70.read(input);
                        this.fragments.push(elem70);
                    }
                    input.readListEnd();
                } else {
                    input.skip(ftype);
                }
                break;
            default:
                input.skip(ftype);
        }
        input.readFieldEnd();
    }
    input.readStructEnd();
    return;
};

hive.snapshots.MetricSnapshot.prototype.write = function (output) {
    output.writeStructBegin("MetricSnapshot");
    if (this.timestamp !== null && this.timestamp !== undefined) {
        output.writeFieldBegin("timestamp", Thrift.Type.I64, 1);
        output.writeI64(this.timestamp);
        output.writeFieldEnd();
    }
    if (this.guid !== null && this.guid !== undefined) {
        output.writeFieldBegin("guid", Thrift.Type.STRING, 2);
        output.writeString(this.guid);
        output.writeFieldEnd();
    }
    if (this.eventId !== null && this.eventId !== undefined) {
        output.writeFieldBegin("eventId", Thrift.Type.STRUCT, 3);
        this.eventId.write(output);
        output.writeFieldEnd();
    }
    if (this.streamInfo !== null && this.streamInfo !== undefined) {
        output.writeFieldBegin("streamInfo", Thrift.Type.STRUCT, 4);
        this.streamInfo.write(output);
        output.writeFieldEnd();
    }
    if (this.metrics !== null && this.metrics !== undefined) {
        output.writeFieldBegin("metrics", Thrift.Type.STRUCT, 5);
        this.metrics.write(output);
        output.writeFieldEnd();
    }
    if (this.traffic !== null && this.traffic !== undefined) {
        output.writeFieldBegin("traffic", Thrift.Type.MAP, 6);
        output.writeMapBegin(Thrift.Type.STRUCT, Thrift.Type.STRUCT, Thrift.objectLength(this.traffic));
        for (var kiter71 in this.traffic) {
            if (this.traffic.hasOwnProperty(kiter71)) {
                var viter72 = this.traffic[kiter71];
                viter72.key.write(output);
                viter72.value.write(output);
            }
        }
        output.writeMapEnd();
        output.writeFieldEnd();
    }
    if (this.snapshotInfo !== null && this.snapshotInfo !== undefined) {
        output.writeFieldBegin("snapshotInfo", Thrift.Type.STRUCT, 7);
        this.snapshotInfo.write(output);
        output.writeFieldEnd();
    }
    if (this.agentInfo !== null && this.agentInfo !== undefined) {
        output.writeFieldBegin("agentInfo", Thrift.Type.STRUCT, 8);
        this.agentInfo.write(output);
        output.writeFieldEnd();
    }
    if (this.connInfo !== null && this.connInfo !== undefined) {
        output.writeFieldBegin("connInfo", Thrift.Type.STRUCT, 9);
        this.connInfo.write(output);
        output.writeFieldEnd();
    }
    if (this.partners !== null && this.partners !== undefined) {
        output.writeFieldBegin("partners", Thrift.Type.MAP, 10);
        output.writeMapBegin(Thrift.Type.STRUCT, Thrift.Type.STRUCT, Thrift.objectLength(this.partners));
        for (var kiter73 in this.partners) {
            if (this.partners.hasOwnProperty(kiter73)) {
                var viter74 = this.partners[kiter73];
                viter74.key.write(output);
                viter74.value.write(output);
            }
        }
        output.writeMapEnd();
        output.writeFieldEnd();
    }
    if (this.player !== null && this.player !== undefined) {
        output.writeFieldBegin("player", Thrift.Type.STRUCT, 11);
        this.player.write(output);
        output.writeFieldEnd();
    }
    if (this.client !== null && this.client !== undefined) {
        output.writeFieldBegin("client", Thrift.Type.STRUCT, 12);
        this.client.write(output);
        output.writeFieldEnd();
    }
    if (this.sessionId !== null && this.sessionId !== undefined) {
        output.writeFieldBegin("sessionId", Thrift.Type.STRING, 13);
        output.writeString(this.sessionId);
        output.writeFieldEnd();
    }
    if (this.responseInfo !== null && this.responseInfo !== undefined) {
        output.writeFieldBegin("responseInfo", Thrift.Type.STRUCT, 14);
        this.responseInfo.write(output);
        output.writeFieldEnd();
    }
    if (this.testInfo !== null && this.testInfo !== undefined) {
        output.writeFieldBegin("testInfo", Thrift.Type.STRUCT, 15);
        this.testInfo.write(output);
        output.writeFieldEnd();
    }
    if (this.clientId !== null && this.clientId !== undefined) {
        output.writeFieldBegin("clientId", Thrift.Type.I64, 16);
        output.writeI64(this.clientId);
        output.writeFieldEnd();
    }
    if (this.fragments !== null && this.fragments !== undefined) {
        output.writeFieldBegin("fragments", Thrift.Type.LIST, 17);
        output.writeListBegin(Thrift.Type.STRUCT, this.fragments.length);
        for (var iter75 in this.fragments) {
            if (this.fragments.hasOwnProperty(iter75)) {
                iter75 = this.fragments[iter75];
                iter75.write(output);
            }
        }
        output.writeListEnd();
        output.writeFieldEnd();
    }
    if (this.fetchedFragments !== null && this.fetchedFragments !== undefined) {
        output.writeFieldBegin('fetchedFragments', Thrift.Type.LIST, 18);
        output.writeListBegin(Thrift.Type.STRUCT, this.fetchedFragments.length);
        for (var iter83 in this.fetchedFragments) {
            if (this.fetchedFragments.hasOwnProperty(iter83)) {
                iter83 = this.fetchedFragments[iter83];
                iter83.write(output);
            }
        }
        output.writeListEnd();
        output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
};

hive.snapshots.JsonMetricSnapshot = function (args) {
    this.timestamp = null;
    this.guid = null;
    this.eventId = null;
    this.streamInfo = null;
    this.metrics = null;
    this.traffic = null;
    this.snapshotInfo = null;
    this.agentInfo = null;
    this.connInfo = null;
    this.partners = null;
    this.player = null;
    this.client = null;
    this.sessionId = null;
    this.responseInfo = null;
    this.testInfo = null;
    this.clientId = null;
    this.fragments = null;
    this.fetchedFragments = null;
    if (args) {
        if (args.timestamp !== undefined && args.timestamp !== null) {
            this.timestamp = args.timestamp;
        }
        if (args.guid !== undefined && args.guid !== null) {
            this.guid = args.guid;
        }
        if (args.eventId !== undefined && args.eventId !== null) {
            this.eventId = new EventId(args.eventId);
        }
        if (args.streamInfo !== undefined && args.streamInfo !== null) {
            this.streamInfo = new hive.snapshots.StreamInfo(args.streamInfo);
        }
        if (args.metrics !== undefined && args.metrics !== null) {
            this.metrics = new hive.snapshots.Metrics(args.metrics);
        }
        if (args.traffic !== undefined && args.traffic !== null) {
            this.traffic = Thrift.copyMap(args.traffic, [hive.snapshots.Traffic]);
        }
        if (args.snapshotInfo !== undefined && args.snapshotInfo !== null) {
            this.snapshotInfo = new SnapshotInfo(args.snapshotInfo);
        }
        if (args.agentInfo !== undefined && args.agentInfo !== null) {
            this.agentInfo = new hive.snapshots.AgentInfo(args.agentInfo);
        }
        if (args.connInfo !== undefined && args.connInfo !== null) {
            this.connInfo = new hive.snapshots.ConnectivityInfo(args.connInfo);
        }
        if (args.partners !== undefined && args.partners !== null) {
            this.partners = Thrift.copyMap(args.partners, [hive.snapshots.Partner]);
        }
        if (args.player !== undefined && args.player !== null) {
            this.player = new hive.snapshots.Player(args.player);
        }
        if (args.client !== undefined && args.client !== null) {
            this.client = new hive.snapshots.ClientInfo(args.client);
        }
        if (args.sessionId !== undefined && args.sessionId !== null) {
            this.sessionId = args.sessionId;
        }
        if (args.responseInfo !== undefined && args.responseInfo !== null) {
            this.responseInfo = new hive.snapshots.ServiceResponseInfo(args.responseInfo);
        }
        if (args.testInfo !== undefined && args.testInfo !== null) {
            this.testInfo = new TestInfo(args.testInfo);
        }
        if (args.clientId !== undefined && args.clientId !== null) {
            this.clientId = args.clientId;
        }
        if (args.fragments !== undefined && args.fragments !== null) {
            this.fragments = Thrift.copyList(args.fragments, [hive.snapshots.FragmentMetadata]);
        }
        if (args.fetchedFragments !== undefined && args.fetchedFragments !== null) {
            this.fetchedFragments = Thrift.copyList(args.fetchedFragments, [hive.snapshots.FragmentDownload]);
        }
    }
};
hive.snapshots.JsonMetricSnapshot.prototype = {};
hive.snapshots.JsonMetricSnapshot.prototype.read = function (input) {
    input.readStructBegin();
    while (true) {
        var ret = input.readFieldBegin();
        var fname = ret.fname;
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
            break;
        }
        switch (fid) {
            case 1:
                if (ftype == Thrift.Type.I64) {
                    this.timestamp = input.readI64().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 2:
                if (ftype == Thrift.Type.STRING) {
                    this.guid = input.readString().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 3:
                if (ftype == Thrift.Type.STRUCT) {
                    this.eventId = new EventId();
                    this.eventId.read(input);
                } else {
                    input.skip(ftype);
                }
                break;
            case 4:
                if (ftype == Thrift.Type.STRUCT) {
                    this.streamInfo = new hive.snapshots.StreamInfo();
                    this.streamInfo.read(input);
                } else {
                    input.skip(ftype);
                }
                break;
            case 5:
                if (ftype == Thrift.Type.STRUCT) {
                    this.metrics = new hive.snapshots.Metrics();
                    this.metrics.read(input);
                } else {
                    input.skip(ftype);
                }
                break;
            case 6:
                if (ftype == Thrift.Type.MAP) {
                    var _size76 = 0;
                    var _rtmp380;
                    this.traffic = {};
                    var _ktype77 = 0;
                    var _vtype78 = 0;
                    _rtmp380 = input.readMapBegin();
                    _ktype77 = _rtmp380.ktype;
                    _vtype78 = _rtmp380.vtype;
                    _size76 = _rtmp380.size;
                    for (var _i81 = 0; _i81 < _size76; ++_i81) {
                        if (_i81 > 0) {
                            if (input.rstack.length > input.rpos[input.rpos.length - 1] + 1) {
                                input.rstack.pop();
                            }
                        }
                        var key82 = null;
                        var val83 = null;
                        key82 = input.readString().value;
                        val83 = new hive.snapshots.Traffic();
                        val83.read(input);
                        this.traffic[key82] = val83;
                    }
                    input.readMapEnd();
                } else {
                    input.skip(ftype);
                }
                break;
            case 7:
                if (ftype == Thrift.Type.STRUCT) {
                    this.snapshotInfo = new SnapshotInfo();
                    this.snapshotInfo.read(input);
                } else {
                    input.skip(ftype);
                }
                break;
            case 8:
                if (ftype == Thrift.Type.STRUCT) {
                    this.agentInfo = new hive.snapshots.AgentInfo();
                    this.agentInfo.read(input);
                } else {
                    input.skip(ftype);
                }
                break;
            case 9:
                if (ftype == Thrift.Type.STRUCT) {
                    this.connInfo = new hive.snapshots.ConnectivityInfo();
                    this.connInfo.read(input);
                } else {
                    input.skip(ftype);
                }
                break;
            case 10:
                if (ftype == Thrift.Type.MAP) {
                    var _size84 = 0;
                    var _rtmp388;
                    this.partners = {};
                    var _ktype85 = 0;
                    var _vtype86 = 0;
                    _rtmp388 = input.readMapBegin();
                    _ktype85 = _rtmp388.ktype;
                    _vtype86 = _rtmp388.vtype;
                    _size84 = _rtmp388.size;
                    for (var _i89 = 0; _i89 < _size84; ++_i89) {
                        if (_i89 > 0) {
                            if (input.rstack.length > input.rpos[input.rpos.length - 1] + 1) {
                                input.rstack.pop();
                            }
                        }
                        var key90 = null;
                        var val91 = null;
                        key90 = input.readString().value;
                        val91 = new hive.snapshots.Partner();
                        val91.read(input);
                        this.partners[key90] = val91;
                    }
                    input.readMapEnd();
                } else {
                    input.skip(ftype);
                }
                break;
            case 11:
                if (ftype == Thrift.Type.STRUCT) {
                    this.player = new hive.snapshots.Player();
                    this.player.read(input);
                } else {
                    input.skip(ftype);
                }
                break;
            case 12:
                if (ftype == Thrift.Type.STRUCT) {
                    this.client = new hive.snapshots.ClientInfo();
                    this.client.read(input);
                } else {
                    input.skip(ftype);
                }
                break;
            case 13:
                if (ftype == Thrift.Type.STRING) {
                    this.sessionId = input.readString().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 14:
                if (ftype == Thrift.Type.STRUCT) {
                    this.responseInfo = new hive.snapshots.ServiceResponseInfo();
                    this.responseInfo.read(input);
                } else {
                    input.skip(ftype);
                }
                break;
            case 15:
                if (ftype == Thrift.Type.STRUCT) {
                    this.testInfo = new TestInfo();
                    this.testInfo.read(input);
                } else {
                    input.skip(ftype);
                }
                break;
            case 16:
                if (ftype == Thrift.Type.STRING) {
                    this.clientId = input.readString().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 17:
                if (ftype == Thrift.Type.LIST) {
                    var _size92 = 0;
                    var _rtmp396;
                    this.fragments = [];
                    var _etype95 = 0;
                    _rtmp396 = input.readListBegin();
                    _etype95 = _rtmp396.etype;
                    _size92 = _rtmp396.size;
                    for (var _i97 = 0; _i97 < _size92; ++_i97) {
                        var elem98 = null;
                        elem98 = new hive.snapshots.FragmentMetadata();
                        elem98.read(input);
                        this.fragments.push(elem98);
                    }
                    input.readListEnd();
                } else {
                    input.skip(ftype);
                }
                break;
            case 18:
                if (ftype == Thrift.Type.LIST) {
                    var _size107 = 0;
                    var _rtmp3111;
                    this.fetchedFragments = [];
                    var _etype110 = 0;
                    _rtmp3111 = input.readListBegin();
                    _etype110 = _rtmp3111.etype;
                    _size107 = _rtmp3111.size;
                    for (var _i112 = 0; _i112 < _size107; ++_i112) {
                        var elem113 = null;
                        elem113 = new hive.snapshots.FragmentDownload();
                        elem113.read(input);
                        this.fetchedFragments.push(elem113);
                    }
                    input.readListEnd();
                } else {
                    input.skip(ftype);
                }
                break;
            default:
                input.skip(ftype);
        }
        input.readFieldEnd();
    }
    input.readStructEnd();
    return;
};

hive.snapshots.JsonMetricSnapshot.prototype.write = function (output) {
    output.writeStructBegin("JsonMetricSnapshot");
    if (this.timestamp !== null && this.timestamp !== undefined) {
        output.writeFieldBegin("timestamp", Thrift.Type.I64, 1);
        output.writeI64(this.timestamp);
        output.writeFieldEnd();
    }
    if (this.guid !== null && this.guid !== undefined) {
        output.writeFieldBegin("guid", Thrift.Type.STRING, 2);
        output.writeString(this.guid);
        output.writeFieldEnd();
    }
    if (this.eventId !== null && this.eventId !== undefined) {
        output.writeFieldBegin("eventId", Thrift.Type.STRUCT, 3);
        this.eventId.write(output);
        output.writeFieldEnd();
    }
    if (this.streamInfo !== null && this.streamInfo !== undefined) {
        output.writeFieldBegin("streamInfo", Thrift.Type.STRUCT, 4);
        this.streamInfo.write(output);
        output.writeFieldEnd();
    }
    if (this.metrics !== null && this.metrics !== undefined) {
        output.writeFieldBegin("metrics", Thrift.Type.STRUCT, 5);
        this.metrics.write(output);
        output.writeFieldEnd();
    }
    if (this.traffic !== null && this.traffic !== undefined) {
        output.writeFieldBegin("traffic", Thrift.Type.MAP, 6);
        output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.STRUCT, Thrift.objectLength(this.traffic));
        for (var kiter99 in this.traffic) {
            if (this.traffic.hasOwnProperty(kiter99)) {
                var viter100 = this.traffic[kiter99];
                output.writeString(kiter99);
                viter100.write(output);
            }
        }
        output.writeMapEnd();
        output.writeFieldEnd();
    }
    if (this.snapshotInfo !== null && this.snapshotInfo !== undefined) {
        output.writeFieldBegin("snapshotInfo", Thrift.Type.STRUCT, 7);
        this.snapshotInfo.write(output);
        output.writeFieldEnd();
    }
    if (this.agentInfo !== null && this.agentInfo !== undefined) {
        output.writeFieldBegin("agentInfo", Thrift.Type.STRUCT, 8);
        this.agentInfo.write(output);
        output.writeFieldEnd();
    }
    if (this.connInfo !== null && this.connInfo !== undefined) {
        output.writeFieldBegin("connInfo", Thrift.Type.STRUCT, 9);
        this.connInfo.write(output);
        output.writeFieldEnd();
    }
    if (this.partners !== null && this.partners !== undefined) {
        output.writeFieldBegin("partners", Thrift.Type.MAP, 10);
        output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.STRUCT, Thrift.objectLength(this.partners));
        for (var kiter101 in this.partners) {
            if (this.partners.hasOwnProperty(kiter101)) {
                var viter102 = this.partners[kiter101];
                output.writeString(kiter101);
                viter102.write(output);
            }
        }
        output.writeMapEnd();
        output.writeFieldEnd();
    }
    if (this.player !== null && this.player !== undefined) {
        output.writeFieldBegin("player", Thrift.Type.STRUCT, 11);
        this.player.write(output);
        output.writeFieldEnd();
    }
    if (this.client !== null && this.client !== undefined) {
        output.writeFieldBegin("client", Thrift.Type.STRUCT, 12);
        this.client.write(output);
        output.writeFieldEnd();
    }
    if (this.sessionId !== null && this.sessionId !== undefined) {
        output.writeFieldBegin("sessionId", Thrift.Type.STRING, 13);
        output.writeString(this.sessionId);
        output.writeFieldEnd();
    }
    if (this.responseInfo !== null && this.responseInfo !== undefined) {
        output.writeFieldBegin("responseInfo", Thrift.Type.STRUCT, 14);
        this.responseInfo.write(output);
        output.writeFieldEnd();
    }
    if (this.testInfo !== null && this.testInfo !== undefined) {
        output.writeFieldBegin("testInfo", Thrift.Type.STRUCT, 15);
        this.testInfo.write(output);
        output.writeFieldEnd();
    }
    if (this.clientId !== null && this.clientId !== undefined) {
        output.writeFieldBegin("clientId", Thrift.Type.STRING, 16);
        output.writeString(this.clientId);
        output.writeFieldEnd();
    }
    if (this.fragments !== null && this.fragments !== undefined) {
        output.writeFieldBegin("fragments", Thrift.Type.LIST, 17);
        output.writeListBegin(Thrift.Type.STRUCT, this.fragments.length);
        for (var iter103 in this.fragments) {
            if (this.fragments.hasOwnProperty(iter103)) {
                iter103 = this.fragments[iter103];
                iter103.write(output);
            }
        }
        output.writeListEnd();
        output.writeFieldEnd();
    }
    if (this.fetchedFragments !== null && this.fetchedFragments !== undefined) {
        output.writeFieldBegin('fetchedFragments', Thrift.Type.LIST, 18);
        output.writeListBegin(Thrift.Type.STRUCT, this.fetchedFragments.length);
        for (var iter119 in this.fetchedFragments) {
            if (this.fetchedFragments.hasOwnProperty(iter119)) {
                iter119 = this.fetchedFragments[iter119];
                iter119.write(output);
            }
        }
        output.writeListEnd();
        output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
};


/***/ }),

/***/ "../../../protocol/services/new_tracker_types.js":
/*!************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/protocol/services/new_tracker_types.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

//
// Autogenerated by Thrift Compiler (0.11.0)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//

var Thrift = __webpack_require__(/*! @hivestreaming/thrift */ "../../../node_modules/@hivestreaming/thrift/src/thrift.js");

var hive = window.hive;
if (typeof hive === 'undefined') {
    hive = window.hive = {};
}
if (typeof hive.services === 'undefined') {
    hive.services = {};
}
if (typeof hive.services.protocol === 'undefined') {
    hive.services.protocol = {};
}
if (typeof hive.services.protocol.tracker === 'undefined') {
    hive.services.protocol.tracker = {};
}
hive.services.protocol.tracker.TrackerPeerStreamState = {
    '1': 'PLAYER',
    'PLAYER': 1,
    '2': 'P2P_AGENT',
    'P2P_AGENT': 2,
    '3': 'PREFETCHER_FIRST_TIER',
    'PREFETCHER_FIRST_TIER': 3,
    '4': 'PREFETCHER_SECOND_TIER',
    'PREFETCHER_SECOND_TIER': 4
};
hive.services.protocol.tracker.TrackerRankType = {
    '1': 'Global',
    'Global': 1,
    '2': 'InternalAs',
    'InternalAs': 2,
    '3': 'ExternalAs',
    'ExternalAs': 3,
    '4': 'LocalityAs',
    'LocalityAs': 4
};
hive.services.protocol.tracker.TrackerAsType = {
    '1': 'Internal',
    'Internal': 1,
    '2': 'External',
    'External': 2,
    '3': 'Locality',
    'Locality': '3'
};
hive.services.protocol.tracker.TrackerPeerStreamInfo = function (args) {
    this.state = null;
    this.bitrate = null;
    this.delta = null;
    this.qualityLevel = null;
    if (args) {
        if (args.state !== undefined && args.state !== null) {
            this.state = args.state;
        }
        if (args.bitrate !== undefined && args.bitrate !== null) {
            this.bitrate = args.bitrate;
        }
        if (args.delta !== undefined && args.delta !== null) {
            this.delta = args.delta;
        }
        if (args.qualityLevel !== undefined && args.qualityLevel !== null) {
            this.qualityLevel = args.qualityLevel;
        }
    }
};
hive.services.protocol.tracker.TrackerPeerStreamInfo.prototype = {};
hive.services.protocol.tracker.TrackerPeerStreamInfo.prototype.read = function (input) {
    input.readStructBegin();
    while (true) {
        var ret = input.readFieldBegin();
        var fname = ret.fname;
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
            break;
        }
        switch (fid) {
            case 1:
                if (ftype == Thrift.Type.I32) {
                    this.state = input.readI32().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 2:
                if (ftype == Thrift.Type.I32) {
                    this.bitrate = input.readI32().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 3:
                if (ftype == Thrift.Type.I32) {
                    this.delta = input.readI32().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 4:
                if (ftype == Thrift.Type.STRING) {
                    this.qualityLevel = input.readString().value;
                } else {
                    input.skip(ftype);
                }
                break;
            default:
                input.skip(ftype);
        }
        input.readFieldEnd();
    }
    input.readStructEnd();
    return;
};

hive.services.protocol.tracker.TrackerPeerStreamInfo.prototype.write = function (output) {
    output.writeStructBegin('TrackerPeerStreamInfo');
    if (this.state !== null && this.state !== undefined) {
        output.writeFieldBegin('state', Thrift.Type.I32, 1);
        output.writeI32(this.state);
        output.writeFieldEnd();
    }
    if (this.bitrate !== null && this.bitrate !== undefined) {
        output.writeFieldBegin('bitrate', Thrift.Type.I32, 2);
        output.writeI32(this.bitrate);
        output.writeFieldEnd();
    }
    if (this.delta !== null && this.delta !== undefined) {
        output.writeFieldBegin('delta', Thrift.Type.I32, 3);
        output.writeI32(this.delta);
        output.writeFieldEnd();
    }
    if (this.qualityLevel !== null && this.qualityLevel !== undefined) {
        output.writeFieldBegin('qualityLevel', Thrift.Type.STRING, 4);
        output.writeString(this.qualityLevel);
        output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
};

hive.services.protocol.tracker.TrackerPeerInfo = function (args) {
    this.guid = null;
    this.internalAs = null;
    this.externalAs = null;
    this.nat = null;
    this.bandwidth = null;
    this.watchingBitrate = null;
    this.privateIp = null;
    this.publicIp = null;
    this.streams = null;
    this.rankValue = null;
    this.timestamp = null;
    this.publicIpString = null;
    this.privateIpString = null;
    this.watchingQualityLevel = null;
    this.localityGroup = null;
    this.isVpn = null;
    if (args) {
        if (args.guid !== undefined && args.guid !== null) {
            this.guid = args.guid;
        }
        if (args.internalAs !== undefined && args.internalAs !== null) {
            this.internalAs = args.internalAs;
        }
        if (args.externalAs !== undefined && args.externalAs !== null) {
            this.externalAs = args.externalAs;
        }
        if (args.nat !== undefined && args.nat !== null) {
            this.nat = args.nat;
        }
        if (args.bandwidth !== undefined && args.bandwidth !== null) {
            this.bandwidth = args.bandwidth;
        }
        if (args.watchingBitrate !== undefined && args.watchingBitrate !== null) {
            this.watchingBitrate = args.watchingBitrate;
        }
        if (args.privateIp !== undefined && args.privateIp !== null) {
            this.privateIp = args.privateIp;
        }
        if (args.publicIp !== undefined && args.publicIp !== null) {
            this.publicIp = args.publicIp;
        }
        if (args.streams !== undefined && args.streams !== null) {
            this.streams = args.streams;
        }
        if (args.rankValue !== undefined && args.rankValue !== null) {
            this.rankValue = args.rankValue;
        }
        if (args.timestamp !== undefined && args.timestamp !== null) {
            this.timestamp = args.timestamp;
        }
        if (args.publicIpString !== undefined && args.publicIpString !== null) {
            this.publicIpString = args.publicIpString;
        }
        if (args.privateIpString !== undefined && args.privateIpString !== null) {
            this.privateIpString = args.privateIpString;
        }
        if (args.watchingQualityLevel !== undefined && args.watchingQualityLevel !== null) {
            this.watchingQualityLevel = args.watchingQualityLevel;
        }
        if (args.localityGroupId !== undefined && args.localityGroupId !== null) {
            this.localityGroupId = args.localityGroupId;
        }
        if (args.isVpn !== undefined && args.isVpn !== null) {
            this.isVpn = args.isVpn;
        }
    }
};
hive.services.protocol.tracker.TrackerPeerInfo.prototype = {};
hive.services.protocol.tracker.TrackerPeerInfo.prototype.read = function (input) {
    input.readStructBegin();
    while (true) {
        var ret = input.readFieldBegin();
        var fname = ret.fname;
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
            break;
        }
        switch (fid) {
            case 1:
                if (ftype == Thrift.Type.STRING) {
                    this.guid = input.readBinary().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 2:
                if (ftype == Thrift.Type.I32) {
                    this.internalAs = input.readI32().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 3:
                if (ftype == Thrift.Type.I32) {
                    this.externalAs = input.readI32().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 4:
                if (ftype == Thrift.Type.I32) {
                    this.nat = input.readI32().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 5:
                if (ftype == Thrift.Type.I32) {
                    this.bandwidth = input.readI32().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 6:
                if (ftype == Thrift.Type.I32) {
                    this.watchingBitrate = input.readI32().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 7:
                if (ftype == Thrift.Type.STRUCT) {
                    this.privateIp = new InetAddress();
                    this.privateIp.read(input);
                } else {
                    input.skip(ftype);
                }
                break;
            case 8:
                if (ftype == Thrift.Type.STRUCT) {
                    this.publicIp = new InetAddress();
                    this.publicIp.read(input);
                } else {
                    input.skip(ftype);
                }
                break;
            case 9:
                if (ftype == Thrift.Type.LIST) {
                    var _size0 = 0;
                    var _rtmp34;
                    this.streams = [];
                    var _etype3 = 0;
                    _rtmp34 = input.readListBegin();
                    _etype3 = _rtmp34.etype;
                    _size0 = _rtmp34.size;
                    for (var _i5 = 0; _i5 < _size0; ++_i5) {
                        var elem6 = null;
                        elem6 = new hive.services.protocol.tracker.TrackerPeerStreamInfo();
                        elem6.read(input);
                        this.streams.push(elem6);
                    }
                    input.readListEnd();
                } else {
                    input.skip(ftype);
                }
                break;
            case 10:
                if (ftype == Thrift.Type.DOUBLE) {
                    this.rankValue = input.readDouble().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 11:
                if (ftype == Thrift.Type.I64) {
                    this.timestamp = input.readI64().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 12:
                if (ftype == Thrift.Type.STRING) {
                    this.publicIpString = input.readString().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 13:
                if (ftype == Thrift.Type.STRING) {
                    this.privateIpString = input.readString().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 14:
                if (ftype == Thrift.Type.STRING) {
                    this.watchingQualityLevel = input.readString().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 15:
                if (ftype == Thrift.Type.I32) {
                    this.localityGroupId = input.readI32().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 16:
                if (ftype == Thrift.Type.BOOL) {
                    this.isVpn = input.readBool().value;
                } else {
                    input.skip(ftype);
                }
                break;
            default:
                input.skip(ftype);
        }
        input.readFieldEnd();
    }
    input.readStructEnd();
    return;
};

hive.services.protocol.tracker.TrackerPeerInfo.prototype.write = function (output) {
    output.writeStructBegin('TrackerPeerInfo');
    if (this.guid !== null && this.guid !== undefined) {
        output.writeFieldBegin('guid', Thrift.Type.STRING, 1);
        output.writeBinary(this.guid);
        output.writeFieldEnd();
    }
    if (this.internalAs !== null && this.internalAs !== undefined) {
        output.writeFieldBegin('internalAs', Thrift.Type.I32, 2);
        output.writeI32(this.internalAs);
        output.writeFieldEnd();
    }
    if (this.externalAs !== null && this.externalAs !== undefined) {
        output.writeFieldBegin('externalAs', Thrift.Type.I32, 3);
        output.writeI32(this.externalAs);
        output.writeFieldEnd();
    }
    if (this.nat !== null && this.nat !== undefined) {
        output.writeFieldBegin('nat', Thrift.Type.I32, 4);
        output.writeI32(this.nat);
        output.writeFieldEnd();
    }
    if (this.bandwidth !== null && this.bandwidth !== undefined) {
        output.writeFieldBegin('bandwidth', Thrift.Type.I32, 5);
        output.writeI32(this.bandwidth);
        output.writeFieldEnd();
    }
    if (this.watchingBitrate !== null && this.watchingBitrate !== undefined) {
        output.writeFieldBegin('watchingBitrate', Thrift.Type.I32, 6);
        output.writeI32(this.watchingBitrate);
        output.writeFieldEnd();
    }
    if (this.privateIp !== null && this.privateIp !== undefined) {
        output.writeFieldBegin('privateIp', Thrift.Type.STRUCT, 7);
        this.privateIp.write(output);
        output.writeFieldEnd();
    }
    if (this.publicIp !== null && this.publicIp !== undefined) {
        output.writeFieldBegin('publicIp', Thrift.Type.STRUCT, 8);
        this.publicIp.write(output);
        output.writeFieldEnd();
    }
    if (this.streams !== null && this.streams !== undefined) {
        output.writeFieldBegin('streams', Thrift.Type.LIST, 9);
        output.writeListBegin(Thrift.Type.STRUCT, this.streams.length);
        for (var iter7 in this.streams) {
            if (this.streams.hasOwnProperty(iter7)) {
                iter7 = this.streams[iter7];
                iter7.write(output);
            }
        }
        output.writeListEnd();
        output.writeFieldEnd();
    }
    if (this.rankValue !== null && this.rankValue !== undefined) {
        output.writeFieldBegin('rankValue', Thrift.Type.DOUBLE, 10);
        output.writeDouble(this.rankValue);
        output.writeFieldEnd();
    }
    if (this.timestamp !== null && this.timestamp !== undefined) {
        output.writeFieldBegin('timestamp', Thrift.Type.I64, 11);
        output.writeI64(this.timestamp);
        output.writeFieldEnd();
    }
    if (this.publicIpString !== null && this.publicIpString !== undefined) {
        output.writeFieldBegin('publicIpString', Thrift.Type.STRING, 12);
        output.writeString(this.publicIpString);
        output.writeFieldEnd();
    }
    if (this.privateIpString !== null && this.privateIpString !== undefined) {
        output.writeFieldBegin('privateIpString', Thrift.Type.STRING, 13);
        output.writeString(this.privateIpString);
        output.writeFieldEnd();
    }
    if (this.watchingQualityLevel !== null && this.watchingQualityLevel !== undefined) {
        output.writeFieldBegin('watchingQualityLevel', Thrift.Type.STRING, 14);
        output.writeString(this.watchingQualityLevel);
        output.writeFieldEnd();
    }
    if (this.localityGroupId !== null && this.localityGroupId !== undefined) {
        output.writeFieldBegin('localityGroupId', Thrift.Type.I32, 15);
        output.writeI32(this.localityGroupId);
        output.writeFieldEnd();
    }
    if (this.isVpn !== null && this.isVpn !== undefined) {
        output.writeFieldBegin('isVpn', Thrift.Type.BOOL, 16);
        output.writeBool(this.isVpn);
        output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
};

hive.services.protocol.tracker.CustomerKey = function (args) {
    this.partnerId = null;
    this.customerId = null;
    if (args) {
        if (args.partnerId !== undefined && args.partnerId !== null) {
            this.partnerId = args.partnerId;
        }
        if (args.customerId !== undefined && args.customerId !== null) {
            this.customerId = args.customerId;
        }
    }
};
hive.services.protocol.tracker.CustomerKey.prototype = {};
hive.services.protocol.tracker.CustomerKey.prototype.read = function (input) {
    input.readStructBegin();
    while (true) {
        var ret = input.readFieldBegin();
        var fname = ret.fname;
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
            break;
        }
        switch (fid) {
            case 1:
                if (ftype == Thrift.Type.STRING) {
                    this.partnerId = input.readString().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 2:
                if (ftype == Thrift.Type.STRING) {
                    this.customerId = input.readString().value;
                } else {
                    input.skip(ftype);
                }
                break;
            default:
                input.skip(ftype);
        }
        input.readFieldEnd();
    }
    input.readStructEnd();
    return;
};

hive.services.protocol.tracker.CustomerKey.prototype.write = function (output) {
    output.writeStructBegin('CustomerKey');
    if (this.partnerId !== null && this.partnerId !== undefined) {
        output.writeFieldBegin('partnerId', Thrift.Type.STRING, 1);
        output.writeString(this.partnerId);
        output.writeFieldEnd();
    }
    if (this.customerId !== null && this.customerId !== undefined) {
        output.writeFieldBegin('customerId', Thrift.Type.STRING, 2);
        output.writeString(this.customerId);
        output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
};

hive.services.protocol.tracker.TrackerAsQuery = function (args) {
    this.asType = null;
    this.asn = null;
    if (args) {
        if (args.asType !== undefined && args.asType !== null) {
            this.asType = args.asType;
        }
        if (args.asn !== undefined && args.asn !== null) {
            this.asn = args.asn;
        }
    }
};
hive.services.protocol.tracker.TrackerAsQuery.prototype = {};
hive.services.protocol.tracker.TrackerAsQuery.prototype.read = function (input) {
    input.readStructBegin();
    while (true) {
        var ret = input.readFieldBegin();
        var fname = ret.fname;
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
            break;
        }
        switch (fid) {
            case 1:
                if (ftype == Thrift.Type.I32) {
                    this.asType = input.readI32().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 2:
                if (ftype == Thrift.Type.I32) {
                    this.asn = input.readI32().value;
                } else {
                    input.skip(ftype);
                }
                break;
            default:
                input.skip(ftype);
        }
        input.readFieldEnd();
    }
    input.readStructEnd();
    return;
};

hive.services.protocol.tracker.TrackerAsQuery.prototype.write = function (output) {
    output.writeStructBegin('TrackerAsQuery');
    if (this.asType !== null && this.asType !== undefined) {
        output.writeFieldBegin('asType', Thrift.Type.I32, 1);
        output.writeI32(this.asType);
        output.writeFieldEnd();
    }
    if (this.asn !== null && this.asn !== undefined) {
        output.writeFieldBegin('asn', Thrift.Type.I32, 2);
        output.writeI32(this.asn);
        output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
};

hive.services.protocol.tracker.TrackerBitrateQuery = function (args) {
    this.bitrate = null;
    this.asn = null;
    this.streamState = null;
    if (args) {
        if (args.bitrate !== undefined && args.bitrate !== null) {
            this.bitrate = args.bitrate;
        }
        if (args.asn !== undefined && args.asn !== null) {
            this.asn = args.asn;
        }
        if (args.streamState !== undefined && args.streamState !== null) {
            this.streamState = args.streamState;
        }
    }
};
hive.services.protocol.tracker.TrackerBitrateQuery.prototype = {};
hive.services.protocol.tracker.TrackerBitrateQuery.prototype.read = function (input) {
    input.readStructBegin();
    while (true) {
        var ret = input.readFieldBegin();
        var fname = ret.fname;
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
            break;
        }
        switch (fid) {
            case 1:
                if (ftype == Thrift.Type.I32) {
                    this.bitrate = input.readI32().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 2:
                if (ftype == Thrift.Type.STRUCT) {
                    this.asn = new hive.services.protocol.tracker.TrackerAsQuery();
                    this.asn.read(input);
                } else {
                    input.skip(ftype);
                }
                break;
            case 3:
                if (ftype == Thrift.Type.I32) {
                    this.streamState = input.readI32().value;
                } else {
                    input.skip(ftype);
                }
                break;
            default:
                input.skip(ftype);
        }
        input.readFieldEnd();
    }
    input.readStructEnd();
    return;
};

hive.services.protocol.tracker.TrackerBitrateQuery.prototype.write = function (output) {
    output.writeStructBegin('TrackerBitrateQuery');
    if (this.bitrate !== null && this.bitrate !== undefined) {
        output.writeFieldBegin('bitrate', Thrift.Type.I32, 1);
        output.writeI32(this.bitrate);
        output.writeFieldEnd();
    }
    if (this.asn !== null && this.asn !== undefined) {
        output.writeFieldBegin('asn', Thrift.Type.STRUCT, 2);
        this.asn.write(output);
        output.writeFieldEnd();
    }
    if (this.streamState !== null && this.streamState !== undefined) {
        output.writeFieldBegin('streamState', Thrift.Type.I32, 3);
        output.writeI32(this.streamState);
        output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
};

hive.services.protocol.tracker.TrackerQualityLevelQuery = function (args) {
    this.qualityLevel = null;
    this.asn = null;
    this.streamState = null;
    if (args) {
        if (args.qualityLevel !== undefined && args.qualityLevel !== null) {
            this.qualityLevel = args.qualityLevel;
        }
        if (args.asn !== undefined && args.asn !== null) {
            this.asn = args.asn;
        }
        if (args.streamState !== undefined && args.streamState !== null) {
            this.streamState = args.streamState;
        }
    }
};
hive.services.protocol.tracker.TrackerQualityLevelQuery.prototype = {};
hive.services.protocol.tracker.TrackerQualityLevelQuery.prototype.read = function (input) {
    input.readStructBegin();
    while (true) {
        var ret = input.readFieldBegin();
        var fname = ret.fname;
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
            break;
        }
        switch (fid) {
            case 1:
                if (ftype == Thrift.Type.STRING) {
                    this.qualityLevel = input.readString().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 2:
                if (ftype == Thrift.Type.STRUCT) {
                    this.asn = new hive.services.protocol.tracker.TrackerAsQuery();
                    this.asn.read(input);
                } else {
                    input.skip(ftype);
                }
                break;
            case 3:
                if (ftype == Thrift.Type.I32) {
                    this.streamState = input.readI32().value;
                } else {
                    input.skip(ftype);
                }
                break;
            default:
                input.skip(ftype);
        }
        input.readFieldEnd();
    }
    input.readStructEnd();
    return;
};

hive.services.protocol.tracker.TrackerQualityLevelQuery.prototype.write = function (output) {
    output.writeStructBegin('TrackerQualityLevelQuery');
    if (this.qualityLevel !== null && this.qualityLevel !== undefined) {
        output.writeFieldBegin('qualityLevel', Thrift.Type.STRING, 1);
        output.writeString(this.qualityLevel);
        output.writeFieldEnd();
    }
    if (this.asn !== null && this.asn !== undefined) {
        output.writeFieldBegin('asn', Thrift.Type.STRUCT, 2);
        this.asn.write(output);
        output.writeFieldEnd();
    }
    if (this.streamState !== null && this.streamState !== undefined) {
        output.writeFieldBegin('streamState', Thrift.Type.I32, 3);
        output.writeI32(this.streamState);
        output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
};

hive.services.protocol.tracker.TrackerRankQuery = function (args) {
    this.rankType = null;
    this.asQuery = null;
    if (args) {
        if (args.rankType !== undefined && args.rankType !== null) {
            this.rankType = args.rankType;
        }
        if (args.asQuery !== undefined && args.asQuery !== null) {
            this.asQuery = args.asQuery;
        }
    }
};
hive.services.protocol.tracker.TrackerRankQuery.prototype = {};
hive.services.protocol.tracker.TrackerRankQuery.prototype.read = function (input) {
    input.readStructBegin();
    while (true) {
        var ret = input.readFieldBegin();
        var fname = ret.fname;
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
            break;
        }
        switch (fid) {
            case 1:
                if (ftype == Thrift.Type.I32) {
                    this.rankType = input.readI32().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 2:
                if (ftype == Thrift.Type.STRUCT) {
                    this.asQuery = new hive.services.protocol.tracker.TrackerAsQuery();
                    this.asQuery.read(input);
                } else {
                    input.skip(ftype);
                }
                break;
            default:
                input.skip(ftype);
        }
        input.readFieldEnd();
    }
    input.readStructEnd();
    return;
};

hive.services.protocol.tracker.TrackerRankQuery.prototype.write = function (output) {
    output.writeStructBegin('TrackerRankQuery');
    if (this.rankType !== null && this.rankType !== undefined) {
        output.writeFieldBegin('rankType', Thrift.Type.I32, 1);
        output.writeI32(this.rankType);
        output.writeFieldEnd();
    }
    if (this.asQuery !== null && this.asQuery !== undefined) {
        output.writeFieldBegin('asQuery', Thrift.Type.STRUCT, 2);
        this.asQuery.write(output);
        output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
};

hive.services.protocol.tracker.TrackerQuery = function (args) {
    this.random = null;
    this.asns = null;
    this.watchers = null;
    this.streamers = null;
    this.rankings = null;
    this.watchersForQualityLevel = null;
    this.streamersForQualityLevel = null;
    if (args) {
        if (args.random !== undefined && args.random !== null) {
            this.random = args.random;
        }
        if (args.asns !== undefined && args.asns !== null) {
            this.asns = args.asns;
        }
        if (args.watchers !== undefined && args.watchers !== null) {
            this.watchers = args.watchers;
        }
        if (args.streamers !== undefined && args.streamers !== null) {
            this.streamers = args.streamers;
        }
        if (args.rankings !== undefined && args.rankings !== null) {
            this.rankings = args.rankings;
        }
        if (args.watchersForQualityLevel !== undefined && args.watchersForQualityLevel !== null) {
            this.watchersForQualityLevel = args.watchersForQualityLevel;
        }
        if (args.streamersForQualityLevel !== undefined && args.streamersForQualityLevel !== null) {
            this.streamersForQualityLevel = args.streamersForQualityLevel;
        }
    }
};
hive.services.protocol.tracker.TrackerQuery.prototype = {};
hive.services.protocol.tracker.TrackerQuery.prototype.read = function (input) {
    input.readStructBegin();
    while (true) {
        var ret = input.readFieldBegin();
        var fname = ret.fname;
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
            break;
        }
        switch (fid) {
            case 1:
                if (ftype == Thrift.Type.I32) {
                    this.random = input.readI32().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 2:
                if (ftype == Thrift.Type.MAP) {
                    var _size8 = 0;
                    var _rtmp312;
                    this.asns = {};
                    var _ktype9 = 0;
                    var _vtype10 = 0;
                    _rtmp312 = input.readMapBegin();
                    _ktype9 = _rtmp312.ktype;
                    _vtype10 = _rtmp312.vtype;
                    _size8 = _rtmp312.size;
                    for (var _i13 = 0; _i13 < _size8; ++_i13) {
                        if (_i13 > 0) {
                            if (input.rstack.length > input.rpos[input.rpos.length - 1] + 1) {
                                input.rstack.pop();
                            }
                        }
                        var key14 = null;
                        var val15 = null;
                        key14 = new hive.services.protocol.tracker.TrackerAsQuery();
                        key14.read(input);
                        val15 = input.readI32().value;
                        this.asns[key14] = val15;
                    }
                    input.readMapEnd();
                } else {
                    input.skip(ftype);
                }
                break;
            case 3:
                if (ftype == Thrift.Type.MAP) {
                    var _size16 = 0;
                    var _rtmp320;
                    this.watchers = {};
                    var _ktype17 = 0;
                    var _vtype18 = 0;
                    _rtmp320 = input.readMapBegin();
                    _ktype17 = _rtmp320.ktype;
                    _vtype18 = _rtmp320.vtype;
                    _size16 = _rtmp320.size;
                    for (var _i21 = 0; _i21 < _size16; ++_i21) {
                        if (_i21 > 0) {
                            if (input.rstack.length > input.rpos[input.rpos.length - 1] + 1) {
                                input.rstack.pop();
                            }
                        }
                        var key22 = null;
                        var val23 = null;
                        key22 = new hive.services.protocol.tracker.TrackerBitrateQuery();
                        key22.read(input);
                        val23 = input.readI32().value;
                        this.watchers[key22] = val23;
                    }
                    input.readMapEnd();
                } else {
                    input.skip(ftype);
                }
                break;
            case 4:
                if (ftype == Thrift.Type.MAP) {
                    var _size24 = 0;
                    var _rtmp328;
                    this.streamers = {};
                    var _ktype25 = 0;
                    var _vtype26 = 0;
                    _rtmp328 = input.readMapBegin();
                    _ktype25 = _rtmp328.ktype;
                    _vtype26 = _rtmp328.vtype;
                    _size24 = _rtmp328.size;
                    for (var _i29 = 0; _i29 < _size24; ++_i29) {
                        if (_i29 > 0) {
                            if (input.rstack.length > input.rpos[input.rpos.length - 1] + 1) {
                                input.rstack.pop();
                            }
                        }
                        var key30 = null;
                        var val31 = null;
                        key30 = new hive.services.protocol.tracker.TrackerBitrateQuery();
                        key30.read(input);
                        val31 = input.readI32().value;
                        this.streamers[key30] = val31;
                    }
                    input.readMapEnd();
                } else {
                    input.skip(ftype);
                }
                break;
            case 5:
                if (ftype == Thrift.Type.LIST) {
                    var _size32 = 0;
                    var _rtmp336;
                    this.rankings = [];
                    var _etype35 = 0;
                    _rtmp336 = input.readListBegin();
                    _etype35 = _rtmp336.etype;
                    _size32 = _rtmp336.size;
                    for (var _i37 = 0; _i37 < _size32; ++_i37) {
                        var elem38 = null;
                        elem38 = input.readI32().value;
                        this.rankings.push(elem38);
                    }
                    input.readListEnd();
                } else {
                    input.skip(ftype);
                }
                break;
            case 6:
                if (ftype == Thrift.Type.MAP) {
                    var _size39 = 0;
                    var _rtmp343;
                    this.watchersForQualityLevel = {};
                    var _ktype40 = 0;
                    var _vtype41 = 0;
                    _rtmp343 = input.readMapBegin();
                    _ktype40 = _rtmp343.ktype;
                    _vtype41 = _rtmp343.vtype;
                    _size39 = _rtmp343.size;
                    for (var _i44 = 0; _i44 < _size39; ++_i44) {
                        if (_i44 > 0) {
                            if (input.rstack.length > input.rpos[input.rpos.length - 1] + 1) {
                                input.rstack.pop();
                            }
                        }
                        var key45 = null;
                        var val46 = null;
                        key45 = new hive.services.protocol.tracker.TrackerQualityLevelQuery();
                        key45.read(input);
                        val46 = input.readI32().value;
                        this.watchersForQualityLevel[key45] = val46;
                    }
                    input.readMapEnd();
                } else {
                    input.skip(ftype);
                }
                break;
            case 7:
                if (ftype == Thrift.Type.MAP) {
                    var _size47 = 0;
                    var _rtmp351;
                    this.streamersForQualityLevel = {};
                    var _ktype48 = 0;
                    var _vtype49 = 0;
                    _rtmp351 = input.readMapBegin();
                    _ktype48 = _rtmp351.ktype;
                    _vtype49 = _rtmp351.vtype;
                    _size47 = _rtmp351.size;
                    for (var _i52 = 0; _i52 < _size47; ++_i52) {
                        if (_i52 > 0) {
                            if (input.rstack.length > input.rpos[input.rpos.length - 1] + 1) {
                                input.rstack.pop();
                            }
                        }
                        var key53 = null;
                        var val54 = null;
                        key53 = new hive.services.protocol.tracker.TrackerQualityLevelQuery();
                        key53.read(input);
                        val54 = input.readI32().value;
                        this.streamersForQualityLevel[key53] = val54;
                    }
                    input.readMapEnd();
                } else {
                    input.skip(ftype);
                }
                break;
            default:
                input.skip(ftype);
        }
        input.readFieldEnd();
    }
    input.readStructEnd();
    return;
};

hive.services.protocol.tracker.TrackerQuery.prototype.write = function (output) {
    output.writeStructBegin('TrackerQuery');
    if (this.random !== null && this.random !== undefined) {
        output.writeFieldBegin('random', Thrift.Type.I32, 1);
        output.writeI32(this.random);
        output.writeFieldEnd();
    }
    if (this.asns !== null && this.asns !== undefined) {
        output.writeFieldBegin('asns', Thrift.Type.MAP, 2);
        output.writeMapBegin(Thrift.Type.STRUCT, Thrift.Type.I32, Thrift.objectLength(this.asns));
        for (var kiter55 in this.asns) {
            if (this.asns.hasOwnProperty(kiter55)) {
                var viter56 = this.asns[kiter55];
                viter56.key.write(output);
                output.writeI32(viter56.value);
            }
        }
        output.writeMapEnd();
        output.writeFieldEnd();
    }
    if (this.watchers !== null && this.watchers !== undefined) {
        output.writeFieldBegin('watchers', Thrift.Type.MAP, 3);
        output.writeMapBegin(Thrift.Type.STRUCT, Thrift.Type.I32, Thrift.objectLength(this.watchers));
        for (var kiter57 in this.watchers) {
            if (this.watchers.hasOwnProperty(kiter57)) {
                var viter58 = this.watchers[kiter57];
                viter58.key.write(output);
                output.writeI32(viter58.value);
            }
        }
        output.writeMapEnd();
        output.writeFieldEnd();
    }
    if (this.streamers !== null && this.streamers !== undefined) {
        output.writeFieldBegin('streamers', Thrift.Type.MAP, 4);
        output.writeMapBegin(Thrift.Type.STRUCT, Thrift.Type.I32, Thrift.objectLength(this.streamers));
        for (var kiter59 in this.streamers) {
            if (this.streamers.hasOwnProperty(kiter59)) {
                var viter60 = this.streamers[kiter59];
                viter60.key.write(output);
                output.writeI32(viter60.value);
            }
        }
        output.writeMapEnd();
        output.writeFieldEnd();
    }
    if (this.rankings !== null && this.rankings !== undefined) {
        output.writeFieldBegin('rankings', Thrift.Type.LIST, 5);
        output.writeListBegin(Thrift.Type.I32, this.rankings.length);
        for (var iter61 in this.rankings) {
            if (this.rankings.hasOwnProperty(iter61)) {
                iter61 = this.rankings[iter61];
                output.writeI32(iter61);
            }
        }
        output.writeListEnd();
        output.writeFieldEnd();
    }
    if (this.watchersForQualityLevel !== null && this.watchersForQualityLevel !== undefined) {
        output.writeFieldBegin('watchersForQualityLevel', Thrift.Type.MAP, 6);
        output.writeMapBegin(Thrift.Type.STRUCT, Thrift.Type.I32, Thrift.objectLength(this.watchersForQualityLevel));
        for (var kiter62 in this.watchersForQualityLevel) {
            if (this.watchersForQualityLevel.hasOwnProperty(kiter62)) {
                var viter63 = this.watchersForQualityLevel[kiter62];
                viter63.key.write(output);
                output.writeI32(viter63.value);
            }
        }
        output.writeMapEnd();
        output.writeFieldEnd();
    }
    if (this.streamersForQualityLevel !== null && this.streamersForQualityLevel !== undefined) {
        output.writeFieldBegin('streamersForQualityLevel', Thrift.Type.MAP, 7);
        output.writeMapBegin(Thrift.Type.STRUCT, Thrift.Type.I32, Thrift.objectLength(this.streamersForQualityLevel));
        for (var kiter64 in this.streamersForQualityLevel) {
            if (this.streamersForQualityLevel.hasOwnProperty(kiter64)) {
                var viter65 = this.streamersForQualityLevel[kiter64];
                viter65.key.write(output);
                output.writeI32(viter65.value);
            }
        }
        output.writeMapEnd();
        output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
};

hive.services.protocol.tracker.TrackerPeerRankingKey = function (args) {
    this.rankType = null;
    this.internalAs = null;
    this.externalAs = null;
    if (args) {
        if (args.rankType !== undefined && args.rankType !== null) {
            this.rankType = args.rankType;
        }
        if (args.internalAs !== undefined && args.internalAs !== null) {
            this.internalAs = args.internalAs;
        }
        if (args.externalAs !== undefined && args.externalAs !== null) {
            this.externalAs = args.externalAs;
        }
    }
};
hive.services.protocol.tracker.TrackerPeerRankingKey.prototype = {};
hive.services.protocol.tracker.TrackerPeerRankingKey.prototype.read = function (input) {
    input.readStructBegin();
    while (true) {
        var ret = input.readFieldBegin();
        var fname = ret.fname;
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
            break;
        }
        switch (fid) {
            case 1:
                if (ftype == Thrift.Type.I32) {
                    this.rankType = input.readI32().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 2:
                if (ftype == Thrift.Type.I32) {
                    this.internalAs = input.readI32().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 3:
                if (ftype == Thrift.Type.I32) {
                    this.externalAs = input.readI32().value;
                } else {
                    input.skip(ftype);
                }
                break;
            default:
                input.skip(ftype);
        }
        input.readFieldEnd();
    }
    input.readStructEnd();
    return;
};

hive.services.protocol.tracker.TrackerPeerRankingKey.prototype.write = function (output) {
    output.writeStructBegin('TrackerPeerRankingKey');
    if (this.rankType !== null && this.rankType !== undefined) {
        output.writeFieldBegin('rankType', Thrift.Type.I32, 1);
        output.writeI32(this.rankType);
        output.writeFieldEnd();
    }
    if (this.internalAs !== null && this.internalAs !== undefined) {
        output.writeFieldBegin('internalAs', Thrift.Type.I32, 2);
        output.writeI32(this.internalAs);
        output.writeFieldEnd();
    }
    if (this.externalAs !== null && this.externalAs !== undefined) {
        output.writeFieldBegin('externalAs', Thrift.Type.I32, 3);
        output.writeI32(this.externalAs);
        output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
};

hive.services.protocol.tracker.TrackerPeerRanking = function (args) {
    this.key = null;
    this.ranking = null;
    this.groupSize = null;
    this.cumulatedRankValue = null;
    this.totalOfRankValues = null;
    if (args) {
        if (args.key !== undefined && args.key !== null) {
            this.key = args.key;
        }
        if (args.ranking !== undefined && args.ranking !== null) {
            this.ranking = args.ranking;
        }
        if (args.groupSize !== undefined && args.groupSize !== null) {
            this.groupSize = args.groupSize;
        }
        if (args.cumulatedRankValue !== undefined && args.cumulatedRankValue !== null) {
            this.cumulatedRankValue = args.cumulatedRankValue;
        }
        if (args.totalOfRankValues !== undefined && args.totalOfRankValues !== null) {
            this.totalOfRankValues = args.totalOfRankValues;
        }
    }
};
hive.services.protocol.tracker.TrackerPeerRanking.prototype = {};
hive.services.protocol.tracker.TrackerPeerRanking.prototype.read = function (input) {
    input.readStructBegin();
    while (true) {
        var ret = input.readFieldBegin();
        var fname = ret.fname;
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
            break;
        }
        switch (fid) {
            case 1:
                if (ftype == Thrift.Type.STRUCT) {
                    this.key = new hive.services.protocol.tracker.TrackerPeerRankingKey();
                    this.key.read(input);
                } else {
                    input.skip(ftype);
                }
                break;
            case 2:
                if (ftype == Thrift.Type.I32) {
                    this.ranking = input.readI32().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 3:
                if (ftype == Thrift.Type.I32) {
                    this.groupSize = input.readI32().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 4:
                if (ftype == Thrift.Type.DOUBLE) {
                    this.cumulatedRankValue = input.readDouble().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 5:
                if (ftype == Thrift.Type.DOUBLE) {
                    this.totalOfRankValues = input.readDouble().value;
                } else {
                    input.skip(ftype);
                }
                break;
            default:
                input.skip(ftype);
        }
        input.readFieldEnd();
    }
    input.readStructEnd();
    return;
};

hive.services.protocol.tracker.TrackerPeerRanking.prototype.write = function (output) {
    output.writeStructBegin('TrackerPeerRanking');
    if (this.key !== null && this.key !== undefined) {
        output.writeFieldBegin('key', Thrift.Type.STRUCT, 1);
        this.key.write(output);
        output.writeFieldEnd();
    }
    if (this.ranking !== null && this.ranking !== undefined) {
        output.writeFieldBegin('ranking', Thrift.Type.I32, 2);
        output.writeI32(this.ranking);
        output.writeFieldEnd();
    }
    if (this.groupSize !== null && this.groupSize !== undefined) {
        output.writeFieldBegin('groupSize', Thrift.Type.I32, 3);
        output.writeI32(this.groupSize);
        output.writeFieldEnd();
    }
    if (this.cumulatedRankValue !== null && this.cumulatedRankValue !== undefined) {
        output.writeFieldBegin('cumulatedRankValue', Thrift.Type.DOUBLE, 4);
        output.writeDouble(this.cumulatedRankValue);
        output.writeFieldEnd();
    }
    if (this.totalOfRankValues !== null && this.totalOfRankValues !== undefined) {
        output.writeFieldBegin('totalOfRankValues', Thrift.Type.DOUBLE, 5);
        output.writeDouble(this.totalOfRankValues);
        output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
};

hive.services.protocol.tracker.TrackerRequest = function (args) {
    this.info = null;
    this.contentId = null;
    this.query = null;
    this.streamType = null;
    this.sessionId = null;
    this.customerKey = null;
    if (args) {
        if (args.info !== undefined && args.info !== null) {
            this.info = args.info;
        }
        if (args.contentId !== undefined && args.contentId !== null) {
            this.contentId = args.contentId;
        }
        if (args.query !== undefined && args.query !== null) {
            this.query = args.query;
        }
        if (args.streamType !== undefined && args.streamType !== null) {
            this.streamType = args.streamType;
        }
        if (args.sessionId !== undefined && args.sessionId !== null) {
            this.sessionId = args.sessionId;
        }
        if (args.customerKey !== undefined && args.customerKey !== null) {
            this.customerKey = args.customerKey;
        }
    }
};
hive.services.protocol.tracker.TrackerRequest.prototype = {};
hive.services.protocol.tracker.TrackerRequest.prototype.read = function (input) {
    input.readStructBegin();
    while (true) {
        var ret = input.readFieldBegin();
        var fname = ret.fname;
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
            break;
        }
        switch (fid) {
            case 1:
                if (ftype == Thrift.Type.STRUCT) {
                    this.info = new hive.services.protocol.tracker.TrackerPeerInfo();
                    this.info.read(input);
                } else {
                    input.skip(ftype);
                }
                break;
            case 2:
                if (ftype == Thrift.Type.STRING) {
                    this.contentId = input.readString().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 3:
                if (ftype == Thrift.Type.STRUCT) {
                    this.query = new hive.services.protocol.tracker.TrackerQuery();
                    this.query.read(input);
                } else {
                    input.skip(ftype);
                }
                break;
            case 4:
                if (ftype == Thrift.Type.I32) {
                    this.streamType = input.readI32().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 5:
                if (ftype == Thrift.Type.STRING) {
                    this.sessionId = input.readString().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 6:
                if (ftype == Thrift.Type.STRUCT) {
                    this.customerKey = new hive.services.protocol.tracker.CustomerKey();
                    this.customerKey.read(input);
                } else {
                    input.skip(ftype);
                }
                break;
            default:
                input.skip(ftype);
        }
        input.readFieldEnd();
    }
    input.readStructEnd();
    return;
};

hive.services.protocol.tracker.TrackerRequest.prototype.write = function (output) {
    output.writeStructBegin('TrackerRequest');
    if (this.info !== null && this.info !== undefined) {
        output.writeFieldBegin('info', Thrift.Type.STRUCT, 1);
        this.info.write(output);
        output.writeFieldEnd();
    }
    if (this.contentId !== null && this.contentId !== undefined) {
        output.writeFieldBegin('contentId', Thrift.Type.STRING, 2);
        output.writeString(this.contentId);
        output.writeFieldEnd();
    }
    if (this.query !== null && this.query !== undefined) {
        output.writeFieldBegin('query', Thrift.Type.STRUCT, 3);
        this.query.write(output);
        output.writeFieldEnd();
    }
    if (this.streamType !== null && this.streamType !== undefined) {
        output.writeFieldBegin('streamType', Thrift.Type.I32, 4);
        output.writeI32(this.streamType);
        output.writeFieldEnd();
    }
    if (this.sessionId !== null && this.sessionId !== undefined) {
        output.writeFieldBegin('sessionId', Thrift.Type.STRING, 5);
        output.writeString(this.sessionId);
        output.writeFieldEnd();
    }
    if (this.customerKey !== null && this.customerKey !== undefined) {
        output.writeFieldBegin('customerKey', Thrift.Type.STRUCT, 6);
        this.customerKey.write(output);
        output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
};

hive.services.protocol.tracker.TrackerResponse = function (args) {
    this.infos = null;
    this.rankings = null;
    this.peerInfo = null;
    this.sessionId = null;
    if (args) {
        if (args.infos !== undefined && args.infos !== null) {
            this.infos = args.infos;
        }
        if (args.rankings !== undefined && args.rankings !== null) {
            this.rankings = args.rankings;
        }
        if (args.peerInfo !== undefined && args.peerInfo !== null) {
            this.peerInfo = args.peerInfo;
        }
        if (args.sessionId !== undefined && args.sessionId !== null) {
            this.sessionId = args.sessionId;
        }
    }
};
hive.services.protocol.tracker.TrackerResponse.prototype = {};
hive.services.protocol.tracker.TrackerResponse.prototype.read = function (input) {
    input.readStructBegin();
    while (true) {
        var ret = input.readFieldBegin();
        var fname = ret.fname;
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
            break;
        }
        switch (fid) {
            case 1:
                if (ftype == Thrift.Type.LIST) {
                    var _size66 = 0;
                    var _rtmp370;
                    this.infos = [];
                    var _etype69 = 0;
                    _rtmp370 = input.readListBegin();
                    _etype69 = _rtmp370.etype;
                    _size66 = _rtmp370.size;
                    for (var _i71 = 0; _i71 < _size66; ++_i71) {
                        var elem72 = null;
                        elem72 = new hive.services.protocol.tracker.TrackerPeerInfo();
                        elem72.read(input);
                        this.infos.push(elem72);
                    }
                    input.readListEnd();
                } else {
                    input.skip(ftype);
                }
                break;
            case 2:
                if (ftype == Thrift.Type.LIST) {
                    var _size73 = 0;
                    var _rtmp377;
                    this.rankings = [];
                    var _etype76 = 0;
                    _rtmp377 = input.readListBegin();
                    _etype76 = _rtmp377.etype;
                    _size73 = _rtmp377.size;
                    for (var _i78 = 0; _i78 < _size73; ++_i78) {
                        var elem79 = null;
                        elem79 = new hive.services.protocol.tracker.TrackerPeerRanking();
                        elem79.read(input);
                        this.rankings.push(elem79);
                    }
                    input.readListEnd();
                } else {
                    input.skip(ftype);
                }
                break;
            case 3:
                if (ftype == Thrift.Type.STRUCT) {
                    this.peerInfo = new hive.services.protocol.tracker.TrackerPeerInfo();
                    this.peerInfo.read(input);
                } else {
                    input.skip(ftype);
                }
                break;
            case 4:
                if (ftype == Thrift.Type.STRING) {
                    this.sessionId = input.readString().value;
                } else {
                    input.skip(ftype);
                }
                break;
            default:
                input.skip(ftype);
        }
        input.readFieldEnd();
    }
    input.readStructEnd();
    return;
};

hive.services.protocol.tracker.TrackerResponse.prototype.write = function (output) {
    output.writeStructBegin('TrackerResponse');
    if (this.infos !== null && this.infos !== undefined) {
        output.writeFieldBegin('infos', Thrift.Type.LIST, 1);
        output.writeListBegin(Thrift.Type.STRUCT, this.infos.length);
        for (var iter80 in this.infos) {
            if (this.infos.hasOwnProperty(iter80)) {
                iter80 = this.infos[iter80];
                iter80.write(output);
            }
        }
        output.writeListEnd();
        output.writeFieldEnd();
    }
    if (this.rankings !== null && this.rankings !== undefined) {
        output.writeFieldBegin('rankings', Thrift.Type.LIST, 2);
        output.writeListBegin(Thrift.Type.STRUCT, this.rankings.length);
        for (var iter81 in this.rankings) {
            if (this.rankings.hasOwnProperty(iter81)) {
                iter81 = this.rankings[iter81];
                iter81.write(output);
            }
        }
        output.writeListEnd();
        output.writeFieldEnd();
    }
    if (this.peerInfo !== null && this.peerInfo !== undefined) {
        output.writeFieldBegin('peerInfo', Thrift.Type.STRUCT, 3);
        this.peerInfo.write(output);
        output.writeFieldEnd();
    }
    if (this.sessionId !== null && this.sessionId !== undefined) {
        output.writeFieldBegin('sessionId', Thrift.Type.STRING, 4);
        output.writeString(this.sessionId);
        output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
};

hive.services.protocol.tracker.TrackerStoreIndexKey = function (args) {
    this.timestamp = null;
    this.contentId = null;
    this.asType = null;
    this.asn = null;
    this.bitrate = null;
    this.streamState = null;
    this.rankType = null;
    this.qualityLevel = null;
    if (args) {
        if (args.timestamp !== undefined && args.timestamp !== null) {
            this.timestamp = args.timestamp;
        }
        if (args.contentId !== undefined && args.contentId !== null) {
            this.contentId = args.contentId;
        }
        if (args.asType !== undefined && args.asType !== null) {
            this.asType = args.asType;
        }
        if (args.asn !== undefined && args.asn !== null) {
            this.asn = args.asn;
        }
        if (args.bitrate !== undefined && args.bitrate !== null) {
            this.bitrate = args.bitrate;
        }
        if (args.streamState !== undefined && args.streamState !== null) {
            this.streamState = args.streamState;
        }
        if (args.rankType !== undefined && args.rankType !== null) {
            this.rankType = args.rankType;
        }
        if (args.qualityLevel !== undefined && args.qualityLevel !== null) {
            this.qualityLevel = args.qualityLevel;
        }
    }
};
hive.services.protocol.tracker.TrackerStoreIndexKey.prototype = {};
hive.services.protocol.tracker.TrackerStoreIndexKey.prototype.read = function (input) {
    input.readStructBegin();
    while (true) {
        var ret = input.readFieldBegin();
        var fname = ret.fname;
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
            break;
        }
        switch (fid) {
            case 1:
                if (ftype == Thrift.Type.I32) {
                    this.timestamp = input.readI32().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 2:
                if (ftype == Thrift.Type.STRING) {
                    this.contentId = input.readString().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 3:
                if (ftype == Thrift.Type.I32) {
                    this.asType = input.readI32().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 4:
                if (ftype == Thrift.Type.I32) {
                    this.asn = input.readI32().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 5:
                if (ftype == Thrift.Type.I32) {
                    this.bitrate = input.readI32().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 6:
                if (ftype == Thrift.Type.I32) {
                    this.streamState = input.readI32().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 7:
                if (ftype == Thrift.Type.I32) {
                    this.rankType = input.readI32().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 8:
                if (ftype == Thrift.Type.STRING) {
                    this.qualityLevel = input.readString().value;
                } else {
                    input.skip(ftype);
                }
                break;
            default:
                input.skip(ftype);
        }
        input.readFieldEnd();
    }
    input.readStructEnd();
    return;
};

hive.services.protocol.tracker.TrackerStoreIndexKey.prototype.write = function (output) {
    output.writeStructBegin('TrackerStoreIndexKey');
    if (this.timestamp !== null && this.timestamp !== undefined) {
        output.writeFieldBegin('timestamp', Thrift.Type.I32, 1);
        output.writeI32(this.timestamp);
        output.writeFieldEnd();
    }
    if (this.contentId !== null && this.contentId !== undefined) {
        output.writeFieldBegin('contentId', Thrift.Type.STRING, 2);
        output.writeString(this.contentId);
        output.writeFieldEnd();
    }
    if (this.asType !== null && this.asType !== undefined) {
        output.writeFieldBegin('asType', Thrift.Type.I32, 3);
        output.writeI32(this.asType);
        output.writeFieldEnd();
    }
    if (this.asn !== null && this.asn !== undefined) {
        output.writeFieldBegin('asn', Thrift.Type.I32, 4);
        output.writeI32(this.asn);
        output.writeFieldEnd();
    }
    if (this.bitrate !== null && this.bitrate !== undefined) {
        output.writeFieldBegin('bitrate', Thrift.Type.I32, 5);
        output.writeI32(this.bitrate);
        output.writeFieldEnd();
    }
    if (this.streamState !== null && this.streamState !== undefined) {
        output.writeFieldBegin('streamState', Thrift.Type.I32, 6);
        output.writeI32(this.streamState);
        output.writeFieldEnd();
    }
    if (this.rankType !== null && this.rankType !== undefined) {
        output.writeFieldBegin('rankType', Thrift.Type.I32, 7);
        output.writeI32(this.rankType);
        output.writeFieldEnd();
    }
    if (this.qualityLevel !== null && this.qualityLevel !== undefined) {
        output.writeFieldBegin('qualityLevel', Thrift.Type.STRING, 8);
        output.writeString(this.qualityLevel);
        output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
};

hive.services.protocol.tracker.TrackerStoreRankPeer = function (args) {
    this.guid = null;
    this.rank = null;
    this.key = null;
    if (args) {
        if (args.guid !== undefined && args.guid !== null) {
            this.guid = args.guid;
        }
        if (args.rank !== undefined && args.rank !== null) {
            this.rank = args.rank;
        }
        if (args.key !== undefined && args.key !== null) {
            this.key = args.key;
        }
    }
};
hive.services.protocol.tracker.TrackerStoreRankPeer.prototype = {};
hive.services.protocol.tracker.TrackerStoreRankPeer.prototype.read = function (input) {
    input.readStructBegin();
    while (true) {
        var ret = input.readFieldBegin();
        var fname = ret.fname;
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
            break;
        }
        switch (fid) {
            case 1:
                if (ftype == Thrift.Type.STRING) {
                    this.guid = input.readBinary().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 2:
                if (ftype == Thrift.Type.DOUBLE) {
                    this.rank = input.readDouble().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 3:
                if (ftype == Thrift.Type.STRUCT) {
                    this.key = new hive.services.protocol.tracker.TrackerPeerRankingKey();
                    this.key.read(input);
                } else {
                    input.skip(ftype);
                }
                break;
            default:
                input.skip(ftype);
        }
        input.readFieldEnd();
    }
    input.readStructEnd();
    return;
};

hive.services.protocol.tracker.TrackerStoreRankPeer.prototype.write = function (output) {
    output.writeStructBegin('TrackerStoreRankPeer');
    if (this.guid !== null && this.guid !== undefined) {
        output.writeFieldBegin('guid', Thrift.Type.STRING, 1);
        output.writeBinary(this.guid);
        output.writeFieldEnd();
    }
    if (this.rank !== null && this.rank !== undefined) {
        output.writeFieldBegin('rank', Thrift.Type.DOUBLE, 2);
        output.writeDouble(this.rank);
        output.writeFieldEnd();
    }
    if (this.key !== null && this.key !== undefined) {
        output.writeFieldBegin('key', Thrift.Type.STRUCT, 3);
        this.key.write(output);
        output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
};

hive.services.protocol.tracker.TrackerRequestQueueKey = function (args) {
    this.guid = null;
    this.contentId = null;
    this.partner = null;
    this.customer = null;
    if (args) {
        if (args.guid !== undefined && args.guid !== null) {
            this.guid = args.guid;
        }
        if (args.contentId !== undefined && args.contentId !== null) {
            this.contentId = args.contentId;
        }
        if (args.partner !== undefined && args.partner !== null) {
            this.partner = args.partner;
        }
        if (args.customer !== undefined && args.customer !== null) {
            this.customer = args.customer;
        }
    }
};
hive.services.protocol.tracker.TrackerRequestQueueKey.prototype = {};
hive.services.protocol.tracker.TrackerRequestQueueKey.prototype.read = function (input) {
    input.readStructBegin();
    while (true) {
        var ret = input.readFieldBegin();
        var fname = ret.fname;
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
            break;
        }
        switch (fid) {
            case 1:
                if (ftype == Thrift.Type.STRING) {
                    this.guid = input.readBinary().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 2:
                if (ftype == Thrift.Type.STRING) {
                    this.contentId = input.readString().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 3:
                if (ftype == Thrift.Type.STRING) {
                    this.partner = input.readString().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 4:
                if (ftype == Thrift.Type.STRING) {
                    this.customer = input.readString().value;
                } else {
                    input.skip(ftype);
                }
                break;
            default:
                input.skip(ftype);
        }
        input.readFieldEnd();
    }
    input.readStructEnd();
    return;
};

hive.services.protocol.tracker.TrackerRequestQueueKey.prototype.write = function (output) {
    output.writeStructBegin('TrackerRequestQueueKey');
    if (this.guid !== null && this.guid !== undefined) {
        output.writeFieldBegin('guid', Thrift.Type.STRING, 1);
        output.writeBinary(this.guid);
        output.writeFieldEnd();
    }
    if (this.contentId !== null && this.contentId !== undefined) {
        output.writeFieldBegin('contentId', Thrift.Type.STRING, 2);
        output.writeString(this.contentId);
        output.writeFieldEnd();
    }
    if (this.partner !== null && this.partner !== undefined) {
        output.writeFieldBegin('partner', Thrift.Type.STRING, 3);
        output.writeString(this.partner);
        output.writeFieldEnd();
    }
    if (this.customer !== null && this.customer !== undefined) {
        output.writeFieldBegin('customer', Thrift.Type.STRING, 4);
        output.writeString(this.customer);
        output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
};

hive.services.protocol.tracker.TrackerRequestQueueMessage = function (args) {
    this.timestamp = null;
    this.request = null;
    this.response = null;
    this.guid = null;
    this.contentId = null;
    this.partner = null;
    this.customer = null;
    if (args) {
        if (args.timestamp !== undefined && args.timestamp !== null) {
            this.timestamp = args.timestamp;
        }
        if (args.request !== undefined && args.request !== null) {
            this.request = args.request;
        }
        if (args.response !== undefined && args.response !== null) {
            this.response = args.response;
        }
        if (args.guid !== undefined && args.guid !== null) {
            this.guid = args.guid;
        }
        if (args.contentId !== undefined && args.contentId !== null) {
            this.contentId = args.contentId;
        }
        if (args.partner !== undefined && args.partner !== null) {
            this.partner = args.partner;
        }
        if (args.customer !== undefined && args.customer !== null) {
            this.customer = args.customer;
        }
    }
};
hive.services.protocol.tracker.TrackerRequestQueueMessage.prototype = {};
hive.services.protocol.tracker.TrackerRequestQueueMessage.prototype.read = function (input) {
    input.readStructBegin();
    while (true) {
        var ret = input.readFieldBegin();
        var fname = ret.fname;
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
            break;
        }
        switch (fid) {
            case 1:
                if (ftype == Thrift.Type.I64) {
                    this.timestamp = input.readI64().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 2:
                if (ftype == Thrift.Type.STRUCT) {
                    this.request = new hive.services.protocol.tracker.TrackerRequest();
                    this.request.read(input);
                } else {
                    input.skip(ftype);
                }
                break;
            case 3:
                if (ftype == Thrift.Type.STRUCT) {
                    this.response = new hive.services.protocol.tracker.TrackerResponse();
                    this.response.read(input);
                } else {
                    input.skip(ftype);
                }
                break;
            case 4:
                if (ftype == Thrift.Type.STRING) {
                    this.guid = input.readBinary().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 5:
                if (ftype == Thrift.Type.STRING) {
                    this.contentId = input.readString().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 6:
                if (ftype == Thrift.Type.STRING) {
                    this.partner = input.readString().value;
                } else {
                    input.skip(ftype);
                }
                break;
            case 7:
                if (ftype == Thrift.Type.STRING) {
                    this.customer = input.readString().value;
                } else {
                    input.skip(ftype);
                }
                break;
            default:
                input.skip(ftype);
        }
        input.readFieldEnd();
    }
    input.readStructEnd();
    return;
};

hive.services.protocol.tracker.TrackerRequestQueueMessage.prototype.write = function (output) {
    output.writeStructBegin('TrackerRequestQueueMessage');
    if (this.timestamp !== null && this.timestamp !== undefined) {
        output.writeFieldBegin('timestamp', Thrift.Type.I64, 1);
        output.writeI64(this.timestamp);
        output.writeFieldEnd();
    }
    if (this.request !== null && this.request !== undefined) {
        output.writeFieldBegin('request', Thrift.Type.STRUCT, 2);
        this.request.write(output);
        output.writeFieldEnd();
    }
    if (this.response !== null && this.response !== undefined) {
        output.writeFieldBegin('response', Thrift.Type.STRUCT, 3);
        this.response.write(output);
        output.writeFieldEnd();
    }
    if (this.guid !== null && this.guid !== undefined) {
        output.writeFieldBegin('guid', Thrift.Type.STRING, 4);
        output.writeBinary(this.guid);
        output.writeFieldEnd();
    }
    if (this.contentId !== null && this.contentId !== undefined) {
        output.writeFieldBegin('contentId', Thrift.Type.STRING, 5);
        output.writeString(this.contentId);
        output.writeFieldEnd();
    }
    if (this.partner !== null && this.partner !== undefined) {
        output.writeFieldBegin('partner', Thrift.Type.STRING, 6);
        output.writeString(this.partner);
        output.writeFieldEnd();
    }
    if (this.customer !== null && this.customer !== undefined) {
        output.writeFieldBegin('customer', Thrift.Type.STRING, 7);
        output.writeString(this.customer);
        output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
};


/***/ }),

/***/ "../../../protocol/services/remote_config_types.js":
/*!**************************************************************************!*\
  !*** /home/omar/Desktop/hivejs/protocol/services/remote_config_types.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

//
// Autogenerated by Thrift Compiler (0.9.3)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//
var Thrift = __webpack_require__(/*! @hivestreaming/thrift */ "../../../node_modules/@hivestreaming/thrift/src/thrift.js");

if (typeof hive === 'undefined') {
  hive = {};
}
if (typeof hive.services === 'undefined') {
  hive.services = {};
}
if (typeof hive.services.protocol === 'undefined') {
  hive.services.protocol = {};
}
if (typeof hive.services.protocol.remoteconfig === 'undefined') {
  hive.services.protocol.remoteconfig = {};
}
hive.services.protocol.remoteconfig.RemoteConfigRequest = function(args) {
  this.partnerId = null;
  this.customerId = null;
  this.privateIps = null;
  this.siteId = null;
  if (args) {
    if (args.partnerId !== undefined && args.partnerId !== null) {
      this.partnerId = args.partnerId;
    }
    if (args.customerId !== undefined && args.customerId !== null) {
      this.customerId = args.customerId;
    }
    if (args.privateIps !== undefined && args.privateIps !== null) {
      this.privateIps = Thrift.copyList(args.privateIps, [null]);
    }
    if (args.siteId !== undefined && args.siteId !== null) {
      this.siteId = args.siteId;
    }
  }
};
hive.services.protocol.remoteconfig.RemoteConfigRequest.prototype = {};
hive.services.protocol.remoteconfig.RemoteConfigRequest.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.partnerId = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRING) {
        this.customerId = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.LIST) {
        var _size0 = 0;
        var _rtmp34;
        this.privateIps = [];
        var _etype3 = 0;
        _rtmp34 = input.readListBegin();
        _etype3 = _rtmp34.etype;
        _size0 = _rtmp34.size;
        for (var _i5 = 0; _i5 < _size0; ++_i5)
        {
          var elem6 = null;
          elem6 = input.readString().value;
          this.privateIps.push(elem6);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.I32) {
        this.siteId = input.readI32().value;
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

hive.services.protocol.remoteconfig.RemoteConfigRequest.prototype.write = function(output) {
  output.writeStructBegin('RemoteConfigRequest');
  if (this.partnerId !== null && this.partnerId !== undefined) {
    output.writeFieldBegin('partnerId', Thrift.Type.STRING, 1);
    output.writeString(this.partnerId);
    output.writeFieldEnd();
  }
  if (this.customerId !== null && this.customerId !== undefined) {
    output.writeFieldBegin('customerId', Thrift.Type.STRING, 2);
    output.writeString(this.customerId);
    output.writeFieldEnd();
  }
  if (this.privateIps !== null && this.privateIps !== undefined) {
    output.writeFieldBegin('privateIps', Thrift.Type.LIST, 3);
    output.writeListBegin(Thrift.Type.STRING, this.privateIps.length);
    for (var iter7 in this.privateIps)
    {
      if (this.privateIps.hasOwnProperty(iter7))
      {
        iter7 = this.privateIps[iter7];
        output.writeString(iter7);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  if (this.siteId !== null && this.siteId !== undefined) {
    output.writeFieldBegin('siteId', Thrift.Type.I32, 4);
    output.writeI32(this.siteId);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

hive.services.protocol.remoteconfig.RemoteConfigResponse = function(args) {
  this.configs = null;
  this.siteId = null;
  this.privateIp = null;
  this.isVpn = null;
  if (args) {
    if (args.configs !== undefined && args.configs !== null) {
      this.configs = args.configs;
    }
    if (args.siteId !== undefined && args.siteId !== null) {
      this.siteId = args.siteId;
    }
    if (args.privateIp !== undefined && args.privateIp !== null) {
      this.privateIp = args.privateIp;
    }
    if (args.isVpn !== undefined && args.isVpn !== null) {
      this.isVpn = args.isVpn;
    }
  }
};
hive.services.protocol.remoteconfig.RemoteConfigResponse.prototype = {};
hive.services.protocol.remoteconfig.RemoteConfigResponse.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.configs = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.I32) {
        this.siteId = input.readI32().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRING) {
        this.privateIp = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.BOOL) {
        this.isVpn = input.readBool().value;
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

hive.services.protocol.remoteconfig.RemoteConfigResponse.prototype.write = function(output) {
  output.writeStructBegin('RemoteConfigResponse');
  if (this.configs !== null && this.configs !== undefined) {
    output.writeFieldBegin('configs', Thrift.Type.STRING, 1);
    output.writeString(this.configs);
    output.writeFieldEnd();
  }
  if (this.siteId !== null && this.siteId !== undefined) {
    output.writeFieldBegin('siteId', Thrift.Type.I32, 2);
    output.writeI32(this.siteId);
    output.writeFieldEnd();
  }
  if (this.privateIp !== null && this.privateIp !== undefined) {
    output.writeFieldBegin('privateIp', Thrift.Type.STRING, 3);
    output.writeString(this.privateIp);
    output.writeFieldEnd();
  }
  if (this.isVpn !== null && this.isVpn !== undefined) {
    output.writeFieldBegin('isVpn', Thrift.Type.BOOL, 4);
    output.writeBool(this.isVpn);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};



/***/ }),

/***/ "../../../protocol/services/services_types.js":
/*!*********************************************************************!*\
  !*** /home/omar/Desktop/hivejs/protocol/services/services_types.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

//
// Autogenerated by Thrift Compiler (0.9.3)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//

var HiveStreamingServices = window.HiveStreamingServices = {
  '1' : 'REMOTE_EXECUTOR',
  'REMOTE_EXECUTOR' : 1,
  '2' : 'PEER_FORWARDER',
  'PEER_FORWARDER' : 2,
  '3' : 'PEER_INDEX',
  'PEER_INDEX' : 3,
  '4' : 'PEER_BROADCAST',
  'PEER_BROADCAST' : 4,
  '5' : 'PEER_FILTER',
  'PEER_FILTER' : 5,
  '6' : 'PEER_LOGGING',
  'PEER_LOGGING' : 6,
  '7' : 'HIVEJS_TRACKER',
  'HIVEJS_TRACKER' : 7,
  '8' : 'PEER_SYSTEM',
  'PEER_SYSTEM' : 8,
  '9' : 'HIVEJS_SNAPSHOTS',
  'HIVEJS_SNAPSHOTS' : 9,
  '10' : 'HIVEJS_TICKETS',
  'HIVEJS_TICKETS' : 10,
  '11' : 'HIVEJS_KEEPALIVE',
  'HIVEJS_KEEPALIVE' : 11,
  '12' : 'HIVEJS_FORWARDING',
  'HIVEJS_FORWARDING' : 12,
  '13' : 'INTERNAL_TICKET',
  'INTERNAL_TICKET' : 13,
  '14' : 'LOCALITY_SERVICE',
  'LOCALITY_SERVICE': 14,
  '15' : 'REMOTE_CONFIG_SERVICE',
  'REMOTE_CONFIG_SERVICE': 15
};


/***/ }),

/***/ "../../../protocol/snapshots/IntegrationData.js":
/*!***********************************************************************!*\
  !*** /home/omar/Desktop/hivejs/protocol/snapshots/IntegrationData.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.IntegrationData = void 0;
var IntegrationData = /** @class */ (function () {
    function IntegrationData() {
    }
    return IntegrationData;
}());
exports.IntegrationData = IntegrationData;


/***/ }),

/***/ "../../../protocol/snapshots/PeerInfo.js":
/*!****************************************************************!*\
  !*** /home/omar/Desktop/hivejs/protocol/snapshots/PeerInfo.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.PeerInfo = void 0;
var PeerInfo = /** @class */ (function () {
    function PeerInfo() {
    }
    return PeerInfo;
}());
exports.PeerInfo = PeerInfo;


/***/ }),

/***/ "../../../protocol/snapshots/SessionData.js":
/*!*******************************************************************!*\
  !*** /home/omar/Desktop/hivejs/protocol/snapshots/SessionData.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.SessionData = void 0;
var SessionData = /** @class */ (function () {
    function SessionData() {
    }
    return SessionData;
}());
exports.SessionData = SessionData;


/***/ }),

/***/ "../../../protocol/snapshots/TrackContainer.js":
/*!**********************************************************************!*\
  !*** /home/omar/Desktop/hivejs/protocol/snapshots/TrackContainer.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.TrackContainer = void 0;
var TrackContainer = /** @class */ (function () {
    function TrackContainer() {
    }
    return TrackContainer;
}());
exports.TrackContainer = TrackContainer;


/***/ }),

/***/ "../../../protocol/snapshots/TrackData.js":
/*!*****************************************************************!*\
  !*** /home/omar/Desktop/hivejs/protocol/snapshots/TrackData.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.TrackData = void 0;
var TrackData = /** @class */ (function () {
    function TrackData() {
    }
    return TrackData;
}());
exports.TrackData = TrackData;


/***/ }),

/***/ "../../../scripts/build-project/empty.js":
/*!****************************************************************!*\
  !*** /home/omar/Desktop/hivejs/scripts/build-project/empty.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = undefined;


/***/ }),

/***/ "./build/index.js":
/*!************************!*\
  !*** ./build/index.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.HiveHtml5 = exports.OptionsHtml5 = void 0;
var Core = __webpack_require__(/*! hivejs-core */ "../../../core/build/core/src/common/comm.hive.js");
var UAParser = __webpack_require__(/*! ua-parser-js */ "../../../node_modules/ua-parser-js/src/ua-parser.js");
var PLAYER_NAME_REGEX = /^(?:@[a-z0-9-*~][a-z0-9-*._~]*\/)?[a-z0-9-~][a-z0-9-._~]*$/;
var PLAYER_VERSION_REGEX = /^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$/;
var OptionsHtml5 = /** @class */ (function (_super) {
    __extends(OptionsHtml5, _super);
    function OptionsHtml5() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * Partner-provided player name for generic HTML5 plugin. This value must
         * match the requirements for a package name from NPM. See
         * https://json.schemastore.org/package for more information.
         */
        _this.playerName = undefined;
        /**
          * Partner-provided player version for generic HTML5 plugin. This value
          * must be in semver form. See https://semver.org/ for more information.
          */
        _this.playerVersion = undefined;
        return _this;
    }
    return OptionsHtml5;
}(Core.Options));
exports.OptionsHtml5 = OptionsHtml5;
var HiveHtml5 = /** @class */ (function (_super) {
    __extends(HiveHtml5, _super);
    function HiveHtml5(video, options) {
        if (options === void 0) { options = {}; }
        var _this = _super.call(this, options) || this;
        var playerVersion = options.playerVersion, playerName = options.playerName;
        if (typeof playerVersion === 'string' && playerVersion.match(PLAYER_VERSION_REGEX)) {
            _this.playerVersion = playerVersion;
        }
        else {
            _this.logger().warn('Missing or invalid playerVersion specified in Hive Plugin options.');
        }
        if (typeof playerName === 'string' && playerName.length <= 214 && playerName.match(PLAYER_NAME_REGEX)) {
            _this.playerName = playerName;
        }
        else {
            _this.logger().warn('Missing or invalid playerName specified in Hive Plugin options.');
        }
        if (!(video instanceof HTMLVideoElement)) {
            var message = _this.loggerId + " the hive plugin needs to be initialized with the HTML video element.";
            Core.logError(message, _this.loggerId, Core.PluginErrorCodes.NO_REQUIRED_PARAMETERS);
            throw new Error(message);
        }
        _this.video = video;
        return _this;
    }
    /* =============================================
        Partner API
    ============================================= */
    HiveHtml5.prototype.initSession = function (ticketOrToken) {
        var _this = this;
        this.closeHiveSession('Starting a new session.');
        return this.newSession(ticketOrToken)
            .then(function (session) {
            if (_this.video) {
                _this.registerEvents();
            }
            return session.toHiveSession();
        })
            .fail(function (error) {
            _this.closeHiveSession();
            throw error;
        });
    };
    HiveHtml5.prototype.closeHiveSession = function (reason) {
        if (this.getPotentialSession()) {
            _super.prototype.closeHiveSession.call(this, reason);
        }
    };
    /* =============================================
        Event handling
    ============================================= */
    HiveHtml5.prototype.registerEvents = function () {
        this.eventBinder.addTarget(this.video, 'addEventListener', 'removeEventListener')
            .registerEvents({
            loadedmetadata: this.onLoadedMetadata,
            waiting: this.onWaiting,
            canplay: this.onCanPlay,
            pause: this.onPause,
            playing: this.onPlay,
            ended: this.onEnded,
            seeking: this.onSeeking,
            volumechange: this.onVolumeChange
        });
        var fullscreenHandlers = {
            'fullscreenchange': this.onFullscreenChange,
            'mozfullscreenchange': this.onFullscreenChange,
            'webkitfullscreenchange': this.onFullscreenChange,
            'msfullscreenchange': this.onFullscreenChange
        };
        this.eventBinder.addTarget(window.document, 'addEventListener', 'removeEventListener').registerEvents(window.document, fullscreenHandlers);
        this.eventBinder.addTarget(this.video.textTracks, 'addEventListener', 'removeEventListener').registerEvents(this.video.textTracks, { change: this.onCaptionChange });
    };
    HiveHtml5.prototype.registerEvent = function (target, handlerName) {
        this.eventBinder.addTarget(target, 'addEventListener', 'removeEventListener').registerEvents(target, { change: this[handlerName] });
    };
    HiveHtml5.prototype.onLoadedMetadata = function (event) {
        this.logger().debug('Metadata loaded', event);
        this.onActivateSession();
        this.onStartBuffering(false);
        this.startPeriodicFeedback();
    };
    HiveHtml5.prototype.onWaiting = function (event) {
        this.logger().debug('Waiting', event);
        this.onStartBuffering();
    };
    HiveHtml5.prototype.onCanPlay = function (event) {
        this.logger().debug('Can Play', event);
        this.onEndBuffering();
    };
    HiveHtml5.prototype.onPause = function () {
        this.logger().debug('pause');
        this.filterEvent(Core.PlayerEvents.PAUSED);
    };
    HiveHtml5.prototype.onPlay = function () {
        this.logger().debug('playing');
        this.filterEvent(Core.PlayerEvents.PLAYING);
    };
    HiveHtml5.prototype.onEnded = function () {
        this.logger().debug('ended');
        this.onEventFeedback(Core.PlayerEvents.STOPPED, { 'code': 1 });
    };
    HiveHtml5.prototype.onSeeking = function () {
        this.logger().debug('seeking');
        this.onEventFeedback(Core.PlayerEvents.SKIP);
    };
    HiveHtml5.prototype.onVolumeChange = function () {
        if (this.isMuted === this.video.muted)
            return;
        this.logger().debug("mutechange " + this.video.muted);
        this.onEventFeedback(Core.PlayerEvents.MUTED, { 'value': this.video.muted });
        this.isMuted = this.video.muted;
    };
    HiveHtml5.prototype.onFullscreenChange = function (event) {
        var _a;
        if (event.target === this.video || ((_a = event.target) === null || _a === void 0 ? void 0 : _a.getElementsByTagName('video')[0]) === this.video) {
            var isFullscreen = this.isFullscreen();
            this.logger().debug('fullscreen', isFullscreen);
            this.filterEvent(Core.PlayerEvents.FULLSCREEN, { 'value': isFullscreen });
        }
    };
    HiveHtml5.prototype.onCaptionChange = function () {
        var captionLanguage = this.getCaptionLanguage();
        if (!captionLanguage) {
            this.filterEvent(Core.PlayerEvents.CAPTION_SWITCH, { value: false });
        }
        else {
            this.filterEvent(Core.PlayerEvents.CAPTION_SWITCH, { value: true, details: captionLanguage });
        }
    };
    // -----------------------------------  Request interception -----------------------------------
    HiveHtml5.prototype.createXMLHttpRequest = function () {
        return new Core.HiveRequestFactory(this.getPluginId()).createXMLHttpRequest();
    };
    /* =============================================
        Data API
    ============================================= */
    HiveHtml5.prototype.getPlayerSource = function () {
        // if source is a blob, try to get it after manifest interception
        if (this.getManifestUrl())
            return this.getManifestUrl();
        if (this.video.currentSrc.startsWith('blob:')) {
            this.logger().warn('Current video source is a blob');
            return '';
        }
        else {
            return this.video.currentSrc;
        }
    };
    HiveHtml5.prototype.getCurrentTime = function () {
        return Math.round(this.video.currentTime * 1000);
    };
    HiveHtml5.prototype.getBufferLen = function () {
        if (this.video.buffered.length > 0)
            return Math.max(0, Math.round(this.video.buffered.end(0) * 1000) - Math.round(this.video.currentTime * 1000));
    };
    HiveHtml5.prototype.getWindowSize = function () {
        return {
            width: this.video.clientWidth,
            height: this.video.clientHeight
        };
    };
    HiveHtml5.prototype.getTextTracks = function () {
        var textTracks = Core.BasicUtils.toHiveTextTrackList(this.video.textTracks);
        this.logger().debug('getTextTracks', textTracks);
        return textTracks;
    };
    HiveHtml5.prototype.getCaptionLanguage = function () {
        var _a;
        return ((_a = Array.from(this.video.textTracks).find(function (textTrack) { return textTrack.mode === 'showing'; })) === null || _a === void 0 ? void 0 : _a.language) || null;
    };
    HiveHtml5.prototype.isFullscreen = function () {
        var _a, _b, _c, _d, _e, _f;
        var parser = new UAParser((_a = window.navigator) === null || _a === void 0 ? void 0 : _a.userAgent);
        var browser = parser === null || parser === void 0 ? void 0 : parser.getBrowser();
        /**
         * Safari instance property to get fullscreen status
         * https://developer.apple.com/documentation/webkitjs/document/1631511-webkitisfullscreen
         * Works for Safari Desktop 5.1+ and Safari Mobile 9.0+
         */
        if ((_b = browser === null || browser === void 0 ? void 0 : browser.name) === null || _b === void 0 ? void 0 : _b.includes('Safari')) {
            return window.document['webkitIsFullScreen'];
        }
        /**
         * This works for all browsers except Safari
         * https://developer.mozilla.org/en-US/docs/Web/API/Document/fullscreenElement
         * fullscreenElement is undefined when screen is not in FullScreen mode.
         * As the node element not always gonna be VIDEO then we cant use exactly document.fullscreenElement.nodeName == 'VIDEO')
         * Could be wrapped in other HTML tags that's why needs to find by tag VIDEO
         */
        if (((_d = (_c = window.document) === null || _c === void 0 ? void 0 : _c.fullscreenElement) === null || _d === void 0 ? void 0 : _d.getElementsByTagName('VIDEO').length) > 0 || ((_f = (_e = window.document) === null || _e === void 0 ? void 0 : _e.fullscreenElement) === null || _f === void 0 ? void 0 : _f.nodeName) === 'VIDEO') {
            return true;
        }
        return false;
    };
    HiveHtml5.prototype.isLive = function () {
        return this.video.duration === Infinity;
    };
    HiveHtml5.prototype.isActive = function () {
        return true;
    };
    HiveHtml5.prototype.getStreamProtocol = function () {
        var src = this.getPlayerSource();
        return Core.BasicUtils.getStreamProtocol(src);
    };
    HiveHtml5.prototype.getPlayerTech = function () {
        return Core.PlayerTech.HTML5;
    };
    HiveHtml5.prototype.getPlayerVersion = function () {
        return this.playerVersion;
    };
    HiveHtml5.prototype.getPlayerName = function () {
        return this.playerName;
    };
    HiveHtml5.prototype.getPlayerVolume = function () {
        return Core.BasicUtils.getVolume(this.video);
    };
    return HiveHtml5;
}(Core.Plugin));
exports.HiveHtml5 = HiveHtml5;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 0:
/*!**********************!*\
  !*** path (ignored) ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ })

/******/ });
});
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const crypto_1 = require("crypto");
const fs_1 = require("fs");
const util_1 = require("util");
var writeFile = fs_1.promises.writeFile;
var readFile = fs_1.promises.readFile;
const generateKeyPair = (0, util_1.promisify)(crypto_1.generateKeyPair);
/**
 * Helper class to generate and store RSA assymetric keys.
 */
class HiveKeyPair {
    /**
     * Create a new `HivePublicKeyCreator`.
     * @param {KeyObject} privateKey A `KeyObject` representing the private key.
     * @param {KeyObject} publicKey A `KeyObject` representing the public key.
     */
    constructor(publicKey, privateKey) {
        this.publicKey = publicKey;
        this.privateKey = privateKey;
    }
    /**
     * Create a new `HivePublicKeyCreator` with a newly generated asymmetric key
     * pair.
     */
    static async create() {
        const { publicKey, privateKey } = await generateKeyPair('rsa', {
            modulusLength: 4096
        });
        return new HiveKeyPair(publicKey, privateKey);
    }
    /**
     * Synchronously create a new `HivePublicKeyCreator` with a newly generated
     * asymmetric key pair.
     */
    static createSync() {
        const { publicKey, privateKey } = (0, crypto_1.generateKeyPairSync)('rsa', {
            modulusLength: 4096
        });
        return new HiveKeyPair(publicKey, privateKey);
    }
    /**
     * Create a new `HivePublicKeyCreator` from a file that contains a private
     * key in PEM-encoded format.
     *
     * @param {string} file File to read private key from
     */
    static async readFromFile(file) {
        const privateKeyBuffer = await readFile(file);
        const privateKey = (0, crypto_1.createPrivateKey)(privateKeyBuffer);
        const publicKey = (0, crypto_1.createPublicKey)({
            key: privateKeyBuffer
        });
        return new HiveKeyPair(publicKey, privateKey);
    }
    /**
     * Synchronously create a new `HivePublicKeyCreator` from a file that
     * contains a private key in PEM-encoded format.
     *
     * @param {string} file Filename to read the private key from.
     */
    static readFromFileSync(file) {
        const privateKeyBuffer = (0, fs_1.readFileSync)(file);
        const privateKey = (0, crypto_1.createPrivateKey)(privateKeyBuffer);
        const publicKey = (0, crypto_1.createPublicKey)({
            key: privateKeyBuffer
        });
        return new HiveKeyPair(publicKey, privateKey);
    }
    /**
     * Write the private key to file in PEM-encoded format.
     *
     * @param {string} filename Filename to store the private key to.
     * @return {Promise<void>} The `Promise` representing the filesystem write,
     * fulfills with `undefined` upon success.
     */
    writePrivateKey(filename) {
        return writeFile(filename, this.privateKey.export({
            format: 'pem',
            type: 'pkcs8'
        }));
    }
    /**
     * Synchronously write the private key to file in PEM-encoded format.
     *
     * @param {string} filename Filename to store the private key to.
     */
    writePrivateKeySync(filename) {
        (0, fs_1.writeFileSync)(filename, this.privateKey.export({
            format: 'pem',
            type: 'pkcs8'
        }));
    }
    /**
     * Return the public key in a format used by the Hive Public Key Service.
     */
    exportPublicKey() {
        const exported = this.publicKey.export({ format: 'jwk' });
        return {
            modulus: exported.n,
            exponent: exported.e
        };
    }
}
exports.default = HiveKeyPair;
